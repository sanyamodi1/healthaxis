# Hospital Management System - HealthAxis

## 📄 app\(auth)\layout.tsx

```tsx
import React from 'react';
import Image from 'next/image';
import LandingPageimg from "../../assests/Signup.jpg";

const AuthLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div className="w-full h-screen flex items-center justify-center">
      {/* Left side: 80% height box */}
      <div className="w-1/2 h-[80%] flex items-center justify-center">
        {children}
      </div>

      {/* Right side: full image with overlay */}
      <div className="w-1/2 h-full relative">
        <Image
          src={LandingPageimg}
          width={1000}
          height={1000}
          alt="landingImage"
          className="object-cover w-full h-full"
        />
        <div className="absolute top-0 w-full h-full z-10 flex flex-col items-center justify-center">
          <div className="absolute inset-0 bg-black/40 z-[-1]"></div>

          <h1 className="text-6xl font-bold text-white 2xl:text-5xl">
            HealthAxis
          </h1>
          <p className="text-white text-base">You're Welcome</p>
        </div>
      </div>
    </div>
  );
};

export default AuthLayout;

```

## 📄 app\(auth)\sign-in\[[...sign-in]]\page.tsx

```tsx
import { SignIn } from '@clerk/nextjs'

export default function Page() {
  return (
    <div>
      <SignIn />
    </div>
  )
}
```

## 📄 app\(auth)\sign-up\[[...sign-up]]\page.tsx

```tsx
import { SignUp } from '@clerk/nextjs'

export default function Page() {
  return (
    <div>
      <SignUp />
    </div>
  )
}
```

## 📄 app\(protected)\admin\page.tsx

```tsx
import { AvailableDoctors } from "@/components/available-doctor";
import { AppointmentChart } from "@/components/charts/appointment-chart";
import { StatSummary } from "@/components/charts/stat-summary";
import { StatCard } from "@/components/stat-card";
import { RecentAppointments } from "@/components/tables/recent-appointment";
import { Button } from "@/components/ui/button";
import { getAdminDashboardStats } from "@/utils/services/admin";
import { BriefcaseBusiness, BriefcaseMedical, User, Users } from "lucide-react";
import React from "react";

const AdminDashboard = async () => {
  const {
    availableDoctors,
    last5Records,
    appointmentCounts,
    monthlyData,
    totalDoctors,
    totalPatient,
    totalAppointments,
  } = await getAdminDashboardStats();

  const cardData = [
    {
      title: "Patients",
      value: totalPatient,
      icon: Users,
      className: "bg-blue-600/15",
      iconClassName: "bg-blue-600/25 text-blue-600",
      note: "Total patients",
      link: "/manage-patients",
    },
    {
      title: "Doctors",
      value: totalDoctors,
      icon: User,
      className: "bg-rose-600/15",
      iconClassName: "bg-rose-600/25 text-rose-600",
      note: "Total doctors",
      link: "/manage-doctors",
    },
    {
      title: "Appointments",
      value: totalAppointments,
      icon: BriefcaseBusiness,
      className: "bg-yellow-600/15",
      iconClassName: "bg-yellow-600/25 text-yellow-600",
      note: "Total appointments",
      link: "/manage-appointments",
    },
    {
      title: "Consultation",
      value: appointmentCounts?.COMPLETED,
      icon: BriefcaseMedical,
      className: "bg-emerald-600/15",
      iconClassName: "bg-emerald-600/25 text-emerald-600",
      note: "Total consultation",
      link: "/manage-appointments",
    },
  ];

  return (
    <div className="py-6 px-3 flex flex-col xl:flex-row rounded-xl gap-6">
      {/* LEFT */}
      <div className="w-full xl:w-[69%]">
        <div className="bg-white rounded-xl p-4 mb-8">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-lg font-semibold">Statistics</h1>
            <Button size={"sm"} variant={"outline"}>
              {new Date().getFullYear()}
            </Button>
          </div>

          <div className="w-full  flex flex-wrap gap-5">
            {cardData?.map((el, index) => (
              <StatCard
                key={index}
                title={el.title}
                value={el.value!}
                icon={el.icon}
                className={el.className}
                iconClassName={el.iconClassName}
                note={el.note}
                link={el.link}
              />
            ))}
          </div>
        </div>

        <div className="h-[500px]">
          <AppointmentChart data={monthlyData!} />
        </div>

        <div className="bg-white rounded-xl p-4 mt-8">
          <RecentAppointments data={last5Records!} />
        </div>
      </div>

      {/* RIGHT */}

      <div className="w-full xl:w-[30%]">
        <div className="w-full h-[450px]">
          <StatSummary data={appointmentCounts} total={totalAppointments!} />
        </div>

        <AvailableDoctors data={availableDoctors as any} />
      </div>
    </div>
  );
};

export default AdminDashboard;
```

## 📄 app\(protected)\admin\system-settings\page.tsx

```tsx
import { AvailableDoctors } from "@/components/available-doctor";
import { AppointmentChart } from "@/components/charts/appointment-chart";
import { StatSummary } from "@/components/charts/stat-summary";
import { StatCard } from "@/components/stat-card";
import { RecentAppointments } from "@/components/tables/recent-appointment";
import { Button } from "@/components/ui/button";
import { getAdminDashboardStats } from "@/utils/services/admin";
import { BriefcaseBusiness, BriefcaseMedical, User, Users } from "lucide-react";
import React from "react";

const AdminDashboard = async () => {
  const {
    availableDoctors,
    last5Records,
    appointmentCounts,
    monthlyData,
    totalDoctors,
    totalPatient,
    totalAppointments,
  } = await getAdminDashboardStats();

  const cardData = [
    {
      title: "Patients",
      value: totalPatient,
      icon: Users,
      className: "bg-blue-600/15",
      iconClassName: "bg-blue-600/25 text-blue-600",
      note: "Total patients",
      link: "/manage-patients",
    },
    {
      title: "Doctors",
      value: totalDoctors,
      icon: User,
      className: "bg-rose-600/15",
      iconClassName: "bg-rose-600/25 text-rose-600",
      note: "Total doctors",
      link: "/manage-doctors",
    },
    {
      title: "Appointments",
      value: totalAppointments,
      icon: BriefcaseBusiness,
      className: "bg-yellow-600/15",
      iconClassName: "bg-yellow-600/25 text-yellow-600",
      note: "Total appointments",
      link: "/manage-appointments",
    },
    {
      title: "Consultation",
      value: appointmentCounts?.COMPLETED,
      icon: BriefcaseMedical,
      className: "bg-emerald-600/15",
      iconClassName: "bg-emerald-600/25 text-emerald-600",
      note: "Total consultation",
      link: "/manage-appointments",
    },
  ];

  return (
    <div className="py-6 px-3 flex flex-col xl:flex-row rounded-xl gap-6">
      {/* LEFT */}
      <div className="w-full xl:w-[69%]">
        <div className="bg-white rounded-xl p-4 mb-8">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-lg font-semibold">Statistics</h1>
            <Button size={"sm"} variant={"outline"}>
              {new Date().getFullYear()}
            </Button>
          </div>

          <div className="w-full  flex flex-wrap gap-5">
            {cardData?.map((el, index) => (
              <StatCard
                key={index}
                title={el.title}
                value={el.value!}
                icon={el.icon}
                className={el.className}
                iconClassName={el.iconClassName}
                note={el.note}
                link={el.link}
              />
            ))}
          </div>
        </div>

        <div className="h-[500px]">
          <AppointmentChart data={monthlyData!} />
        </div>

        <div className="bg-white rounded-xl p-4 mt-8">
          <RecentAppointments data={last5Records!} />
        </div>
      </div>

      {/* RIGHT */}

      <div className="w-full xl:w-[30%]">
        <div className="w-full h-[450px]">
          <StatSummary data={appointmentCounts} total={totalAppointments!} />
        </div>

        <AvailableDoctors data={availableDoctors as any} />
      </div>
    </div>
  );
};

export default AdminDashboard;
```

## 📄 app\(protected)\doctor\page.tsx

```tsx
import { AvailableDoctors } from "@/components/available-doctor";
import { AppointmentChart } from "@/components/charts/appointment-chart";
import { StatSummary } from "@/components/charts/stat-summary";
import { StatCard } from "@/components/stat-card";
import { RecentAppointments } from "@/components/tables/recent-appointment";
import { Button } from "@/components/ui/button";
import { checkRole, getRole } from "@/utils/roles";
import { getDoctorDashboardStats } from "@/utils/services/doctor";
import { currentUser } from "@clerk/nextjs/server";
import { BriefcaseBusiness, BriefcaseMedical, User, Users } from "lucide-react";
import Link from "next/link";
import { redirect } from "next/navigation";
import React from "react";

const DoctorDashboard = async () => {
  const user = await currentUser();

  const {
    totalPatient,
    totalNurses,
    totalAppointment,
    appointmentCounts,
    availableDoctors,
    monthlyData,
    last5Records,
  } = await getDoctorDashboardStats();

  const cardData = [
    {
      title: "Patients",
      value: totalPatient,
      icon: Users,
      className: "bg-blue-600/15",
      iconClassName: "bg-blue-600/25 text-blue-600",
      note: "Total patients",
      link: "/record/patients",
    },
    {
      title: "Nurses",
      value: totalNurses,
      icon: User,
      className: "bg-rose-600/15",
      iconClassName: "bg-rose-600/25 text-rose-600",
      note: "Total nurses",
      link: "",
    },
    {
      title: "Appointments",
      value: totalAppointment,
      icon: BriefcaseBusiness,
      className: "bg-yellow-600/15",
      iconClassName: "bg-yellow-600/25 text-yellow-600",
      note: "Total appointments",
      link: "/record/appointments",
    },
    {
      title: "Consultation",
      value: appointmentCounts?.COMPLETED,
      icon: BriefcaseMedical,
      className: "bg-emerald-600/15",
      iconClassName: "bg-emerald-600/25 text-emerald-600",
      note: "Total consultation",
      link: "/record/appointments",
    },
  ];

  return (
    <div className="rounded-xl py-6 px-3 flex flex-col xl:flex-row gap-6">
      {/* LEFT */}
      <div className="w-full xl:w-[69%]">
        <div className="bg-white rounded-xl p-4 mb-8">
          <div className="flex items-center justify-between mb-6">
            <h1 className="text-lg xl:text-2xl font-semibold">
              Welcome, Dr. {user?.firstName}
            </h1>
            <Button size="sm" variant="outline" asChild>
              <Link href={`/record/doctors/${user?.id}`}>View profile</Link>
            </Button>
          </div>

          <div className="w-full flex flex-wrap gap-2">
            {cardData?.map((el, index) => (
              <StatCard
                key={index}
                title={el?.title}
                value={el?.value!}
                icon={el?.icon}
                className={el?.className}
                iconClassName={el?.iconClassName}
                note={el?.note}
                link={el?.link}
              />
            ))}
          </div>
        </div>

        <div className="h-[500px]">
          <AppointmentChart data={monthlyData!} />
        </div>

        <div className="bg-white rounded-xl p-4 mt-8">
          <RecentAppointments data={last5Records!} />
        </div>
      </div>

      {/* RIGHT */}
      <div className="w-full xl:w-[30%]">
        <div className="w-full h-[450px] mb-8">
          <StatSummary data={appointmentCounts} total={totalAppointment!} />
        </div>

        <AvailableDoctors data={availableDoctors as any} />
      </div>
    </div>
  );
};

export default DoctorDashboard;
```

## 📄 app\(protected)\layout.tsx

```tsx
import  Navbar from "../../components/navbar";
import Sidebar  from "../../components/sidebar";
import React from "react";

const ProtectedLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div className="w-full h-screen flex bg-yellow-700">
      <div className="w-[14%] md:w-[8%] lg:w-[16%] xl:w-[14%]">
        <Sidebar />
      </div>

      <div className="w-[86%] md:w-[92%] lg:w-[84%] xl:w-[86%] bg-[#F7F8FA] flex flex-col">
        <Navbar />

        <div className="h-full w-full p-2 overflow-y-scroll">{children}</div>
      </div>
    </div>
  );
};

export default ProtectedLayout;
```

## 📄 app\(protected)\patient\page.tsx

```tsx
import { AvailableDoctors } from "@/components/available-doctor";
import { AppointmentChart } from "@/components/charts/appointment-chart";
import { StatSummary } from "@/components/charts/stat-summary";
import { PatientRatingContainer } from "@/components/patient-rating-container";
import { StatCard } from "@/components/stat-card";
import { RecentAppointments } from "@/components/tables/recent-appointment";
import { Button } from "@/components/ui/button";
import { AvailableDoctorProps } from "@/types/data-types";
import { getPatientDashboardStatistics } from "@/utils/services/patient";
import { UserButton } from "@clerk/nextjs";
import { currentUser } from "@clerk/nextjs/server";
import { Briefcase, BriefcaseBusiness, BriefcaseMedical } from "lucide-react";
import Link from "next/link";
import { redirect } from "next/navigation";
import React from "react";

const PatientDashboard = async () => {
  const user = await currentUser();

  const {
    data,
    appointmentCounts ,
    last5Records,
    totalAppointments,
    availableDoctor,
    monthlyData,
  } = await getPatientDashboardStatistics(user?.id!);

  if (user && !data) {
    redirect("/patient/registration");
  }

  if (!data) return null;

  const cardData = [
    {
      title: "appointments",
      value: totalAppointments,
      icon: Briefcase,
      className: "bg-blue-600/15",
      iconClassName: "bg-blue-600/25 text-blue-600",
      note: "Total appointments",
    },
    {
      title: "cancelled",
      value: appointmentCounts?.CANCELLED,
      icon: Briefcase,
      className: "bg-rose-600/15",
      iconClassName: "bg-rose-600/25 text-rose-600",
      note: "Cancelled Appointments",
    },
    {
      title: "pending",
      value: appointmentCounts?.PENDING! + appointmentCounts?.SCHEDULED!,
      icon: BriefcaseBusiness,
      className: "bg-yellow-600/15",
      iconClassName: "bg-yellow-600/25 text-yellow-600",
      note: "Pending Appointments",
    },
    {
      title: "completed",
      value: appointmentCounts?.COMPLETED,
      icon: BriefcaseMedical,
      className: "bg-emerald-600/15",
      iconClassName: "bg-emerald-600/25 text-emerald-600",
      note: "Successfully appointments",
    },
  ];

  return (
    <div className="w-full py-6 px-3 flex flex-col rounded-xl xl:flex-row gap-6">
      {/* LEFT */}
      <div className="w-full xl:w-[69%]">
        <div className="bg-white rounded-xl p-4 mb-8">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-lg xl:text-2xl font-semibold">
              Welcome {data?.first_name || user?.firstName}
            </h1>

            <div className="space-x-2">
              <Button size={"sm"}>{new Date().getFullYear()}</Button>
              <Button size="sm" variant="outline" className="hover:underline">
                <Link href="/patient/self">View Profile</Link>
              </Button>
            </div>
          </div>

          <div className="w-full flex flex-wrap gap-5">
            {cardData?.map((el, id) => (
              <StatCard key={id} {...el} link="#" />
            ))}
          </div>
        </div>

        <div className="h-[500px]">
          <AppointmentChart data={monthlyData} />
        </div>

        <div className="bg-white rounded-xl p-4 mt-8">
          <RecentAppointments data={last5Records} />
        </div>
      </div>

      {/* RIGHT */}
      <div className="w-full xl:w-[30%]">
        <div className="w-full h-[450px] mb-8">
          <StatSummary data={appointmentCounts} total={totalAppointments} />
        </div>

        <AvailableDoctors data={availableDoctor as AvailableDoctorProps} />
        <div className="mt-4">
        <PatientRatingContainer />
        </div>
      </div>
    </div>
  );
};

export default PatientDashboard;
```

## 📄 app\(protected)\patient\registration\page.tsx

```tsx
import NewPatient from '@/components/new-patient'
import { getPatientById } from '@/utils/services/patient'
import { auth } from '@clerk/nextjs/server'
import React from 'react'

const Registration = async () => {
  const { userId } = await auth()
  const {data} = await getPatientById(userId!)
  return (
    <div className='py-6 px-3 flex justify-center'>
      <NewPatient data = {data!} type={!data ? 'create'  : 'update'}  />
    </div>
  )
}

export default Registration
```

## 📄 app\(protected)\patient\[patientId]\page.tsx

```tsx
import { MedicalHistoryContainer } from "@/components/medical-history-container";
import { PatientRatingContainer } from "@/components/patient-rating-container";
import { ProfileImage } from "@/components/profile-image";
import { Card } from "@/components/ui/card";
import { getPatientFullDataById } from "@/utils/services/patient";
import { auth } from "@clerk/nextjs/server";
import { format } from "date-fns";
import Link from "next/link";
import React from "react";

interface ParamsProps {
  params: Promise<{ patientId: string }>;
  searchParams?: Promise<{ [key: string]: string | string[] | undefined }>;
}

const PatientProfile = async (props: ParamsProps) => {
  const searchParams = await props.searchParams;
  const params = await props.params;

  let id = params.patientId;
  let patientId = params.patientId;
  const cat = searchParams?.cat || "medical-history";

  if (patientId === "self") {
    const { userId } = await auth();
    id = userId!;
  } else id = patientId;

  const { data } = await getPatientFullDataById(id);

  const SmallCard = ({ label, value }: { label: string; value: string }) => (
    <div className="w-full md:w-1/3">
      <span className="text-sm text-gray-500">{label}</span>
      <p className="text-sm md:text-base capitalize">{value}</p>
    </div>
  );

  return (
    <div className="bg-gray-100/60 h-full rounded-xl py-6 px-3 2xl:p-6 flex flex-col lg:flex-row gap-6">
      <div className="w-full xl:w-3/4">
        <div className="w-full flex flex-col lg:flex-row gap-4">
          <Card className="bg-white rounded-xl p-4 w-full lg:w-[30%] border-none flex flex-col items-center">
            <ProfileImage
              url={data?.img!}
              name={data?.first_name + " " + data?.last_name}
              className="h-20 w-20 md:flex"
              bgColor={data?.colorCode!}
              textClassName="text-3xl"
            />
            <h1 className="font-semibold text-2xl mt-2">
              {data?.first_name + " " + data?.last_name}
            </h1>
            <span className="text-sm text-gray-500">{data?.email}</span>

            <div className="w-full flex items-center justify-center gap-2 mt-4">
              <div className="w-1/2 space-y-1 text-center">
                <p className="text-xl font-medium">{data?.totalAppointments}</p>
                <span className="text-xs text-gray-500">Appointments</span>
              </div>
            </div>
          </Card>

          <Card className="bg-white rounded-xl p-6 w-full lg:w-[70%] border-none space-y-6">
            <div className="flex flex-col md:flex-row md:flex-wrap md:items-center xl:justify-between gap-y-4 md:gap-x-0">
              <SmallCard
                label={"Gender"}
                value={data?.gender?.toLowerCase()!}
              />
              <SmallCard
                label="Date of Birth"
                value={format(data?.date_of_birth!, "yyyy-MM-dd")}
              />
              <SmallCard label={"Phone Number"} value={data?.phone!} />
            </div>

            <div className="flex flex-col md:flex-row md:flex-wrap md:items-center xl:justify-between gap-y-4 md:gap-x-0">
              <SmallCard label="Marital Status" value={data?.marital_status!} />
              <SmallCard label="Blood Group" value={data?.blood_group!} />
              <SmallCard label="Address" value={data?.address!} />
            </div>

            <div className="flex flex-col md:flex-row md:flex-wrap md:items-center xl:justify-between gap-y-4 md:gap-x-0">
              <SmallCard
                label="Contact Person"
                value={data?.emergency_contact_name!}
              />
              <SmallCard
                label="Emergency Contact"
                value={data?.emergency_contact_number!}
              />
              <SmallCard
                label="Last Visit"
                value={
                  data?.lastVisit
                    ? format(data?.lastVisit!, "yyyy-MM-dd")
                    : "No last visit"
                }
              />
            </div>
          </Card>
        </div>

        <div className="mt-10">
          {cat === "medical-history" && (
            <MedicalHistoryContainer patientId={id} />
          )}

          {/* {cat === "payments" && <Payments patientId={id!} />} */}
        </div>
      </div>

      <div className="w-full xl:w-1/3">
        <div className="bg-white p-4 rounded-md mb-8">
          <h1 className="text-xl font-semibold">Quick Links</h1>

          <div className="mt-4 flex gap-4 flex-wrap text-xs text-gray-500">
            <Link
              className="p-3 rounded-md bg-yellow-50 hover:underline"
              href={`/record/appointments?id=${id}`}
            >
              Patient&apos;s Appointments
            </Link>
            <Link
              className="p-3 rounded-md bg-purple-50 hover:underline"
              href="?cat=medical-history"
            >
              Medical Records
            </Link>
            <Link
              className="p-3 rounded-md bg-violet-100"
              href={`?cat=payments`}
            >
              Medical Bills
            </Link>
            <Link className="p-3 rounded-md bg-pink-50" href={`/`}>
              Dashboard
            </Link>

            <Link className="p-3 rounded-md bg-rose-100" href={`#`}>
              Lab Test & Result
            </Link>
            {patientId === "self" && (
              <Link
                className="p-3 rounded-md bg-black/10"
                href={`/patient/registration`}
              >
                Edit Information
              </Link>
            )}
          </div>
        </div>

        <PatientRatingContainer id={id!} />
      </div>
    </div>
  );
};

export default PatientProfile;
```

## 📄 app\(protected)\record\appointments\page.tsx

```tsx
import { AppointmentActionOptions } from "@/components/appointment-actions";
import { AppointmentStatusIndicator } from "@/components/appointment-status-indicator";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { ViewAppointment } from "@/components/view-appointment";
import { checkRole, getRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getPatientAppointments } from "@/utils/services/appointment";
import { auth } from "@clerk/nextjs/server";
import { Appointment , Patient , Doctor } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { BriefcaseBusiness } from "lucide-react";
import React from "react";
import { Pagination } from "@/components/pagination";
import { AppointmentContainer } from "@/components/appointment-container";
const columns = [
  {
    header: "Info",
    key: "name",
  },
  {
    header: "Date",
    key: "appointment_date",
    className: "hidden md:table-cell",
  },
  {
    header: "Time",
    key: "time",
    className: "hidden md:table-cell",
  },
  {
    header: "Doctor",
    key: "doctor",
    className: "hidden md:table-cell",
  },
  {
    header: "Status",
    key: "status",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

interface DataProps extends Appointment {
  patient: Patient;
  doctor: Doctor;
}
const Appointments = async (props: {
  searchParams?: Promise<{ [key: string]: string | undefined }>;
}) => {
  const searchParams = await props.searchParams;
  const userRole = await getRole();
  const { userId } = await auth();
  const isPatient = await checkRole("PATIENT");

  const page = (searchParams?.p || "1") as string;
  const searchQuery = searchParams?.q || "";
  const id = searchParams?.id || undefined;

  let queryId = undefined;

  if (
    userRole == "admin" ||
    (userRole == "doctor" && id) ||
    (userRole === "nurse" && id)
  ) {
    queryId = id;
  } else if (userRole === "doctor" || userRole === "patient") {
    queryId = userId;
  } else if (userRole === "nurse") {
    queryId = undefined;
  }

  const { data, totalPages, totalRecord, currentPage } =
    await getPatientAppointments({
      page,
      search: searchQuery,
      id: queryId!,
    });

  if (!data) return null;

  const renderItem = (item: DataProps) => {
    const patient_name = `${item?.patient?.first_name} ${item?.patient?.last_name}`;

    return (
      <tr
        key={item?.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="flex items-center gap-2 md:gap-4 py-2 xl:py-4">
          <ProfileImage
            url={item?.patient?.img!}
            name={patient_name}
            bgColor={item?.patient?.colorCode!}
          />
          <div>
            <h3 className="font-semibold uppercase">{patient_name}</h3>
            <span className="text-xs md:text-sm capitalize">
              {item?.patient?.gender.toLowerCase()}
            </span>
          </div>
        </td>

        <td className="hidden md:table-cell">
          {format(item?.appointmentDate, "yyyy-MM-dd")}
        </td>
        <td className="hidden md:table-cell">{item.appointmentTime}</td>

        <td className="hidden  items-center py-2  md:table-cell">
          <div className="flex items-center  gap-2 md:gap-4">
            <ProfileImage
              url={item.doctor?.img!}
              name={item.doctor?.name}
              bgColor={item?.doctor?.colorCode!}
              textClassName="text-black"
            />

            <div>
              <h3 className="font-semibold uppercase">{item.doctor?.name}</h3>
              <span className="text-xs md:text-sm capitalize">
                {item.doctor?.specialization}
              </span>
            </div>
          </div>
        </td>

        <td className="hidden xl:table-cell">
          <AppointmentStatusIndicator status={item.status!} />
        </td>
        <td>
          <div className="flex items-center gap-2">
            <ViewAppointment id={item?.id.toString()} />
            <AppointmentActionOptions
              userId={userId!}
              patientId={item?.patient_id}
              doctorId={item?.doctor_id}
              status={item?.status}
              appointmentId={item.id}
            />
          </div>
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl p-2 md:p-4 2xl:p-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <BriefcaseBusiness size={20} className="text-gray-500" />
          <p className="text-2xl font-semibold">{totalRecord ?? 0}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total appointments
          </span>
        </div>

        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />

          {isPatient && <AppointmentContainer id={userId!} />}
        </div>
      </div>

      <div className="mt-6">
        <Table columns={columns} renderRow={renderItem} data={data} />

        {data?.length > 0 && (
          <Pagination
            totalRecords={totalRecord!}
            currentPage={currentPage!}
            totalPages={totalPages!}
            limit={DATA_LIMIT}
          />
        )}
      </div>
    </div>
  );
};

export default Appointments;
```

## 📄 app\(protected)\record\appointments\[id]\page.tsx

```tsx
import { AppointmentDetails } from "@/components/appointment/appointment-details";
import AppointmentQuickLinks from "@/components/appointment/appointment-quick-links";
import { BillsContainer } from "@/components/appointment/bills-container";
import ChartContainer from "@/components/appointment/chart-container";
import { DiagnosisContainer } from "@/components/appointment/diagnosis-container";
import { PatientDetailsCard } from "@/components/appointment/patient-details-card";
import { PaymentsContainer } from "@/components/appointment/payment-container";
import { VitalSigns } from "@/components/appointment/vital-signs";
import { MedicalHistoryContainer } from "@/components/medical-history-container";
import { getAppointmentWithMedicalRecordsById } from "@/utils/services/appointment";

const AppointmentDetailsPage = async ({
  params,
  searchParams,
}: {
  params: Promise<{ id: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) => {
  const { id } = await params;
  const search = await searchParams;
  const cat = (search?.cat as string) || "charts";

  const { data } = await getAppointmentWithMedicalRecordsById(Number(id));

  return (
    <div className="flex p-6 flex-col-reverse lg:flex-row w-full min-h-screen gap-10">
      {/* LEFT */}
      <div className="w-full lg:w-[65%] flex flex-col gap-6">
        {cat === "charts" && <ChartContainer id={data?.patient_id!} />}
        {cat === "appointments" && (
          <>
            <AppointmentDetails
              id={data?.id!}
              patient_id={data?.patient_id!}
              appointment_date={data?.appointmentDate!}
              time={data?.appointmentTime!}
              notes={data?.note!}
            />

            <VitalSigns
              id={id}
              patientId={data?.patient_id!}
              doctorId={data?.doctor_id!}
            />
          </>
        )}
        {cat === "diagnosis" && (
          <DiagnosisContainer
            id={id}
            patientId={data?.patient_id!}
            doctorId={data?.doctor_id!}
          />
        )}
        {cat === "medical-history" && (
          <MedicalHistoryContainer id={id!} patientId={data?.patient_id!} />
        )}
        {cat === "billing" && <BillsContainer id={id} />}
        {cat === "payments" && (
          <PaymentsContainer patientId={data?.patient_id!} />
        )}
      </div>
      {/* RIGHT */}
      <div className="flex-1 space-y-6">
        <AppointmentQuickLinks staffId={data?.doctor_id as string} />
        <PatientDetailsCard data={data?.patient!} />
      </div>
    </div>
  );
};

export default AppointmentDetailsPage;
```

## 📄 app\(protected)\record\billing\page.tsx

```tsx
import { ActionDialog } from "@/components/action-dialog";
import { ViewAction } from "@/components/action-options";
import { Pagination } from "@/components/pagination";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { cn } from "@/lib/utils";
import { SearchParamsProps } from "@/types";
import { checkRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getPaymentRecords } from "../../../../utils/services/payments";
import { Patient , Payment } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { ReceiptText } from "lucide-react";

const columns = [
  {
    header: "RNO",
    key: "id",
  },
  {
    header: "Patient",
    key: "info",
    className: "",
  },
  {
    header: "Contact",
    key: "phone",
    className: "hidden md:table-cell",
  },
  {
    header: "Bill Date",
    key: "bill_date",
    className: "hidden md:table-cell",
  },
  {
    header: "Total",
    key: "total",
    className: "hidden xl:table-cell",
  },
  {
    header: "Discount",
    key: "discount",
    className: "hidden xl:table-cell",
  },
  {
    header: "Payable",
    key: "payable",
    className: "hidden xl:table-cell",
  },
  {
    header: "Paid",
    key: "payable",
    className: "hidden xl:table-cell",
  },
  {
    header: "Status",
    key: "status",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

interface ExtendedProps extends Payment {
  patient: Patient;
}

const BillingPage = async (props: SearchParamsProps) => {
  const searchParams = await props.searchParams;
  const page = (searchParams?.p || "1") as string;
  const searchQuery = (searchParams?.q || "") as string;

  const { data, totalPages, totalRecords, currentPage } =
    await getPaymentRecords({
      page,
      search: searchQuery,
    });
  const isAdmin = await checkRole("ADMIN");

  if (!data) return null;

  const renderRow = (item: ExtendedProps) => {
    const name = item?.patient?.first_name + " " + item?.patient?.last_name;
    const patient = item?.patient;

    return (
      <tr
        key={item?.id + patient?.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td># {item?.id}</td>
        <td className="flex items-center gap-4 p-4">
          <ProfileImage
            url={item?.patient?.img!}
            name={name}
            bgColor={patient?.colorCode!}
            textClassName="text-black"
          />
          <div>
            <h3 className="uppercase">{name}</h3>
            <span className="text-sm capitalize">{patient?.gender}</span>
          </div>
        </td>
        <td className="hidden md:table-cell">{patient?.phone}</td>
        <td className="hidden md:table-cell">
          {format(item?.bill_date, "yyyy-MM-dd")}
        </td>
        <td className="hidden xl:table-cell">
          {item?.total_amount?.toFixed(2)}
        </td>
        <td className="hidden xl:table-cell">{item?.discount?.toFixed(2)}</td>
        <td className="hidden xl:table-cell">
          {(item?.total_amount - item?.discount).toFixed(2)}
        </td>
        <td className="hidden xl:table-cell">
          {(item?.amount_paid).toFixed(2)}
        </td>
        <td className="hidden xl:table-cell">
          <span
            className={cn(
              item?.status === "UNPAID"
                ? "text-red-600"
                : item?.status === "PAID"
                ? "text-emerald-600"
                : "text-gray-600"
            )}
          >
            {item?.status}
          </span>
        </td>

        <td>
          <ViewAction
            href={`/appointments/${item?.appointment_Id}?cat=bills`}
          />

          {isAdmin && (
            <ActionDialog
              type="delete"
              deleteType="payment"
              id={item?.id.toString()}
            />
          )}
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl py-6 px-3 2xl:px-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <ReceiptText size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalRecords}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total records
          </span>
        </div>
        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />
        </div>
      </div>

      <div className="mt-4">
        <Table columns={columns} data={data} renderRow={renderRow} />

        <Pagination
          totalPages={totalPages}
          currentPage={currentPage}
          totalRecords={totalRecords}
          limit={DATA_LIMIT}
        />
      </div>
    </div>
  );
};

export default BillingPage;
```

## 📄 app\(protected)\record\doctors\page.tsx

```tsx
import { ActionDialog } from "@/components/action-dialog";
import { ViewAction } from "@/components/action-options";
import { DoctorForm } from "@/components/forms/doctor-form";
import { Pagination } from "@/components/pagination";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { Button } from "@/components/ui/button";
import { SearchParamsProps } from "../../../../types";
import { checkRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getAllDoctors } from "@/utils/services/doctor";
import { Doctor } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { Users } from "lucide-react";
import React from "react";

const columns = [
  {
    header: "Info",
    key: "name",
  },
  {
    header: "License #",
    key: "license",
    className: "hidden md:table-cell",
  },
  {
    header: "Phone",
    key: "contact",
    className: "hidden md:table-cell",
  },
  {
    header: "Email",
    key: "email",
    className: "hidden lg:table-cell",
  },
  {
    header: "Joined Date",
    key: "created_at",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

const DoctorsList = async (props: SearchParamsProps) => {
  const searchParams = await props.searchParams;
  const page = (searchParams?.p || "1") as string;
  const searchQuery = (searchParams?.q || "") as string;

  const { data, totalPages, totalRecords, currentPage } = await getAllDoctors({
    page,
    search: searchQuery,
  });

  if (!data) return null;
  const isAdmin = await checkRole("ADMIN");

  const renderRow = (item: Doctor) => (
    <tr
      key={item?.id}
      className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
    >
      <td className="flex items-center gap-4 p-4">
        <ProfileImage
          url={item?.img!}
          name={item?.name}
          bgColor={item?.colorCode!}
          textClassName="text-black"
        />
        <div>
          <h3 className="uppercase">{item?.name}</h3>
          <span className="text-sm capitalize">{item?.specialization}</span>
        </div>
      </td>
      <td className="hidden md:table-cell">{item?.license_number}</td>
      <td className="hidden md:table-cell">{item?.phone}</td>
      <td className="hidden lg:table-cell">{item?.email}</td>
      <td className="hidden xl:table-cell">
        {format(item?.created_at, "yyyy-MM-dd")}
      </td>
      <td>
        <div className="flex items-center gap-2">
          <ViewAction href={`doctors/${item?.id}`} />
          {isAdmin && (
            <ActionDialog type="delete" id={item?.id} deleteType="doctor" />
          )}
        </div>
      </td>
    </tr>
  );

  return (
    <div className="bg-white rounded-xl py-6 px-3 2xl:px-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <Users size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalRecords}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total doctors
          </span>
        </div>
        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />
          {isAdmin && <DoctorForm />}
        </div>
      </div>

      <div className="mt-4">
        <Table columns={columns} data={data} renderRow={renderRow} />

        {totalPages && (
          <Pagination
            totalPages={totalPages}
            currentPage={currentPage}
            totalRecords={totalRecords}
            limit={DATA_LIMIT}
          />
        )}
      </div>
    </div>
  );
};

export default DoctorsList;
```

## 📄 app\(protected)\record\doctors\[id]\page.tsx

```tsx
import { availableDays } from "@/components/available-doctor";
import { PatientRatingContainer } from "@/components/patient-rating-container";
import { ProfileImage } from "@/components/profile-image";
import { RatingContainer } from "@/components/rating-container";
import { RecentAppointments } from "@/components/tables/recent-appointment";
import { getDoctorById } from "@/utils/services/doctor";
import { format } from "date-fns";
import Link from "next/link";
import React from "react";

import { BsCalendarDateFill, BsPersonWorkspace } from "react-icons/bs";
import { FaBriefcaseMedical, FaCalendarDays } from "react-icons/fa6";
import { IoTimeSharp } from "react-icons/io5";
import { MdEmail, MdLocalPhone } from "react-icons/md";

const DoctorProfile = async (props: { params: Promise<{ id: string }> }) => {
  const params = await props.params;
  const { data, totalAppointment } = await getDoctorById(params?.id);

  if (!data) return null;

  return (
    <div className="bg-gray-100/60 h-full rounded-xl py-6 px-3 2xl:px-5 flex flex-col lg:flex-row gap-6">
      <div className="w-full lg:w-[70%]">
        <div className="flex flex-col lg:flex-row gap-4">
          <div className="bg-blue-50 py-6 px-4 rounded-md flex-1 flex gap-4">
            <ProfileImage
              url={data?.img!}
              name={data?.name}
              className="size-20"
              bgColor={data?.colorCode!}
              textClassName="text-4xl text-black"
            />

            <div className="w-2/3 flex flex-col justify-between gap-x-4">
              <div className="flex items-center gap-4">
                <h1 className="text=xl font-semibold uppercase">
                  {data?.name}
                </h1>
              </div>
              <p className="text-sm text-gray-500">
                {data?.address || "No address information"}
              </p>

              <div className="mt-4 flex items-center justify-between gap-2 flex-wrap text-sm font-medium">
                <div className="w-full flex text-base">
                  <span>License #:</span>
                  <p className="font-semibold">{data?.license_number}</p>
                </div>

                <div className="w-full md:w-1/3 lg:w-full 2xl:w-1/3 flex items-center gap-2">
                  <FaBriefcaseMedical className="text-lg" />
                  <span className="capitalize">{data?.specialization}</span>
                </div>
                <div className="w-full md:w-1/3 lg:w-full 2xl:w-1/3 flex items-center gap-2">
                  <BsPersonWorkspace className="text-lg" />
                  <span className="capitalize">{data?.type}</span>
                </div>
                <div className="w-full md:w-1/3 lg:w-full 2xl:w-1/3 flex items-center gap-2">
                  <MdEmail className="text-lg" />
                  <span className="capitalize">{data?.email}</span>
                </div>
                <div className="w-full md:w-1/3 lg:w-full 2xl:w-1/3 flex items-center gap-2">
                  <MdLocalPhone className="text-lg" />
                  <span className="capitalize">{data?.phone}</span>
                </div>
              </div>
            </div>
          </div>

          {/* SATS */}
          <div className="flex-1 flex gap-4 justify-between flex-wrap">
            <div className="doctorCard">
              <FaBriefcaseMedical className="size-5" />
              <div>
                <h1 className="text-xl font-serif">{totalAppointment}</h1>
                <span className="text-sm text-gray-500">Appointments</span>
              </div>
            </div>
            <div className="doctorCard">
              <FaCalendarDays className="size-5" />
              <div>
                <h1 className="text-xl font-serif">
                  {data?.working_days?.length}
                </h1>
                <span className="text-sm text-gray-500">Working Days</span>
              </div>
            </div>

            <div className="doctorCard">
              <IoTimeSharp className="size-5" />
              <div>
                <h1 className="text-xl font-serif">
                  {availableDays({ data: data.working_days })}
                </h1>
                <span className="text-sm text-gray-500">Working Hours</span>
              </div>
            </div>
            <div className="doctorCard">
              <BsCalendarDateFill className="size-5" />
              <div>
                <h1 className="text-xl font-serif">
                  {format(data?.created_at, "yyyy-MM-dd")}
                </h1>
                <span className="text-sm text-gray-500">Joined Date</span>
              </div>
            </div>
          </div>
        </div>
        {/* recent appointment */}

        <div className="bg-white rounded-e-xl p-4 mt-6">
          <RecentAppointments data={data?.appointments} />
        </div>
      </div>

      {/* RIGHT SIDE */}

      <div className="w-full lg:w-[30%] flex flex-col gap-4">
        <div className="bg-white p-4 rounded-md">
          <h1 className="text-xl font-semibold">Quick Links</h1>

          <div className="mt-8 flex gap-4 flex-wrap text-sm text-gray-500">
            <Link
              href={`/record/appointments?id=${data?.id}`}
              className="p-3 rounded-md bg-yellow-60 hover:underline"
            >
              Doctor Appointments
            </Link>

            <Link
              href="#"
              className="p-3 rounded-md bg-purple-50 hover:underline"
            >
              Apply for Leave
            </Link>
          </div>
        </div>

        <RatingContainer id={params?.id} />
      </div>
    </div>
  );
};

export default DoctorProfile;
```

## 📄 app\(protected)\record\medical-records\page.tsx

```tsx
import { ViewAction } from "@/components/action-options";
import { Pagination } from "@/components/pagination";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { SearchParamsProps } from "@/types";
import { checkRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getMedicalRecords } from "@/utils/services/medical-record";
// import { Diagnosis, LabTest, MedicalRecords, Patient } from "@prisma/client";
import { Diagnosis, LabTest, MedicalRecords , Patient } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { BriefcaseBusiness } from "lucide-react";

const columns = [
  {
    header: "No",
    key: "no",
  },
  {
    header: "Info",
    key: "name",
  },
  {
    header: "Date & Time",
    key: "medical_date",
    className: "hidden md:table-cell",
  },
  {
    header: "Doctor",
    key: "doctor",
    className: "hidden 2xl:table-cell",
  },
  {
    header: "Diagnosis",
    key: "diagnosis",
    className: "hidden lg:table-cell",
  },
  {
    header: "Lab Test",
    key: "lab_test",
    className: "hidden 2xl:table-cell",
  },
  {
    header: "Action",
    key: "action",
    className: "",
  },
];

interface ExtendedProps extends MedicalRecords {
  patient: Patient;
  diagnosis: Diagnosis[];
  lab_test: LabTest[];
}

const MedicalRecordsPage = async (props: SearchParamsProps) => {
  const searchParams = await props.searchParams;
  const page = (searchParams?.p || "1") as string;
  const searchQuery = (searchParams?.q || "") as string;

  const { data, totalPages, totalRecords, currentPage } =
    await getMedicalRecords({
      page,
      search: searchQuery,
    });
  const isAdmin = await checkRole("ADMIN");

  if (!data) return null;

  const renderRow = (item: ExtendedProps) => {
    const name = item?.patient?.first_name + " " + item?.patient?.last_name;
    const patient = item?.patient;

    return (
      <tr
        key={item?.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="flex items-center gap-4 p-4">
          <ProfileImage
            url={item?.patient?.img!}
            name={name}
            bgColor={patient?.colorCode!}
            textClassName="text-black"
          />
          <div>
            <h3 className="uppercase">{name}</h3>
            <span className="text-sm capitalize">{patient?.gender}</span>
          </div>
        </td>
        <td className="hidden md:table-cell">
          {format(item?.created_at, "yyyy-MM-dd HH:mm:ss")}
        </td>
        <td className="hidden 2xl:table-cell">{item?.doctor_id}</td>
        <td className="hidden lg:table-cell">
          {item?.diagnosis?.length === 0 ? (
            <span className="text-gray-400 italic">No diagnosis found</span>
          ) : (
            <span>{item?.diagnosis.length}</span>
          )}
        </td>
        <td className="hidden xl:table-cell">
          {item?.lab_test?.length === 0 ? (
            <span className="text-gray-400 italic">No lab found</span>
          ) : (
            <span>{item?.lab_test.length}</span>
          )}
        </td>

        <td>
          <ViewAction href={`/appointments/${item?.appointment_id}`} />
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl py-6 px-3 2xl:px-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <BriefcaseBusiness size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalRecords}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total records
          </span>
        </div>
        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />
        </div>
      </div>

      <div className="mt-4">
        <Table columns={columns} data={data} renderRow={renderRow} />

        <Pagination
          totalPages={totalPages}
          currentPage={currentPage}
          totalRecords={totalRecords}
          limit={DATA_LIMIT}
        />
      </div>
    </div>
  );
};

export default MedicalRecordsPage;
```

## 📄 app\(protected)\record\patients\page.tsx

```tsx
import { ActionDialog } from "@/components/action-dialog";
import { ActionOptions, ViewAction } from "@/components/action-options";
import { StaffForm } from "@/components/forms/staff-form";
import { Pagination } from "@/components/pagination";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { Button } from "@/components/ui/button";
import { SearchParamsProps } from "@/types";
import { calculateAge } from "@/utils";
import { checkRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getAllPatients } from "@/utils/services/patient";
import { Patient } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { UserPen, Users } from "lucide-react";

const columns = [
  {
    header: "Patient Name",
    key: "name",
  },
  {
    header: "Gender",
    key: "gender",
    className: "hidden md:table-cell",
  },
  {
    header: "Phone",
    key: "contact",
    className: "hidden md:table-cell",
  },
  {
    header: "Email",
    key: "email",
    className: "hidden lg:table-cell",
  },
  {
    header: "Address",
    key: "address",
    className: "hidden xl:table-cell",
  },
  {
    header: "Last Visit",
    key: "created_at",
    className: "hidden lg:table-cell",
  },
  {
    header: "Last Treatment",
    key: "treatment",
    className: "hidden 2xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

interface PatientProps extends Patient {
  appointments: {
    medical: {
      created_at: Date;
      treatment_plan: string;
    }[];
  }[];
}
const PatientList = async (props: SearchParamsProps) => {
  const searchParams = await props.searchParams;
  const page = (searchParams?.p || "1") as string;
  const searchQuery = (searchParams?.q || "") as string;

  const { data, totalPages, totalRecords, currentPage } = await getAllPatients({
    page,
    search: searchQuery,
  });
  const isAdmin = await checkRole("ADMIN");

  if (!data) return null;

  const renderRow = (item: PatientProps) => {
    const lastVisit = item?.appointments[0]?.medical[0] || null;

    const name = item?.first_name + " " + item?.last_name;

    return (
      <tr
        key={item?.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="flex items-center gap-4 p-4">
          <ProfileImage
            url={item?.img!}
            name={name}
            bgColor={item?.colorCode!}
            textClassName="text-black"
          />
          <div>
            <h3 className="uppercase">{name}</h3>
            <span className="text-sm capitalize">
              {calculateAge(item?.date_of_birth)}
            </span>
          </div>
        </td>
        <td className="hidden md:table-cell">{item?.gender}</td>
        <td className="hidden md:table-cell">{item?.phone}</td>
        <td className="hidden lg:table-cell">{item?.email}</td>
        <td className="hidden xl:table-cell">{item?.address}</td>
        <td className="hidden xl:table-cell">
          {lastVisit ? (
            format(lastVisit?.created_at, "yyyy-MM-dd HH:mm:ss")
          ) : (
            <span className="text-gray-400 italic">No last visit</span>
          )}
        </td>
        <td className="hidden xl:table-cell">
          {lastVisit ? (
            lastVisit?.treatment_plan
          ) : (
            <span className="text-gray-400 italic">No last treatment</span>
          )}
        </td>
        <td>
          <div className="flex items-center gap-2">
            <ViewAction href={`/patient/${item?.id}`} />

            <ActionOptions>
              <div className="space-y-3">
                <Button variant={"ghost"} className="text-xs font-light">
                  <UserPen size={16} />
                  Edit
                </Button>

                {isAdmin && (
                  <ActionDialog
                    type="delete"
                    id={item.id}
                    deleteType="patient"
                  />
                )}
              </div>
            </ActionOptions>
          </div>
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl py-6 px-3 2xl:px-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <Users size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalRecords}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total patients
          </span>
        </div>
        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />
        </div>
      </div>

      <div className="mt-4">
        <Table columns={columns} data={data} renderRow={renderRow} />

        {totalPages && (
          <Pagination
            totalPages={totalPages}
            currentPage={currentPage}
            totalRecords={totalRecords}
            limit={DATA_LIMIT}
          />
        )}
      </div>
    </div>
  );
};

export default PatientList;
```

## 📄 app\(protected)\record\staffs\page.tsx

```tsx
import { ActionDialog } from "@/components/action-dialog";
import { ViewAction } from "@/components/action-options";
import { DoctorForm } from "@/components/forms/doctor-form";
import { StaffForm } from "@/components/forms/staff-form";
import { Pagination } from "@/components/pagination";
import { ProfileImage } from "@/components/profile-image";
import SearchInput from "@/components/search-input";
import { Table } from "@/components/tables/table";
import { Button } from "@/components/ui/button";
import { SearchParamsProps } from "@/types";
import { checkRole } from "@/utils/roles";
import { DATA_LIMIT } from "@/utils/seetings";
import { getAllStaff } from "@/utils/services/staff";
import { Doctor , Staff } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { Users } from "lucide-react";
import React from "react";

const columns = [
  {
    header: "Info",
    key: "name",
  },
  {
    header: "Role",
    key: "role",
    className: "hidden md:table-cell",
  },
  {
    header: "Phone",
    key: "contact",
    className: "hidden md:table-cell",
  },
  {
    header: "Email",
    key: "email",
    className: "hidden lg:table-cell",
  },
  {
    header: "Joined Date",
    key: "created_at",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

const StaffList = async (props: SearchParamsProps) => {
  const searchParams = await props.searchParams;
  const page = (searchParams?.p || "1") as string;
  const searchQuery = (searchParams?.q || "") as string;

  const { data, totalPages, totalRecords, currentPage } = await getAllStaff({
    page,
    search: searchQuery,
  });

  if (!data) return null;
  const isAdmin = await checkRole("ADMIN");

  const renderRow = (item: Staff) => (
    <tr
      key={item?.id}
      className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
    >
      <td className="flex items-center gap-4 p-4">
        <ProfileImage
          url={item?.img!}
          name={item?.name}
        //   bgColor={item?.colorCode!}
          textClassName="text-black"
        />
        <div>
          <h3 className="uppercase">{item?.name}</h3>
          <span className="text-sm capitalize">{item?.phone}</span>
        </div>
      </td>
      <td className="hidden md:table-cell">{item?.role}</td>
      <td className="hidden md:table-cell">{item?.phone}</td>
      <td className="hidden lg:table-cell">{item?.email}</td>
      <td className="hidden xl:table-cell">
        {format(item?.created_at, "yyyy-MM-dd")}
      </td>
      <td>
        <div className="flex items-center gap-2">
          <ActionDialog type="staff" id={item?.id} data={item} />

          {isAdmin && (
            <ActionDialog type="delete" id={item?.id} deleteType="staff" />
          )}
        </div>
      </td>
    </tr>
  );

  return (
    <div className="bg-white rounded-xl py-6 px-3 2xl:px-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <Users size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalRecords}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total staffs
          </span>
        </div>
        <div className="w-full lg:w-fit flex items-center justify-between lg:justify-start gap-2">
          <SearchInput />
          {isAdmin && <StaffForm />}
        </div>
      </div>

      <div className="mt-4">
        <Table columns={columns} data={data} renderRow={renderRow} />

        {totalPages && (
          <Pagination
            totalPages={totalPages}
            currentPage={currentPage}
            totalRecords={totalRecords}
            limit={DATA_LIMIT}
          />
        )}
      </div>
    </div>
  );
};

export default StaffList;
```

## 📄 app\(protected)\record\users\page.tsx

```tsx
import { Table } from "@/components/tables/table";
import { clerkClient } from "@clerk/nextjs/server";
import { format } from "date-fns";
import { BriefcaseBusiness } from "lucide-react";
import React from "react";

const columns = [
  {
    header: "user ID",
    key: "id",
    className: "hidden lg:table-cell",
  },
  {
    header: "Name",
    key: "name",
  },
  {
    header: "Email",
    key: "email",
    className: "hidden md:table-cell",
  },
  {
    header: "Role",
    key: "role",
  },
  {
    header: "Status",
    key: "status",
  },
  {
    header: "Last Login",
    key: "last_login",
    className: "hidden xl:table-cell",
  },
];

interface UserProps {
  id: string;
  firstName: string;
  lastName: string;
  emailAddresses: { emailAddress: string }[];
  publicMetadata: { role: string };
  lastSignInAt: number | string;
}
const UserPage = async () => {
  const client = await clerkClient();

  const { data, totalCount } = await client.users.getUserList({
    orderBy: "-created_at",
  });

  if (!data) return null;

  const renderRow = (item: UserProps) => (
    <tr
      key={item.id}
      className="border-b border-gray-200 even:bg-slate-50 text-base hover:bg-slate-50"
    >
      <td className="hidden lg:table-cell items-center">{item?.id}</td>
      <td className="table-cell py-2 xl:py-4">
        {item?.firstName} {item?.lastName}
      </td>
      <td className="table-cell">{item?.emailAddresses[0].emailAddress}</td>
      <td className="table-cell capitalize">{item?.publicMetadata.role}</td>
      <td className="hidden md:table-cell capitalize">Active</td>
      <td className="hidden md:table-cell capitalize">
        {format(item?.lastSignInAt, "yyyy-MM-dd h:mm:ss")}
      </td>
    </tr>
  );
  return (
    <div className="bg-white rounded-xl p-2 md:p-4 2xl:p-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <BriefcaseBusiness size={20} className="text-gray-500" />

          <p className="text-2xl font-semibold">{totalCount}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total users
          </span>
        </div>
      </div>

      <div>
        <Table columns={columns} data={data} renderRow={renderRow} />
      </div>
    </div>
  );
};

export default UserPage;
```

## 📄 app\actions\admin.ts

```ts
"use server";

import db from "@/lib/db";
import {
  DoctorSchema,
  ServicesSchema,
  StaffSchema,
  WorkingDaysSchema,
} from "@/lib/schema";
import { generateRandomColor } from "@/utils";
import { checkRole } from "@/utils/roles";
import { auth, clerkClient } from "@clerk/nextjs/server";

export async function createNewStaff(data: any) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return { success: false, msg: "Unauthorized" };
    }

    const isAdmin = await checkRole("ADMIN");

    if (!isAdmin) {
      return { success: false, msg: "Unauthorized" };
    }

    const values = StaffSchema.safeParse(data);

    if (!values.success) {
      return {
        success: false,
        errors: true,
        message: "Please provide all required info",
      };
    }

    const validatedValues = values.data;

    const client = await clerkClient();

    const user = await client.users.createUser({
      emailAddress: [validatedValues.email],
      password: validatedValues.password,
      firstName: validatedValues.name.split(" ")[0],
      lastName: validatedValues.name.split(" ")[1],
      publicMetadata: { role: "doctor" },
    });

    delete validatedValues["password"];

    const doctor = await db.staff.create({
      data: {
        name: validatedValues.name,
        phone: validatedValues.phone,
        email: validatedValues.email,
        address: validatedValues.address,
        role: validatedValues.role,
        license_number: validatedValues.license_number,
        department: validatedValues.department,
        // colorCode: generateRandomColor(),
        id: user.id,
        status: "ACTIVE",
      },
    });

    return {
      success: true,
      message: "Doctor added successfully",
      error: false,
    };
  } catch (error) {
    console.log(error);
    return { error: true, success: false, message: "Something went wrong" };
  }
}
export async function createNewDoctor(data: any) {
  try {
    const values = DoctorSchema.safeParse(data);

    const workingDaysValues = WorkingDaysSchema.safeParse(data?.work_schedule);

    if (!values.success || !workingDaysValues.success) {
      return {
        success: false,
        errors: true,
        message: "Please provide all required info",
      };
    }

    const validatedValues = values.data;
    const workingDayData = workingDaysValues.data!;

    const client = await clerkClient();

    const user = await client.users.createUser({
      emailAddress: [validatedValues.email],
      password: validatedValues.password,
      firstName: validatedValues.name.split(" ")[0],
      lastName: validatedValues.name.split(" ")[1],
      publicMetadata: { role: "doctor" },
    });

    delete validatedValues["password"];

    const doctor = await db.doctor.create({
      data: {
        ...validatedValues,
        id: user.id,
      },
    });

    await Promise.all(
      workingDayData?.map((el) =>
        db.workingDays.create({
          data: { ...el, doctor_id: doctor.id },
        })
      )
    );

    return {
      success: true,
      message: "Doctor added successfully",
      error: false,
    };
  } catch (error) {
    console.log(error);
    return { error: true, success: false, message: "Something went wrong" };
  }
}

export async function addNewService(data: any) {
  try {
    const isValidData = ServicesSchema.safeParse(data);

    const validatedData = isValidData.data;

    await db.services.create({
      data: { ...validatedData!, price: Number(data.price!) },
    });

    return {
      success: true,
      error: false,
      msg: `Service added successfully`,
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}
```

## 📄 app\actions\appointment.ts

```ts
"use server";

import { VitalSignsFormData } from "@/components/dialogs/add-vital-signs";
import db from "@/lib/db";
import { AppointmentSchema, VitalSignsSchema } from "@/lib/schema";
import { auth, currentUser } from "@clerk/nextjs/server";
import { AppointmentStatus } from "@/lib/generated/prisma";

export async function createNewAppointment(data: any) {
  try {
    const validatedData = AppointmentSchema.safeParse(data);

    if (!validatedData.success) {
      return { success: false, msg: "Invalid data" };
    }
    const validated = validatedData.data;

    await db.appointment.create({
      data: {
        patient_id: data.patient_id,
        doctor_id: validated.doctor_id,
        appointmentTime: validated.time,
        type: validated.type,
        appointmentDate: new Date(validated.appointment_date),
        note: validated.note,
      },
    });

    return {
      success: true,
      message: "Appointment booked successfully",
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}
export async function appointmentAction(
  id: string | number,

  status: AppointmentStatus,
  reason: string
) {
  try {
    await db.appointment.update({
      where: { id: Number(id) },
      data: {
        status,
        reason,
      },
    });

    return {
      success: true,
      error: false,
      msg: `Appointment ${status.toLowerCase()} successfully`,
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}

export async function addVitalSigns(
  data: VitalSignsFormData,
  appointmentId: string,
  doctorId: string
) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return { success: false, msg: "Unauthorized" };
    }

    const validatedData = VitalSignsSchema.parse(data);

    let medicalRecord = null;

    if (!validatedData.medical_id) {
      medicalRecord = await db.medicalRecords.create({
        data: {
          patient_id: validatedData.patient_id,
          appointment_id: Number(appointmentId),
          doctor_id: doctorId,
        },
      });
    }

    const med_id = validatedData.medical_id || medicalRecord?.id;

    await db.vitalSigns.create({
      data: {
        ...validatedData,
        medical_id: Number(med_id!),
      },
    });

    return {
      success: true,
      msg: "Vital signs added successfully",
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}
```

## 📄 app\actions\general.ts

```ts
"use server";

import {
  ReviewFormValues,
  reviewSchema,
} from "@/components/dialogs/review-form";
import db from "@/lib/db";
import { clerkClient } from "@clerk/nextjs/server";

export async function deleteDataById(
  id: string,

  deleteType: "doctor" | "staff" | "patient" | "payment" | "bill"
) {
  try {
    switch (deleteType) {
      case "doctor":
        await db.doctor.delete({ where: { id: id } });
      case "staff":
        await db.staff.delete({ where: { id: id } });
      case "patient":
        await db.patient.delete({ where: { id: id } });
      case "payment":
        await db.payment.delete({ where: { id: Number(id) } });
    }

    if (
      deleteType === "staff" ||
      deleteType === "patient" ||
      deleteType === "doctor"
    ) {
      const client = await clerkClient();
      await client.users.deleteUser(id);
    }

    return {
      success: true,
      message: "Data deleted successfully",
      status: 200,
    };
  } catch (error) {
    console.log(error);

    return {
      success: false,
      message: "Internal Server Error",
      status: 500,
    };
  }
}

export async function createReview(values: ReviewFormValues) {
  try {
    const validatedFields = reviewSchema.parse(values);

    await db.rating.create({
      data: {
        ...validatedFields,
      },
    });

    return {
      success: true,
      message: "Review created successfully",
      status: 200,
    };
  } catch (error) {
    console.log(error);

    return {
      success: false,
      message: "Internal Server Error",
      status: 500,
    };
  }
}
```

## 📄 app\actions\medical.ts

```ts
"use server";

import { DiagnosisFormData } from "@/components/dialogs/add-diagnosis";
import db from "@/lib/db";
import {
  DiagnosisSchema,
  PatientBillSchema,
  PaymentSchema,
} from "@/lib/schema";
import { checkRole } from "@/utils/roles";

export const addDiagnosis = async (
  data: DiagnosisFormData,
  appointmentId: string
) => {
  try {
    const validatedData = DiagnosisSchema.parse(data);

    let medicalRecord = null;

    if (!validatedData.medical_id) {
      medicalRecord = await db.medicalRecords.create({
        data: {
          patient_id: validatedData.patient_id,
          doctor_id: validatedData.doctor_id,
          appointment_id: Number(appointmentId),
        },
      });
    }

    const med_id = validatedData.medical_id || medicalRecord?.id;
    await db.diagnosis.create({
      data: {
        ...validatedData,
        medical_id: Number(med_id),
      },
    });

    return {
      success: true,
      message: "Diagnosis added successfully",
      status: 201,
    };
  } catch (error) {
    console.log(error);
    return {
      error: "Failed to add diagnosis",
    };
  }
};

export async function addNewBill(data: any) {
  try {
    const isAdmin = await checkRole("ADMIN");
    const isDoctor = await checkRole("DOCTOR");

    if (!isAdmin && !isDoctor) {
      return {
        success: false,
        msg: "You are not authorized to add a bill",
      };
    }

    const isValidData = PatientBillSchema.safeParse(data);

    const validatedData = isValidData.data;
    let bill_info = null;

    if (!data?.bill_id || data?.bill_id === "undefined") {
      const info = await db.appointment.findUnique({
        where: { id: Number(data?.appointment_id)! },
        select: {
          id: true,
          patient_id: true,
          bills: {
            where: {
              appointment_Id: Number(data?.appointment_id),
            },
          },
        },
      });

      if (!info?.bills?.length) {
        bill_info = await db.payment.create({
          data: {
            appointment_Id: Number(data?.appointment_id),
            patient_id: info?.patient_id!,
            bill_date: new Date(),
            payment_Date: new Date(),
            discount: 0.0,
            amount_paid: 0.0,
            total_amount: 0.0,
          },
        });
      } else {
        bill_info = info?.bills[0];
      }
    } else {
      bill_info = {
        id: data?.bill_id,
      };
    }

    await db.patientBills.create({
      data: {
        bill_id: Number(bill_info?.id),
        service_id: Number(validatedData?.service_id),
        service_date: new Date(validatedData?.service_date!),
        quantity: Number(validatedData?.quantity),
        unit_cost: Number(validatedData?.unit_cost),
        total_cost: Number(validatedData?.total_cost),
      },
    });

    return {
      success: true,
      error: false,
      msg: `Bill added successfully`,
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}

export async function generateBill(data: any) {
  try {
    const isValidData = PaymentSchema.safeParse(data);

    const validatedData = isValidData.data;

    const discountAmount =
      (Number(validatedData?.discount) / 100) *
      Number(validatedData?.total_amount);

    const res = await db.payment.update({
      data: {
        bill_date: validatedData?.bill_date,
        discount: discountAmount,
        total_amount: Number(validatedData?.total_amount)!,
      },
      where: { id: Number(validatedData?.id) },
    });

    await db.appointment.update({
      data: {
        status: "COMPLETED",
      },
      where: { id: res.appointment_Id },
    });
    return {
      success: true,
      error: false,
      msg: `Bill generated successfully`,
    };
  } catch (error) {
    console.log(error);
    return { success: false, msg: "Internal Server Error" };
  }
}
```

## 📄 app\actions\patient.ts

```ts
"use server";

import db from "../../lib/db";
import { PatientFormSchema } from "../../lib/schema";
import { clerkClient } from "@clerk/nextjs/server";

export async function updatePatient(data: any, pid: string) {
  try {
    const validateData = PatientFormSchema.safeParse(data);

    if (!validateData.success) {
      return {
        success: false,
        error: true,
        msg: "Provide all required fields",
      };
    }

    const patientData = validateData.data;

    const client = await clerkClient();
    await client.users.updateUser(pid, {
      firstName: patientData.first_name,
      lastName: patientData.last_name,
    });

    await db.patient.update({
      data: {
        ...patientData,
      },
      where: { id: pid },
    });

    return {
      success: true,
      error: false,
      msg: "Patient info updated successfully",
    };
  } catch (error: any) {
    console.error(error);
    return { success: false, error: true, msg: error?.message };
  }
}
export async function createNewPatient(data: any, pid: string) {
  try {
    const validateData = PatientFormSchema.safeParse(data);

    if (!validateData.success) {
      return {
        success: false,
        error: true,
        msg: "Provide all required fields",
      };
    }

    const patientData = validateData.data;
    let patient_id = pid;

    const client = await clerkClient();
    if (pid === "new-patient") {
      const user = await client.users.createUser({
        emailAddress: [patientData.email],
        password: patientData.phone,
        firstName: patientData.first_name,
        lastName: patientData.last_name,
        publicMetadata: { role: "patient" },
      });

      patient_id = user?.id;
    } else {
      await client.users.updateUser(pid, {
        publicMetadata: { role: "patient" },
      });
    }

    await db.patient.create({
      data: {
        ...patientData,
        id: patient_id,
      },
    });

    return { success: true, error: false, msg: "Patient created successfully" };
  } catch (error: any) {
    console.error(error);
    return { success: false, error: true, msg: error?.message };
  }
}
```

## 📄 app\globals.css

```css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

```

## 📄 app\layout.tsx

```tsx
import { type Metadata } from 'next';
import { ClerkProvider } from '@clerk/nextjs';
import { Toaster } from 'sonner';
import { Inter, Roboto_Mono } from 'next/font/google';
import './globals.css';

const geistSans = Inter({
  variable: '--font-geist-sans',
  subsets: ['latin'],
  display: 'swap',
});

const geistMono = Roboto_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'Your App',
  description: 'Description',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en" className={`${geistSans.variable} ${geistMono.variable}`}>
        <body>
          <div className="min-h-screen flex flex-col">
            {children} 
          </div>
          <Toaster richColors position="top-center" />
        </body>
      </html>
    </ClerkProvider>
  );  
}
```

## 📄 app\layoutDebugger.tsx

```tsx
'use client';
import { useEffect } from 'react';

export function LayoutDebugger() {
  useEffect(() => {
    console.log('Layout mounted');
    return () => console.log('Layout unmounted');
  }, []);
  
  return null;
}
```

## 📄 app\page.tsx

```tsx
import { Button } from "@/components/ui/button";
import { UserButton } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";
import Image from "next/image";
import { getRole } from "@/utils/roles";
import Link from "next/link";
import { redirect } from "next/navigation"

export default async function Home() {
  const { userId } = await auth();
  const role = await getRole();

  if (userId && role) {
    redirect(`/${role}`);
  }

  return (
    <div className="flex flex-col items-center justify-center h-screen p-6">
      <div className="flex-1 flex flex-col items-center justify-center">
        <div className="mb-8">
          <h1 className="text-4xl md:text-5xl font-bold text-center">
            Welcome to <br />
            <span className="text-blue-600 text-5xl md:text-6xl">
              HealthAxis
            </span>
          </h1>
        </div>

        <div className="text-center max-w-xl flex flex-col items-center justify-center">
          <p className="mb-8">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Eveniet, pariatur aut Lorem ipsum dolor sit amet.
          </p>
        </div>

        <div className="flex justify-center items-center gap-4">
          {
            userId ? <>
              <Link href={`/${role}`}>
                <Button>
                  View Dashboard
                </Button> 
              </Link>
              {/* <UserButton></UserButton> */}
            </> : <>
              <Link href="/sign-up">
                <Button className="md:text-base font-medium">
                  New Patient
                </Button>
              </Link>

              <Link href="/sign-in">
                <Button
                  variant="outline"
                  className="md:text-base underline hover:text-blue-500">
                  Login to account
                </Button>
              </Link>
            </>
          }
        </div>
      </div>

      <footer className="mt-8">
        <p className="text-center text-sm">
          &copy; 2025 HealthAxis Hospitam Management System.
        </p>

      </footer>
    </div>
  );
}

```

## 📄 components\action-dialog.tsx

```tsx
"use client";

import React, { useState } from "react";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "./ui/dialog";
import { useRouter } from "next/navigation";
import { Button } from "./ui/button";
import { Trash2 } from "lucide-react";
import { FaQuestion } from "react-icons/fa6";
import { toast } from "sonner";
import { deleteDataById } from "@/app/actions/general";
import { ProfileImage } from "./profile-image";
import { SmallCard } from "./small-card";

interface ActionDialogProps {
  type: "doctor" | "staff" | "delete";
  id: string;
  data?: any;
  deleteType?: "doctor" | "staff" | "patient" | "payment" | "bill";
}
export const ActionDialog = ({
  id,
  data,
  type,
  deleteType,
}: ActionDialogProps) => {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  if (type === "delete") {
    const handleDelete = async () => {
      try {
        setLoading(true);

        const res = await deleteDataById(id, deleteType!);

        if (res.success) {
          toast.success("Record deleted successfully");
          router.refresh();
        } else {
          toast.error("Failed to delete record");
        }
      } catch (error) {
        console.log(error);
        toast.error("Something went wrong");
      } finally {
        setLoading(false);
      }
    };

    return (
      <Dialog>
        <DialogTrigger asChild>
          <Button
            variant={"outline"}
            className="flex items-center justify-center rounded-full text-red-500"
          >
            <Trash2 size={16} className="text-red-500" />
            {deleteType === "patient" && "Delete"}
          </Button>
        </DialogTrigger>

        <DialogContent>
          <div className="flex flex-col items-center justify-center py-6">
            <DialogTitle>
              <div className="bg-red-200 p-4 rounded-full mb-2">
                <FaQuestion size={50} className="text-red-500" />
              </div>
            </DialogTitle>

            <span className="text-xl text-black">Delete Confirmation</span>
            <p className="text-sm">
              Are you sure you want to delete the selected record?
            </p>

            <div className="flex justify-center mt-6 items-center gap-x-3">
              <DialogClose asChild>
                <Button variant={"outline"} className="px-4 py-2">
                  Cancel
                </Button>
              </DialogClose>

              <Button
                disabled={loading}
                variant="outline"
                className="px-4 py-2 text-sm font-medium bg-destructive text-white hover:bg-destructive hover:text-white"
                onClick={handleDelete}
              >
                Yes. Delete
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    );
  }

  if (type === "staff") {
    return (
      <Dialog>
        <DialogTrigger asChild>
          <Button
            variant={"outline"}
            className="flex items-center justify-center rounded-full text-blue-600/10  hover:underline"
          >
            View
          </Button>
        </DialogTrigger>

        <DialogContent className="max-w-[300px] md:max-w-2xl max-h-[90%] p-8 overflow-y-auto">
          <DialogTitle className="text-lg text-gray-600 font-semibold mb-4">
            Staff Information
          </DialogTitle>

          <div className="flex justify-between">
            <div className="flex gap-3 items-center">
              <ProfileImage
                url={data?.img!}
                name={data?.name}
                className="xl:size-20"
                bgColor={data?.colorCode!}
                textClassName="xl:text-2xl"
              />

              <div className="flex flex-col">
                <p className="text-xl font-semibold">{data?.name}</p>
                <span className="text-gray-600 text-sm md:text-base capitalize">
                  {data?.role?.toLowerCase()}
                </span>
                <span className="text-blue-500 text-sm">Full-Time</span>
              </div>
            </div>
          </div>

          <div className="mt-10 space-y-6">
            <div className="flex flex-col md:flex-row md:flex-wrap md:items-center  gap-y-4 md:gap-x-0 xl:justify-between">
              {/* <SmallCard label="Full Name" value={data?.name} /> */}
              <SmallCard label="Email Address" value={data?.email} />
              <SmallCard label="Phone Number" value={data?.phone} />
            </div>

            <div>
              <SmallCard label="Address" value={data?.address || "N/A"} />
            </div>

            <div className="flex flex-col md:flex-row md:flex-wrap md:items-center  gap-y-4 md:gap-x-0 xl:justify-between">
              <SmallCard label="Role" value={data?.role} />
              <SmallCard label="Department" value={data?.department || "N/A"} />
              <SmallCard
                label="License Number"
                value={data?.license_number || "N/A"}
              />
            </div>
          </div>
        </DialogContent>
      </Dialog>
    );
  }
  return null;
};
```

## 📄 components\action-options.tsx

```tsx
"use client";

import { EllipsisVertical } from "lucide-react";
import Link from "next/link";
import React from "react";

import { Button } from "./ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover";

export const ActionOptions = ({ children }: { children: React.ReactNode }) => {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className="flex items-center justify-center rounded-full p-1"
        >
          <EllipsisVertical size={16} className="text-sm text-gray-500" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-56 p-3">
        <span className="text-xs text-gray-400 mb-4 uppercase">
          Perform Action
        </span>
        {children}
      </PopoverContent>
    </Popover>
  );
};

const className =
  "flex items-center justify-center rounded-full bg-blue-600/10 hover:underline text-blue-600 px-1.5 py-1 text-xs md:text-sm disabled:text-gray-400 disabled:hover:no-underline disabled:cursor-not-allowed";

export const ViewAction = ({
  href,
  disabled = false,
}: {
  href: string;
  disabled?: boolean;
}) => {
  return (
    <Link href={href}>
      <button disabled={disabled} className={className}>
        View
      </button>
    </Link>
  );
};

export const ViewActionButton = () => {
  return (
    <button type="button" className={className}>
      View
    </button>
  );
};
```

## 📄 components\appointment\appointment-details.tsx

```tsx
import { format } from "date-fns";
import { SmallCard } from "../small-card";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";

interface AppointmentDetailsProps {
  id: number | string;
  patient_id: string;
  appointment_date: Date;
  time: string;
  notes?: string;
}
export const AppointmentDetails = ({
  id,
  patient_id,
  appointment_date,
  time,
  notes,
}: AppointmentDetailsProps) => {
  return (
    <Card className="shadow-none">
      <CardHeader>
        <CardTitle>Appointment Information</CardTitle>
      </CardHeader>

      <CardContent className="space-y-4">
        <div className="flex ">
          <SmallCard label="Appointment #" value={`# ${id}`} />
          <SmallCard
            label="Date"
            value={format(appointment_date, "MMM d, yyyy")}
          />
          <SmallCard label="Time" value={time} />
        </div>

        <div>
          <span className="text-sm font-medium">Additional Notes</span>
          <p className="text-sm text-gray-500">{notes || "No notes"}</p>
        </div>
      </CardContent>
    </Card>
  );
};
```

## 📄 components\appointment\appointment-quick-links.tsx

```tsx
import Link from "next/link";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { checkRole } from "@/utils/roles";
import { ReviewForm } from "../dialogs/review-form";

const AppointmentQuickLinks = async ({ staffId }: { staffId: string }) => {
  const isPatient = await checkRole("PATIENT");

  return (
    <Card className="w-full rounded-xl bg-white shadow-none">
      <CardHeader>
        <CardTitle>Quick Links</CardTitle>
      </CardHeader>
      <CardContent className="flex flex-wrap gap-2">
        <Link
          href="?cat=charts"
          className="px-4 py-2 rounded-lg bg-gray-100 text-gray-600"
        >
          Charts
        </Link>
        <Link
          href="?cat=appointments"
          className="px-4 py-2 rounded-lg bg-violet-100 text-violet-600"
        >
          Appointments
        </Link>

        <Link
          href="?cat=diagnosis"
          className="px-4 py-2 rounded-lg bg-blue-100 text-blue-600"
        >
          Diagnosis
        </Link>

        <Link
          href="?cat=billing"
          className="px-4 py-2 rounded-lg bg-green-100 text-green-600"
        >
          Bills
        </Link>

        <Link
          href="?cat=medical-history"
          className="px-4 py-2 rounded-lg bg-red-100 text-red-600"
        >
          Medical History
        </Link>

        <Link
          href="?cat=payments"
          className="px-4 py-2 rounded-lg bg-purple-100 text-purple-600"
        >
          Payments
        </Link>

        <Link
          href="?cat=lab-test"
          className="px-4 py-2 rounded-lg bg-purple-100 text-purple-600"
        >
          Lab Test
        </Link>

        <Link
          href="?cat=appointments#vital-signs"
          className="px-4 py-2 rounded-lg bg-purple-100 text-purple-600"
        >
          Vital Signs
        </Link>

        {!isPatient && <ReviewForm staffId={staffId} />}
      </CardContent>
    </Card>
  );
};

export default AppointmentQuickLinks;
```

## 📄 components\appointment\bills-container.tsx

```tsx
import db from "@/lib/db";
import { calculateDiscount } from "@/utils";
import { checkRole } from "@/utils/roles";
import { ReceiptText } from "lucide-react";
import { Table } from "../tables/table";
import { PatientBills } from "@/lib/generated/prisma";
import { format, formatDate } from "date-fns";
import { ActionDialog } from "../action-dialog";
import { Separator } from "../ui/separator";
import { AddBills } from "../dialogs/add-bills";
import { GenerateFinalBills } from "./generate-final-bill";

const columns = [
  {
    header: "No",
    key: "no",
    className: "hidden md:table-cell",
  },
  {
    header: "Service",
    key: "service",
  },
  {
    header: "Date",
    key: "date",
    className: "",
  },
  {
    header: "Quantity",
    key: "qnty",
    className: "hidden md:table-cell",
  },
  {
    header: "Unit Price",
    key: "price",
    className: "hidden md:table-cell",
  },
  {
    header: "Total Cost",
    key: "total",
    className: "",
  },
  {
    header: "Action",
    key: "action",
    className: "hidden xl:table-cell",
  },
];

interface ExtendedBillProps extends PatientBills {
  service: {
    service_name: string;
    id: number;
  };
}
export const BillsContainer = async ({ id }: { id: string }) => {
  const [data, servicesData] = await Promise.all([
    db.payment.findFirst({
      where: { appointment_Id: Number(id) },
      include: {
        bills: {
          include: {
            service: { select: { service_name: true, id: true } },
          },

          orderBy: { created_at: "asc" },
        },
      },
    }),
    db.services.findMany(),
  ]);

  let totalBills = 0;

  const billData = data?.bills || [];
  const discount = data
    ? calculateDiscount({
        amount: data?.total_amount,
        discount: data?.discount,
      })
    : null;

  if (billData) {
    totalBills = billData.reduce((sum, acc) => sum + acc.total_cost, 0);
  }

  const renderRow = (item: ExtendedBillProps) => {
    return (
      <tr
        key={item.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="hidden md:table-cell py-2 xl:py-6"># {item?.id}</td>

        <td className="items-center py-2">{item?.service?.service_name}</td>

        <td className="">{format(item?.service_date, "MMM d, yyyy")}</td>

        <td className="hidden items-center py-2  md:table-cell">
          {item?.quantity}
        </td>
        <td className="hidden lg:table-cell">{item?.unit_cost.toFixed(2)}</td>
        <td>{item?.total_cost.toFixed(2)}</td>

        <td className="hidden xl:table-cell">
          <ActionDialog
            type="delete"
            id={item?.id.toString()}
            deleteType="bill"
          />
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl p-2 2xl:p-4">
      <div className="w-full flex flex-col md:flex-row md:items-center justify-between mb-6">
        <div className="">
          <h1 className="font-semibold text-xl">Patient Bills</h1>
          <div className="hidden lg:flex items-center gap-1">
            <ReceiptText size={20} className="text-gray-500" />
            <p className="text-2xl font-semibold">{billData?.length}</p>
            <span className="text-gray-600 text-sm xl:text-base">
              total records
            </span>
          </div>
        </div>

        {((await checkRole("ADMIN")) || (await checkRole("DOCTOR"))) && (
          <div className="flex items-center mt-5 justify-end">
            <AddBills id={data?.id} appId={id} servicesData={servicesData} />

            <GenerateFinalBills id={data?.id} total_bill={totalBills} />
          </div>
        )}
      </div>

      <Table columns={columns} renderRow={renderRow} data={billData!} />

      <Separator />

      <div className="flex flex-wrap lg:flex-nowrap items-center justify-between md:text-center py-2 space-y-6">
        <div className="w-[120px]">
          <span className="text-gray-500">Total Bill</span>
          <p className="text-xl font-semibold">
            {(data?.total_amount || totalBills).toFixed(2)}
          </p>
        </div>
        <div className="w-[120px]">
          <span className="text-gray-500">Discount</span>
          <p className="text-xl font-semibold text-yellow-600">
            {(data?.discount || 0.0).toFixed(2)}{" "}
            <span className="text-sm text-gray-600">
              {" "}
              ({discount?.discountPercentage?.toFixed(2) || "0.0"}%)
            </span>
          </p>
        </div>
        <div className="w-[120px]">
          <span className="text-gray-500">Payable</span>
          <p className="text-xl font-semibold ">
            {(discount?.finalAmount || 0.0).toFixed(2)}
          </p>
        </div>
        <div className="w-[120px]">
          <span className="text-gray-500">Amount Paid</span>
          <p className="text-xl font-semibold text-emerald-600">
            {(data?.amount_paid || 0.0).toFixed(2)}
          </p>
        </div>
        <div className="w-[120px]">
          <span className="text-gray-500">Unpaid Amount</span>
          <p className="text-xl font-semibold text-red-600">
            {(discount?.finalAmount! - data?.amount_paid! || 0.0).toFixed(2)}
          </p>
        </div>
      </div>
    </div>
  );
};
```

## 📄 components\appointment\blood-pressure-chart.tsx

```tsx
"use client";

import {
  Bar,
  BarChart,
  CartesianGrid,
  Legend,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";

interface BloodPressureChartProps {
  average: string;
  data: {
    label: string;
    systolic: number;
    diastolic: number;
  }[];
}

const BloodPressureChart = ({ data, average }: BloodPressureChartProps) => {
  const lastData = data[data.length - 1];

  return (
    <Card className="shadow-none col-span-2">
      <CardHeader>
        <CardTitle>Blood Pressure</CardTitle>
      </CardHeader>

      <CardContent>
        <div className="flex justify-between items-center mb-4">
          <div>
            <p className="text-lg xl:text-xl font-semibold">
              {lastData?.systolic || 0}/ {lastData?.diastolic || 0} mg/dL
            </p>
            <p className="text-sm text-muted-foreground">Recent Reading</p>
          </div>

          <div>
            <p className="text-lg xl:text-xl font-semibold">{average}</p>
            <p className="text-sm text-muted-foreground">7 Days Average</p>
          </div>

          <Button variant={"outline"} size={"sm"}>
            See Insight
          </Button>
        </div>

        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={data}>
            <CartesianGrid
              strokeDasharray="3 3"
              vertical={false}
              stroke="#ddd"
            />
            <XAxis dataKey="label" axisLine={false} tickLine={false} />
            <YAxis
              axisLine={false}
              tick={{ fill: "#9ca3af" }}
              tickLine={false}
            />

            <Tooltip
              contentStyle={{ borderRadius: "10px", borderColor: "#fff" }}
            />

            <Legend
              align="left"
              verticalAlign="top"
              wrapperStyle={{
                paddingTop: "20px",
                paddingBottom: "40px",
                textTransform: "capitalize",
              }}
            />

            <Bar
              dataKey="systolic"
              fill="#000000"
              legendType="circle"
              radius={[10, 10, 0, 0]}
            />
            <Bar
              dataKey="diastolic"
              fill="#2563eb"
              legendType="circle"
              radius={[10, 10, 0, 0]}
            />
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
};

export default BloodPressureChart;
```

## 📄 components\appointment\chart-container.tsx

```tsx
import { getVitalSignData } from "../../utils/services/medical";
import BloodPressureChart from "./blood-pressure-chart";
import { HeartRateChart } from "./heart-rate-chart";

export default async function ChartContainer({ id }: { id: string }) {
  const { data, average, heartRateData, averageHeartRate } =
    await getVitalSignData(id.toString());

  return (
    <>
      <BloodPressureChart data={data} average={average} />
      <HeartRateChart data={heartRateData} average={averageHeartRate} />
    </>
  );
}
```

## 📄 components\appointment\diagnosis-container.tsx

```tsx
import db from "@/lib/db";
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { NoDataFound } from "../no-data-found";
import { AddDiagnosis } from "../dialogs/add-diagnosis";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { checkRole } from "@/utils/roles";
import { record } from "zod";
import { MedicalHistoryCard } from "./medical-history-card";

export const DiagnosisContainer = async ({
  patientId,
  doctorId,
  id,
}: {
  patientId: string;
  doctorId: string;
  id: string;
}) => {
  const { userId } = await auth();

  if (!userId) redirect("/sign-in");

  const data = await db.medicalRecords.findFirst({
    where: { appointment_id: Number(id) },
    include: {
      diagnosis: {
        include: { doctor: true },
        orderBy: { created_at: "desc" },
      },
    },
    orderBy: { created_at: "desc" },
  });

  const diagnosis = data?.diagnosis || null;
  const isPatient = await checkRole("PATIENT");

  return (
    <div>
      {diagnosis?.length === 0 || !diagnosis ? (
        <div className="flex flex-col items-center justify-center mt-20">
          <NoDataFound note="No diagnosis found" />
          <AddDiagnosis
            key={new Date().getTime()}
            patientId={patientId}
            doctorId={doctorId}
            appointmentId={id}
            medicalId={data?.id.toString() || ""}
          />
        </div>
      ) : (
        <section className="space-y-6">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between">
              <CardTitle>Medical Records</CardTitle>

              {!isPatient && (
                <AddDiagnosis
                  key={new Date().getTime()}
                  patientId={patientId}
                  doctorId={doctorId}
                  appointmentId={id}
                  medicalId={data?.id.toString() || ""}
                />
              )}
            </CardHeader>

            <CardContent className="space-y-8">
              {diagnosis?.map((record, id) => (
                <div key={record.id}>
                  <MedicalHistoryCard record={record} index={id} />
                </div>
              ))}
            </CardContent>
          </Card>
        </section>
      )}
    </div>
  );
};
```

## 📄 components\appointment\generate-final-bill.tsx

```tsx
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { Plus } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";

import { generateBill } from "@/app/actions/medical";
import { PaymentSchema } from "@/lib/schema";
import { z } from "zod";
import { CustomInput } from "../cutom-input";
import { Button } from "../ui/button";
import { CardHeader } from "../ui/card";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Form } from "../ui/form";

interface DataProps {
  id?: string | number;
  total_bill: number;
}
export const GenerateFinalBills = ({ id, total_bill }: DataProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  let discountInfo = null;

  const form = useForm<z.infer<typeof PaymentSchema>>({
    resolver: zodResolver(PaymentSchema),
    defaultValues: {
      id: id?.toString(),
      bill_date: new Date(),
      discount: "0",
      total_amount: total_bill.toString(),
    },
  });

  const handleOnSubmit = async (values: z.infer<typeof PaymentSchema>) => {
    try {
      setIsLoading(true);

      const resp = await generateBill(values);

      if (resp.success) {
        toast.success("Patient bill generated successfully!");

        router.refresh();

        form.reset();
      } else if (resp.error) {
        toast.error(resp.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" size="sm" className="text-sm font-normal">
            <Plus size={22} className="text-gray-400" />
            Generate Final Bill
          </Button>
        </DialogTrigger>
        <DialogContent>
          <CardHeader className="px-0">
            <DialogTitle>Patient Medical Bill</DialogTitle>
          </CardHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-8"
            >
              <div className="flex items-center gap-2">
                <div className="">
                  <span>Total Bill</span>
                  <p className="text-3xl font-semibold">
                    {total_bill?.toFixed(2)}
                  </p>
                </div>
              </div>

              <CustomInput
                type="input"
                control={form.control}
                name="discount"
                placeholder="eg.: 5"
                label="Discount (%)"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="bill_date"
                label="Bill Date"
                placeholder=""
                inputType="date"
              />

              <Button
                type="submit"
                disabled={isLoading}
                className="bg-blue-600 w-full"
              >
                Generate Bill
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\appointment\heart-rate-chart.tsx

```tsx
"use client";

import {
  CartesianGrid,
  Line,
  LineChart,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";
import { Button } from "../ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";

interface DataProps {
  average: string;
  data: {
    label: string;
    value1: number;
    value2: number;
  }[];
}

export function HeartRateChart({ average, data }: DataProps) {
  const lastData = data[data.length - 1];

  return (
    <Card>
      <CardHeader>
        <CardTitle>Heart Rate</CardTitle>
      </CardHeader>

      <CardContent>
        <div className="flex justify-between items-center mb-4">
          <div>
            <p className="text-lg xl:text-xl font-semibold">
              {lastData?.value1 || 0}-{lastData?.value2 || 0}
            </p>
            <p className="text-sm text-gray-500">Recent Reading</p>
          </div>
          <div>
            <p className="text-lg xl:text-xl font-semibold">{average}</p>
            <p className="text-sm text-gray-500">Average Rate</p>
          </div>
          <Button size="sm" variant="outline">
            See Insights
          </Button>
        </div>

        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={data}>
            <CartesianGrid
              strokeDasharray="3 3"
              vertical={false}
              stroke="#ddd"
            />
            <XAxis
              dataKey="label"
              axisLine={false}
              tick={{ fill: "#9ca3af" }}
              tickLine={false}
            />
            <YAxis
              axisLine={false}
              tick={{ fill: "#9ca3af" }}
              tickLine={false}
            />
            <Tooltip
              contentStyle={{ borderRadius: "10px", borderColor: "#fff" }}
            />
            <Line
              type="monotone"
              dataKey="value1"
              stroke="#8884d8"
              activeDot={{ r: 8 }}
            />
            <Line type="monotone" dataKey="value2" stroke="#82ca9d" />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}
```

## 📄 components\appointment\medical-history-card.tsx

```tsx
import { Diagnosis , Doctor } from "@/lib/generated/prisma";
import { Card } from "../ui/card";
import { Separator } from "../ui/separator";

interface ExtendedMedicalRecord extends Diagnosis {
  doctor: Doctor;
}
export const MedicalHistoryCard = ({
  record,
  index,
}: {
  record: ExtendedMedicalRecord;
  index: number;
}) => {
  return (
    <Card className="shadow-none">
      <div className="space-y-6 pt-4">
        <div className="flex gap-x-6 justify-between">
          <div>
            <span className="text-sm text-gray-500">Appointment ID</span>
            <p className="text-xl font-medium"># {record.id}</p>
          </div>
          {index === 0 && (
            <div className="px-4 h-8 text-center bg-blue-100 rounded-full font-semibold text-blue-600">
              <span>Recent</span>
            </div>
          )}

          <div>
            <span className="text-sm text-gray-500">Date</span>
            <p className="text-xl font-medium">
              {record.created_at.toLocaleDateString()}
            </p>
          </div>
        </div>

        <Separator />

        <div>
          <span className="text-sm text-gray-500">Diagnosis</span>
          <p className="text-lg text-muted-foreground">{record.diagnosis}</p>
        </div>
        <Separator />

        <div>
          <span className="text-sm text-gray-500">Symptoms</span>
          <p className="text-lg text-muted-foreground">{record.symptoms}</p>
        </div>

        <Separator />

        <div>
          <span className="text-sm text-gray-500">Additional Note</span>
          <p className="text-lg text-muted-foreground">{record.notes}</p>
        </div>

        <Separator />

        <div>
          <span className="text-sm text-gray-500">Doctor</span>
          <div>
            <p className="text-lg text-muted-foreground">
              {record.doctor.name}
            </p>
            <span>{record.doctor.specialization}</span>
          </div>
        </div>
      </div>
    </Card>
  );
};
```

## 📄 components\appointment\patient-details-card.tsx

```tsx
import { Patient } from "@/lib/generated/prisma";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import Image from "next/image";
import { calculateAge } from "@/utils";
import { Calendar, Home, Info, Mail, Phone } from "lucide-react";
import { format } from "date-fns";

export const PatientDetailsCard = ({ data }: { data: Patient }) => {
  return (
    <Card className="shadow-none bg-white">
      <CardHeader>
        <CardTitle>Patient Details</CardTitle>
        <div className="relative size-20 xl:size-24 rounded-full overflow-hidden">
          <Image
            src={data.img || "/user.jpg"}
            alt={data?.first_name}
            width={100}
            height={100}
            className="rounded-full"
          />
        </div>

        <div>
          <h2 className="text-lg font-semibold">
            {data?.first_name} {data?.last_name}
          </h2>
          <p className="text-sm text-gray-500">
            {data?.email} - {data?.phone}
          </p>
          <p className="text-sm text-gray-500">
            {data?.gender} - {calculateAge(data?.date_of_birth)}
          </p>
        </div>
      </CardHeader>

      <CardContent className="mt-4 space-y-4">
        <div className="flex items-start gap-3">
          <Calendar size={22} className="text-0gray-400" />
          <div>
            <p className="text-sm text-gray-500">Date of Birth</p>
            <p className="text-base font-medium text-muted-foreground">
              {format(new Date(data?.date_of_birth), "MMM d, yyyy")}
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <Home size={22} className="text-0gray-400" />
          <div>
            <p className="text-sm text-gray-500">Address</p>
            <p className="text-base font-medium text-muted-foreground">
              {data?.address}
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <Mail size={22} className="text-0gray-400" />
          <div>
            <p className="text-sm text-gray-500">Email</p>
            <p className="text-base font-medium text-muted-foreground">
              {data?.email}
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <Phone size={22} className="text-0gray-400" />
          <div>
            <p className="text-sm text-gray-500">Phone</p>
            <p className="text-base font-medium text-muted-foreground">
              {data?.phone}
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <Info size={22} className="text-0gray-400" />
          <div>
            <p className="text-sm text-gray-500">Physician</p>
            <p className="text-base font-medium text-muted-foreground">
              Dr Codewave, MBBS, FCPS
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <div>
            <p className="text-sm text-gray-500">Active Conditions</p>
            <p className="text-base font-medium text-muted-foreground">
              {data?.medical_conditions}
            </p>
          </div>
        </div>
        <div className="flex items-start gap-3">
          <div>
            <p className="text-sm text-gray-500">Allergies</p>
            <p className="text-base font-medium text-muted-foreground">
              {data?.allergies}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};
```

## 📄 components\appointment\payment-container.tsx

```tsx
import db from "@/lib/db";
import { Table } from "../tables/table";
import { Payment } from "@/lib/generated/prisma";
import { format } from "date-fns";
import { ViewAction } from "../action-options";
import { checkRole } from "@/utils/roles";
import { ActionDialog } from "../action-dialog";

const columns = [
  {
    header: "No",
    key: "id",
  },
  {
    header: "Bill Date",
    key: "bill_date",
    className: "",
  },
  {
    header: "Payment Date",
    key: "pay_date",
    className: "hidden md:table-cell",
  },
  {
    header: "Total",
    key: "total",
    className: "",
  },
  {
    header: "Discount",
    key: "discount",
    className: "hidden xl:table-cell",
  },
  {
    header: "Payable",
    key: "payable",
    className: "hidden xl:table-cell",
  },
  {
    header: "Paid",
    key: "payable",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];

export const PaymentsContainer = async ({
  patientId,
}: {
  patientId: string;
}) => {
  const data = await db.payment.findMany({
    where: { patient_id: patientId },
  });

  if (!data) return null;
  const isAdmin = await checkRole("ADMIN");

  const renderRow = (item: Payment) => {
    return (
      <tr
        key={item.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="flex items-center gap-2 md:gap-4 py-2 xl:py-4">
          #{item?.id}
        </td>

        <td className="lowercase">{format(item?.bill_date, "MMM d, yyyy")}</td>
        <td className="hidden  items-center py-2  md:table-cell">
          {format(item?.payment_Date, "MMM d, yyyy")}
        </td>
        <td className="">{item?.total_amount.toFixed(2)}</td>
        <td className="hidden xl:table-cell">{item?.discount.toFixed(2)}</td>
        <td className="hidden xl:table-cell">
          {(item?.total_amount - item?.discount).toFixed(2)}
        </td>
        <td className="hidden xl:table-cell">{item?.amount_paid.toFixed(2)}</td>

        <td className="">
          <div className="flex items-center">
            <ViewAction
              href={`/record/appointments/${item?.appointment_Id}?cat=bills`}
            />
            {isAdmin && (
              <ActionDialog
                type="delete"
                deleteType="payment"
                id={item?.id.toString()}
              />
            )}
          </div>
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl p-2 md:p-4 2xl:p-6">
      <div className="flex items-center justify-between">
        <div className="hidden lg:flex items-center gap-1">
          <p className="text-2xl font-semibold">{data?.length ?? 0}</p>
          <span className="text-gray-600 text-sm xl:text-base">
            total records
          </span>
        </div>
      </div>

      <Table columns={columns} renderRow={renderRow} data={data} />
    </div>
  );
};
```

## 📄 components\appointment\vital-signs.tsx

```tsx
import db from "@/lib/db";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { calculateBMI } from "@/utils";
import { stat } from "fs";
import { format } from "date-fns";
import { Separator } from "../ui/separator";
import { checkRole } from "@/utils/roles";
import { AddVitalSigns } from "../dialogs/add-vital-signs";

interface VitalSignsProps {
  id: number | string;
  patientId: string;
  doctorId: string;
  medicalId?: string;
  appointmentId?: string;
}

const ItemCard = ({ label, value }: { label: string; value: string }) => {
  return (
    <div className="w-full">
      <p className="text-lg xl:text-xl font-medium">{value}</p>
      <p className="text-sm xl:text-base text-gray-500">{label}</p>
    </div>
  );
};
export const VitalSigns = async ({
  id,
  patientId,
  doctorId,
}: VitalSignsProps) => {
  const data = await db.medicalRecords.findFirst({
    where: { appointment_id: Number(id) },
    include: {
      vital_signs: {
        orderBy: { created_at: "desc" },
      },
    },
    orderBy: { created_at: "desc" },
  });

  const vitals = data?.vital_signs || null;

  const isPatient = await checkRole("PATIENT");

  return (
    <section id="vital-signs">
      <Card>
        <CardHeader className="flex flex-row justify-between items-center">
          <CardTitle>Vital Signs</CardTitle>

          {!isPatient && (
            <AddVitalSigns
              key={new Date().getTime()}
              patientId={patientId}
              doctorId={doctorId}
              appointmentId={id!.toString()}
              medicalId={data ? data?.id!.toString() : ""}
            />
          )}
        </CardHeader>

        <CardContent className="space-y-4">
          {vitals?.map((el) => {
            const { bmi, status, colorCode } = calculateBMI(
              el.weight || 0,
              el.height || 0
            );

            return (
              <div className="space-y-4" key={el?.id}>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <ItemCard
                    label="Body Temperature"
                    value={`${el?.body_temperature}°C`}
                  />
                  <ItemCard
                    label="Blood Pressure"
                    value={`${el?.systolic} / ${el?.diastolic} mmHg`}
                  />
                  <ItemCard label="Heart Rate" value={`${el?.heartRate} bpm`} />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <ItemCard label="Weight" value={`${el?.weight} kg`} />
                  <ItemCard label="Height" value={`${el?.height} cm`} />

                  <div className="w-full">
                    <div className="flex gap-x-2 items-center">
                      <p className="text-lg xl:text-xl font-medium">{bmi}</p>
                      <span
                        className="text-sm font-medium"
                        style={{ color: colorCode }}
                      >
                        ({status})
                      </span>
                    </div>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <ItemCard
                    label="Respiratory Rate"
                    value={`${el?.respiratoryRate || "N/A"}`}
                  />
                  <ItemCard
                    label="Oxygen Saturation"
                    value={`${el?.oxygen_saturation || "n/a"}`}
                  />
                  <ItemCard
                    label="Reading Date"
                    value={format(el?.created_at, "MMM d, yyyy hh:mm a")}
                  />
                </div>
                <Separator className="mt-4" />
              </div>
            );
          })}
        </CardContent>
      </Card>
    </section>
  );
};
```

## 📄 components\appointment-action-dialog.tsx

```tsx
"use client";

import { useRouter } from "next/navigation";
import React, { useState } from "react";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "./ui/dialog";
import { Button } from "./ui/button";
import { Ban, Check } from "lucide-react";
import { MdCancel } from "react-icons/md";
import { GiConfirmed } from "react-icons/gi";
import { Textarea } from "./ui/textarea";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { appointmentAction } from "@/app/actions/appointment";

interface ActionsProps {
  type: "approve" | "cancel";
  id: string | number;
  disabled: boolean;
}

export const AppointmentActionDialog = ({
  type,
  id,
  disabled,
}: ActionsProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const [reason, setReason] = useState("");
  const router = useRouter();

  const handleAction = async () => {
    if (type === "cancel" && !reason) {
      toast.error("Please provide a reason for cancellation.");
      return;
    }

    try {
      setIsLoading(true);
      const newReason =
        reason ||
        `Appointment has ben ${
          type === "approve" ? "scheduled" : "cancelled"
        } on ${new Date()}`;

      const resp = await appointmentAction(
        id,
        type === "approve" ? "SCHEDULED" : "CANCELLED",
        newReason
      );

      if (resp.success) {
        toast.success(resp.msg);
        setReason("");
        router.refresh();
      } else if (resp.error) {
        toast.error(resp.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog>
      <DialogTrigger asChild disabled={!disabled}>
        {type === "approve" ? (
          <Button size="sm" variant="ghost" className="w-full justify-start">
            <Check size={16} /> Approve
          </Button>
        ) : (
          <Button
            size="sm"
            variant="outline"
            className="w-full flex items-center justify-start gap-2 rounded-full text-red-500 disabled:cursor-not-allowed"
          >
            <Ban size={16} /> Cancel
          </Button>
        )}
      </DialogTrigger>

      <DialogContent>
        <div className="flex flex-col items-center justify-center py-6">
          <DialogTitle>
            {type === "approve" ? (
              <div className="bg-emerald-200 p-4 rounded-full mb-2">
                <GiConfirmed size={50} className="text-emerald-500" />
              </div>
            ) : (
              <div className="bg-red-200 p-4 rounded-full mb-2">
                <MdCancel size={50} className="text-red-500" />
              </div>
            )}
          </DialogTitle>

          <span className="text-xl text-black">
            Appointment
            {type === "approve" ? " Confirmation" : " Cancellation"}
          </span>
          <p className="text-sm text-center text-gray-500">
            {type === "approve"
              ? "You're about to confirmed this appointment. Yes to approve or No to cancel."
              : "Are you sure you want to cancel this appointment?"}
          </p>

          {type == "cancel" && (
            <Textarea
              disabled={isLoading}
              className="mt-4"
              placeholder="Cancellation reason...."
              onChange={(e) => setReason(e.target.value)}
            ></Textarea>
          )}

          <div className="flex justify-center mt-6 items-center gap-x-4">
            <Button
              disabled={isLoading}
              onClick={() => handleAction()}
              variant="outline"
              className={cn(
                "px-4 py-2 text-sm font-medium text-white hover:text-white hover:underline",
                type === "approve"
                  ? "bg-blue-600 hover:bg-blue-700"
                  : "bg-destructive hover:bg-destructive"
              )}
            >
              Yes, {type === "approve" ? "Approve" : "Delete"}
            </Button>
            <DialogClose asChild>
              <Button
                variant="outline"
                className="px-4 py-2 text-sm underline text-gray-500"
              >
                No
              </Button>
            </DialogClose>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};
```

## 📄 components\appointment-action.tsx

```tsx
"use client";

import { AppointmentStatus } from "@/lib/generated/prisma";
import { useState } from "react";
import { toast } from "sonner";
import { Button } from "./ui/button";
import { Textarea } from "./ui/textarea";
import { useRouter } from "next/navigation";
import { appointmentAction } from "@/app/actions/appointment";

interface ActionProps {
  id: string | number;
  status: string;
}
export const AppointmentAction = ({ id, status }: ActionProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const [selected, setSelected] = useState("");
  const [reason, setReason] = useState("");
  const router = useRouter();

  const handleAction = async () => {
    try {
      setIsLoading(true);
      const newReason =
        reason ||
        `Appointment has ben ${selected.toLowerCase()} on ${new Date()}`;

      const resp = await appointmentAction(
        id,
        selected as AppointmentStatus,
        newReason
      );

      if (resp.success) {
        toast.success(resp.msg);

        router.refresh();
      } else if (resp.error) {
        toast.error(resp.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <div className="flex items-center space-x-3">
        <Button
          variant="outline"
          disabled={status === "PENDING" || isLoading || status === "COMPLETED"}
          className="bg-yellow-200 text-black"
          onClick={() => setSelected("PENDING")}
        >
          Pending
        </Button>
        <Button
          variant="outline"
          disabled={
            status === "SCHEDULED" || isLoading || status === "COMPLETED"
          }
          className="bg-blue-200 text-black"
          onClick={() => setSelected("SCHEDULED")}
        >
          Approve
        </Button>
        <Button
          variant="outline"
          disabled={
            status === "COMPLETED" || isLoading || status === "COMPLETED"
          }
          className="bg-emerald-200 text-black"
          onClick={() => setSelected("COMPLETED")}
        >
          Completed
        </Button>
        <Button
          variant="outline"
          disabled={
            status === "CANCELLED" || isLoading || status === "COMPLETED"
          }
          className="bg-red-200 text-black"
          onClick={() => setSelected("CANCELLED")}
        >
          Cancel
        </Button>
      </div>
      {selected === "CANCELLED" && (
        <>
          <Textarea
            disabled={isLoading}
            className="mt-4"
            placeholder="Enter reason...."
            onChange={(e) => setReason(e.target.value)}
          ></Textarea>
        </>
      )}

      {selected && (
        <div className="flex items-center justify-between mt-6 bg-red-100 p-4 rounded">
          <p className="">Are you sure you want to perform this action?</p>
          <Button disabled={isLoading} type="button" onClick={handleAction}>
            Yes
          </Button>
        </div>
      )}
    </div>
  );
};
```

## 📄 components\appointment-actions.tsx

```tsx
import { checkRole } from "../utils/roles";
import { auth } from "@clerk/nextjs/server";
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover";
import { Button } from "./ui/button";
import { EllipsisVertical, User } from "lucide-react";
import Link from "next/link";
import { AppointmentActionDialog } from "./appointment-action-dialog";

interface ActionsProps {
    userId: string;
    status: string;
    patientId: string;
    doctorId: string;
    appointmentId: number;
}

export const AppointmentActionOptions = async ({
    userId,
    patientId,
    doctorId,
    status,
    appointmentId,
}: ActionsProps) => {
    const { userId: currentUserId } = await auth(); // Get current user ID from session
    const isAdmin = await checkRole("admin"); // Role is lowercase per your logic

    return (
        <Popover>
            <PopoverTrigger asChild>
                <Button
                    variant="outline"
                    className="flex items-center justify-center rounded-full p-1"
                >
                    <EllipsisVertical size={16} className="text-sm text-gray-500" />
                </Button>
            </PopoverTrigger>

            <PopoverContent className="w-56 p-3">
                <div className="space-y-3 flex flex-col items-start">
                    <span className="text-gray-400 text-xs">Perform Actions</span>

                    <Button
                        size="sm"
                        variant="ghost"
                        className="w-full justify-start"
                        asChild
                    >
                        <Link href={`appointments/${appointmentId}`}>
                            <User size={16} /> View Full Details
                        </Link>
                    </Button>

                    {/* Approve button: show only if not scheduled */}
                    {status !== "SCHEDULED" && (
                        <AppointmentActionDialog
                            type="approve"
                            id={appointmentId}
                            disabled={!isAdmin && currentUserId !== doctorId}
                        />
                    )}

                    {/* Cancel button: allow only if pending AND (admin or doctor or patient) */}
                    <AppointmentActionDialog
                        type="cancel"
                        id={appointmentId}
                        disabled={
                            !(
                                status === "PENDING" &&
                                (isAdmin ||
                                    currentUserId === doctorId ||
                                    currentUserId === patientId)
                            )
                        }
                    />
                </div>
            </PopoverContent>
        </Popover>
    );
};

```

## 📄 components\appointment-container.tsx

```tsx
import React from "react";
import { BookAppointment } from "./forms/book-appointment";
import { getPatientById } from "@/utils/services/patient";
import { getDoctors } from "@/utils/services/doctor";

export const AppointmentContainer = async ({ id }: { id: string }) => {
  const { data } = await getPatientById(id);
  const { data: doctors } = await getDoctors();

  return (
    <div>
      <BookAppointment data={data!} doctors={doctors!} />
    </div>
  );
};
```

## 📄 components\appointment-status-indicator.tsx

```tsx
import { cn } from "@/lib/utils";
import { AppointmentStatus } from "@/lib/generated/prisma";

const status_color = {
  PENDING: "bg-yellow-600/15 text-yellow-600",
  SCHEDULED: "bg-emerald-600/15 text-emerald-600",
  CANCELLED: "bg-red-600/15 text-red-600",
  COMPLETED: "bg-blue-600/15 text-blue-600",
};

export const AppointmentStatusIndicator = ({
  status,
}: {
  status: AppointmentStatus;
}) => {
  return (
    <p
      className={cn(
        "w-fit px-2 py-1 rounded-full capitalize text-xs lg:text-sm",
        status_color[status]
      )}
    >
      {status}
    </p>
  );
};
```

## 📄 components\available-doctor.tsx

```tsx
import { AvailableDoctorProps } from "@/types/data-types";
import { checkRole } from "@/utils/roles";
import React from "react";
import { Button } from "./ui/button";
import Link from "next/link";
import { Card } from "./ui/card";
import { ProfileImage } from "./profile-image";
import { daysOfWeek } from "@/utils";
import { cn } from "@/lib/utils";

const getToday = () => {
  const today = new Date().getDay();
  return daysOfWeek[today];
};

const todayDay = getToday();

interface Days {
  day: string;
  start_time: string;
  close_time: string;
}

interface DataProps {
  data: AvailableDoctorProps;
}

export const availableDays = ({ data }: { data: Days[] }) => {
  const isTodayWorkingDay = data?.find(
    (dayObj) => dayObj?.day?.toLowerCase() === todayDay
  );

  return isTodayWorkingDay
    ? `${isTodayWorkingDay?.start_time} - ${isTodayWorkingDay?.close_time}`
    : "Not Available";
};
export const AvailableDoctors = async ({ data }: DataProps) => {
  return (
    <div className="bg-white rounded-xl p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-lg font-semibold">Available Doctors</h1>

        {(await checkRole("ADMIN")) && (
          <Button
            asChild
            variant={"outline"}
            disabled={data?.length === 0}
            className="disabled:cursor-not-allowed disabled:text-gray-200"
          >
            <Link href="/record/doctors">View all</Link>
          </Button>
        )}
      </div>

      <div className="w-full space-y-5 md:space-y-0 md:gap-6 flex flex-col md:flex-row md:flex-wrap">
        {data?.map((doc, id) => (
          <Card
            key={id}
            className=" border-none  w-full md:w-[300px] min-h-28 xl:w-full p-4 flex  gap-4 odd:bg-emerald-600/5 even:bg-yellow-600/5"
          >
            <ProfileImage
              url={doc?.img}
              name={doc?.name}
              className={`md:flex min-w-14 min-h-14 md:min-w-16 md:min-h-16`}
              textClassName="text-2xl font-semibold text-black"
              // bgColor={doc?.colorCode!}
            />
            {/* <p>{doc.colorCode}</p> */}
            <div>
              <h2 className="font-semibold text-lg md:text-xl">{doc?.name}</h2>
              <p className="text-base capitalize text-gray-600">
                {doc?.specialization}
              </p>
              <p className="text-sm flex items-center">
                <span className="hidden lg:flex">Available Time:</span>
                {availableDays({ data: doc?.working_days })}
              </p>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
};
```

## 📄 components\charts\appointment-chart.tsx

```tsx
"use client";

import { AppointmentsChartProps } from "@/types/data-types";
import React from "react";
import {
  ResponsiveContainer,
  BarChart,
  CartesianGrid,
  Legend,
  Bar,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

interface DataProps {
  data: AppointmentsChartProps;
}
export const AppointmentChart = ({ data }: DataProps) => {
  return (
    <div className="bg-white rounded-xl p-4 h-full">
      <div className="flex justify-between items-center">
        <h1 className="text-lg font-semibold">Appointments</h1>
      </div>

      <ResponsiveContainer width={"100%"} height="90%">
        <BarChart width={100} height={300} data={data} barSize={25}>
          <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#ddd" />

          <XAxis
            dataKey="name"
            axisLine={false}
            tick={{ fill: "#9ca3af" }}
            tickLine={false}
          />
          <YAxis axisLine={false} tick={{ fill: "#9ca3af" }} tickLine={false} />
          <Tooltip
            contentStyle={{ borderRadius: "10px", borderColor: "#fff" }}
          />
          <Legend
            align="left"
            verticalAlign="top"
            wrapperStyle={{
              paddingTop: "20px",
              paddingBottom: "40px",
              textTransform: "capitalize",
            }}
          />
          <Bar
            dataKey="appointment"
            fill="#000000"
            legendType="circle"
            radius={[10, 10, 0, 0]}
          />
          <Bar
            dataKey="completed"
            fill="#2563eb"
            legendType="circle"
            radius={[10, 10, 0, 0]}
          />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
};
```

## 📄 components\charts\rating-chart.tsx

```tsx
"use client";

import React from "react";
import { PieChart, Pie, Sector, Cell, ResponsiveContainer } from "recharts";

export const RatingChart = ({
  totalRatings,
  averageRating,
}: {
  totalRatings: number;
  averageRating: number;
}) => {
  const negative = 5 - averageRating;

  const data = [
    { name: "Positive", value: averageRating, fill: "#2ecc71" },
    { name: "Negative", value: negative, fill: "#e74c3c" },
  ];

  return (
    <div className="bg-white p-4 rounded-md h-80 relative">
      <div className="flex items-center justify-between">
        <h1 className="text-xl font-semibold">Ratings</h1>
      </div>

      <ResponsiveContainer width={"100%"} height={"100%"}>
        <PieChart>
          <Pie
            dataKey={"value"}
            startAngle={180}
            endAngle={0}
            data={data}
            cx={"50%"}
            cy={"50%"}
            innerRadius={70}
            fill="#8884d8"
          />
        </PieChart>
      </ResponsiveContainer>

      <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center">
        <h1 className="text-2xl font-bold">{averageRating?.toFixed(1)}</h1>
        <p className="text-xs text-gray-500">of max ratings</p>
      </div>

      <h2 className="font-medium absolute bottom-16 left-0 right-0 m-auto text-center">
        Rated by {totalRatings} patients
      </h2>
    </div>
  );
};
```

## 📄 components\charts\stat-summary.tsx

```tsx
"use client";

import Link from "next/link";
import { Button } from "../ui/button";
import { ResponsiveContainer, RadialBarChart, RadialBar } from "recharts";
import { Users } from "lucide-react";
import { formatNumber } from "@/utils";

export const StatSummary = ({ data, total }: { data: any; total: number }) => {
  const dataInfo = [
    { name: "Total", count: total || 0, fill: "white" },
    {
      name: "Appointments",
      count: data?.PENDING + data?.SCHEDULED || 0,
      fill: "#000000",
    },
    { name: "Consultation", count: data?.COMPLETED || 0, fill: "#2563eb" },
  ];

  const appointment = dataInfo[1].count;
  const consultation = dataInfo[2].count;

  return (
    <div className="bg-white rounded-xl w-full h-full p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-lg font-semibold">Summary</h1>

        <Button
          asChild
          size="sm"
          variant="outline"
          className="font-normal text-xs"
        >
          <Link href="/record/appointments">See details</Link>
        </Button>
      </div>

      <div className="relative w-full h-[75%]">
        <ResponsiveContainer>
          <RadialBarChart
            cx="50%"
            cy="50%"
            innerRadius="40%"
            outerRadius="100%"
            barSize={32}
            data={dataInfo}
          >
            <RadialBar background dataKey={"count"} />
          </RadialBarChart>
        </ResponsiveContainer>

        <Users
          size={30}
          className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-gray-400"
        />
      </div>

      <div className="flex justify-center gap-16">
        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <div className="w-5 h-5 bg-[#000000] rounded-xl" />
            <h1 className="font-bold">{formatNumber(appointment)}</h1>
          </div>
          <h2 className="text-xs text-gray-400">
            {dataInfo[1].name}(
            {((appointment / (appointment + consultation)) * 100).toFixed(0)})
          </h2>
        </div>

        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <div className="w-5 h-5 bg-[#2563eb] rounded-xl" />
            <h1 className="font-bold">{formatNumber(consultation)}</h1>
          </div>

          <h2 className="text-xs text-gray-400">
            {dataInfo[2].name}(
            {((consultation / (appointment + consultation)) * 100).toFixed(0)})
          </h2>
        </div>
      </div>
    </div>
  );
};
```

## 📄 components\cutom-input.tsx

```tsx
import React, { Fragment } from "react";
import { Control } from "react-hook-form";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "./ui/form";
import { Input } from "./ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "./ui/select";
import { Checkbox } from "./ui/checkbox";
import { Textarea } from "./ui/textarea";
import { RadioGroup, RadioGroupItem } from "./ui/radio-group";
import { Label } from "./ui/label";
// import { Switch } from "./ui/switch";

interface InputProps {
  type: "input" | "select" | "checkbox" | "switch" | "radio" | "textarea";
  control: Control<any>;
  name: string;
  label?: string;
  placeholder?: string;
  inputType?: "text" | "email" | "password" | "date";
  selectList?: { label: string; value: string }[];
  defaultValue?: string;
}

const RenderInput = ({ field, props }: { field: any; props: InputProps }) => {
  switch (props.type) {
    case "input":
      return (
        <FormControl>
          <Input
            type={props.inputType}
            placeholder={props.placeholder}
            {...field}
          />
        </FormControl>
      );

    case "select":
      return (
        <Select onValueChange={field.onChange} value={field?.value}>
          <FormControl>
            <SelectTrigger>
              <SelectValue placeholder={props.placeholder} />
            </SelectTrigger>
          </FormControl>
          <SelectContent>
            {props.selectList?.map((i, id) => (
              <SelectItem key={id} value={i.value}>
                {i.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      );

    case "checkbox":
      return (
        <div className="items-top flex space-x-2">
          <Checkbox
            id={props.name}
            onCheckedChange={(e) => field.onChange(e === true || null)}
          />
          <div className="grid gap-1.5 leading-none">
            <label
              htmlFor={props.name}
              className="cursor-pointer text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
            >
              {props.label}
            </label>
            <p className="text-sm text-muted-foreground">{props.placeholder}</p>
          </div>
        </div>
      );

    case "radio":
      return (
        <div className="w-full">
          <FormLabel>{props.label}</FormLabel>
          <RadioGroup
            defaultValue={props.defaultValue}
            onChange={field.onChange}
            className="flex gap-4"
          >
            {props?.selectList?.map((i, id) => (
              <div className="flex items-center w-full" key={id}>
                <RadioGroupItem
                  value={i.value}
                  id={i.value}
                  className="peer sr-only"
                />
                <Label
                  htmlFor={i.value}
                  className="flex flex-1 items-center justify-center rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-blue-500 peer-data-[state=checked]:text-blue-600"
                >
                  {i.label}
                </Label>
              </div>
            ))}
          </RadioGroup>
        </div>
      );

    case "textarea":
      return (
        <FormControl>
          <Textarea
            type={props.inputType}
            placeholder={props.placeholder}
            {...field}
          ></Textarea>
        </FormControl>
      );
  }
};
export const CustomInput = (props: InputProps) => {
  const { name, label, control, type } = props;

  return (
    // <div className="w-full pt-6">
    <FormField
      control={control}
      name={name}
      render={({ field }) => (
        <FormItem className="w-full">
          {type !== "radio" && type !== "checkbox" && (
            <FormLabel>{label}</FormLabel>
          )}
          <RenderInput field={field} props={props} />
          <FormMessage />
        </FormItem>
      )}
    />
    // </div>
  );
};

type Day = {
  day: string;
  start_time?: string;
  close_time?: string;
};
interface SwitchProps {
  data: { label: string; value: string }[];
  setWorkSchedule: React.Dispatch<React.SetStateAction<Day[]>>;
}

export const SwitchInput = ({ data, setWorkSchedule }: SwitchProps) => {
  const handleChange = (day: string, field: any, value: string) => {
    setWorkSchedule((prevDays) => {
      const dayExist = prevDays.find((d) => d.day === day);

      if (dayExist) {
        return prevDays.map((d) =>
          d.day === day ? { ...d, [field]: value } : d
        );
      } else {
        if (field === true) {
          return [
            ...prevDays,
            { day, start_time: "09:00", close_time: "17:00" },
          ];
        } else {
          return [...prevDays, { day, [field]: value }];
        }
      }
    });
  };

  return (
    <div className="">
      {data?.map((el, id) => (
        <div
          key={id}
          className="w-full  flex items-center space-y-3 border-t border-t-gray-200  py-3"
        >
          {/* <Switch
            id={el.value}
            className="data-[state=checked]:bg-blue-600 peer"
            onCheckedChange={(e) => handleChange(el.value, true, "09:00")}
          /> */}
          <Label htmlFor={el.value} className="w-20 capitalize">
            {el.value}
          </Label>

          <Label className="text-gray-400 font-normal italic peer-data-[state=checked]:hidden pl-10">
            Not working on this day
          </Label>

          <div className="hidden peer-data-[state=checked]:flex items-center gap-2 pl-6:">
            <Input
              name={`${el.label}.start_time`}
              type="time"
              defaultValue="09:00"
              onChange={(e) =>
                handleChange(el.value, "start_time", e.target.value)
              }
            />
            <Input
              name={`${el.label}.close_time`}
              type="time"
              defaultValue="17:00"
              onChange={(e) =>
                handleChange(el.value, "close_time", e.target.value)
              }
            />
          </div>
        </div>
      ))}
    </div>
  );
};
```

## 📄 components\dialogs\add-bills.tsx

```tsx
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { Plus } from "lucide-react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";

import { PatientBillSchema } from "@/lib/schema";
import { Services } from "@/lib/generated/prisma";
import { z } from "zod";

import { Button } from "../ui/button";
import { CardDescription, CardHeader } from "../ui/card";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Form } from "../ui/form";
import { CustomInput } from "../cutom-input";
import { addNewBill } from "@/app/actions/medical";

interface DataProps {
  id?: string | number;
  appId?: string | number;
  servicesData: Services[];
}
export const AddBills = ({ id, appId, servicesData }: DataProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const [data, setData] = useState<any>();

  const form = useForm<z.infer<typeof PatientBillSchema>>({
    resolver: zodResolver(PatientBillSchema),
    defaultValues: {
      bill_id: String(id),
      service_id: undefined,
      service_date: new Date().toDateString(),
      appointment_id: String(appId),
      quantity: undefined,
      unit_cost: undefined,
      total_cost: undefined,
    },
  });

  const handleOnSubmit = async (values: z.infer<typeof PatientBillSchema>) => {
    try {
      setIsLoading(true);
      const resp = await addNewBill(values);

      if (resp.success) {
        toast.success("Patient bill added successfully!");

        router.refresh();

        form.reset();
      } else if (resp.error) {
        toast.error(resp.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (servicesData) {
      setData(
        servicesData?.map((service) => ({
          value: service.id.toString(),
          label: service.service_name,
        }))
      );
    }
  }, [servicesData, id]);

  const selectedService = form.watch("service_id");
  const quantity = form.watch("quantity");

  useEffect(() => {
    if (selectedService) {
      const unit_cost = servicesData.find(
        (el) => el.id === Number(selectedService)
      );

      if (unit_cost) {
        form.setValue("unit_cost", unit_cost?.price.toFixed(2));
      }
      if (quantity) {
        form.setValue(
          "total_cost",
          (Number(quantity) * unit_cost?.price!).toFixed(2)
        );
      }
    }
  }, [selectedService, quantity]);

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button size="sm" className="text-sm font-normal">
            <Plus size={22} className="text-gray-400" />
            Add Bill
          </Button>
        </DialogTrigger>
        <DialogContent>
          <CardHeader className="px-0">
            <DialogTitle>Add Patient Bill</DialogTitle>
            <CardDescription>
              Ensure accurate readings are perform as this may affect the
              diagnosis and other medical processes.
            </CardDescription>
          </CardHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-8"
            >
              <div className="flex items-center gap-2">
                <CustomInput
                  type="select"
                  control={form.control}
                  name="service_id"
                  placeholder="Select service"
                  label="Service Name"
                  selectList={data!}
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="unit_cost"
                  placeholder=""
                  label="Unit Cost"
                />
              </div>

              <div className="flex items-center gap-2">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="quantity"
                  placeholder="Enter quantity"
                  label="Quantity"
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="total_cost"
                  placeholder="0.00"
                  label="Total Cost"
                />
              </div>

              <CustomInput
                type="input"
                control={form.control}
                name="service_date"
                label="Service Date"
                placeholder=""
                inputType="date"
              />

              <Button
                type="submit"
                disabled={isLoading}
                className="bg-blue-600 w-full"
              >
                Submit
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\dialogs\add-diagnosis.tsx

```tsx
"use client";

import { DiagnosisSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Button } from "../ui/button";
import { Plus } from "lucide-react";
import { CardDescription, CardHeader } from "../ui/card";
import { Form } from "../ui/form";
import { CustomInput } from "../cutom-input";
import { toast } from "sonner";
import { addDiagnosis } from "@/app/actions/medical";

interface AddDiagnosisProps {
  patientId: string;
  doctorId: string;
  appointmentId: string;
  medicalId: string;
}

export type DiagnosisFormData = z.infer<typeof DiagnosisSchema>;
export const AddDiagnosis = ({
  patientId,
  doctorId,
  appointmentId,
  medicalId,
}: AddDiagnosisProps) => {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const form = useForm<DiagnosisFormData>({
    resolver: zodResolver(DiagnosisSchema),
    defaultValues: {
      patient_id: patientId,
      medical_id: medicalId,
      doctor_id: doctorId,
      symptoms: "",
      diagnosis: "",
      notes: "",
      prescribed_medications: "",
      follow_up_plan: "",
    },
  });

  const handleOnSubmit = async (data: DiagnosisFormData) => {
    try {
      setLoading(true);

      const res = await addDiagnosis(data, appointmentId);

      if (res.success) {
        toast.success(res.message);
        router.refresh();
        form.reset();
      } else {
        toast.error(res.error);
      }
    } catch (error) {
      console.log(error);
      toast.error("Failed to add diagnosis");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button
            variant={"outline"}
            size={"lg"}
            className="bg-blue-600 text-white mt-4"
          >
            <Plus size={22} className="text-white" />
            Add Diagnosis
          </Button>
        </DialogTrigger>

        <DialogContent className="sm:max-w-[60%] 2xl:max-w-[40%]">
          <CardHeader className="px-0">
            <DialogTitle>Add New Diagnosis</DialogTitle>
            <CardDescription>
              Ensure accurate findings are presented and corrected accordingly
              to ensure that they are correct for your application and that they
              do not result in an error.
            </CardDescription>
          </CardHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-6"
            >
              <div className="flex items-center gap-4">
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="symptoms"
                  label="Symptoms"
                  placeholder="Enter symptoms here ..."
                />
              </div>

              <div className="flex items-center gap-4">
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="diagnosis"
                  placeholder="Enter diagnosis here ..."
                  label="Diagnosis (Findings)"
                />
              </div>
              <div className="flex items-center gap-4">
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="prescribed_medications"
                  placeholder="Enter principles here ..."
                  label="Prescriptions for this patient"
                />
              </div>

              <div className="flex items-center gap-4">
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="notes"
                  placeholder="Optional note"
                  label="Additional Notes for this treatment"
                />
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="follow_up_plan"
                  placeholder="Optional"
                  label="Follow Up Plan"
                />
              </div>

              <Button
                type="submit"
                disabled={loading}
                className="bg-blue-600 w-full"
              >
                Submit
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\dialogs\add-service.tsx

```tsx
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { Plus } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";

import { addNewService } from "@/app/actions/admin";

import { z } from "zod";

import { Button } from "../ui/button";
import { CardDescription, CardHeader } from "../ui/card";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Form } from "../ui/form";
import { ServicesSchema } from "@/lib/schema";
import { CustomInput } from "../cutom-input";

export const AddService = () => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const form = useForm<z.infer<typeof ServicesSchema>>({
    resolver: zodResolver(ServicesSchema),
    defaultValues: {
      service_name: undefined,
      price: undefined,
      description: undefined,
    },
  });

  const handleOnSubmit = async (values: z.infer<typeof ServicesSchema>) => {
    try {
      setIsLoading(true);
      const resp = await addNewService(values);

      if (resp.success) {
        toast.success("Service added successfully!");

        router.refresh();

        form.reset();
      } else if (resp.error) {
        toast.error(resp.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button size="sm" className="text-sm font-normal">
            <Plus size={22} className="text-gray-500" /> Add New Service
          </Button>
        </DialogTrigger>
        <DialogContent>
          <CardHeader className="px-0">
            <DialogTitle>Add New Service</DialogTitle>
            <CardDescription>
              Ensure accurate readings are perform as this may affect the
              diagnosis and other medical processes.
            </CardDescription>
          </CardHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-8"
            >
              <CustomInput
                type="input"
                control={form.control}
                name="service_name"
                label="Service Name"
                placeholder=""
              />

              <CustomInput
                type="input"
                control={form.control}
                name="price"
                placeholder=""
                label="Service Price"
              />
              <div className="flex items-center gap-4">
                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="description"
                  placeholder=""
                  label="Service Description"
                />
              </div>

              <Button
                type="submit"
                disabled={isLoading}
                className="bg-blue-600 w-full"
              >
                Submit
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\dialogs\add-vital-signs.tsx

```tsx
"use client";

import { addVitalSigns } from "@/app/actions/appointment";
import { VitalSignsSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { Plus } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import { z } from "zod";
import { CustomInput } from "../cutom-input";
import { Button } from "../ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Form } from "../ui/form";

interface AddVitalSignsProps {
  patientId: string;
  doctorId: string;
  appointmentId: string;
  medicalId?: string;
}

export type VitalSignsFormData = z.infer<typeof VitalSignsSchema>;

export const AddVitalSigns = ({
  patientId,
  doctorId,
  appointmentId,
  medicalId,
}: AddVitalSignsProps) => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const form = useForm<VitalSignsFormData>({
    resolver: zodResolver(VitalSignsSchema),
    defaultValues: {
      patient_id: patientId,
      medical_id: medicalId,
      body_temperature: undefined,
      heartRate: undefined,
      systolic: undefined,
      diastolic: undefined,
      respiratory_rate: undefined,
      oxygen_saturation: undefined,
      weight: undefined,
      height: undefined,
    },
  });

  const handleOnSubmit = async (data: VitalSignsFormData) => {
    try {
      setIsLoading(true);

      const res = await addVitalSigns(data, appointmentId, doctorId);

      if (res.success) {
        router.refresh();
        toast.success(res.msg);
        form.reset();
      } else {
        toast.error(res.msg);
      }
    } catch (error) {
      console.log(error);
      toast.error("Failed to add vital signs");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button size="sm" variant="outline" className="text-sm font-normal">
            <Plus size={22} className="text-gray-500" /> Add Vital Signs
          </Button>
        </DialogTrigger>

        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add Vital Signs</DialogTitle>
            <DialogDescription>
              Add vital signs for the patient
            </DialogDescription>
          </DialogHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-8"
            >
              <div className="flex items-center gap-4">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="body_temperature"
                  label="Body Temperature (°C)"
                  placeholder="eg.:37.5"
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="heartRate"
                  placeholder="eg: 54-123"
                  label="Heart Rate (BPM)"
                />
              </div>

              <div className="flex items-center gap-4">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="systolic"
                  placeholder="eg: 120"
                  label="Systolic BP"
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="diastolic"
                  placeholder="eg: 80"
                  label="Diastolic BP"
                />
              </div>

              <div className="flex items-center gap-4">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="weight"
                  placeholder="eg.: 80"
                  label="Weight (Kg)"
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="height"
                  placeholder="eg.: 175"
                  label="Height (Cm)"
                />
              </div>

              <div className="flex items-center gap-4">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="respiratory_rate"
                  placeholder="Optional"
                  label="Respiratory Rate"
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="oxygen_saturation"
                  placeholder="Optional"
                  label="Oxygen Saturation"
                />
              </div>

              <Button type="submit" disabled={isLoading} className="w-full">
                {isLoading ? "Submitting..." : "Submit"}
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\dialogs\review-form.tsx

```tsx
"use client";

import { useAuth } from "@clerk/nextjs";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../ui/dialog";
import { Button } from "../ui/button";
import { Plus, StarIcon } from "lucide-react";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "../ui/form";
import { cn } from "@/lib/utils";
import { Textarea } from "../ui/textarea";
import { toast } from "sonner";
import { createReview } from "@/app/actions/general";

export const reviewSchema = z.object({
  patient_id: z.string(),
  staff_id: z.string(),
  rating: z.number().min(1).max(5),
  comment: z
    .string()
    .min(1, "Review must be at least 10 characters long")
    .max(500, "Review must not exceed 500 characters"),
});

export type ReviewFormValues = z.infer<typeof reviewSchema>;

export const ReviewForm = ({ staffId }: { staffId: string }) => {
  const router = useRouter();
  const user = useAuth();
  const [loading, setLoading] = useState(false);

  const form = useForm<ReviewFormValues>({
    resolver: zodResolver(reviewSchema),
    defaultValues: {
      patient_id: user?.userId as string,
      staff_id: staffId,
      rating: 1,
      comment: "",
    },
  });

  const handleSubmit = async (values: ReviewFormValues) => {
    try {
      setLoading(true);
      const response = await createReview(values);

      if (response.success) {
        toast.success(response.message);
        router.refresh();
      } else {
        toast.error(response.message);
      }
    } catch (error) {
      console.log(error);
      toast.error("Failed to create review");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button
            size={"sm"}
            className="px-4 py-2 rounded-lg bg-black/10 text-black hover:bg-transparent font-light"
          >
            <Plus /> Add New Review
          </Button>
        </DialogTrigger>

        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Review</DialogTitle>
            <DialogDescription>
              Please fill in the form below to add a new review.
            </DialogDescription>
          </DialogHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleSubmit)}
              className="space-y-6"
            >
              <FormField
                control={form.control}
                name="rating"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Rating</FormLabel>
                    <FormControl>
                      <div className="flex items-center space-x-3">
                        {[1, 2, 3, 4, 5].map((star) => (
                          <button
                            key={star}
                            onClick={() => field.onChange(star)}
                          >
                            <StarIcon
                              size={30}
                              className={cn(
                                star <= field.value
                                  ? "text-yellow-500 fill-yellow-500"
                                  : "text-gray-400"
                              )}
                            />
                          </button>
                        ))}
                      </div>
                    </FormControl>
                    <FormDescription>
                      Please rate the staff based on your experience.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="comment"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Comment</FormLabel>
                    <FormControl>
                      <Textarea
                        placeholder="Write your review here..."
                        className="resize-none"
                        {...field}
                      />
                    </FormControl>
                    <FormDescription>
                      Please write a detailed review of your experience.
                    </FormDescription>
                  </FormItem>
                )}
              />

              <Button type="submit" disabled={loading} className="w-full">
                {loading ? "Submitting..." : "Submit"}
              </Button>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

## 📄 components\forms\book-appointment.tsx

```tsx
"use client";

import { AppointmentSchema } from "@/lib/schema";
import { generateTimes } from "@/utils";
import { zodResolver } from "@hookform/resolvers/zod";
import { Doctor,Patient } from "@/lib/generated/prisma";
import { useRouter } from "next/navigation";
import React, { useState } from "react";
import { SubmitHandler, useForm } from "react-hook-form";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "../ui/sheet";
import { Button } from "../ui/button";
import { UserPen } from "lucide-react";
import { z } from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "../ui/form";
import { ProfileImage } from "../profile-image";
import { CustomInput } from "../cutom-input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../ui/select";
import { toast } from "sonner";
import { createNewAppointment } from "@/app/actions/appointment";

const TYPES = [
  { label: "General Consultation", value: "General Consultation" },
  { label: "General Check up", value: "General Check Up" },
  { label: "Antenatal", value: "Antenatal" },
  { label: "Maternity", value: "Maternity" },
  { label: "Lab Test", value: "Lab Test" },
  { label: "ANT", value: "ANT" },
];

export const BookAppointment = ({
  data,
  doctors,
}: {
  data: Patient;
  doctors: Doctor[];
}) => {
  const [loading, setLoading] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const router = useRouter();
  const [physicians, setPhysicians] = useState<Doctor[] | undefined>(doctors);

  const appointmentTimes = generateTimes(8, 17, 30);

  const patientName = `${data?.first_name} ${data?.last_name}`;

  const form = useForm<z.infer<typeof AppointmentSchema>>({
    resolver: zodResolver(AppointmentSchema),
    defaultValues: {
      doctor_id: "",
      appointment_date: "",
      time: "",
      type: "",
      note: "",
    },
  });

  const onSubmit: SubmitHandler<z.infer<typeof AppointmentSchema>> = async (
    values
  ) => {
    try {
      setIsSubmitting(true);
      const newData = { ...values, patient_id: data?.id! };

      const res = await createNewAppointment(newData);

      if (res.success) {
        form.reset({});
        router.refresh();
        toast.success("Appointment created successfully");
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong. Try again later.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button
          variant="ghost"
          className="w-full flex items-center gap-2 justify-start text-sm font-light bg-blue-600 text-white"
        >
          <UserPen size={16} /> Book Appointment
        </Button>
      </SheetTrigger>

      <SheetContent className="rounded-xl rounded-r-2xl md:h-p[95%] md:top-[2.5%] md:right-[1%] w-full">
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <span>Loading</span>
          </div>
        ) : (
          <div className="h-full overflow-y-auto p-4">
            <SheetHeader>
              <SheetTitle>Book Appointment</SheetTitle>
            </SheetHeader>

            <Form {...form}>
              <form
                onSubmit={form.handleSubmit(onSubmit)}
                className="space-y-8 mt-5 2xl:mt-10"
              >
                <div className="w-full rounded-md border border-input bg-background px-3 py-1 flex items-center gap-4">
                  <ProfileImage
                    url={data?.img!}
                    name={patientName}
                    className="size-16 border border-input"
                    bgColor={data?.colorCode!}
                  />

                  <div>
                    <p className="font-semibold text-lg">{patientName}</p>
                    <span className="text-sm text-gray-500 capitalize">
                      {data?.gender}
                    </span>
                  </div>
                </div>

                <CustomInput
                  type="select"
                  selectList={TYPES}
                  control={form.control}
                  name="type"
                  label="Appointment Type"
                  placeholder="Select a appointment type"
                />

                <FormField
                  control={form.control}
                  name="doctor_id"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Physician</FormLabel>
                      <Select
                        onValueChange={field.onChange}
                        defaultValue={field.value}
                        disabled={isSubmitting}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Select a physician" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent className="">
                          {physicians?.map((i, id) => (
                            <SelectItem key={id} value={i.id} className="p-2">
                              <div className="flex flex-row gap-2 p-2">
                                <ProfileImage
                                  url={i?.img!}
                                  name={i?.name}
                                  bgColor={i?.colorCode!}
                                  textClassName="text-black"
                                />
                                <div>
                                  <p className="font-medium text-start ">
                                    {i.name}
                                  </p>
                                  <span className="text-sm text-gray-600">
                                    {i?.specialization}
                                  </span>
                                </div>
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="flex items-center gap-2">
                  <CustomInput
                    type="input"
                    control={form.control}
                    name="appointment_date"
                    placeholder=""
                    label="Date"
                    inputType="date"
                  />
                  <CustomInput
                    type="select"
                    control={form.control}
                    name="time"
                    placeholder="Select time"
                    label="Time"
                    selectList={appointmentTimes}
                  />
                </div>

                <CustomInput
                  type="textarea"
                  control={form.control}
                  name="note"
                  placeholder="Additional note"
                  label="Additional Note"
                />

                <Button
                  disabled={isSubmitting}
                  type="submit"
                  className="bg-blue-600 w-full"
                >
                  Submit
                </Button>
              </form>
            </Form>
          </div>
        )}
      </SheetContent>
    </Sheet>
  );
};
```

## 📄 components\forms\doctor-form.tsx

```tsx
"use client";

import { DoctorSchema } from "../../lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";
import React, { useActionState, useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "../ui/sheet";
import { Button } from "../ui/button";
import { Plus } from "lucide-react";
import { Form } from "../ui/form";
import { CustomInput, SwitchInput } from "../cutom-input";
import { SPECIALIZATION } from "../../utils/seetings";
import { Label } from "../ui/label";
import { toast } from "sonner";
import { createNewDoctor } from "@/app/actions/admin";

const TYPES = [
  { label: "Full-Time", value: "FULL" },
  { label: "Part-Time", value: "PART" },
];

const WORKING_DAYS = [
  { label: "Sunday", value: "sunday" },
  { label: "Monday", value: "monday" },
  { label: "Tuesday", value: "tuesday" },
  { label: "Wednesday", value: "wednesday" },
  { label: "Thursday", value: "thursday" },
  { label: "Friday", value: "friday" },
  { label: "Saturday", value: "saturday" },
];

type Day = {
  day: string;
  start_time?: string;
  close_time?: string;
};

export const DoctorForm = () => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const [workSchedule, setWorkSchedule] = useState<Day[]>([]);

  const form = useForm<z.infer<typeof DoctorSchema>>({
    resolver: zodResolver(DoctorSchema),
    defaultValues: {
      name: "",
      email: "",
      phone: "",
      specialization: "",
      address: "",
      type: "FULL",
      department: "",
      img: "",
      password: "",
      license_number: "",
    },
  });

  const handleSubmit = async (values: z.infer<typeof DoctorSchema>) => {
    try {
      if (workSchedule.length === 0) {
        toast.error("Please select work schedule");
        return;
      }

      setIsLoading(true);
      const resp = await createNewDoctor({
        ...values,
        work_schedule: workSchedule,
      });

      if (resp.success) {
        toast.success("Doctor added successfully!");

        setWorkSchedule([]);
        form.reset();
        router.refresh();
      } else if (resp.error) {
        toast.error(resp.message);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong");
    } finally {
      setIsLoading(false);
    }
  };

  const selectedSpecialization = form.watch("specialization");

  useEffect(() => {
    if (selectedSpecialization) {
      const department = SPECIALIZATION.find(
        (el) => el.value === selectedSpecialization
      );

      if (department) {
        form.setValue("department", department.department);
      }
    }
  }, [selectedSpecialization]);

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button>
          <Plus size={20} />
          Add Doctor
        </Button>
      </SheetTrigger>

      <SheetContent className="rounded-xl rounded-r-xl md:h-[90%] md:top-[5%] md:right-[1%] w-full overflow-y-scroll">
        <SheetHeader>
          <SheetTitle>Add New Doctor</SheetTitle>
        </SheetHeader>

        <div>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleSubmit)}
              className="space-y-8 mt-5 2xl:mt-10"
            >
              <CustomInput
                type="radio"
                selectList={TYPES}
                control={form.control}
                name="type"
                label="Type"
                placeholder=""
                defaultValue="FULL"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="name"
                placeholder="Doctor's name"
                label="Full Name"
              />

              <div className="flex items-center gap-2">
                <CustomInput
                  type="select"
                  control={form.control}
                  name="specialization"
                  placeholder="Select specialization"
                  label="Specialization"
                  selectList={SPECIALIZATION}
                />
                <CustomInput
                  type="input"
                  control={form.control}
                  name="department"
                  placeholder="OPD"
                  label="Department"
                />
              </div>

              <CustomInput
                type="input"
                control={form.control}
                name="license_number"
                placeholder="License Number"
                label="License Number"
              />
              <div className="flex items-center gap-2">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="email"
                  placeholder="john@example.com"
                  label="Email Address"
                />

                <CustomInput
                  type="input"
                  control={form.control}
                  name="phone"
                  placeholder="9225600735"
                  label="Contact Number"
                />
              </div>

              <CustomInput
                type="input"
                control={form.control}
                name="address"
                placeholder="1479 Street, Apt 1839-G, NY"
                label="Address"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="password"
                placeholder=""
                label="Password"
                inputType="password"
              />

              <div className="mt-6">
                <Label>Working Days</Label>

                <SwitchInput
                  data={WORKING_DAYS}
                  setWorkSchedule={setWorkSchedule}
                />
              </div>

              <Button type="submit" disabled={isLoading} className="w-full">
                Submit
              </Button>
            </form>
          </Form>
        </div>
      </SheetContent>
    </Sheet>
  );
};
```

## 📄 components\forms\staff-form.tsx

```tsx
"use client";

import { DoctorSchema, StaffSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";
import React, { useActionState, useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "../ui/sheet";
import { Button } from "../ui/button";
import { Plus } from "lucide-react";
import { Form } from "../ui/form";
import { CustomInput, SwitchInput } from "../cutom-input";
import { SPECIALIZATION } from "@/utils/seetings";
import { Label } from "../ui/label";
import { toast } from "sonner";
import { createNewDoctor, createNewStaff } from "@/app/actions/admin";

const TYPES = [
  { label: "Nurse", value: "NURSE" },
  { label: "Laboratory", value: "LAB_TECHNICIAN" },
];

export const StaffForm = () => {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const form = useForm<z.infer<typeof StaffSchema>>({
    resolver: zodResolver(StaffSchema),
    defaultValues: {
      name: "",
      email: "",
      phone: "",
      role: "NURSE",
      address: "",
      department: "",
      img: "",
      password: "",
      license_number: "",
    },
  });

  const handleSubmit = async (values: z.infer<typeof StaffSchema>) => {
    try {
      setIsLoading(true);
      const resp = await createNewStaff(values);

      if (resp.success) {
        toast.success("Staff added successfully!");

        form.reset();
        router.refresh();
      } else if (resp.error) {
        toast.error(resp.message);
      }
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button>
          <Plus size={20} />
          New Staff
        </Button>
      </SheetTrigger>

      <SheetContent className="rounded-xl rounded-r-xl md:h-[90%] md:top-[5%] md:right-[1%] w-full overflow-y-scroll">
        <SheetHeader>
          <SheetTitle>Add New Staff</SheetTitle>
        </SheetHeader>

        <div>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleSubmit)}
              className="space-y-8 mt-5 2xl:mt-10"
            >
              <CustomInput
                type="radio"
                selectList={TYPES}
                control={form.control}
                name="role"
                label="Type"
                placeholder=""
                defaultValue="NURSE"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="name"
                placeholder="Staff name"
                label="Full Name"
              />

              <div className="flex items-center gap-2">
                <CustomInput
                  type="input"
                  control={form.control}
                  name="email"
                  placeholder="john@example.com"
                  label="Email Address"
                />

                <CustomInput
                  type="input"
                  control={form.control}
                  name="phone"
                  placeholder="9225600735"
                  label="Contact Number"
                />
              </div>

              <CustomInput
                type="input"
                control={form.control}
                name="license_number"
                placeholder="License Number"
                label="License Number"
              />
              <CustomInput
                type="input"
                control={form.control}
                name="department"
                placeholder="Children's ward"
                label="Department"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="address"
                placeholder="1479 Street, Apt 1839-G, NY"
                label="Address"
              />

              <CustomInput
                type="input"
                control={form.control}
                name="password"
                placeholder=""
                label="Password"
                inputType="password"
              />

              <Button type="submit" disabled={isLoading} className="w-full">
                Submit
              </Button>
            </form>
          </Form>
        </div>
      </SheetContent>
    </Sheet>
  );
};
```

## 📄 components\logoutButton.tsx

```tsx
"use client"

import React from 'react'
import { Button } from './ui/button'
import { LogOut } from 'lucide-react'
import { useClerk } from '@clerk/nextjs'

const LogoutButton = () => {
    const { signOut } = useClerk()
    return (
        <Button
            variant={"outline"}
            className='w-fit bottom-0 gap-2 px-0 md:px-4'
            onClick={() => signOut({
                redirectUrl: "/sign-in"
            })}>
            <LogOut />
            <span className='hidden lg:block'>
                Logout
            </span>
        </Button>
    )
}

export default LogoutButton
```

## 📄 components\medical-history-container.tsx

```tsx
import db from "@/lib/db";
import React from "react";
import { MedicalHistory } from "./medical-history";

interface DataProps {
  id?: number | string;
  patientId: string;
}

export const MedicalHistoryContainer = async ({ id, patientId }: DataProps) => {
  const data = await db.medicalRecords.findMany({
    where: { patient_id: patientId },
    include: {
      diagnosis: { include: { doctor: true } },
      lab_test: true,
    },

    orderBy: { created_at: "desc" },
  });
  return (
    <>
      <MedicalHistory data={data} isShowProfile={false} />
    </>
  );
};
```

## 📄 components\medical-history-dialog.tsx

```tsx
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import React from "react";

interface DataProps {
  id: string | number;
  patientId: string;
  medicalId?: string;
  doctor_id: string | number;
  label: React.ReactNode;
}
export const MedicalHistoryDialog = async ({
  id,
  patientId,
  doctor_id,
  label,
}: DataProps) => {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button
          variant="outline"
          className="flex items-center justify-center rounded-full bg-blue-600/10 hover:underline text-blue-600 px-1.5 py-1 text-xs md:text-sm"
        >
          {label}
        </Button>
      </DialogTrigger>
      <DialogContent className="max-h-[90%] max-w-[425px] md:max-w-2xl 2xl:max-w-4xl p-8 overflow-y-auto">
        {/* <DiagnosisContainer
          id={id}
          patientId={patientId!}
          doctor_id={doctor_id!}
        /> */}

        <p>Diagnosis container form</p>
      </DialogContent>
    </Dialog>
  );
};
```

## 📄 components\medical-history.tsx

```tsx

import { Diagnosis , LabTest , MedicalRecords , Patient } from "@/lib/generated/prisma";
import { BriefcaseBusiness } from "lucide-react";
import React from "react";
import { Table } from "./tables/table";
import { ProfileImage } from "./profile-image";
import { formatDateTime } from "@/utils";
import { ViewAction } from "./action-options";
import { MedicalHistoryDialog } from "./medical-history-dialog";

export interface ExtendedMedicalHistory extends MedicalRecords {
  patient?: Patient;
  diagnosis: Diagnosis[];
  lab_test: LabTest[];
  index?: number;
}

interface DataProps {
  data: ExtendedMedicalHistory[];
  isShowProfile?: boolean;
}

export const MedicalHistory = ({ data, isShowProfile }: DataProps) => {
  const columns = [
    {
      header: "No",
      key: "no",
    },
    {
      header: "Info",
      key: "name",
      className: isShowProfile ? "table-cell" : "hidden",
    },
    {
      header: "Date & Time",
      key: "medical_date",
      className: "",
    },
    {
      header: "Doctor",
      key: "doctor",
      className: "hidden xl:table-cell",
    },
    {
      header: "Diagnosis",
      key: "diagnosis",
      className: "hidden md:table-cell",
    },
    {
      header: "Lab Test",
      key: "lab_test",
      className: "hidden 2xl:table-cell",
    },
  ];

  const renderRow = (item: ExtendedMedicalHistory) => {
    return (
      <tr
        key={item.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="py-2 xl:py-6"># {item?.id}</td>

        {isShowProfile && (
          <td className="flex items-center gap-2 2xl:gap-4 py-2 xl:py-4">
            <ProfileImage
              url={item?.patient?.img!}
              name={item?.patient?.first_name + " " + item?.patient?.last_name}
            />
            <div>
              <h3 className="font-semibold">
                {item?.patient?.first_name + " " + item?.patient?.last_name}
              </h3>
              <span className="text-xs capitalize hidden md:flex">
                {item?.patient?.gender.toLowerCase()}
              </span>
            </div>
          </td>
        )}

        <td className="">{formatDateTime(item?.created_at.toString())}</td>

        <td className="hidden  items-center py-2  xl:table-cell">
          {item?.doctor_id}
        </td>
        <td className="hidden lg:table-cell">
          {item?.diagnosis?.length === 0 ? (
            <span className="text-sm italic text-gray-500">
              No diagnosis found
            </span>
          ) : (
            <>
              <MedicalHistoryDialog
                id={item?.appointment_id}
                patientId={item?.patient_id}
                doctor_id={item?.doctor_id}
                label={
                  <div className="flex gap-x-2 items-center text-lg">
                    {item?.diagnosis?.length}

                    <span className="text-sm">Found</span>
                  </div>
                }
              />
            </>
          )}
        </td>
        <td className="hidden 2xl:table-cell">
          {item?.lab_test?.length === 0 ? (
            <span className="text-sm italic text-gray-500">
              No lab test found
            </span>
          ) : (
            <div className="flex gap-x-2 items-center text-lg">
              {item?.lab_test?.length}

              <span className="text-sm">Found</span>
            </div>
          )}
        </td>

        <td>
          <ViewAction href={`/record/appointments/${item?.appointment_id}`} />
        </td>
      </tr>
    );
  };

  return (
    <>
      <div className="bg-white rounded-xl p-2 2xl:p-6">
        <div className="">
          <h1 className="font-semibold text-xl">Medical History (All)</h1>
          <div className="hidden lg:flex items-center gap-1">
            <BriefcaseBusiness size={20} className="text-gray-500" />
            <p className="text-2xl font-semibold">{data?.length}</p>
            <span className="text-gray-600 text-sm xl:text-base">
              total records
            </span>
          </div>
        </div>
        <Table columns={columns} renderRow={renderRow} data={data} />
      </div>
    </>
  );
};
```

## 📄 components\navbar.tsx

```tsx
"use client";

import { useAuth, UserButton } from '@clerk/nextjs';
import { Bell } from 'lucide-react';
import { usePathname } from 'next/navigation';
import React from 'react'

const Navbar = () => {
    const user = useAuth();
    function formatPathName ():string{
        const pathname = usePathname()
        if(!pathname) return "Overview"
        const splitRoute = pathname.split('/')
        const lastIndex = splitRoute.length - 1 > 2 ? 2 :splitRoute.length - 1
        const pathName = splitRoute [lastIndex]
        const formattedPath = pathName.replace(/-/g, "")
        return formattedPath;
    }
    const path = formatPathName();
  return (
    <div className='p-5 flex justify-between bg-white'>
        <h1 className='text-xl font-medium text-gray-500 capitalize' >
            {
                path || "Overview"
            }
        </h1>
        <div className='flex items-center gap-4'>
            <div className='relative'>
                <Bell />
                <p className='absolute -top-3 right-1 size-4 bg-red-600 text-white rounded-full text-[10px] text-center'>2</p>
            </div>
            {
                user?.userId && <UserButton/>
            }
        </div>
    </div>
  )
}

export default Navbar
```

## 📄 components\new-patient.tsx

```tsx
"use client";

import { useUser } from '@clerk/nextjs';
import { Patient } from "@/lib/generated/prisma";
import { useRouter } from 'next/navigation';
import React, { useEffect, useState } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';
import { Form } from './ui/form';
import { useForm, SubmitHandler } from 'react-hook-form';
import { zodResolver } from "@hookform/resolvers/zod"
import { PatientFormSchema } from '@/lib/schema';
import { z } from 'zod';
import { CustomInput } from './cutom-input';
import { Button } from './ui/button';
import { GENDER, MARITAL_STATUS, RELATION } from '@/lib';
import { createNewPatient } from '@/app/actions/patient';
import { toast } from 'sonner';

// 1. Create explicit type from schema
type PatientFormValues = z.infer<typeof PatientFormSchema>;

interface DataProps {
    data?: Patient;
    type: "create" | "update"
}

const NewPatient = ({ data, type }: DataProps) => {
    const { user } = useUser();
    const [loading, setLoading] = useState(false);
    const router = useRouter();

    const userData = {
        first_name: user?.firstName || "",
        last_name: user?.lastName || "",
        email: user?.emailAddresses[0]?.emailAddress || "",
        phone: user?.phoneNumbers[0]?.toString() || "",
    }

    const userId = user?.id;
    // 2. Use explicit type and type assertion for resolver
    const form = useForm<PatientFormValues>({
        resolver: zodResolver(PatientFormSchema) as any, // Temporary workaround
        defaultValues: {
            ...userData,
            // Add all other default values required by your schema
            date_of_birth: new Date(),
            gender: "MALE" as const,
            marital_status: "single" as const,
            address: "",
            emergency_contact_name: "",
            emergency_contact_number: "",
            relation: "other" as const,
            blood_group: "",
            allergies: "",
            medical_conditions: "",
            insurance_number: "",
            insurance_provider: "",
            medical_history: "",
        },
    });

    // 3. Proper typing for submit handler
    const onSubmit : SubmitHandler<z.infer<typeof PatientFormSchema>> = async (
        values
    ) =>{
        setLoading(true)
        const res = type === "create" ? await createNewPatient(values , userId!) : null;
        setLoading(false)
        if(res?.success){
            toast.success(res.msg);
            form.reset();
            router.push('/')
        }else{
            console.log(res)
            toast.error("Failed to create patient");
        }
    }

    useEffect(() => {
        if (type === "create") {
          userData && form.reset({ ...userData });
        } else if (type === "update") {
          data &&
            form.reset({
              first_name: data.first_name,
              last_name: data.last_name,
              email: data.email,
              phone: data.phone,
              date_of_birth: new Date(data.date_of_birth),
              gender: data.gender === "MALE" || data.gender === "FEMALE" ? data.gender : undefined,
              marital_status: data.marital_status as
                | "married"
                | "single"
                | "divorced"
                | "widowed"
                | "separated",
              address: data.address,
              emergency_contact_name: data.emergency_contact_name,
              emergency_contact_number: data.emergency_contact_number,
              relation: data.relation as
                | "mother"
                | "father"
                | "husband"
                | "wife"
                | "other",
              blood_group: data?.blood_group!,
              allergies: data?.allergies! || "",
              medical_conditions: data?.medical_conditions! || "",
              medical_history: data?.medical_history! || "",
              insurance_number: data.insurance_number! || "",
              insurance_provider: data.insurance_provider! || "",
              medical_consent: data.medical_consent,
              privacy_consent: data.privacy_consent,
              service_consent: data.service_consent,
            });
        }
      }, [user]);
    
    return (
        <div className='w-full'>
            <Card className='max-w-6xl w-full p-4'>
                <CardHeader>
                    <CardTitle>Patient Registration</CardTitle>
                    <CardDescription>
                        Please provide all the information below to help us understand better
                        and provide good and quality service to you.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <Form {...form}>
                        <form onSubmit={form.handleSubmit(onSubmit)} className='space-y-8 mt-5'>
                            <h3 className='text-lg font-semibold'>
                                Personal Information
                            </h3>
                            <>
                                <div className='flex flex-col lg:flex-row gap-y-6 justify-center gap-2 md:gap-x-4'>
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="first_name"
                                        placeholder="First Name"
                                        label="First Name"
                                    />
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="last_name"
                                        placeholder="Doe"
                                        label="Last Name"
                                    />
                                </div>
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="email"
                                    placeholder="john@example.com"
                                    label="Email Address"
                                />
                                <div className="flex flex-col lg:flex-row  gap-y-6 items-center gap-2 md:gap-x-4">
                                    <CustomInput
                                        type="select"
                                        control={form.control}
                                        name="gender"
                                        placeholder="Select gender"
                                        label="Gender"
                                        selectList={GENDER!}
                                    />
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="date_of_birth"
                                        placeholder="01-05-2000"
                                        label="Date of Birth"
                                        inputType="date"
                                    />
                                </div>
                                <div className="flex flex-col lg:flex-row  gap-y-10 items-center gap-4 md:gap-x-4">
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="phone"
                                        placeholder="9225600735"
                                        label="Contact Number"
                                    />
                                    <CustomInput
                                        type="select"
                                        control={form.control}
                                        name="marital_status"
                                        placeholder="Select marital status"
                                        label="Marital Status"
                                        selectList={MARITAL_STATUS!}
                                    />
                                </div>
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="address"
                                    placeholder="1479 Street, Apt 1839-G, NY"
                                    label="Address"
                                />
                            </>

                            <div className="space-y-8">
                                <h3 className="text-lg font-semibold">Family Information</h3>
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="emergency_contact_name"
                                    placeholder="Anne Smith"
                                    label="Emergency contact name"
                                />
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="emergency_contact_number"
                                    placeholder="675444467"
                                    label="Emergency contact"
                                />
                                <CustomInput
                                    type="select"
                                    control={form.control}
                                    name="relation"
                                    placeholder="Select relation with contact person"
                                    label="Relation"
                                    selectList={RELATION}
                                />
                            </div>

                            <div className="space-y-8">
                                <h3 className="text-lg font-semibold">Medical Information</h3>

                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="blood_group"
                                    placeholder="A+"
                                    label="Blood group"
                                />
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="allergies"
                                    placeholder="Milk"
                                    label="Allergies"
                                />
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="medical_conditions"
                                    placeholder="Medical conditions"
                                    label="Medical conditions"
                                />
                                <CustomInput
                                    type="input"
                                    control={form.control}
                                    name="medical_history"
                                    placeholder="Medical history"
                                    label="Medical history"
                                />
                                <div className="flex flex-col lg:flex-row  gap-y-6 items-center gap-2 md:gap-4">
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="insurance_provider"
                                        placeholder="Insurance provider"
                                        label="Insurance provider"
                                    />{" "}
                                    <CustomInput
                                        type="input"
                                        control={form.control}
                                        name="insurance_number"
                                        placeholder="Insurance number"
                                        label="Insurance number"
                                    />
                                </div>
                            </div>

                            {type !== "update" && (
                                <div className="">
                                    <h3 className="text-lg font-semibold mb-2">Consent</h3>

                                    <div className="space-y-6">
                                        <CustomInput
                                            name="privacy_consent"
                                            label=" Privacy Policy Agreement"
                                            placeholder=" I consent to the collection, storage, and use of my
                    personal and health information as outlined in the Privacy
                    Policy. I understand how my data will be used, who it may
                    be shared with, and my rights regarding access,
                    correction, and deletion of my data."
                                            type="checkbox"
                                            control={form.control}
                                        />

                                        <CustomInput
                                            control={form.control}
                                            type="checkbox"
                                            name="service_consent"
                                            label=" Terms of Service Agreement"
                                            placeholder=" I agree to the Terms of Service, including my
                    responsibilities as a user of this healthcare management
                    system, the limitations of liability, and the dispute
                    resolution process. I understand that continued use of
                    this service is contingent upon my adherence to these
                    terms."
                                        />

                                        <CustomInput
                                            control={form.control}
                                            type="checkbox"
                                            name="medical_consent"
                                            label="Informed Consent for Medical Treatment"
                                            placeholder="I provide informed consent to receive medical treatment
                    and services through this healthcare management system. I
                    acknowledge that I have been informed of the nature,
                    risks, benefits, and alternatives to the proposed
                    treatments and that I have the right to ask questions and
                    receive further information before proceeding."
                                        />
                                    </div>
                                </div>
                            )}

                            <Button
                                disabled={loading}
                                type="submit"
                                className="w-full md:w-fit px-6"
                            >
                                {type === "create" ? "Submit" : "Update"}
                            </Button>



                        </form>
                    </Form>
                </CardContent>
            </Card>
        </div>
    )
}

export default NewPatient;
```

## 📄 components\no-data-found.tsx

```tsx
import { FaMagnifyingGlassChart } from "react-icons/fa6";

export const NoDataFound = ({ note }: { note?: string }) => {
  return (
    <div className="w-full h-full flex flex-col items-center justify-center py-0">
      <FaMagnifyingGlassChart size={80} className="text-gray-600" />
      <span className="text-xl text-gray-500 mt-2 font-medium">
        {note || "No Record Found"}
      </span>
    </div>
  );
};
```

## 📄 components\pagination.tsx

```tsx
"use client";

import React, { useCallback } from "react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { Button } from "./ui/button";

interface PaginationProps {
  totalRecords: number;
  currentPage: number;
  totalPages: number;
  limit: number;
}

export const Pagination = ({
  totalPages,
  currentPage,
  totalRecords,
  limit,
}: PaginationProps) => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const pathname = usePathname();

  const createQueryString = useCallback(
    (name: string, value: string) => {
      const params = new URLSearchParams(searchParams.toString());
      params.set(name, value);

      return params.toString();
    },
    [searchParams]
  );

  const handlePrevious = () => {
    if (currentPage > 1) {
      router.push(
        pathname + "?" + createQueryString("p", (currentPage - 1).toString())
      );
      // router.push(`?p=${currentPage - 1}`);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      // router.push(`?p=${currentPage + 1}`);
      router.push(
        pathname + "?" + createQueryString("p", (currentPage + 1).toString())
      );
    }
  };

  if (totalRecords === 0) return null;

  return (
    <div className="p-4 flex items-center justify-between text-gray600 mt-5">
      <Button
        size={"sm"}
        variant={"outline"}
        disabled={currentPage === 1}
        onClick={handlePrevious}
        className="py-2 px-4 rounded-md bg-slate-200 text-sm font-semibold disabled:cursor-not-allowed disabled:opacity-50"
      >
        Prev
      </Button>
      {/* 10 - 9 = 11 - 20 of 20 */}
      <div className="flex items-center gap-2 text-sm">
        <span className="text-xs lg:text-sm">
          Showing {currentPage * limit - (limit - 1)} to{" "}
          {currentPage * limit <= totalRecords
            ? currentPage * limit
            : totalRecords}{" "}
          of {totalRecords}
        </span>
      </div>

      <Button
        size={"sm"}
        variant={"outline"}
        disabled={currentPage === totalPages}
        onClick={handleNext}
        className="py-2 px-4 rounded-md bg-slate-200 text-sm font-semibold disabled:cursor-not-allowed disabled:opacity-50"
      >
        Next
      </Button>
    </div>
  );
};
```

## 📄 components\patient-rating-container.tsx

```tsx
import db from "../lib/db";
import { auth } from "@clerk/nextjs/server";
import React from "react";
import { RatingList } from "./rating-list";

export const PatientRatingContainer = async ({ id }: { id?: string }) => {
  const { userId } = await auth();

  const data = await db.rating.findMany({
    take: 10,

    where: { patient_id: id ? id : userId! },
    include: { patient: { select: { last_name: true, first_name: true } } },
    orderBy: { created_at: "desc" },
  });

  if (!data) return null;

  return (
    <div>
      <RatingList data={data} />
    </div>
  );
};
```

## 📄 components\profile-image.tsx

```tsx
import { cn } from "@/lib/utils";
import { getInitials } from "@/utils";
import Image from "next/image";

export const ProfileImage = ({
  url,
  name,
  className,
  textClassName,
  bgColor,
}: {
  url?: string;
  name: string;
  className?: string;
  textClassName?: string;
  bgColor?: string;
}) => {
  if (url)
    return (
      <Image
        src={url}
        alt={name}
        height={40}
        width={40}
        className={cn(
          "flex md:hidden lg:block w-10 h-10 rounded-full object-cover",
          className
        )}
      />
    );

  if (name) {
    return (
      <div
        className={cn(
          "flex md:hidden lg:flex w-10 h-10 rounded-full text-white text-base items-center justify-center font-light",
          className
        )}
        style={{ backgroundColor: bgColor || "#2563eb" }}
      >
        <p className={textClassName}>{getInitials(name)}</p>
      </div>
    );
  }
};
```

## 📄 components\rating-container.tsx

```tsx
import { getRatingById } from "@/utils/services/doctor";
import React from "react";
import { RatingList } from "./rating-list";
import { RatingChart } from "./charts/rating-chart";

export const RatingContainer = async ({ id }: { id: string }) => {
  const { ratings, totalRatings, averageRating } = await getRatingById(id);

  return (
    <div className="space-y-4">
      <RatingChart
        totalRatings={totalRatings!}
        averageRating={Number(averageRating!)}
      />
      <RatingList data={ratings!} />
    </div>
  );
};
```

## 📄 components\rating-list.tsx

```tsx
import { Star } from "lucide-react";
import React from "react";

interface DataProps {
  id: number;
  staff_id: string;
  rating: number;
  comment?: string;
  created_at: Date | string;
  patient: { last_name: string; first_name: string };
}

export const RatingList = ({ data }: { data: any[] }) => {
  return (
    <div className="bg-white rounded-lg">
      <div className="flex items-center justify-between p-4">
        <h1 className="text-xl font-semibold">Patient Reviews</h1>
      </div>

      <div className="space-y-2 p-2">
        {data?.map((rate, id) => (
          <div key={rate?.id} className="even:bg-gray-50 p-3 rounded">
            <div className="flex justify-between">
              <div className="flex items-center gap-4">
                <p className="text-base font-medium">
                  {rate?.patient?.first_name + " " + rate?.patient?.last_name}
                </p>
                <span className="text-sm text-gray-500">
                  {new Date(rate?.created_at).toLocaleDateString()}
                </span>
              </div>

              <div className="flex flex-col items-center">
                <div className="flex items-center text-yellow-600">
                  {Array.from({ length: rate.rating }, (_, index) => (
                    <Star key={index} className="text-lg" />
                  ))}

                  {/* <div className="flex items-center">
                    <Star className="text-lg" />
                    <span>{rate.rating}</span>
                  </div> */}
                </div>
                <span className="">{rate.rating.toFixed(1)}</span>
              </div>
            </div>
          </div>
        ))}

        {data?.length === 0 && (
          <div className="px-2 text-gray-600">
            <p>No Reviews</p>
          </div>
        )}
      </div>
    </div>
  );
};
```

## 📄 components\search-input.tsx

```tsx
"use client";

import { Search } from "lucide-react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { FormEvent, useCallback, useState } from "react";

const SearchInput = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const [searchValue, setSearchValue] = useState("");

  const createQueryString = useCallback(
    (name: string, value: string) => {
      const params = new URLSearchParams(searchParams.toString());
      params.set(name, value);

      return params.toString();
    },
    [searchParams]
  );

  const handleSearch = (e: FormEvent) => {
    e.preventDefault();

    router.push(pathname + "?" + createQueryString("q", searchValue));
  };

  return (
    <form onSubmit={handleSearch}>
      <div className="hidden xl:flex items-center border border-gray-300 px-2 py-2 rounded-md focus-within:ring-2 focus-within:ring-blue-300 focus-within:border-blue-300">
        <Search size={18} className="text-gray-400" />
        <input
          className="outline-none px-2 text-sm"
          placeholder="Search..."
          onChange={(e) => setSearchValue(e.target.value)}
        />
      </div>
    </form>
  );
};

export default SearchInput;
```

## 📄 components\settings\quick-link-settings.tsx

```tsx
import Link from "next/link";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";

export const SettingsQuickLinks = () => {
  return (
    <Card className="w-full rounded-xl bg-white shadow-none">
      <CardHeader>
        <CardTitle className="text-lg text-gray-500">Quick Links</CardTitle>
      </CardHeader>

      <CardContent className="text-sm font-normal flex flex-wrap gap-4">
        <Link
          href="?cat=services"
          className="px-4 py-2 rounded-lg bg-gray-100 text-gray-600"
        >
          Services
        </Link>
        <Link
          href="?cat=appointment"
          className="px-4 py-2 rounded-lg bg-violet-100 text-violet-600"
        >
          Payment Methods
        </Link>

        <Link
          href="?cat=medical-history"
          className="px-4 py-2 rounded-lg bg-rose-100 text-rose-600"
        >
          Medical History
        </Link>
      </CardContent>
    </Card>
  );
};
```

## 📄 components\settings\service-settings.tsx

```tsx
import { getServices } from "@/utils/services/admin";
import { Services } from "@/lib/generated/prisma";
import { AddService } from "../dialogs/add-service";
import { Table } from "../tables/table";
import {
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "../ui/card";

const columns = [
  {
    header: "ID",
    key: "id",
    className: "hidden md:table-cell",
  },
  {
    header: "Service Name",
    key: "name",
    className: "hidden md:table-cell",
  },
  {
    header: "Price",
    key: "price",
    className: "hidden md:table-cell",
  },
  {
    header: "Description",
    key: "description",
    className: "hidden xl:table-cell",
  },
  // {
  //   header: "Actions",
  //   key: "action",
  // },
];

export const ServiceSettings = async () => {
  const { data } = await getServices();

  const renderRow = (item: Services) => (
    <tr
      key={item.id}
      className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
    >
      <td className="flex items-center gap-2 md:gap-4 py-4">{item?.id}</td>

      <td className="hidden md:table-cell">{item.service_name}</td>
      <td className="hidden md:table-cell capitalize">
        {item?.price?.toFixed(2)}
      </td>

      <td className="hidden xl:table-cell w-[50%]">
        <p className="line-clamp-1">{item.description!}</p>
      </td>
      <td>
        {/* <div className="flex items-center gap-2">
              <Link href={`/list/teachers/${item?.id}`}>
                <button className="w-7 h-7 flex items-center justify-center rounded-full bg-lamaSky">
                  View
                </button>
              </Link>
    
              {checkRole("ADMIN") && (
                <ActionDialog
                  type="delete"
                  id={item.id.toString()}
                  deleteType="auditLog"
                />
              )}
            </div> */}
      </td>
    </tr>
  );

  return (
    <>
      <CardHeader className="flex flex-row items-center justify-between">
        <div>
          <CardTitle className="capitalize">Services</CardTitle>
          <CardDescription>
            Perform all settings and other parameters of the system from this
            section .
          </CardDescription>
        </div>
        <AddService />
      </CardHeader>

      <CardContent>
        <Table columns={columns} renderRow={renderRow} data={data!} />
      </CardContent>
    </>
  );
};
```

## 📄 components\sidebar.tsx

```tsx
import { getRole } from '@/utils/roles';
import { access } from 'fs';
import { Bell, Calendar, LayoutDashboard, List, ListOrdered, Logs, LucideIcon, Pill, Receipt, Settings, SquareActivity, User, UserRound, Users } from 'lucide-react'
import Link from 'next/link';
import React from 'react'
import LogoutButton from './logoutButton';

const SidebarIcon = ({ Icon }: { Icon: LucideIcon }) => {
    return <Icon className='size-6 lg:size-5' />;
}

const ACCESS_LEVELS_ALL = [
    "admin",
    "doctor",
    "nurse",
    "lab technician",
    "patient",
];

const Sidebar = async () => {

    const role = await getRole()

    const SIDEBAR_LINKS = [
        {
            label: "MENU",
            links: [
                {
                    name: "Dashboard",
                    href: "/",
                    access: ACCESS_LEVELS_ALL,
                    icon: LayoutDashboard,
                },
                {
                    name: "Profile",
                    href: "/patient/self",
                    access: ["patient"],
                    icon: User
                },
            ],
        },
        {
            label: "Manage",
            links: [
                {
                    name: "Users",
                    href: "/record/users",
                    access: ["admin"],
                    icon: User
                },
                {
                    name: "Doctors",
                    href: "/record/doctors",
                    access: ["admin"],
                    icon: User
                },
                {
                    name: "Staff",
                    href: "/record/staffs",
                    access: ["admin", "doctor"],
                    icon: UserRound
                },
                {
                    name: "Patients",
                    href: "/record/patients",
                    access: ["admin", "doctor", "nurse"],
                    icon: UserRound
                },
                {
                    name: "Appointments",
                    href: "/record/appointments",
                    access: ["admin", "doctor", "nurse"],
                    icon: ListOrdered
                },
                {
                    name: "Medical Records",
                    href: "/record/medical-records",
                    access: ["admin", "doctor", "nurse"],
                    icon: SquareActivity,
                },
                {
                    name: "Billing Overview",
                    href: "/record/billing",
                    access: ["admin", "doctor"],
                    icon: Receipt,
                },
                {
                    name: "Patient Management",
                    href: "/record/patient-management",
                    access: ["nurse"],
                    icon: Users,
                },
                {
                    name: "Administer Medications",
                    href: "/record/administer-medications",
                    access: ["admin", "doctor", "nurse"],
                    icon: Pill,
                },
                {
                    name: "Appointments",
                    href: "/record/appointments",
                    access: ["patient"],
                    icon: ListOrdered,
                },
                {
                    name: "Records",
                    href: "/record/records",
                    access: ["patient"],
                    icon: List
                },
                {
                    name: "Prescription",
                    href: "#",
                    access: ["patient"],
                    icon: Pill,
                },
                {
                    name: "Billing",
                    href: "/patient/self?cat=payments",
                    access: ["patient"],
                    icon: Receipt,
                },
            ],
        },
        {
            label: "System",
            links: [
                {
                    name: "Notifications",
                    href: "/notifications",
                    access: ACCESS_LEVELS_ALL,
                    icon: Bell,
                },
                {
                    name: "Audit Logs",
                    href: "/admin/audit-logs",
                    access: ["admin"],
                    icon: Logs,
                },
                {
                    name: "Settings",
                    href: "/admin/system-settings",
                    access: ["admin"],
                    icon: Settings
                }
            ]
        }
    ]
    return (
        <div className='w-full p-4 flex flex-col justify-between gap-4 bg-white overflow-y-scroll min-h-full'>
            <div className=''>
                <div className='flex items-center justify-center lg:justify-start gap-2'>
                    <div className='p-1.5 rounded-md bg-blue-600 text-white'>
                        <SquareActivity size={22} />
                    </div>
                    <Link href={"/"} className='hidden lg:flex text-base 2xl:text-xl font-bold'>
                        HealthAxis
                    </Link>
                </div>
                <div className='mt-4 text-sm'>
                    {
                        SIDEBAR_LINKS.map((el) =>
                        (
                            <div key={el.label} className='flex flex-col gap-2'>
                                <span className='hidden uppercase lg:block text-gray-400 font-bold my-4'>{el.label}</span>
                                {
                                    el.links.map((link) => {
                                        if (link.access.includes(role.toLowerCase())) {

                                            return (
                                                <Link href={link.href} className='flex items-center justify-center lg:justify-start gap-4 text-gray-500 py-2 md:px-2 rounded:md hover:text-blue-600' key={link.name}>
                                                    <SidebarIcon Icon={link.icon}></SidebarIcon>
                                                    <span className='hidden lg:block'>
                                                        {link.name}
                                                    </span>
                                                </Link>
                                            )
                                        }
                                    })}
                            </div>
                        ))}
                </div>
            </div>
            <LogoutButton/>
        </div>
    )
}

export default Sidebar

```

## 📄 components\small-card.tsx

```tsx
import { cn } from "@/lib/utils";
import React from "react";

export const SmallCard = ({
  label,
  value,
  className,
}: {
  label: string;
  value: string;
  className?: string;
}) => {
  return (
    <div className="w-full  md:w-1/3">
      <span className="text-sm text-gray-500">{label}</span>
      <p className={cn("text-sm md:text-base", className)}>{value}</p>
    </div>
  );
};
```

## 📄 components\stat-card.tsx

```tsx
import { cn } from "@/lib/utils";
import { LucideIcon } from "lucide-react";
import React from "react";
import { Card, CardContent, CardFooter, CardHeader } from "./ui/card";
import { Button } from "./ui/button";
import Link from "next/link";
import { formatNumber } from "../utils";

interface CardProps {
  title: string;
  icon: LucideIcon;
  note: string;
  value: number;
  className?: string;
  iconClassName?: string;
  link: string;
}

const CardIcon = ({ icon: Icon }: { icon: LucideIcon }) => {
  return <Icon />;
};
export const StatCard = ({
  title,
  icon,
  note,
  value,
  className,
  iconClassName,
  link,
}: CardProps) => {
  return (
    <Card className={cn("w-full md:w-[330px] 2xl:w-[250px]", className)}>
      <CardHeader className="flex flex-row items-center justify-between py-3 capitalize">
        <h3>{title}</h3>
        <Button
          asChild
          size="sm"
          variant="outline"
          className="font-normal text-xs bg-transparent p-2 h-0 hover:underline"
        >
          <Link href={link}>See details</Link>
        </Button>
      </CardHeader>

      <CardContent>
        <div className="flex items-center gap-4">
          <div
            className={cn(
              "w-10 h-10 bg-violet-50-500/15 rounded-full flex items-center justify-center text-violet-600",
              iconClassName
            )}
          >
            <CardIcon icon={icon} />
          </div>

          <h2 className="text-2xl 2xl:text-3xl font-semibold">
            {formatNumber(value)}
          </h2>
        </div>
      </CardContent>

      <CardFooter className="pb-3">
        <p className="text-sm text-gray-500">{note}</p>
      </CardFooter>
    </Card>
  );
};
```

## 📄 components\tables\recent-appointment.tsx

```tsx
import Link from "next/link";
import React from "react";
import { Button } from "../ui/button";
import { Table } from "./table";
import { Appointment } from "@/types/data-types";
import { ProfileImage } from "../profile-image";
import { format } from "date-fns";
import { AppointmentStatusIndicator } from "../appointment-status-indicator";
import { ViewAppointment } from "../view-appointment";

interface DataProps {
  data: any[];
}
const columns = [
  { header: "Info", key: "name" },
  {
    header: "Date",
    key: "appointmentDate",
    className: "hidden md:table-cell",
  },
  {
    header: "Time",
    key: "time",
    className: "hidden md:table-cell",
  },
  {
    header: "Doctor",
    key: "doctor",
    className: "hidden md:table-cell",
  },
  {
    header: "Status",
    key: "status",
    className: "hidden xl:table-cell",
  },
  {
    header: "Actions",
    key: "action",
  },
];
export const RecentAppointments = ({ data }: DataProps) => {
  const renderRow = (item: Appointment) => {
    const name = item?.patient?.first_name + " " + item?.patient?.last_name;
    return (
      <tr
        key={item?.id}
        className="border-b border-gray-200 even:bg-slate-50 text-sm hover:bg-slate-50"
      >
        <td className="flex items-center gap-2 2xl:gap-4 py-2 xl:py-4">
          <ProfileImage
            url={item?.patient?.img!}
            name={name}
            className="bg-violet-600"
            // bgColor={item?.patient?.colorCode!}
          />
          <div>
            <h3 className="text-sm md:text-base md:font-medium uppercase">
              {name}
            </h3>
            <span className="text-xs capitalize">
              {item?.patient?.gender?.toLowerCase()}
            </span>
          </div>
        </td>

        <td className="hidden md:table-cell">
          {format(item?.appointmentDate, "yyyy-MM-dd")}
        </td>
        <td className="hidden md:table-cell">{item?.time}</td>
        <td className="hidden md:table-cell items-center py-2">
          <div
            className="flex items-center gap-2 2x:gap-4
          "
          >
            <ProfileImage
              url={item?.doctor?.img!}
              name={item?.doctor?.name}
              className="bg-blue-600"
            //   bgColor={item?.doctor?.colorCode!}
              textClassName="text-black font-medium"
            />
            <div>
              <h3 className="font-medium uppercase">{item?.doctor?.name}</h3>
              <span className="text-xs capitalize">
                {item?.doctor?.specialization}
              </span>
            </div>
          </div>
        </td>

        <td className="hidden xl:table-cell">
          <AppointmentStatusIndicator status={item?.status} />
        </td>

        <td>
          <div className="flex items-center gap-x-2">
            <ViewAppointment id={item?.id} />

            <Link href={`/record/appointments/${item?.id}`}>See all</Link>
          </div>
        </td>
      </tr>
    );
  };

  return (
    <div className="bg-white rounded-xl p-2 2xl:p-4">
      <div className="flex justify-between items-center">
        <h1 className="text-lg font-semibold">Recent Appointments</h1>

        <Button asChild variant={"outline"}>
          <Link href="/record/appointments">View All</Link>
        </Button>
      </div>

      <Table columns={columns} renderRow={renderRow} data={data} />
    </div>
  );
};
```

## 📄 components\tables\table.tsx

```tsx
import React from "react";

interface TableProps {
  columns: { header: string; key: string; className?: string }[];
  renderRow: (item: any) => React.ReactNode;
  data: any[];
}

export const Table = ({ columns, renderRow, data }: TableProps) => {
  return (
    <table className="w-full mt-4">
      <thead>
        <tr className="text-left text-gray-500 text-sm lg:uppercase">
          {columns.map(({ header, key, className }) => (
            <th key={key} className={className}>
              {header}
            </th>
          ))}
        </tr>
      </thead>

      <tbody>
        {data?.length < 1 && (
          <tr className="text-gray-400 text-base py-10">
            <td>No Data Found</td>
          </tr>
        )}

        {data?.length > 0 &&
          data?.map((item, id) => renderRow({ ...item, index: id }))}
      </tbody>
    </table>
  );
};
```

## 📄 components\ui\button.tsx

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

```

## 📄 components\ui\card.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

```

## 📄 components\ui\checkbox.tsx

```tsx
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }

```

## 📄 components\ui\dialog.tsx

```tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

```

## 📄 components\ui\form.tsx

```tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

```

## 📄 components\ui\input.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

## 📄 components\ui\label.tsx

```tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

```

## 📄 components\ui\popover.tsx

```tsx
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

```

## 📄 components\ui\radio-group.tsx

```tsx
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }

```

## 📄 components\ui\select.tsx

```tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

```

## 📄 components\ui\separator.tsx

```tsx
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

```

## 📄 components\ui\sheet.tsx

```tsx
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

```

## 📄 components\ui\switch.tsx

```tsx
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

```

## 📄 components\ui\textarea.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

```

## 📄 components\view-appointment.tsx

```tsx
// import { getAppointmentById } from "@/utils/services/appointment";
import React from "react";
import { NumberDomain } from "recharts/types/util/types";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "./ui/dialog";
import { calculateAge, formatDateTime } from "@/utils";
import { ProfileImage } from "./profile-image";
import { Calendar, Phone } from "lucide-react";
import { format } from "date-fns";
import { AppointmentStatusIndicator } from "./appointment-status-indicator";
import { checkRole } from "@/utils/roles";
import { auth } from "@clerk/nextjs/server";
import { Button } from "./ui/button";
import { getAppointmentById } from "@/utils/services/appointment";

export const ViewAppointment = async ({ id }: { id: string | undefined }) => {
    // const data = null;
  const { data } = await getAppointmentById(Number(id!));
  const { userId } = await auth();

  if (!data) return null;

  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button
          variant="outline"
          className="flex items-center justify-center rounded-full bg-blue-500/10 hover:underline text-blue-600 px-1.5 py-1 text-xs md:text-sm"
        >
          View
        </Button>
      </DialogTrigger>

      <DialogContent className="max-w-[425px] max-h-[95%] md:max-w-2xl 2xl:max-w-3xl p-8 overflow-y-auto">
        <>
          <DialogHeader>
            <DialogTitle>Patient Appointment</DialogTitle>
            <DialogDescription>
              This appointment was booked on the{" "}
              {formatDateTime(data?.created_at.toString())}
            </DialogDescription>
          </DialogHeader>

          {data?.status === "CANCELLED" && (
            <div className="bg-yellow-100 p-4 mt-4 rounded-md">
              <span className="font-semibold text-sm">
                This appointment has been cancelled
              </span>
              <p className="text-sm">
                <strong>Reason</strong>: {data?.reason}
              </p>
            </div>
          )}

          <div className="grid gap-4 py-4">
            <p className="w-fit bg-blue-100 text-blue-600 py-1 rounded text-xs md:text-sm">
              Personal Information
            </p>

            <div className="flex flex-col md:flex-row gap-6 mb-16">
              <div className="flex gap-1 w-full md:w-1/2">
                <ProfileImage
                  url={data?.patient?.img!}
                  name={
                    data?.patient?.first_name + " " + data?.patient?.last_name
                  }
                  className="size-20 bg-blue-500"
                  textClassName="text-2xl"
                />

                <div className="space-y-0.5">
                  <h2 className="text-lg md:text-xl font-semibold uppercase">
                    {data?.patient?.first_name + " " + data?.patient?.last_name}
                  </h2>

                  <p className="flex items-center gap-2 text-gray-600">
                    <Calendar size={20} className="text-gray-500" />
                    {calculateAge(data?.patient?.date_of_birth)}
                  </p>

                  <span className="flex items-center text-sm gap-2">
                    <Phone size={16} className="text-gray-500" />
                    {data?.patient?.phone}
                  </span>
                </div>
              </div>

              <div>
                <span className="text-sm text-gray-500">Address</span>
                <p className="text-gray-600 capitalize">
                  {data?.patient?.address}
                </p>
              </div>
            </div>

            <p className="w-fit bg-blue-100 text-blue-600 py-1 rounded text-xs md:text-sm">
              Appointment Information
            </p>

            <div className="grid grid-cols-3 gap-10">
              <div>
                <span className="text-sm text-gray-500">Date</span>
                <p className="text-sm text-gray-600">
                  {format(data?.appointmentDate, "MMM dd, yyyy")}
                </p>
              </div>
              <div>
                <span className="text-sm text-gray-500">Time</span>
                <p>{data?.appointmentTime}</p>
              </div>
              <div>
                <span className="text-sm text-gray-500">Status</span>
                <AppointmentStatusIndicator status={data?.status} />
              </div>
            </div>

            {data?.note && (
              <div>
                <span className="text-sm text-gray-500">Note from Patient</span>
                <p>{data?.note}</p>
              </div>
            )}

            <p className="w-fit bg-blue-100 text-blue-600 py-1 px-2 rounded text-xs md:text-sm mt-16">
              Physician Information
            </p>
            <div className="w-full flex flex-col md:flex-row gap-8 mb-8">
              <div className="flex gap-3">
                <ProfileImage
                  url={data?.doctor?.img!}
                  name={data?.doctor?.name}
                  className="xl:size-20 bg-emerald-600"
                  textClassName="xl:text-2xl"
                />
                <div className="">
                  <h2 className="text-lg uppercase font-medium">
                    {data?.doctor?.name}
                  </h2>
                  <p className="flex items-center gap-2 text-gray-600 capitalize">
                    {data?.doctor?.specialization}
                  </p>
                </div>
              </div>
            </div>

            {((await checkRole("ADMIN")) || data?.doctor_id === userId) && (
              <>
                <p className="w-fit bg-blue-100 text-blue-600 py-1 px-2 rounded text-xs md:text-sm mt-4">
                  Perform Action
                </p>
                {/* <AppointmentAction id={data.id} status={data?.status} /> */}
              </>
            )}
          </div>
        </>
      </DialogContent>
    </Dialog>
  );
};
```

## 📄 components.json

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

## 📄 generate-readme.js

```js
const fs = require('fs');
const path = require('path');

const OUTPUT_FILE = 'README.md';
const IGNORED_FOLDERS = ['node_modules', '.next', '.git', 'public', '.vscode'];

const getLang = (filename) => {
  const ext = path.extname(filename);
  switch (ext) {
    case '.js': return 'js';
    case '.ts': return 'ts';
    case '.tsx': return 'tsx';
    case '.jsx': return 'jsx';
    case '.json': return 'json';
    case '.css': return 'css';
    case '.html': return 'html';
    case '.md': return 'md';
    default: return '';
  }
};

const isCodeFile = (filename) => {
  return /\.(js|ts|jsx|tsx|json|mjs|css|scss|md|html)$/.test(filename);
};

function walkDir(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      if (!IGNORED_FOLDERS.includes(file)) {
        walkDir(filePath, fileList);
      }
    } else if (isCodeFile(file)) {
      fileList.push(filePath);
    }
  });

  return fileList;
}

function dumpToReadme(fileList) {
  const output = fs.createWriteStream(OUTPUT_FILE);
  output.write(`# 📁 Project Source Code Dump\n\n`);

  fileList.forEach((filePath) => {
    const relativePath = path.relative(__dirname, filePath);
    const content = fs.readFileSync(filePath, 'utf-8');
    const lang = getLang(filePath);

    output.write(`## 📄 ${relativePath}\n\n`);
    output.write('```' + lang + '\n');
    output.write(content);
    output.write('\n```\n\n');
  });

  output.close();
  console.log(`✅ README.md created with all code files!`);
}

const allFiles = walkDir(__dirname);
dumpToReadme(allFiles);

```

## 📄 lib\db.ts

```ts
import { PrismaClient } from "./generated/prisma";

const globalForPrisma = globalThis as unknown as {
  prismaGlobal?: PrismaClient;
};

const prisma = globalForPrisma.prismaGlobal ?? new PrismaClient();

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prismaGlobal = prisma;
}

export default prisma;

```

## 📄 lib\generated\prisma\client.d.ts

```ts
export * from "./index"
```

## 📄 lib\generated\prisma\client.js

```js
module.exports = { ...require('.') }
```

## 📄 lib\generated\prisma\default.d.ts

```ts
export * from "./index"
```

## 📄 lib\generated\prisma\default.js

```js
module.exports = { ...require('.') }
```

## 📄 lib\generated\prisma\edge.d.ts

```ts
export * from "./default"
```

## 📄 lib\generated\prisma\edge.js

```js

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  objectEnumValues,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require('./runtime/edge.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 6.6.0
 * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
 */
Prisma.prismaVersion = {
  client: "6.6.0",
  engine: "f676762280b54cd07c770017ed3711ddde35f37a"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}





/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.PatientScalarFieldEnum = {
  id: 'id',
  first_name: 'first_name',
  last_name: 'last_name',
  date_of_birth: 'date_of_birth',
  gender: 'gender',
  phone: 'phone',
  email: 'email',
  marital_status: 'marital_status',
  address: 'address',
  emergency_contact_name: 'emergency_contact_name',
  emergency_contact_number: 'emergency_contact_number',
  relation: 'relation',
  blood_group: 'blood_group',
  allergies: 'allergies',
  medical_conditions: 'medical_conditions',
  medical_history: 'medical_history',
  insurance_provider: 'insurance_provider',
  insurance_number: 'insurance_number',
  privacy_consent: 'privacy_consent',
  service_consent: 'service_consent',
  medical_consent: 'medical_consent',
  img: 'img',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DoctorScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  specialization: 'specialization',
  license_number: 'license_number',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  availability_status: 'availability_status',
  type: 'type',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.WorkingDaysScalarFieldEnum = {
  id: 'id',
  doctor_id: 'doctor_id',
  day: 'day',
  start_time: 'start_time',
  close_time: 'close_time',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.StaffScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  license_number: 'license_number',
  role: 'role',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AppointmentScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  doctor_id: 'doctor_id',
  appointmentDate: 'appointmentDate',
  appointmentTime: 'appointmentTime',
  status: 'status',
  type: 'type',
  note: 'note',
  reason: 'reason',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PaymentScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  patient_id: 'patient_id',
  appointment_Id: 'appointment_Id',
  bill_date: 'bill_date',
  payment_Date: 'payment_Date',
  discount: 'discount',
  total_amount: 'total_amount',
  amount_paid: 'amount_paid',
  payment_method: 'payment_method',
  status: 'status',
  receipt_number: 'receipt_number',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PatientBillsScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  service_id: 'service_id',
  service_date: 'service_date',
  quantity: 'quantity',
  unit_cost: 'unit_cost',
  total_cost: 'total_cost',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.LabTestScalarFieldEnum = {
  id: 'id',
  record_id: 'record_id',
  test_date: 'test_date',
  result: 'result',
  status: 'status',
  notes: 'notes',
  service_id: 'service_id',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.MedicalRecordsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  appointment_id: 'appointment_id',
  doctor_id: 'doctor_id',
  treatment_plan: 'treatment_plan',
  prescriptions: 'prescriptions',
  lab_request: 'lab_request',
  notes: 'notes',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.VitalSignsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  body_temperature: 'body_temperature',
  systolic: 'systolic',
  diastolic: 'diastolic',
  heartRate: 'heartRate',
  respiratoryRate: 'respiratoryRate',
  oxygen_saturation: 'oxygen_saturation',
  weight: 'weight',
  height: 'height',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DiagnosisScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  diagnosis: 'diagnosis',
  doctor_id: 'doctor_id',
  symptoms: 'symptoms',
  notes: 'notes',
  prescribed_medications: 'prescribed_medications',
  follow_up_plan: 'follow_up_plan',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AuditLogScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  record_id: 'record_id',
  action: 'action',
  details: 'details',
  model: 'model',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.RatingScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  staff_id: 'staff_id',
  rating: 'rating',
  comment: 'comment',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.ServicesScalarFieldEnum = {
  id: 'id',
  service_name: 'service_name',
  description: 'description',
  price: 'price',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};
exports.Role = exports.$Enums.Role = {
  ADMIN: 'ADMIN',
  NURSE: 'NURSE',
  DOCTOR: 'DOCTOR',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  PATIENT: 'PATIENT',
  CASHIER: 'CASHIER'
};

exports.Status = exports.$Enums.Status = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DORMANT: 'DORMANT'
};

exports.JOBTYPE = exports.$Enums.JOBTYPE = {
  FULL: 'FULL',
  PART: 'PART'
};

exports.GENDER = exports.$Enums.GENDER = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

exports.AppointmentStatus = exports.$Enums.AppointmentStatus = {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

exports.PaymentMethod = exports.$Enums.PaymentMethod = {
  CASH: 'CASH',
  CARD: 'CARD',
  UPI: 'UPI'
};

exports.PaymentStatus = exports.$Enums.PaymentStatus = {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  PART: 'PART'
};

exports.Prisma.ModelName = {
  Patient: 'Patient',
  Doctor: 'Doctor',
  WorkingDays: 'WorkingDays',
  Staff: 'Staff',
  Appointment: 'Appointment',
  Payment: 'Payment',
  PatientBills: 'PatientBills',
  LabTest: 'LabTest',
  MedicalRecords: 'MedicalRecords',
  VitalSigns: 'VitalSigns',
  Diagnosis: 'Diagnosis',
  AuditLog: 'AuditLog',
  Rating: 'Rating',
  Services: 'Services'
};
/**
 * Create the Client
 */
const config = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client-js"
    },
    "output": {
      "value": "C:\\Users\\dell\\Desktop\\fuckin_dbms\\lib\\generated\\prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "windows",
        "native": true
      }
    ],
    "previewFeatures": [],
    "sourceFilePath": "C:\\Users\\dell\\Desktop\\fuckin_dbms\\prisma\\schema.prisma",
    "isCustomOutput": true
  },
  "relativeEnvPaths": {
    "rootEnvPath": null,
    "schemaEnvPath": "../../../.env"
  },
  "relativePath": "../../../prisma",
  "clientVersion": "6.6.0",
  "engineVersion": "f676762280b54cd07c770017ed3711ddde35f37a",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider = \"prisma-client-js\"\n  output   = \"../lib/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nenum Role {\n  ADMIN\n  NURSE\n  DOCTOR\n  LAB_TECHNICIAN\n  PATIENT\n  CASHIER\n}\n\nenum Status {\n  ACTIVE\n  INACTIVE\n  DORMANT\n}\n\nenum JOBTYPE {\n  FULL\n  PART\n}\n\nenum GENDER {\n  MALE\n  FEMALE\n  OTHER\n}\n\nenum AppointmentStatus {\n  PENDING\n  SCHEDULED\n  CANCELLED\n  COMPLETED\n}\n\nenum PaymentMethod {\n  CASH\n  CARD\n  UPI\n}\n\nenum PaymentStatus {\n  PAID\n  UNPAID\n  PART\n}\n\nmodel Patient {\n  id                       String   @id\n  first_name               String\n  last_name                String\n  date_of_birth            DateTime\n  gender                   GENDER   @default(MALE)\n  phone                    String\n  email                    String   @unique\n  marital_status           String\n  address                  String\n  emergency_contact_name   String\n  emergency_contact_number String\n  relation                 String\n  blood_group              String?\n  allergies                String?\n  medical_conditions       String?\n  medical_history          String?\n  insurance_provider       String?\n  insurance_number         String?\n  privacy_consent          Boolean\n  service_consent          Boolean\n  medical_consent          Boolean\n  img                      String?\n  colorCode                String?\n\n  appointments Appointment[]\n  medical      MedicalRecords[]\n  payments     Payment[]\n  ratings      Rating[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Doctor {\n  id                  String  @id\n  email               String  @unique\n  name                String\n  specialization      String\n  license_number      String\n  phone               String\n  address             String\n  department          String?\n  img                 String?\n  availability_status String?\n  type                JOBTYPE @default(FULL)\n  colorCode           String?\n\n  working_days WorkingDays[]\n  appointments Appointment[]\n  ratings      Rating[]\n  diagnosis    Diagnosis[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel WorkingDays {\n  id         Int    @id @default(autoincrement())\n  doctor_id  String\n  day        String\n  start_time String\n  close_time String\n\n  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Staff {\n  id             String  @id\n  name           String\n  email          String  @unique\n  phone          String\n  address        String\n  department     String?\n  img            String?\n  license_number String?\n\n  role   Role\n  status Status @default(ACTIVE)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Appointment {\n  id              Int               @id @default(autoincrement())\n  patient_id      String\n  doctor_id       String\n  appointmentDate DateTime\n  appointmentTime String\n  status          AppointmentStatus @default(PENDING)\n  type            String\n  note            String?\n  patient         Patient           @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  doctor          Doctor            @relation(fields: [doctor_id], references: [id])\n\n  bills   Payment[]\n  medical MedicalRecords[]\n\n  reason     String?\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Payment {\n  id             Int      @id @default(autoincrement())\n  bill_id        Int?\n  patient_id     String\n  appointment_Id Int      @unique\n  bill_date      DateTime\n  payment_Date   DateTime\n  discount       Float\n  total_amount   Float\n  amount_paid    Float\n\n  payment_method PaymentMethod @default(CASH)\n  status         PaymentStatus @default(UNPAID)\n  receipt_number Int           @default(autoincrement())\n\n  appointment Appointment    @relation(fields: [appointment_Id], references: [id], onDelete: Cascade)\n  patient     Patient        @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  bills       PatientBills[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel PatientBills {\n  id           Int      @id @default(autoincrement())\n  bill_id      Int\n  service_id   Int\n  service_date DateTime\n  quantity     Int\n  unit_cost    Float\n  total_cost   Float\n  service      Services @relation(fields: [service_id], references: [id])\n  payment      Payment  @relation(fields: [bill_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel LabTest {\n  id         Int      @id @default(autoincrement())\n  record_id  Int\n  test_date  DateTime\n  result     String\n  status     String\n  notes      String\n  service_id Int      @unique\n  services   Services @relation(fields: [service_id], references: [id])\n\n  medical_record MedicalRecords @relation(fields: [record_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel MedicalRecords {\n  id             Int     @id @default(autoincrement())\n  patient_id     String\n  appointment_id Int\n  doctor_id      String\n  treatment_plan String?\n  prescriptions  String?\n  lab_request    String?\n\n  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)\n  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  lab_test    LabTest[]\n  notes       String?\n\n  vital_signs VitalSigns[]\n  diagnosis   Diagnosis[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel VitalSigns {\n  id                Int            @id @default(autoincrement())\n  patient_id        String\n  medical_id        Int\n  medical           MedicalRecords @relation(fields: [medical_id], references: [id], onDelete: Cascade)\n  body_temperature  Float\n  systolic          Int\n  diastolic         Int\n  heartRate         String\n  respiratoryRate   Int?\n  oxygen_saturation Int?\n  weight            Float?\n  height            Float?\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Diagnosis {\n  id                     Int            @id @default(autoincrement())\n  patient_id             String\n  medical_id             Int\n  medical                MedicalRecords @relation(fields: [medical_id], references: [id])\n  diagnosis              String\n  doctor_id              String\n  doctor                 Doctor         @relation(fields: [doctor_id], references: [id], onDelete: Cascade)\n  symptoms               String\n  notes                  String?\n  prescribed_medications String?\n  follow_up_plan         String?\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel AuditLog {\n  id        Int     @id @default(autoincrement())\n  user_id   String\n  record_id String\n  action    String\n  details   String?\n  model     String\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Rating {\n  id         Int     @id @default(autoincrement())\n  patient_id String\n  staff_id   String\n  rating     Int\n  comment    String?\n\n  doctor  Doctor  @relation(fields: [staff_id], references: [id], onDelete: Cascade)\n  patient Patient @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Services {\n  id           Int            @id @default(autoincrement())\n  service_name String\n  description  String\n  price        Float\n  labtest      LabTest?\n  bills        PatientBills[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n",
  "inlineSchemaHash": "d5d257b0852a4d9033b89e8f82d0278da94847994f9f67d5c910c19f30df7d4f",
  "copyEngine": true
}
config.dirname = '/'

config.runtimeDataModel = JSON.parse("{\"models\":{\"Patient\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"first_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"last_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"date_of_birth\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"gender\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"GENDER\",\"nativeType\":null,\"default\":\"MALE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"marital_status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emergency_contact_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emergency_contact_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"relation\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"blood_group\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"allergies\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_conditions\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_history\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"insurance_provider\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"insurance_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"privacy_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"colorCode\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToPatient\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToPatient\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"PatientToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"ratings\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Rating\",\"nativeType\":null,\"relationName\":\"PatientToRating\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Doctor\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"specialization\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"license_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"department\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"availability_status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"JOBTYPE\",\"nativeType\":null,\"default\":\"FULL\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"colorCode\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"working_days\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"WorkingDays\",\"nativeType\":null,\"relationName\":\"DoctorToWorkingDays\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToDoctor\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"ratings\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Rating\",\"nativeType\":null,\"relationName\":\"DoctorToRating\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Diagnosis\",\"nativeType\":null,\"relationName\":\"DiagnosisToDoctor\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"WorkingDays\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"day\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"start_time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"close_time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DoctorToWorkingDays\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Staff\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"department\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"license_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Role\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Status\",\"nativeType\":null,\"default\":\"ACTIVE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Appointment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointmentDate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointmentTime\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"AppointmentStatus\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"note\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"AppointmentToPatient\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"AppointmentToDoctor\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"AppointmentToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"AppointmentToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"reason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Payment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment_Id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment_Date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"discount\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"total_amount\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"amount_paid\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment_method\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"PaymentMethod\",\"nativeType\":null,\"default\":\"CASH\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"PaymentStatus\",\"nativeType\":null,\"default\":\"UNPAID\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"receipt_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToPayment\",\"relationFromFields\":[\"appointment_Id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"PatientToPayment\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PatientBills\",\"nativeType\":null,\"relationName\":\"PatientBillsToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"PatientBills\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"quantity\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"unit_cost\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"total_cost\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Services\",\"nativeType\":null,\"relationName\":\"PatientBillsToServices\",\"relationFromFields\":[\"service_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"PatientBillsToPayment\",\"relationFromFields\":[\"bill_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"LabTest\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"record_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"test_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"result\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"services\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Services\",\"nativeType\":null,\"relationName\":\"LabTestToServices\",\"relationFromFields\":[\"service_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_record\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"LabTestToMedicalRecords\",\"relationFromFields\":[\"record_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"MedicalRecords\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"treatment_plan\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"prescriptions\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"lab_request\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToMedicalRecords\",\"relationFromFields\":[\"appointment_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToPatient\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"lab_test\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"LabTest\",\"nativeType\":null,\"relationName\":\"LabTestToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"vital_signs\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"VitalSigns\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToVitalSigns\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Diagnosis\",\"nativeType\":null,\"relationName\":\"DiagnosisToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"VitalSigns\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToVitalSigns\",\"relationFromFields\":[\"medical_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"body_temperature\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"systolic\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diastolic\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"heartRate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"respiratoryRate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"oxygen_saturation\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"weight\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"height\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Diagnosis\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"DiagnosisToMedicalRecords\",\"relationFromFields\":[\"medical_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DiagnosisToDoctor\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"symptoms\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"prescribed_medications\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"follow_up_plan\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"AuditLog\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"record_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"action\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"details\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"model\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Rating\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"staff_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"rating\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comment\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DoctorToRating\",\"relationFromFields\":[\"staff_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"PatientToRating\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Services\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"price\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"labtest\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"LabTest\",\"nativeType\":null,\"relationName\":\"LabTestToServices\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PatientBills\",\"nativeType\":null,\"relationName\":\"PatientBillsToServices\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"Role\":{\"values\":[{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"NURSE\",\"dbName\":null},{\"name\":\"DOCTOR\",\"dbName\":null},{\"name\":\"LAB_TECHNICIAN\",\"dbName\":null},{\"name\":\"PATIENT\",\"dbName\":null},{\"name\":\"CASHIER\",\"dbName\":null}],\"dbName\":null},\"Status\":{\"values\":[{\"name\":\"ACTIVE\",\"dbName\":null},{\"name\":\"INACTIVE\",\"dbName\":null},{\"name\":\"DORMANT\",\"dbName\":null}],\"dbName\":null},\"JOBTYPE\":{\"values\":[{\"name\":\"FULL\",\"dbName\":null},{\"name\":\"PART\",\"dbName\":null}],\"dbName\":null},\"GENDER\":{\"values\":[{\"name\":\"MALE\",\"dbName\":null},{\"name\":\"FEMALE\",\"dbName\":null},{\"name\":\"OTHER\",\"dbName\":null}],\"dbName\":null},\"AppointmentStatus\":{\"values\":[{\"name\":\"PENDING\",\"dbName\":null},{\"name\":\"SCHEDULED\",\"dbName\":null},{\"name\":\"CANCELLED\",\"dbName\":null},{\"name\":\"COMPLETED\",\"dbName\":null}],\"dbName\":null},\"PaymentMethod\":{\"values\":[{\"name\":\"CASH\",\"dbName\":null},{\"name\":\"CARD\",\"dbName\":null},{\"name\":\"UPI\",\"dbName\":null}],\"dbName\":null},\"PaymentStatus\":{\"values\":[{\"name\":\"PAID\",\"dbName\":null},{\"name\":\"UNPAID\",\"dbName\":null},{\"name\":\"PART\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}")
defineDmmfProperty(exports.Prisma, config.runtimeDataModel)
config.engineWasm = undefined
config.compilerWasm = undefined

config.injectableEdgeEnv = () => ({
  parsed: {
    DATABASE_URL: typeof globalThis !== 'undefined' && globalThis['DATABASE_URL'] || typeof process !== 'undefined' && process.env && process.env.DATABASE_URL || undefined
  }
})

if (typeof globalThis !== 'undefined' && globalThis['DEBUG'] || typeof process !== 'undefined' && process.env && process.env.DEBUG || undefined) {
  Debug.enable(typeof globalThis !== 'undefined' && globalThis['DEBUG'] || typeof process !== 'undefined' && process.env && process.env.DEBUG || undefined)
}

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient
Object.assign(exports, Prisma)


```

## 📄 lib\generated\prisma\index-browser.js

```js

Object.defineProperty(exports, "__esModule", { value: true });

const {
  Decimal,
  objectEnumValues,
  makeStrictEnum,
  Public,
  getRuntime,
  skip
} = require('./runtime/index-browser.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 6.6.0
 * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
 */
Prisma.prismaVersion = {
  client: "6.6.0",
  engine: "f676762280b54cd07c770017ed3711ddde35f37a"
}

Prisma.PrismaClientKnownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)};
Prisma.PrismaClientUnknownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientRustPanicError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientInitializationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientValidationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.empty = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`empty is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.join = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`join is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.raw = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`raw is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.defineExtension = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}



/**
 * Enums
 */

exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.PatientScalarFieldEnum = {
  id: 'id',
  first_name: 'first_name',
  last_name: 'last_name',
  date_of_birth: 'date_of_birth',
  gender: 'gender',
  phone: 'phone',
  email: 'email',
  marital_status: 'marital_status',
  address: 'address',
  emergency_contact_name: 'emergency_contact_name',
  emergency_contact_number: 'emergency_contact_number',
  relation: 'relation',
  blood_group: 'blood_group',
  allergies: 'allergies',
  medical_conditions: 'medical_conditions',
  medical_history: 'medical_history',
  insurance_provider: 'insurance_provider',
  insurance_number: 'insurance_number',
  privacy_consent: 'privacy_consent',
  service_consent: 'service_consent',
  medical_consent: 'medical_consent',
  img: 'img',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DoctorScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  specialization: 'specialization',
  license_number: 'license_number',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  availability_status: 'availability_status',
  type: 'type',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.WorkingDaysScalarFieldEnum = {
  id: 'id',
  doctor_id: 'doctor_id',
  day: 'day',
  start_time: 'start_time',
  close_time: 'close_time',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.StaffScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  license_number: 'license_number',
  role: 'role',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AppointmentScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  doctor_id: 'doctor_id',
  appointmentDate: 'appointmentDate',
  appointmentTime: 'appointmentTime',
  status: 'status',
  type: 'type',
  note: 'note',
  reason: 'reason',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PaymentScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  patient_id: 'patient_id',
  appointment_Id: 'appointment_Id',
  bill_date: 'bill_date',
  payment_Date: 'payment_Date',
  discount: 'discount',
  total_amount: 'total_amount',
  amount_paid: 'amount_paid',
  payment_method: 'payment_method',
  status: 'status',
  receipt_number: 'receipt_number',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PatientBillsScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  service_id: 'service_id',
  service_date: 'service_date',
  quantity: 'quantity',
  unit_cost: 'unit_cost',
  total_cost: 'total_cost',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.LabTestScalarFieldEnum = {
  id: 'id',
  record_id: 'record_id',
  test_date: 'test_date',
  result: 'result',
  status: 'status',
  notes: 'notes',
  service_id: 'service_id',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.MedicalRecordsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  appointment_id: 'appointment_id',
  doctor_id: 'doctor_id',
  treatment_plan: 'treatment_plan',
  prescriptions: 'prescriptions',
  lab_request: 'lab_request',
  notes: 'notes',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.VitalSignsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  body_temperature: 'body_temperature',
  systolic: 'systolic',
  diastolic: 'diastolic',
  heartRate: 'heartRate',
  respiratoryRate: 'respiratoryRate',
  oxygen_saturation: 'oxygen_saturation',
  weight: 'weight',
  height: 'height',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DiagnosisScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  diagnosis: 'diagnosis',
  doctor_id: 'doctor_id',
  symptoms: 'symptoms',
  notes: 'notes',
  prescribed_medications: 'prescribed_medications',
  follow_up_plan: 'follow_up_plan',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AuditLogScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  record_id: 'record_id',
  action: 'action',
  details: 'details',
  model: 'model',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.RatingScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  staff_id: 'staff_id',
  rating: 'rating',
  comment: 'comment',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.ServicesScalarFieldEnum = {
  id: 'id',
  service_name: 'service_name',
  description: 'description',
  price: 'price',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};
exports.GENDER = exports.$Enums.GENDER = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

exports.JOBTYPE = exports.$Enums.JOBTYPE = {
  FULL: 'FULL',
  PART: 'PART'
};

exports.Role = exports.$Enums.Role = {
  ADMIN: 'ADMIN',
  NURSE: 'NURSE',
  DOCTOR: 'DOCTOR',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  PATIENT: 'PATIENT',
  CASHIER: 'CASHIER'
};

exports.Status = exports.$Enums.Status = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DORMANT: 'DORMANT'
};

exports.AppointmentStatus = exports.$Enums.AppointmentStatus = {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

exports.PaymentMethod = exports.$Enums.PaymentMethod = {
  CASH: 'CASH',
  CARD: 'CARD',
  UPI: 'UPI'
};

exports.PaymentStatus = exports.$Enums.PaymentStatus = {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  PART: 'PART'
};

exports.Prisma.ModelName = {
  Patient: 'Patient',
  Doctor: 'Doctor',
  WorkingDays: 'WorkingDays',
  Staff: 'Staff',
  Appointment: 'Appointment',
  Payment: 'Payment',
  PatientBills: 'PatientBills',
  LabTest: 'LabTest',
  MedicalRecords: 'MedicalRecords',
  VitalSigns: 'VitalSigns',
  Diagnosis: 'Diagnosis',
  AuditLog: 'AuditLog',
  Rating: 'Rating',
  Services: 'Services'
};

/**
 * This is a stub Prisma Client that will error at runtime if called.
 */
class PrismaClient {
  constructor() {
    return new Proxy(this, {
      get(target, prop) {
        let message
        const runtime = getRuntime()
        if (runtime.isEdge) {
          message = `PrismaClient is not configured to run in ${runtime.prettyName}. In order to run Prisma Client on edge runtime, either:
- Use Prisma Accelerate: https://pris.ly/d/accelerate
- Use Driver Adapters: https://pris.ly/d/driver-adapters
`;
        } else {
          message = 'PrismaClient is unable to run in this browser environment, or has been bundled for the browser (running in `' + runtime.prettyName + '`).'
        }

        message += `
If this is unexpected, please open an issue: https://pris.ly/prisma-prisma-bug-report`

        throw new Error(message)
      }
    })
  }
}

exports.PrismaClient = PrismaClient

Object.assign(exports, Prisma)

```

## 📄 lib\generated\prisma\index.d.ts

```ts

/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model WorkingDays
 * 
 */
export type WorkingDays = $Result.DefaultSelection<Prisma.$WorkingDaysPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PatientBills
 * 
 */
export type PatientBills = $Result.DefaultSelection<Prisma.$PatientBillsPayload>
/**
 * Model LabTest
 * 
 */
export type LabTest = $Result.DefaultSelection<Prisma.$LabTestPayload>
/**
 * Model MedicalRecords
 * 
 */
export type MedicalRecords = $Result.DefaultSelection<Prisma.$MedicalRecordsPayload>
/**
 * Model VitalSigns
 * 
 */
export type VitalSigns = $Result.DefaultSelection<Prisma.$VitalSignsPayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Services
 * 
 */
export type Services = $Result.DefaultSelection<Prisma.$ServicesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  NURSE: 'NURSE',
  DOCTOR: 'DOCTOR',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  PATIENT: 'PATIENT',
  CASHIER: 'CASHIER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DORMANT: 'DORMANT'
};

export type Status = (typeof Status)[keyof typeof Status]


export const JOBTYPE: {
  FULL: 'FULL',
  PART: 'PART'
};

export type JOBTYPE = (typeof JOBTYPE)[keyof typeof JOBTYPE]


export const GENDER: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type GENDER = (typeof GENDER)[keyof typeof GENDER]


export const AppointmentStatus: {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  UPI: 'UPI'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  PART: 'PART'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type JOBTYPE = $Enums.JOBTYPE

export const JOBTYPE: typeof $Enums.JOBTYPE

export type GENDER = $Enums.GENDER

export const GENDER: typeof $Enums.GENDER

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Patients
 * const patients = await prisma.patient.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Patients
   * const patients = await prisma.patient.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workingDays`: Exposes CRUD operations for the **WorkingDays** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingDays
    * const workingDays = await prisma.workingDays.findMany()
    * ```
    */
  get workingDays(): Prisma.WorkingDaysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientBills`: Exposes CRUD operations for the **PatientBills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientBills
    * const patientBills = await prisma.patientBills.findMany()
    * ```
    */
  get patientBills(): Prisma.PatientBillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labTest`: Exposes CRUD operations for the **LabTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabTests
    * const labTests = await prisma.labTest.findMany()
    * ```
    */
  get labTest(): Prisma.LabTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalRecords`: Exposes CRUD operations for the **MedicalRecords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecords.findMany()
    * ```
    */
  get medicalRecords(): Prisma.MedicalRecordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSigns`: Exposes CRUD operations for the **VitalSigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSigns.findMany()
    * ```
    */
  get vitalSigns(): Prisma.VitalSignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **Services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.ServicesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Patient: 'Patient',
    Doctor: 'Doctor',
    WorkingDays: 'WorkingDays',
    Staff: 'Staff',
    Appointment: 'Appointment',
    Payment: 'Payment',
    PatientBills: 'PatientBills',
    LabTest: 'LabTest',
    MedicalRecords: 'MedicalRecords',
    VitalSigns: 'VitalSigns',
    Diagnosis: 'Diagnosis',
    AuditLog: 'AuditLog',
    Rating: 'Rating',
    Services: 'Services'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "patient" | "doctor" | "workingDays" | "staff" | "appointment" | "payment" | "patientBills" | "labTest" | "medicalRecords" | "vitalSigns" | "diagnosis" | "auditLog" | "rating" | "services"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      WorkingDays: {
        payload: Prisma.$WorkingDaysPayload<ExtArgs>
        fields: Prisma.WorkingDaysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkingDaysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkingDaysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          findFirst: {
            args: Prisma.WorkingDaysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkingDaysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          findMany: {
            args: Prisma.WorkingDaysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[]
          }
          create: {
            args: Prisma.WorkingDaysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          createMany: {
            args: Prisma.WorkingDaysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkingDaysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[]
          }
          delete: {
            args: Prisma.WorkingDaysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          update: {
            args: Prisma.WorkingDaysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          deleteMany: {
            args: Prisma.WorkingDaysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkingDaysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkingDaysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[]
          }
          upsert: {
            args: Prisma.WorkingDaysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingDaysPayload>
          }
          aggregate: {
            args: Prisma.WorkingDaysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingDays>
          }
          groupBy: {
            args: Prisma.WorkingDaysGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingDaysGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkingDaysCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingDaysCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PatientBills: {
        payload: Prisma.$PatientBillsPayload<ExtArgs>
        fields: Prisma.PatientBillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientBillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientBillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          findFirst: {
            args: Prisma.PatientBillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientBillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          findMany: {
            args: Prisma.PatientBillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>[]
          }
          create: {
            args: Prisma.PatientBillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          createMany: {
            args: Prisma.PatientBillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientBillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>[]
          }
          delete: {
            args: Prisma.PatientBillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          update: {
            args: Prisma.PatientBillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          deleteMany: {
            args: Prisma.PatientBillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientBillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientBillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>[]
          }
          upsert: {
            args: Prisma.PatientBillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBillsPayload>
          }
          aggregate: {
            args: Prisma.PatientBillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientBills>
          }
          groupBy: {
            args: Prisma.PatientBillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientBillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientBillsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientBillsCountAggregateOutputType> | number
          }
        }
      }
      LabTest: {
        payload: Prisma.$LabTestPayload<ExtArgs>
        fields: Prisma.LabTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findFirst: {
            args: Prisma.LabTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findMany: {
            args: Prisma.LabTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          create: {
            args: Prisma.LabTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          createMany: {
            args: Prisma.LabTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          delete: {
            args: Prisma.LabTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          update: {
            args: Prisma.LabTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          deleteMany: {
            args: Prisma.LabTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          upsert: {
            args: Prisma.LabTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          aggregate: {
            args: Prisma.LabTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabTest>
          }
          groupBy: {
            args: Prisma.LabTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabTestCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecords: {
        payload: Prisma.$MedicalRecordsPayload<ExtArgs>
        fields: Prisma.MedicalRecordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalRecordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[]
          }
          delete: {
            args: Prisma.MedicalRecordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          update: {
            args: Prisma.MedicalRecordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalRecordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[]
          }
          upsert: {
            args: Prisma.MedicalRecordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalRecords>
          }
          groupBy: {
            args: Prisma.MedicalRecordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordsCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordsCountAggregateOutputType> | number
          }
        }
      }
      VitalSigns: {
        payload: Prisma.$VitalSignsPayload<ExtArgs>
        fields: Prisma.VitalSignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findFirst: {
            args: Prisma.VitalSignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findMany: {
            args: Prisma.VitalSignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          create: {
            args: Prisma.VitalSignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          createMany: {
            args: Prisma.VitalSignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalSignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          delete: {
            args: Prisma.VitalSignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          update: {
            args: Prisma.VitalSignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalSignsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          upsert: {
            args: Prisma.VitalSignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          aggregate: {
            args: Prisma.VitalSignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSigns>
          }
          groupBy: {
            args: Prisma.VitalSignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignsCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiagnosisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Services: {
        payload: Prisma.$ServicesPayload<ExtArgs>
        fields: Prisma.ServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          findFirst: {
            args: Prisma.ServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          findMany: {
            args: Prisma.ServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          create: {
            args: Prisma.ServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          createMany: {
            args: Prisma.ServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          delete: {
            args: Prisma.ServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          update: {
            args: Prisma.ServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          deleteMany: {
            args: Prisma.ServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          upsert: {
            args: Prisma.ServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.ServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    patient?: PatientOmit
    doctor?: DoctorOmit
    workingDays?: WorkingDaysOmit
    staff?: StaffOmit
    appointment?: AppointmentOmit
    payment?: PaymentOmit
    patientBills?: PatientBillsOmit
    labTest?: LabTestOmit
    medicalRecords?: MedicalRecordsOmit
    vitalSigns?: VitalSignsOmit
    diagnosis?: DiagnosisOmit
    auditLog?: AuditLogOmit
    rating?: RatingOmit
    services?: ServicesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    medical: number
    payments: number
    ratings: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    medical?: boolean | PatientCountOutputTypeCountMedicalArgs
    payments?: boolean | PatientCountOutputTypeCountPaymentsArgs
    ratings?: boolean | PatientCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordsWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    working_days: number
    appointments: number
    ratings: number
    diagnosis: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    working_days?: boolean | DoctorCountOutputTypeCountWorking_daysArgs
    appointments?: boolean | DoctorCountOutputTypeCountAppointmentsArgs
    ratings?: boolean | DoctorCountOutputTypeCountRatingsArgs
    diagnosis?: boolean | DoctorCountOutputTypeCountDiagnosisArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountWorking_daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingDaysWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    bills: number
    medical: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | AppointmentCountOutputTypeCountBillsArgs
    medical?: boolean | AppointmentCountOutputTypeCountMedicalArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountMedicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordsWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    bills: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | PaymentCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientBillsWhereInput
  }


  /**
   * Count Type MedicalRecordsCountOutputType
   */

  export type MedicalRecordsCountOutputType = {
    lab_test: number
    vital_signs: number
    diagnosis: number
  }

  export type MedicalRecordsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab_test?: boolean | MedicalRecordsCountOutputTypeCountLab_testArgs
    vital_signs?: boolean | MedicalRecordsCountOutputTypeCountVital_signsArgs
    diagnosis?: boolean | MedicalRecordsCountOutputTypeCountDiagnosisArgs
  }

  // Custom InputTypes
  /**
   * MedicalRecordsCountOutputType without action
   */
  export type MedicalRecordsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecordsCountOutputType
     */
    select?: MedicalRecordsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalRecordsCountOutputType without action
   */
  export type MedicalRecordsCountOutputTypeCountLab_testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestWhereInput
  }

  /**
   * MedicalRecordsCountOutputType without action
   */
  export type MedicalRecordsCountOutputTypeCountVital_signsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
  }

  /**
   * MedicalRecordsCountOutputType without action
   */
  export type MedicalRecordsCountOutputTypeCountDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }


  /**
   * Count Type ServicesCountOutputType
   */

  export type ServicesCountOutputType = {
    bills: number
  }

  export type ServicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | ServicesCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientBillsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    date_of_birth: Date | null
    gender: $Enums.GENDER | null
    phone: string | null
    email: string | null
    marital_status: string | null
    address: string | null
    emergency_contact_name: string | null
    emergency_contact_number: string | null
    relation: string | null
    blood_group: string | null
    allergies: string | null
    medical_conditions: string | null
    medical_history: string | null
    insurance_provider: string | null
    insurance_number: string | null
    privacy_consent: boolean | null
    service_consent: boolean | null
    medical_consent: boolean | null
    img: string | null
    colorCode: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    date_of_birth: Date | null
    gender: $Enums.GENDER | null
    phone: string | null
    email: string | null
    marital_status: string | null
    address: string | null
    emergency_contact_name: string | null
    emergency_contact_number: string | null
    relation: string | null
    blood_group: string | null
    allergies: string | null
    medical_conditions: string | null
    medical_history: string | null
    insurance_provider: string | null
    insurance_number: string | null
    privacy_consent: boolean | null
    service_consent: boolean | null
    medical_consent: boolean | null
    img: string | null
    colorCode: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    date_of_birth: number
    gender: number
    phone: number
    email: number
    marital_status: number
    address: number
    emergency_contact_name: number
    emergency_contact_number: number
    relation: number
    blood_group: number
    allergies: number
    medical_conditions: number
    medical_history: number
    insurance_provider: number
    insurance_number: number
    privacy_consent: number
    service_consent: number
    medical_consent: number
    img: number
    colorCode: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    phone?: true
    email?: true
    marital_status?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_number?: true
    relation?: true
    blood_group?: true
    allergies?: true
    medical_conditions?: true
    medical_history?: true
    insurance_provider?: true
    insurance_number?: true
    privacy_consent?: true
    service_consent?: true
    medical_consent?: true
    img?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    phone?: true
    email?: true
    marital_status?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_number?: true
    relation?: true
    blood_group?: true
    allergies?: true
    medical_conditions?: true
    medical_history?: true
    insurance_provider?: true
    insurance_number?: true
    privacy_consent?: true
    service_consent?: true
    medical_consent?: true
    img?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    phone?: true
    email?: true
    marital_status?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_number?: true
    relation?: true
    blood_group?: true
    allergies?: true
    medical_conditions?: true
    medical_history?: true
    insurance_provider?: true
    insurance_number?: true
    privacy_consent?: true
    service_consent?: true
    medical_consent?: true
    img?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date
    gender: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group: string | null
    allergies: string | null
    medical_conditions: string | null
    medical_history: string | null
    insurance_provider: string | null
    insurance_number: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img: string | null
    colorCode: string | null
    created_at: Date
    updated_at: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    marital_status?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_number?: boolean
    relation?: boolean
    blood_group?: boolean
    allergies?: boolean
    medical_conditions?: boolean
    medical_history?: boolean
    insurance_provider?: boolean
    insurance_number?: boolean
    privacy_consent?: boolean
    service_consent?: boolean
    medical_consent?: boolean
    img?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    medical?: boolean | Patient$medicalArgs<ExtArgs>
    payments?: boolean | Patient$paymentsArgs<ExtArgs>
    ratings?: boolean | Patient$ratingsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    marital_status?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_number?: boolean
    relation?: boolean
    blood_group?: boolean
    allergies?: boolean
    medical_conditions?: boolean
    medical_history?: boolean
    insurance_provider?: boolean
    insurance_number?: boolean
    privacy_consent?: boolean
    service_consent?: boolean
    medical_consent?: boolean
    img?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    marital_status?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_number?: boolean
    relation?: boolean
    blood_group?: boolean
    allergies?: boolean
    medical_conditions?: boolean
    medical_history?: boolean
    insurance_provider?: boolean
    insurance_number?: boolean
    privacy_consent?: boolean
    service_consent?: boolean
    medical_consent?: boolean
    img?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    phone?: boolean
    email?: boolean
    marital_status?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_number?: boolean
    relation?: boolean
    blood_group?: boolean
    allergies?: boolean
    medical_conditions?: boolean
    medical_history?: boolean
    insurance_provider?: boolean
    insurance_number?: boolean
    privacy_consent?: boolean
    service_consent?: boolean
    medical_consent?: boolean
    img?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "date_of_birth" | "gender" | "phone" | "email" | "marital_status" | "address" | "emergency_contact_name" | "emergency_contact_number" | "relation" | "blood_group" | "allergies" | "medical_conditions" | "medical_history" | "insurance_provider" | "insurance_number" | "privacy_consent" | "service_consent" | "medical_consent" | "img" | "colorCode" | "created_at" | "updated_at", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    medical?: boolean | Patient$medicalArgs<ExtArgs>
    payments?: boolean | Patient$paymentsArgs<ExtArgs>
    ratings?: boolean | Patient$ratingsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      medical: Prisma.$MedicalRecordsPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string
      last_name: string
      date_of_birth: Date
      gender: $Enums.GENDER
      phone: string
      email: string
      marital_status: string
      address: string
      emergency_contact_name: string
      emergency_contact_number: string
      relation: string
      blood_group: string | null
      allergies: string | null
      medical_conditions: string | null
      medical_history: string | null
      insurance_provider: string | null
      insurance_number: string | null
      privacy_consent: boolean
      service_consent: boolean
      medical_consent: boolean
      img: string | null
      colorCode: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medical<T extends Patient$medicalArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Patient$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Patient$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly first_name: FieldRef<"Patient", 'String'>
    readonly last_name: FieldRef<"Patient", 'String'>
    readonly date_of_birth: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'GENDER'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly marital_status: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly emergency_contact_name: FieldRef<"Patient", 'String'>
    readonly emergency_contact_number: FieldRef<"Patient", 'String'>
    readonly relation: FieldRef<"Patient", 'String'>
    readonly blood_group: FieldRef<"Patient", 'String'>
    readonly allergies: FieldRef<"Patient", 'String'>
    readonly medical_conditions: FieldRef<"Patient", 'String'>
    readonly medical_history: FieldRef<"Patient", 'String'>
    readonly insurance_provider: FieldRef<"Patient", 'String'>
    readonly insurance_number: FieldRef<"Patient", 'String'>
    readonly privacy_consent: FieldRef<"Patient", 'Boolean'>
    readonly service_consent: FieldRef<"Patient", 'Boolean'>
    readonly medical_consent: FieldRef<"Patient", 'Boolean'>
    readonly img: FieldRef<"Patient", 'String'>
    readonly colorCode: FieldRef<"Patient", 'String'>
    readonly created_at: FieldRef<"Patient", 'DateTime'>
    readonly updated_at: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.medical
   */
  export type Patient$medicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    where?: MedicalRecordsWhereInput
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    cursor?: MedicalRecordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordsScalarFieldEnum | MedicalRecordsScalarFieldEnum[]
  }

  /**
   * Patient.payments
   */
  export type Patient$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Patient.ratings
   */
  export type Patient$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    specialization: string | null
    license_number: string | null
    phone: string | null
    address: string | null
    department: string | null
    img: string | null
    availability_status: string | null
    type: $Enums.JOBTYPE | null
    colorCode: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    specialization: string | null
    license_number: string | null
    phone: string | null
    address: string | null
    department: string | null
    img: string | null
    availability_status: string | null
    type: $Enums.JOBTYPE | null
    colorCode: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    email: number
    name: number
    specialization: number
    license_number: number
    phone: number
    address: number
    department: number
    img: number
    availability_status: number
    type: number
    colorCode: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DoctorMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    specialization?: true
    license_number?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    availability_status?: true
    type?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    specialization?: true
    license_number?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    availability_status?: true
    type?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    specialization?: true
    license_number?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    availability_status?: true
    type?: true
    colorCode?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department: string | null
    img: string | null
    availability_status: string | null
    type: $Enums.JOBTYPE
    colorCode: string | null
    created_at: Date
    updated_at: Date
    _count: DoctorCountAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    specialization?: boolean
    license_number?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    availability_status?: boolean
    type?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
    working_days?: boolean | Doctor$working_daysArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    ratings?: boolean | Doctor$ratingsArgs<ExtArgs>
    diagnosis?: boolean | Doctor$diagnosisArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    specialization?: boolean
    license_number?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    availability_status?: boolean
    type?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    specialization?: boolean
    license_number?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    availability_status?: boolean
    type?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    specialization?: boolean
    license_number?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    availability_status?: boolean
    type?: boolean
    colorCode?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DoctorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "specialization" | "license_number" | "phone" | "address" | "department" | "img" | "availability_status" | "type" | "colorCode" | "created_at" | "updated_at", ExtArgs["result"]["doctor"]>
  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    working_days?: boolean | Doctor$working_daysArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    ratings?: boolean | Doctor$ratingsArgs<ExtArgs>
    diagnosis?: boolean | Doctor$diagnosisArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DoctorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      working_days: Prisma.$WorkingDaysPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      specialization: string
      license_number: string
      phone: string
      address: string
      department: string | null
      img: string | null
      availability_status: string | null
      type: $Enums.JOBTYPE
      colorCode: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    working_days<T extends Doctor$working_daysArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$working_daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Doctor$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Doctor$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnosis<T extends Doctor$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$diagnosisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'String'>
    readonly email: FieldRef<"Doctor", 'String'>
    readonly name: FieldRef<"Doctor", 'String'>
    readonly specialization: FieldRef<"Doctor", 'String'>
    readonly license_number: FieldRef<"Doctor", 'String'>
    readonly phone: FieldRef<"Doctor", 'String'>
    readonly address: FieldRef<"Doctor", 'String'>
    readonly department: FieldRef<"Doctor", 'String'>
    readonly img: FieldRef<"Doctor", 'String'>
    readonly availability_status: FieldRef<"Doctor", 'String'>
    readonly type: FieldRef<"Doctor", 'JOBTYPE'>
    readonly colorCode: FieldRef<"Doctor", 'String'>
    readonly created_at: FieldRef<"Doctor", 'DateTime'>
    readonly updated_at: FieldRef<"Doctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor updateManyAndReturn
   */
  export type DoctorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to update.
     */
    limit?: number
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number
  }

  /**
   * Doctor.working_days
   */
  export type Doctor$working_daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    where?: WorkingDaysWhereInput
    orderBy?: WorkingDaysOrderByWithRelationInput | WorkingDaysOrderByWithRelationInput[]
    cursor?: WorkingDaysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkingDaysScalarFieldEnum | WorkingDaysScalarFieldEnum[]
  }

  /**
   * Doctor.appointments
   */
  export type Doctor$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Doctor.ratings
   */
  export type Doctor$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Doctor.diagnosis
   */
  export type Doctor$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model WorkingDays
   */

  export type AggregateWorkingDays = {
    _count: WorkingDaysCountAggregateOutputType | null
    _avg: WorkingDaysAvgAggregateOutputType | null
    _sum: WorkingDaysSumAggregateOutputType | null
    _min: WorkingDaysMinAggregateOutputType | null
    _max: WorkingDaysMaxAggregateOutputType | null
  }

  export type WorkingDaysAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkingDaysSumAggregateOutputType = {
    id: number | null
  }

  export type WorkingDaysMinAggregateOutputType = {
    id: number | null
    doctor_id: string | null
    day: string | null
    start_time: string | null
    close_time: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkingDaysMaxAggregateOutputType = {
    id: number | null
    doctor_id: string | null
    day: string | null
    start_time: string | null
    close_time: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkingDaysCountAggregateOutputType = {
    id: number
    doctor_id: number
    day: number
    start_time: number
    close_time: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WorkingDaysAvgAggregateInputType = {
    id?: true
  }

  export type WorkingDaysSumAggregateInputType = {
    id?: true
  }

  export type WorkingDaysMinAggregateInputType = {
    id?: true
    doctor_id?: true
    day?: true
    start_time?: true
    close_time?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkingDaysMaxAggregateInputType = {
    id?: true
    doctor_id?: true
    day?: true
    start_time?: true
    close_time?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkingDaysCountAggregateInputType = {
    id?: true
    doctor_id?: true
    day?: true
    start_time?: true
    close_time?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WorkingDaysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingDays to aggregate.
     */
    where?: WorkingDaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDaysOrderByWithRelationInput | WorkingDaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkingDaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingDays
    **/
    _count?: true | WorkingDaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkingDaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkingDaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingDaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingDaysMaxAggregateInputType
  }

  export type GetWorkingDaysAggregateType<T extends WorkingDaysAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingDays]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingDays[P]>
      : GetScalarType<T[P], AggregateWorkingDays[P]>
  }




  export type WorkingDaysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingDaysWhereInput
    orderBy?: WorkingDaysOrderByWithAggregationInput | WorkingDaysOrderByWithAggregationInput[]
    by: WorkingDaysScalarFieldEnum[] | WorkingDaysScalarFieldEnum
    having?: WorkingDaysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingDaysCountAggregateInputType | true
    _avg?: WorkingDaysAvgAggregateInputType
    _sum?: WorkingDaysSumAggregateInputType
    _min?: WorkingDaysMinAggregateInputType
    _max?: WorkingDaysMaxAggregateInputType
  }

  export type WorkingDaysGroupByOutputType = {
    id: number
    doctor_id: string
    day: string
    start_time: string
    close_time: string
    created_at: Date
    updated_at: Date
    _count: WorkingDaysCountAggregateOutputType | null
    _avg: WorkingDaysAvgAggregateOutputType | null
    _sum: WorkingDaysSumAggregateOutputType | null
    _min: WorkingDaysMinAggregateOutputType | null
    _max: WorkingDaysMaxAggregateOutputType | null
  }

  type GetWorkingDaysGroupByPayload<T extends WorkingDaysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingDaysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingDaysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingDaysGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingDaysGroupByOutputType[P]>
        }
      >
    >


  export type WorkingDaysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctor_id?: boolean
    day?: boolean
    start_time?: boolean
    close_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDays"]>

  export type WorkingDaysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctor_id?: boolean
    day?: boolean
    start_time?: boolean
    close_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDays"]>

  export type WorkingDaysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctor_id?: boolean
    day?: boolean
    start_time?: boolean
    close_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingDays"]>

  export type WorkingDaysSelectScalar = {
    id?: boolean
    doctor_id?: boolean
    day?: boolean
    start_time?: boolean
    close_time?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WorkingDaysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doctor_id" | "day" | "start_time" | "close_time" | "created_at" | "updated_at", ExtArgs["result"]["workingDays"]>
  export type WorkingDaysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type WorkingDaysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type WorkingDaysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $WorkingDaysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkingDays"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctor_id: string
      day: string
      start_time: string
      close_time: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["workingDays"]>
    composites: {}
  }

  type WorkingDaysGetPayload<S extends boolean | null | undefined | WorkingDaysDefaultArgs> = $Result.GetResult<Prisma.$WorkingDaysPayload, S>

  type WorkingDaysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkingDaysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkingDaysCountAggregateInputType | true
    }

  export interface WorkingDaysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkingDays'], meta: { name: 'WorkingDays' } }
    /**
     * Find zero or one WorkingDays that matches the filter.
     * @param {WorkingDaysFindUniqueArgs} args - Arguments to find a WorkingDays
     * @example
     * // Get one WorkingDays
     * const workingDays = await prisma.workingDays.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkingDaysFindUniqueArgs>(args: SelectSubset<T, WorkingDaysFindUniqueArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkingDays that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkingDaysFindUniqueOrThrowArgs} args - Arguments to find a WorkingDays
     * @example
     * // Get one WorkingDays
     * const workingDays = await prisma.workingDays.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkingDaysFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkingDaysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysFindFirstArgs} args - Arguments to find a WorkingDays
     * @example
     * // Get one WorkingDays
     * const workingDays = await prisma.workingDays.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkingDaysFindFirstArgs>(args?: SelectSubset<T, WorkingDaysFindFirstArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingDays that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysFindFirstOrThrowArgs} args - Arguments to find a WorkingDays
     * @example
     * // Get one WorkingDays
     * const workingDays = await prisma.workingDays.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkingDaysFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkingDaysFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkingDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingDays
     * const workingDays = await prisma.workingDays.findMany()
     * 
     * // Get first 10 WorkingDays
     * const workingDays = await prisma.workingDays.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingDaysWithIdOnly = await prisma.workingDays.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkingDaysFindManyArgs>(args?: SelectSubset<T, WorkingDaysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkingDays.
     * @param {WorkingDaysCreateArgs} args - Arguments to create a WorkingDays.
     * @example
     * // Create one WorkingDays
     * const WorkingDays = await prisma.workingDays.create({
     *   data: {
     *     // ... data to create a WorkingDays
     *   }
     * })
     * 
     */
    create<T extends WorkingDaysCreateArgs>(args: SelectSubset<T, WorkingDaysCreateArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkingDays.
     * @param {WorkingDaysCreateManyArgs} args - Arguments to create many WorkingDays.
     * @example
     * // Create many WorkingDays
     * const workingDays = await prisma.workingDays.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkingDaysCreateManyArgs>(args?: SelectSubset<T, WorkingDaysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkingDays and returns the data saved in the database.
     * @param {WorkingDaysCreateManyAndReturnArgs} args - Arguments to create many WorkingDays.
     * @example
     * // Create many WorkingDays
     * const workingDays = await prisma.workingDays.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkingDays and only return the `id`
     * const workingDaysWithIdOnly = await prisma.workingDays.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkingDaysCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkingDaysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkingDays.
     * @param {WorkingDaysDeleteArgs} args - Arguments to delete one WorkingDays.
     * @example
     * // Delete one WorkingDays
     * const WorkingDays = await prisma.workingDays.delete({
     *   where: {
     *     // ... filter to delete one WorkingDays
     *   }
     * })
     * 
     */
    delete<T extends WorkingDaysDeleteArgs>(args: SelectSubset<T, WorkingDaysDeleteArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkingDays.
     * @param {WorkingDaysUpdateArgs} args - Arguments to update one WorkingDays.
     * @example
     * // Update one WorkingDays
     * const workingDays = await prisma.workingDays.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkingDaysUpdateArgs>(args: SelectSubset<T, WorkingDaysUpdateArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkingDays.
     * @param {WorkingDaysDeleteManyArgs} args - Arguments to filter WorkingDays to delete.
     * @example
     * // Delete a few WorkingDays
     * const { count } = await prisma.workingDays.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkingDaysDeleteManyArgs>(args?: SelectSubset<T, WorkingDaysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingDays
     * const workingDays = await prisma.workingDays.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkingDaysUpdateManyArgs>(args: SelectSubset<T, WorkingDaysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingDays and returns the data updated in the database.
     * @param {WorkingDaysUpdateManyAndReturnArgs} args - Arguments to update many WorkingDays.
     * @example
     * // Update many WorkingDays
     * const workingDays = await prisma.workingDays.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkingDays and only return the `id`
     * const workingDaysWithIdOnly = await prisma.workingDays.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkingDaysUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkingDaysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkingDays.
     * @param {WorkingDaysUpsertArgs} args - Arguments to update or create a WorkingDays.
     * @example
     * // Update or create a WorkingDays
     * const workingDays = await prisma.workingDays.upsert({
     *   create: {
     *     // ... data to create a WorkingDays
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingDays we want to update
     *   }
     * })
     */
    upsert<T extends WorkingDaysUpsertArgs>(args: SelectSubset<T, WorkingDaysUpsertArgs<ExtArgs>>): Prisma__WorkingDaysClient<$Result.GetResult<Prisma.$WorkingDaysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysCountArgs} args - Arguments to filter WorkingDays to count.
     * @example
     * // Count the number of WorkingDays
     * const count = await prisma.workingDays.count({
     *   where: {
     *     // ... the filter for the WorkingDays we want to count
     *   }
     * })
    **/
    count<T extends WorkingDaysCountArgs>(
      args?: Subset<T, WorkingDaysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingDaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingDaysAggregateArgs>(args: Subset<T, WorkingDaysAggregateArgs>): Prisma.PrismaPromise<GetWorkingDaysAggregateType<T>>

    /**
     * Group by WorkingDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingDaysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingDaysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingDaysGroupByArgs['orderBy'] }
        : { orderBy?: WorkingDaysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingDaysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingDaysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkingDays model
   */
  readonly fields: WorkingDaysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingDays.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkingDaysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkingDays model
   */
  interface WorkingDaysFieldRefs {
    readonly id: FieldRef<"WorkingDays", 'Int'>
    readonly doctor_id: FieldRef<"WorkingDays", 'String'>
    readonly day: FieldRef<"WorkingDays", 'String'>
    readonly start_time: FieldRef<"WorkingDays", 'String'>
    readonly close_time: FieldRef<"WorkingDays", 'String'>
    readonly created_at: FieldRef<"WorkingDays", 'DateTime'>
    readonly updated_at: FieldRef<"WorkingDays", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkingDays findUnique
   */
  export type WorkingDaysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where: WorkingDaysWhereUniqueInput
  }

  /**
   * WorkingDays findUniqueOrThrow
   */
  export type WorkingDaysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where: WorkingDaysWhereUniqueInput
  }

  /**
   * WorkingDays findFirst
   */
  export type WorkingDaysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where?: WorkingDaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDaysOrderByWithRelationInput | WorkingDaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingDays.
     */
    cursor?: WorkingDaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingDays.
     */
    distinct?: WorkingDaysScalarFieldEnum | WorkingDaysScalarFieldEnum[]
  }

  /**
   * WorkingDays findFirstOrThrow
   */
  export type WorkingDaysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where?: WorkingDaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDaysOrderByWithRelationInput | WorkingDaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingDays.
     */
    cursor?: WorkingDaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingDays.
     */
    distinct?: WorkingDaysScalarFieldEnum | WorkingDaysScalarFieldEnum[]
  }

  /**
   * WorkingDays findMany
   */
  export type WorkingDaysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter, which WorkingDays to fetch.
     */
    where?: WorkingDaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingDays to fetch.
     */
    orderBy?: WorkingDaysOrderByWithRelationInput | WorkingDaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingDays.
     */
    cursor?: WorkingDaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingDays.
     */
    skip?: number
    distinct?: WorkingDaysScalarFieldEnum | WorkingDaysScalarFieldEnum[]
  }

  /**
   * WorkingDays create
   */
  export type WorkingDaysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkingDays.
     */
    data: XOR<WorkingDaysCreateInput, WorkingDaysUncheckedCreateInput>
  }

  /**
   * WorkingDays createMany
   */
  export type WorkingDaysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkingDays.
     */
    data: WorkingDaysCreateManyInput | WorkingDaysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingDays createManyAndReturn
   */
  export type WorkingDaysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * The data used to create many WorkingDays.
     */
    data: WorkingDaysCreateManyInput | WorkingDaysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingDays update
   */
  export type WorkingDaysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkingDays.
     */
    data: XOR<WorkingDaysUpdateInput, WorkingDaysUncheckedUpdateInput>
    /**
     * Choose, which WorkingDays to update.
     */
    where: WorkingDaysWhereUniqueInput
  }

  /**
   * WorkingDays updateMany
   */
  export type WorkingDaysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkingDays.
     */
    data: XOR<WorkingDaysUpdateManyMutationInput, WorkingDaysUncheckedUpdateManyInput>
    /**
     * Filter which WorkingDays to update
     */
    where?: WorkingDaysWhereInput
    /**
     * Limit how many WorkingDays to update.
     */
    limit?: number
  }

  /**
   * WorkingDays updateManyAndReturn
   */
  export type WorkingDaysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * The data used to update WorkingDays.
     */
    data: XOR<WorkingDaysUpdateManyMutationInput, WorkingDaysUncheckedUpdateManyInput>
    /**
     * Filter which WorkingDays to update
     */
    where?: WorkingDaysWhereInput
    /**
     * Limit how many WorkingDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingDays upsert
   */
  export type WorkingDaysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkingDays to update in case it exists.
     */
    where: WorkingDaysWhereUniqueInput
    /**
     * In case the WorkingDays found by the `where` argument doesn't exist, create a new WorkingDays with this data.
     */
    create: XOR<WorkingDaysCreateInput, WorkingDaysUncheckedCreateInput>
    /**
     * In case the WorkingDays was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkingDaysUpdateInput, WorkingDaysUncheckedUpdateInput>
  }

  /**
   * WorkingDays delete
   */
  export type WorkingDaysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
    /**
     * Filter which WorkingDays to delete.
     */
    where: WorkingDaysWhereUniqueInput
  }

  /**
   * WorkingDays deleteMany
   */
  export type WorkingDaysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingDays to delete
     */
    where?: WorkingDaysWhereInput
    /**
     * Limit how many WorkingDays to delete.
     */
    limit?: number
  }

  /**
   * WorkingDays without action
   */
  export type WorkingDaysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingDays
     */
    select?: WorkingDaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingDays
     */
    omit?: WorkingDaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingDaysInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    department: string | null
    img: string | null
    license_number: string | null
    role: $Enums.Role | null
    status: $Enums.Status | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    department: string | null
    img: string | null
    license_number: string | null
    role: $Enums.Role | null
    status: $Enums.Status | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    department: number
    img: number
    license_number: number
    role: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    license_number?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    license_number?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    department?: true
    img?: true
    license_number?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    address: string
    department: string | null
    img: string | null
    license_number: string | null
    role: $Enums.Role
    status: $Enums.Status
    created_at: Date
    updated_at: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    license_number?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    license_number?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    license_number?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    department?: boolean
    img?: boolean
    license_number?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "department" | "img" | "license_number" | "role" | "status" | "created_at" | "updated_at", ExtArgs["result"]["staff"]>

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      address: string
      department: string | null
      img: string | null
      license_number: string | null
      role: $Enums.Role
      status: $Enums.Status
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly phone: FieldRef<"Staff", 'String'>
    readonly address: FieldRef<"Staff", 'String'>
    readonly department: FieldRef<"Staff", 'String'>
    readonly img: FieldRef<"Staff", 'String'>
    readonly license_number: FieldRef<"Staff", 'String'>
    readonly role: FieldRef<"Staff", 'Role'>
    readonly status: FieldRef<"Staff", 'Status'>
    readonly created_at: FieldRef<"Staff", 'DateTime'>
    readonly updated_at: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    patient_id: string | null
    doctor_id: string | null
    appointmentDate: Date | null
    appointmentTime: string | null
    status: $Enums.AppointmentStatus | null
    type: string | null
    note: string | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    patient_id: string | null
    doctor_id: string | null
    appointmentDate: Date | null
    appointmentTime: string | null
    status: $Enums.AppointmentStatus | null
    type: string | null
    note: string | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patient_id: number
    doctor_id: number
    appointmentDate: number
    appointmentTime: number
    status: number
    type: number
    note: number
    reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patient_id?: true
    doctor_id?: true
    appointmentDate?: true
    appointmentTime?: true
    status?: true
    type?: true
    note?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patient_id?: true
    doctor_id?: true
    appointmentDate?: true
    appointmentTime?: true
    status?: true
    type?: true
    note?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patient_id?: true
    doctor_id?: true
    appointmentDate?: true
    appointmentTime?: true
    status?: true
    type?: true
    note?: true
    reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    patient_id: string
    doctor_id: string
    appointmentDate: Date
    appointmentTime: string
    status: $Enums.AppointmentStatus
    type: string
    note: string | null
    reason: string | null
    created_at: Date
    updated_at: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    status?: boolean
    type?: boolean
    note?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    bills?: boolean | Appointment$billsArgs<ExtArgs>
    medical?: boolean | Appointment$medicalArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    status?: boolean
    type?: boolean
    note?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    status?: boolean
    type?: boolean
    note?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    status?: boolean
    type?: boolean
    note?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "doctor_id" | "appointmentDate" | "appointmentTime" | "status" | "type" | "note" | "reason" | "created_at" | "updated_at", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    bills?: boolean | Appointment$billsArgs<ExtArgs>
    medical?: boolean | Appointment$medicalArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
      bills: Prisma.$PaymentPayload<ExtArgs>[]
      medical: Prisma.$MedicalRecordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patient_id: string
      doctor_id: string
      appointmentDate: Date
      appointmentTime: string
      status: $Enums.AppointmentStatus
      type: string
      note: string | null
      reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bills<T extends Appointment$billsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medical<T extends Appointment$medicalArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$medicalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly patient_id: FieldRef<"Appointment", 'String'>
    readonly doctor_id: FieldRef<"Appointment", 'String'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly appointmentTime: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly type: FieldRef<"Appointment", 'String'>
    readonly note: FieldRef<"Appointment", 'String'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly created_at: FieldRef<"Appointment", 'DateTime'>
    readonly updated_at: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.bills
   */
  export type Appointment$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Appointment.medical
   */
  export type Appointment$medicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    where?: MedicalRecordsWhereInput
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    cursor?: MedicalRecordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordsScalarFieldEnum | MedicalRecordsScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bill_id: number | null
    appointment_Id: number | null
    discount: number | null
    total_amount: number | null
    amount_paid: number | null
    receipt_number: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bill_id: number | null
    appointment_Id: number | null
    discount: number | null
    total_amount: number | null
    amount_paid: number | null
    receipt_number: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bill_id: number | null
    patient_id: string | null
    appointment_Id: number | null
    bill_date: Date | null
    payment_Date: Date | null
    discount: number | null
    total_amount: number | null
    amount_paid: number | null
    payment_method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    receipt_number: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bill_id: number | null
    patient_id: string | null
    appointment_Id: number | null
    bill_date: Date | null
    payment_Date: Date | null
    discount: number | null
    total_amount: number | null
    amount_paid: number | null
    payment_method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    receipt_number: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bill_id: number
    patient_id: number
    appointment_Id: number
    bill_date: number
    payment_Date: number
    discount: number
    total_amount: number
    amount_paid: number
    payment_method: number
    status: number
    receipt_number: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bill_id?: true
    appointment_Id?: true
    discount?: true
    total_amount?: true
    amount_paid?: true
    receipt_number?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bill_id?: true
    appointment_Id?: true
    discount?: true
    total_amount?: true
    amount_paid?: true
    receipt_number?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bill_id?: true
    patient_id?: true
    appointment_Id?: true
    bill_date?: true
    payment_Date?: true
    discount?: true
    total_amount?: true
    amount_paid?: true
    payment_method?: true
    status?: true
    receipt_number?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bill_id?: true
    patient_id?: true
    appointment_Id?: true
    bill_date?: true
    payment_Date?: true
    discount?: true
    total_amount?: true
    amount_paid?: true
    payment_method?: true
    status?: true
    receipt_number?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bill_id?: true
    patient_id?: true
    appointment_Id?: true
    bill_date?: true
    payment_Date?: true
    discount?: true
    total_amount?: true
    amount_paid?: true
    payment_method?: true
    status?: true
    receipt_number?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bill_id: number | null
    patient_id: string
    appointment_Id: number
    bill_date: Date
    payment_Date: Date
    discount: number
    total_amount: number
    amount_paid: number
    payment_method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    receipt_number: number
    created_at: Date
    updated_at: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    patient_id?: boolean
    appointment_Id?: boolean
    bill_date?: boolean
    payment_Date?: boolean
    discount?: boolean
    total_amount?: boolean
    amount_paid?: boolean
    payment_method?: boolean
    status?: boolean
    receipt_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bills?: boolean | Payment$billsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    patient_id?: boolean
    appointment_Id?: boolean
    bill_date?: boolean
    payment_Date?: boolean
    discount?: boolean
    total_amount?: boolean
    amount_paid?: boolean
    payment_method?: boolean
    status?: boolean
    receipt_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    patient_id?: boolean
    appointment_Id?: boolean
    bill_date?: boolean
    payment_Date?: boolean
    discount?: boolean
    total_amount?: boolean
    amount_paid?: boolean
    payment_method?: boolean
    status?: boolean
    receipt_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bill_id?: boolean
    patient_id?: boolean
    appointment_Id?: boolean
    bill_date?: boolean
    payment_Date?: boolean
    discount?: boolean
    total_amount?: boolean
    amount_paid?: boolean
    payment_method?: boolean
    status?: boolean
    receipt_number?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bill_id" | "patient_id" | "appointment_Id" | "bill_date" | "payment_Date" | "discount" | "total_amount" | "amount_paid" | "payment_method" | "status" | "receipt_number" | "created_at" | "updated_at", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bills?: boolean | Payment$billsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      bills: Prisma.$PatientBillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bill_id: number | null
      patient_id: string
      appointment_Id: number
      bill_date: Date
      payment_Date: Date
      discount: number
      total_amount: number
      amount_paid: number
      payment_method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      receipt_number: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bills<T extends Payment$billsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bill_id: FieldRef<"Payment", 'Int'>
    readonly patient_id: FieldRef<"Payment", 'String'>
    readonly appointment_Id: FieldRef<"Payment", 'Int'>
    readonly bill_date: FieldRef<"Payment", 'DateTime'>
    readonly payment_Date: FieldRef<"Payment", 'DateTime'>
    readonly discount: FieldRef<"Payment", 'Float'>
    readonly total_amount: FieldRef<"Payment", 'Float'>
    readonly amount_paid: FieldRef<"Payment", 'Float'>
    readonly payment_method: FieldRef<"Payment", 'PaymentMethod'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly receipt_number: FieldRef<"Payment", 'Int'>
    readonly created_at: FieldRef<"Payment", 'DateTime'>
    readonly updated_at: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.bills
   */
  export type Payment$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    where?: PatientBillsWhereInput
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    cursor?: PatientBillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientBillsScalarFieldEnum | PatientBillsScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PatientBills
   */

  export type AggregatePatientBills = {
    _count: PatientBillsCountAggregateOutputType | null
    _avg: PatientBillsAvgAggregateOutputType | null
    _sum: PatientBillsSumAggregateOutputType | null
    _min: PatientBillsMinAggregateOutputType | null
    _max: PatientBillsMaxAggregateOutputType | null
  }

  export type PatientBillsAvgAggregateOutputType = {
    id: number | null
    bill_id: number | null
    service_id: number | null
    quantity: number | null
    unit_cost: number | null
    total_cost: number | null
  }

  export type PatientBillsSumAggregateOutputType = {
    id: number | null
    bill_id: number | null
    service_id: number | null
    quantity: number | null
    unit_cost: number | null
    total_cost: number | null
  }

  export type PatientBillsMinAggregateOutputType = {
    id: number | null
    bill_id: number | null
    service_id: number | null
    service_date: Date | null
    quantity: number | null
    unit_cost: number | null
    total_cost: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PatientBillsMaxAggregateOutputType = {
    id: number | null
    bill_id: number | null
    service_id: number | null
    service_date: Date | null
    quantity: number | null
    unit_cost: number | null
    total_cost: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PatientBillsCountAggregateOutputType = {
    id: number
    bill_id: number
    service_id: number
    service_date: number
    quantity: number
    unit_cost: number
    total_cost: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PatientBillsAvgAggregateInputType = {
    id?: true
    bill_id?: true
    service_id?: true
    quantity?: true
    unit_cost?: true
    total_cost?: true
  }

  export type PatientBillsSumAggregateInputType = {
    id?: true
    bill_id?: true
    service_id?: true
    quantity?: true
    unit_cost?: true
    total_cost?: true
  }

  export type PatientBillsMinAggregateInputType = {
    id?: true
    bill_id?: true
    service_id?: true
    service_date?: true
    quantity?: true
    unit_cost?: true
    total_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type PatientBillsMaxAggregateInputType = {
    id?: true
    bill_id?: true
    service_id?: true
    service_date?: true
    quantity?: true
    unit_cost?: true
    total_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type PatientBillsCountAggregateInputType = {
    id?: true
    bill_id?: true
    service_id?: true
    service_date?: true
    quantity?: true
    unit_cost?: true
    total_cost?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PatientBillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBills to aggregate.
     */
    where?: PatientBillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBills to fetch.
     */
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientBillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientBills
    **/
    _count?: true | PatientBillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientBillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientBillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientBillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientBillsMaxAggregateInputType
  }

  export type GetPatientBillsAggregateType<T extends PatientBillsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientBills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientBills[P]>
      : GetScalarType<T[P], AggregatePatientBills[P]>
  }




  export type PatientBillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientBillsWhereInput
    orderBy?: PatientBillsOrderByWithAggregationInput | PatientBillsOrderByWithAggregationInput[]
    by: PatientBillsScalarFieldEnum[] | PatientBillsScalarFieldEnum
    having?: PatientBillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientBillsCountAggregateInputType | true
    _avg?: PatientBillsAvgAggregateInputType
    _sum?: PatientBillsSumAggregateInputType
    _min?: PatientBillsMinAggregateInputType
    _max?: PatientBillsMaxAggregateInputType
  }

  export type PatientBillsGroupByOutputType = {
    id: number
    bill_id: number
    service_id: number
    service_date: Date
    quantity: number
    unit_cost: number
    total_cost: number
    created_at: Date
    updated_at: Date
    _count: PatientBillsCountAggregateOutputType | null
    _avg: PatientBillsAvgAggregateOutputType | null
    _sum: PatientBillsSumAggregateOutputType | null
    _min: PatientBillsMinAggregateOutputType | null
    _max: PatientBillsMaxAggregateOutputType | null
  }

  type GetPatientBillsGroupByPayload<T extends PatientBillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientBillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientBillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientBillsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientBillsGroupByOutputType[P]>
        }
      >
    >


  export type PatientBillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    service_id?: boolean
    service_date?: boolean
    quantity?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBills"]>

  export type PatientBillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    service_id?: boolean
    service_date?: boolean
    quantity?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBills"]>

  export type PatientBillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    service_id?: boolean
    service_date?: boolean
    quantity?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBills"]>

  export type PatientBillsSelectScalar = {
    id?: boolean
    bill_id?: boolean
    service_id?: boolean
    service_date?: boolean
    quantity?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PatientBillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bill_id" | "service_id" | "service_date" | "quantity" | "unit_cost" | "total_cost" | "created_at" | "updated_at", ExtArgs["result"]["patientBills"]>
  export type PatientBillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type PatientBillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type PatientBillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServicesDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $PatientBillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientBills"
    objects: {
      service: Prisma.$ServicesPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bill_id: number
      service_id: number
      service_date: Date
      quantity: number
      unit_cost: number
      total_cost: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["patientBills"]>
    composites: {}
  }

  type PatientBillsGetPayload<S extends boolean | null | undefined | PatientBillsDefaultArgs> = $Result.GetResult<Prisma.$PatientBillsPayload, S>

  type PatientBillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientBillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientBillsCountAggregateInputType | true
    }

  export interface PatientBillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientBills'], meta: { name: 'PatientBills' } }
    /**
     * Find zero or one PatientBills that matches the filter.
     * @param {PatientBillsFindUniqueArgs} args - Arguments to find a PatientBills
     * @example
     * // Get one PatientBills
     * const patientBills = await prisma.patientBills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientBillsFindUniqueArgs>(args: SelectSubset<T, PatientBillsFindUniqueArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientBills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientBillsFindUniqueOrThrowArgs} args - Arguments to find a PatientBills
     * @example
     * // Get one PatientBills
     * const patientBills = await prisma.patientBills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientBillsFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientBillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientBills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsFindFirstArgs} args - Arguments to find a PatientBills
     * @example
     * // Get one PatientBills
     * const patientBills = await prisma.patientBills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientBillsFindFirstArgs>(args?: SelectSubset<T, PatientBillsFindFirstArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientBills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsFindFirstOrThrowArgs} args - Arguments to find a PatientBills
     * @example
     * // Get one PatientBills
     * const patientBills = await prisma.patientBills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientBillsFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientBillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientBills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientBills
     * const patientBills = await prisma.patientBills.findMany()
     * 
     * // Get first 10 PatientBills
     * const patientBills = await prisma.patientBills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientBillsWithIdOnly = await prisma.patientBills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientBillsFindManyArgs>(args?: SelectSubset<T, PatientBillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientBills.
     * @param {PatientBillsCreateArgs} args - Arguments to create a PatientBills.
     * @example
     * // Create one PatientBills
     * const PatientBills = await prisma.patientBills.create({
     *   data: {
     *     // ... data to create a PatientBills
     *   }
     * })
     * 
     */
    create<T extends PatientBillsCreateArgs>(args: SelectSubset<T, PatientBillsCreateArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientBills.
     * @param {PatientBillsCreateManyArgs} args - Arguments to create many PatientBills.
     * @example
     * // Create many PatientBills
     * const patientBills = await prisma.patientBills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientBillsCreateManyArgs>(args?: SelectSubset<T, PatientBillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientBills and returns the data saved in the database.
     * @param {PatientBillsCreateManyAndReturnArgs} args - Arguments to create many PatientBills.
     * @example
     * // Create many PatientBills
     * const patientBills = await prisma.patientBills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientBills and only return the `id`
     * const patientBillsWithIdOnly = await prisma.patientBills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientBillsCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientBillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientBills.
     * @param {PatientBillsDeleteArgs} args - Arguments to delete one PatientBills.
     * @example
     * // Delete one PatientBills
     * const PatientBills = await prisma.patientBills.delete({
     *   where: {
     *     // ... filter to delete one PatientBills
     *   }
     * })
     * 
     */
    delete<T extends PatientBillsDeleteArgs>(args: SelectSubset<T, PatientBillsDeleteArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientBills.
     * @param {PatientBillsUpdateArgs} args - Arguments to update one PatientBills.
     * @example
     * // Update one PatientBills
     * const patientBills = await prisma.patientBills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientBillsUpdateArgs>(args: SelectSubset<T, PatientBillsUpdateArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientBills.
     * @param {PatientBillsDeleteManyArgs} args - Arguments to filter PatientBills to delete.
     * @example
     * // Delete a few PatientBills
     * const { count } = await prisma.patientBills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientBillsDeleteManyArgs>(args?: SelectSubset<T, PatientBillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientBills
     * const patientBills = await prisma.patientBills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientBillsUpdateManyArgs>(args: SelectSubset<T, PatientBillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientBills and returns the data updated in the database.
     * @param {PatientBillsUpdateManyAndReturnArgs} args - Arguments to update many PatientBills.
     * @example
     * // Update many PatientBills
     * const patientBills = await prisma.patientBills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientBills and only return the `id`
     * const patientBillsWithIdOnly = await prisma.patientBills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientBillsUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientBillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientBills.
     * @param {PatientBillsUpsertArgs} args - Arguments to update or create a PatientBills.
     * @example
     * // Update or create a PatientBills
     * const patientBills = await prisma.patientBills.upsert({
     *   create: {
     *     // ... data to create a PatientBills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientBills we want to update
     *   }
     * })
     */
    upsert<T extends PatientBillsUpsertArgs>(args: SelectSubset<T, PatientBillsUpsertArgs<ExtArgs>>): Prisma__PatientBillsClient<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsCountArgs} args - Arguments to filter PatientBills to count.
     * @example
     * // Count the number of PatientBills
     * const count = await prisma.patientBills.count({
     *   where: {
     *     // ... the filter for the PatientBills we want to count
     *   }
     * })
    **/
    count<T extends PatientBillsCountArgs>(
      args?: Subset<T, PatientBillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientBillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientBillsAggregateArgs>(args: Subset<T, PatientBillsAggregateArgs>): Prisma.PrismaPromise<GetPatientBillsAggregateType<T>>

    /**
     * Group by PatientBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientBillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientBillsGroupByArgs['orderBy'] }
        : { orderBy?: PatientBillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientBillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientBillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientBills model
   */
  readonly fields: PatientBillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientBills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientBillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicesDefaultArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientBills model
   */
  interface PatientBillsFieldRefs {
    readonly id: FieldRef<"PatientBills", 'Int'>
    readonly bill_id: FieldRef<"PatientBills", 'Int'>
    readonly service_id: FieldRef<"PatientBills", 'Int'>
    readonly service_date: FieldRef<"PatientBills", 'DateTime'>
    readonly quantity: FieldRef<"PatientBills", 'Int'>
    readonly unit_cost: FieldRef<"PatientBills", 'Float'>
    readonly total_cost: FieldRef<"PatientBills", 'Float'>
    readonly created_at: FieldRef<"PatientBills", 'DateTime'>
    readonly updated_at: FieldRef<"PatientBills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientBills findUnique
   */
  export type PatientBillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter, which PatientBills to fetch.
     */
    where: PatientBillsWhereUniqueInput
  }

  /**
   * PatientBills findUniqueOrThrow
   */
  export type PatientBillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter, which PatientBills to fetch.
     */
    where: PatientBillsWhereUniqueInput
  }

  /**
   * PatientBills findFirst
   */
  export type PatientBillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter, which PatientBills to fetch.
     */
    where?: PatientBillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBills to fetch.
     */
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBills.
     */
    cursor?: PatientBillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBills.
     */
    distinct?: PatientBillsScalarFieldEnum | PatientBillsScalarFieldEnum[]
  }

  /**
   * PatientBills findFirstOrThrow
   */
  export type PatientBillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter, which PatientBills to fetch.
     */
    where?: PatientBillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBills to fetch.
     */
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBills.
     */
    cursor?: PatientBillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBills.
     */
    distinct?: PatientBillsScalarFieldEnum | PatientBillsScalarFieldEnum[]
  }

  /**
   * PatientBills findMany
   */
  export type PatientBillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter, which PatientBills to fetch.
     */
    where?: PatientBillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBills to fetch.
     */
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientBills.
     */
    cursor?: PatientBillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBills.
     */
    skip?: number
    distinct?: PatientBillsScalarFieldEnum | PatientBillsScalarFieldEnum[]
  }

  /**
   * PatientBills create
   */
  export type PatientBillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientBills.
     */
    data: XOR<PatientBillsCreateInput, PatientBillsUncheckedCreateInput>
  }

  /**
   * PatientBills createMany
   */
  export type PatientBillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientBills.
     */
    data: PatientBillsCreateManyInput | PatientBillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientBills createManyAndReturn
   */
  export type PatientBillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * The data used to create many PatientBills.
     */
    data: PatientBillsCreateManyInput | PatientBillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientBills update
   */
  export type PatientBillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientBills.
     */
    data: XOR<PatientBillsUpdateInput, PatientBillsUncheckedUpdateInput>
    /**
     * Choose, which PatientBills to update.
     */
    where: PatientBillsWhereUniqueInput
  }

  /**
   * PatientBills updateMany
   */
  export type PatientBillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientBills.
     */
    data: XOR<PatientBillsUpdateManyMutationInput, PatientBillsUncheckedUpdateManyInput>
    /**
     * Filter which PatientBills to update
     */
    where?: PatientBillsWhereInput
    /**
     * Limit how many PatientBills to update.
     */
    limit?: number
  }

  /**
   * PatientBills updateManyAndReturn
   */
  export type PatientBillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * The data used to update PatientBills.
     */
    data: XOR<PatientBillsUpdateManyMutationInput, PatientBillsUncheckedUpdateManyInput>
    /**
     * Filter which PatientBills to update
     */
    where?: PatientBillsWhereInput
    /**
     * Limit how many PatientBills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientBills upsert
   */
  export type PatientBillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientBills to update in case it exists.
     */
    where: PatientBillsWhereUniqueInput
    /**
     * In case the PatientBills found by the `where` argument doesn't exist, create a new PatientBills with this data.
     */
    create: XOR<PatientBillsCreateInput, PatientBillsUncheckedCreateInput>
    /**
     * In case the PatientBills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientBillsUpdateInput, PatientBillsUncheckedUpdateInput>
  }

  /**
   * PatientBills delete
   */
  export type PatientBillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    /**
     * Filter which PatientBills to delete.
     */
    where: PatientBillsWhereUniqueInput
  }

  /**
   * PatientBills deleteMany
   */
  export type PatientBillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBills to delete
     */
    where?: PatientBillsWhereInput
    /**
     * Limit how many PatientBills to delete.
     */
    limit?: number
  }

  /**
   * PatientBills without action
   */
  export type PatientBillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
  }


  /**
   * Model LabTest
   */

  export type AggregateLabTest = {
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  export type LabTestAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
    service_id: number | null
  }

  export type LabTestSumAggregateOutputType = {
    id: number | null
    record_id: number | null
    service_id: number | null
  }

  export type LabTestMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    test_date: Date | null
    result: string | null
    status: string | null
    notes: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabTestMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    test_date: Date | null
    result: string | null
    status: string | null
    notes: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabTestCountAggregateOutputType = {
    id: number
    record_id: number
    test_date: number
    result: number
    status: number
    notes: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LabTestAvgAggregateInputType = {
    id?: true
    record_id?: true
    service_id?: true
  }

  export type LabTestSumAggregateInputType = {
    id?: true
    record_id?: true
    service_id?: true
  }

  export type LabTestMinAggregateInputType = {
    id?: true
    record_id?: true
    test_date?: true
    result?: true
    status?: true
    notes?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabTestMaxAggregateInputType = {
    id?: true
    record_id?: true
    test_date?: true
    result?: true
    status?: true
    notes?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabTestCountAggregateInputType = {
    id?: true
    record_id?: true
    test_date?: true
    result?: true
    status?: true
    notes?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LabTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTest to aggregate.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabTests
    **/
    _count?: true | LabTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabTestMaxAggregateInputType
  }

  export type GetLabTestAggregateType<T extends LabTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabTest[P]>
      : GetScalarType<T[P], AggregateLabTest[P]>
  }




  export type LabTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestWhereInput
    orderBy?: LabTestOrderByWithAggregationInput | LabTestOrderByWithAggregationInput[]
    by: LabTestScalarFieldEnum[] | LabTestScalarFieldEnum
    having?: LabTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabTestCountAggregateInputType | true
    _avg?: LabTestAvgAggregateInputType
    _sum?: LabTestSumAggregateInputType
    _min?: LabTestMinAggregateInputType
    _max?: LabTestMaxAggregateInputType
  }

  export type LabTestGroupByOutputType = {
    id: number
    record_id: number
    test_date: Date
    result: string
    status: string
    notes: string
    service_id: number
    created_at: Date
    updated_at: Date
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  type GetLabTestGroupByPayload<T extends LabTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabTestGroupByOutputType[P]>
        }
      >
    >


  export type LabTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    test_date?: boolean
    result?: boolean
    status?: boolean
    notes?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    test_date?: boolean
    result?: boolean
    status?: boolean
    notes?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    test_date?: boolean
    result?: boolean
    status?: boolean
    notes?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectScalar = {
    id?: boolean
    record_id?: boolean
    test_date?: boolean
    result?: boolean
    status?: boolean
    notes?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type LabTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "record_id" | "test_date" | "result" | "status" | "notes" | "service_id" | "created_at" | "updated_at", ExtArgs["result"]["labTest"]>
  export type LabTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }
  export type LabTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }
  export type LabTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServicesDefaultArgs<ExtArgs>
    medical_record?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }

  export type $LabTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabTest"
    objects: {
      services: Prisma.$ServicesPayload<ExtArgs>
      medical_record: Prisma.$MedicalRecordsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number
      test_date: Date
      result: string
      status: string
      notes: string
      service_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["labTest"]>
    composites: {}
  }

  type LabTestGetPayload<S extends boolean | null | undefined | LabTestDefaultArgs> = $Result.GetResult<Prisma.$LabTestPayload, S>

  type LabTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabTestCountAggregateInputType | true
    }

  export interface LabTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabTest'], meta: { name: 'LabTest' } }
    /**
     * Find zero or one LabTest that matches the filter.
     * @param {LabTestFindUniqueArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabTestFindUniqueArgs>(args: SelectSubset<T, LabTestFindUniqueArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabTestFindUniqueOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabTestFindFirstArgs>(args?: SelectSubset<T, LabTestFindFirstArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabTests
     * const labTests = await prisma.labTest.findMany()
     * 
     * // Get first 10 LabTests
     * const labTests = await prisma.labTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labTestWithIdOnly = await prisma.labTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabTestFindManyArgs>(args?: SelectSubset<T, LabTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabTest.
     * @param {LabTestCreateArgs} args - Arguments to create a LabTest.
     * @example
     * // Create one LabTest
     * const LabTest = await prisma.labTest.create({
     *   data: {
     *     // ... data to create a LabTest
     *   }
     * })
     * 
     */
    create<T extends LabTestCreateArgs>(args: SelectSubset<T, LabTestCreateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabTests.
     * @param {LabTestCreateManyArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabTestCreateManyArgs>(args?: SelectSubset<T, LabTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabTests and returns the data saved in the database.
     * @param {LabTestCreateManyAndReturnArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabTests and only return the `id`
     * const labTestWithIdOnly = await prisma.labTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabTest.
     * @param {LabTestDeleteArgs} args - Arguments to delete one LabTest.
     * @example
     * // Delete one LabTest
     * const LabTest = await prisma.labTest.delete({
     *   where: {
     *     // ... filter to delete one LabTest
     *   }
     * })
     * 
     */
    delete<T extends LabTestDeleteArgs>(args: SelectSubset<T, LabTestDeleteArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabTest.
     * @param {LabTestUpdateArgs} args - Arguments to update one LabTest.
     * @example
     * // Update one LabTest
     * const labTest = await prisma.labTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabTestUpdateArgs>(args: SelectSubset<T, LabTestUpdateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabTests.
     * @param {LabTestDeleteManyArgs} args - Arguments to filter LabTests to delete.
     * @example
     * // Delete a few LabTests
     * const { count } = await prisma.labTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabTestDeleteManyArgs>(args?: SelectSubset<T, LabTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabTests
     * const labTest = await prisma.labTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabTestUpdateManyArgs>(args: SelectSubset<T, LabTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests and returns the data updated in the database.
     * @param {LabTestUpdateManyAndReturnArgs} args - Arguments to update many LabTests.
     * @example
     * // Update many LabTests
     * const labTest = await prisma.labTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabTests and only return the `id`
     * const labTestWithIdOnly = await prisma.labTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabTestUpdateManyAndReturnArgs>(args: SelectSubset<T, LabTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabTest.
     * @param {LabTestUpsertArgs} args - Arguments to update or create a LabTest.
     * @example
     * // Update or create a LabTest
     * const labTest = await prisma.labTest.upsert({
     *   create: {
     *     // ... data to create a LabTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabTest we want to update
     *   }
     * })
     */
    upsert<T extends LabTestUpsertArgs>(args: SelectSubset<T, LabTestUpsertArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestCountArgs} args - Arguments to filter LabTests to count.
     * @example
     * // Count the number of LabTests
     * const count = await prisma.labTest.count({
     *   where: {
     *     // ... the filter for the LabTests we want to count
     *   }
     * })
    **/
    count<T extends LabTestCountArgs>(
      args?: Subset<T, LabTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabTestAggregateArgs>(args: Subset<T, LabTestAggregateArgs>): Prisma.PrismaPromise<GetLabTestAggregateType<T>>

    /**
     * Group by LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabTestGroupByArgs['orderBy'] }
        : { orderBy?: LabTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabTest model
   */
  readonly fields: LabTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicesDefaultArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medical_record<T extends MedicalRecordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecordsDefaultArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabTest model
   */
  interface LabTestFieldRefs {
    readonly id: FieldRef<"LabTest", 'Int'>
    readonly record_id: FieldRef<"LabTest", 'Int'>
    readonly test_date: FieldRef<"LabTest", 'DateTime'>
    readonly result: FieldRef<"LabTest", 'String'>
    readonly status: FieldRef<"LabTest", 'String'>
    readonly notes: FieldRef<"LabTest", 'String'>
    readonly service_id: FieldRef<"LabTest", 'Int'>
    readonly created_at: FieldRef<"LabTest", 'DateTime'>
    readonly updated_at: FieldRef<"LabTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabTest findUnique
   */
  export type LabTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findUniqueOrThrow
   */
  export type LabTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findFirst
   */
  export type LabTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findFirstOrThrow
   */
  export type LabTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findMany
   */
  export type LabTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest create
   */
  export type LabTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabTest.
     */
    data: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
  }

  /**
   * LabTest createMany
   */
  export type LabTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabTest createManyAndReturn
   */
  export type LabTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTest update
   */
  export type LabTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabTest.
     */
    data: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
    /**
     * Choose, which LabTest to update.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest updateMany
   */
  export type LabTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to update.
     */
    limit?: number
  }

  /**
   * LabTest updateManyAndReturn
   */
  export type LabTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTest upsert
   */
  export type LabTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabTest to update in case it exists.
     */
    where: LabTestWhereUniqueInput
    /**
     * In case the LabTest found by the `where` argument doesn't exist, create a new LabTest with this data.
     */
    create: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
    /**
     * In case the LabTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
  }

  /**
   * LabTest delete
   */
  export type LabTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter which LabTest to delete.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest deleteMany
   */
  export type LabTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTests to delete
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to delete.
     */
    limit?: number
  }

  /**
   * LabTest without action
   */
  export type LabTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
  }


  /**
   * Model MedicalRecords
   */

  export type AggregateMedicalRecords = {
    _count: MedicalRecordsCountAggregateOutputType | null
    _avg: MedicalRecordsAvgAggregateOutputType | null
    _sum: MedicalRecordsSumAggregateOutputType | null
    _min: MedicalRecordsMinAggregateOutputType | null
    _max: MedicalRecordsMaxAggregateOutputType | null
  }

  export type MedicalRecordsAvgAggregateOutputType = {
    id: number | null
    appointment_id: number | null
  }

  export type MedicalRecordsSumAggregateOutputType = {
    id: number | null
    appointment_id: number | null
  }

  export type MedicalRecordsMinAggregateOutputType = {
    id: number | null
    patient_id: string | null
    appointment_id: number | null
    doctor_id: string | null
    treatment_plan: string | null
    prescriptions: string | null
    lab_request: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MedicalRecordsMaxAggregateOutputType = {
    id: number | null
    patient_id: string | null
    appointment_id: number | null
    doctor_id: string | null
    treatment_plan: string | null
    prescriptions: string | null
    lab_request: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MedicalRecordsCountAggregateOutputType = {
    id: number
    patient_id: number
    appointment_id: number
    doctor_id: number
    treatment_plan: number
    prescriptions: number
    lab_request: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MedicalRecordsAvgAggregateInputType = {
    id?: true
    appointment_id?: true
  }

  export type MedicalRecordsSumAggregateInputType = {
    id?: true
    appointment_id?: true
  }

  export type MedicalRecordsMinAggregateInputType = {
    id?: true
    patient_id?: true
    appointment_id?: true
    doctor_id?: true
    treatment_plan?: true
    prescriptions?: true
    lab_request?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type MedicalRecordsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    appointment_id?: true
    doctor_id?: true
    treatment_plan?: true
    prescriptions?: true
    lab_request?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type MedicalRecordsCountAggregateInputType = {
    id?: true
    patient_id?: true
    appointment_id?: true
    doctor_id?: true
    treatment_plan?: true
    prescriptions?: true
    lab_request?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MedicalRecordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to aggregate.
     */
    where?: MedicalRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalRecordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalRecordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordsMaxAggregateInputType
  }

  export type GetMedicalRecordsAggregateType<T extends MedicalRecordsAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecords[P]>
      : GetScalarType<T[P], AggregateMedicalRecords[P]>
  }




  export type MedicalRecordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordsWhereInput
    orderBy?: MedicalRecordsOrderByWithAggregationInput | MedicalRecordsOrderByWithAggregationInput[]
    by: MedicalRecordsScalarFieldEnum[] | MedicalRecordsScalarFieldEnum
    having?: MedicalRecordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordsCountAggregateInputType | true
    _avg?: MedicalRecordsAvgAggregateInputType
    _sum?: MedicalRecordsSumAggregateInputType
    _min?: MedicalRecordsMinAggregateInputType
    _max?: MedicalRecordsMaxAggregateInputType
  }

  export type MedicalRecordsGroupByOutputType = {
    id: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan: string | null
    prescriptions: string | null
    lab_request: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: MedicalRecordsCountAggregateOutputType | null
    _avg: MedicalRecordsAvgAggregateOutputType | null
    _sum: MedicalRecordsSumAggregateOutputType | null
    _min: MedicalRecordsMinAggregateOutputType | null
    _max: MedicalRecordsMaxAggregateOutputType | null
  }

  type GetMedicalRecordsGroupByPayload<T extends MedicalRecordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalRecordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordsGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordsGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    appointment_id?: boolean
    doctor_id?: boolean
    treatment_plan?: boolean
    prescriptions?: boolean
    lab_request?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lab_test?: boolean | MedicalRecords$lab_testArgs<ExtArgs>
    vital_signs?: boolean | MedicalRecords$vital_signsArgs<ExtArgs>
    diagnosis?: boolean | MedicalRecords$diagnosisArgs<ExtArgs>
    _count?: boolean | MedicalRecordsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecords"]>

  export type MedicalRecordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    appointment_id?: boolean
    doctor_id?: boolean
    treatment_plan?: boolean
    prescriptions?: boolean
    lab_request?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecords"]>

  export type MedicalRecordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    appointment_id?: boolean
    doctor_id?: boolean
    treatment_plan?: boolean
    prescriptions?: boolean
    lab_request?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecords"]>

  export type MedicalRecordsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    appointment_id?: boolean
    doctor_id?: boolean
    treatment_plan?: boolean
    prescriptions?: boolean
    lab_request?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MedicalRecordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "appointment_id" | "doctor_id" | "treatment_plan" | "prescriptions" | "lab_request" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["medicalRecords"]>
  export type MedicalRecordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lab_test?: boolean | MedicalRecords$lab_testArgs<ExtArgs>
    vital_signs?: boolean | MedicalRecords$vital_signsArgs<ExtArgs>
    diagnosis?: boolean | MedicalRecords$diagnosisArgs<ExtArgs>
    _count?: boolean | MedicalRecordsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicalRecordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicalRecordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $MedicalRecordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalRecords"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      lab_test: Prisma.$LabTestPayload<ExtArgs>[]
      vital_signs: Prisma.$VitalSignsPayload<ExtArgs>[]
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patient_id: string
      appointment_id: number
      doctor_id: string
      treatment_plan: string | null
      prescriptions: string | null
      lab_request: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["medicalRecords"]>
    composites: {}
  }

  type MedicalRecordsGetPayload<S extends boolean | null | undefined | MedicalRecordsDefaultArgs> = $Result.GetResult<Prisma.$MedicalRecordsPayload, S>

  type MedicalRecordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalRecordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalRecordsCountAggregateInputType | true
    }

  export interface MedicalRecordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecords'], meta: { name: 'MedicalRecords' } }
    /**
     * Find zero or one MedicalRecords that matches the filter.
     * @param {MedicalRecordsFindUniqueArgs} args - Arguments to find a MedicalRecords
     * @example
     * // Get one MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalRecordsFindUniqueArgs>(args: SelectSubset<T, MedicalRecordsFindUniqueArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalRecords that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalRecordsFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecords
     * @example
     * // Get one MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalRecordsFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalRecordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsFindFirstArgs} args - Arguments to find a MedicalRecords
     * @example
     * // Get one MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalRecordsFindFirstArgs>(args?: SelectSubset<T, MedicalRecordsFindFirstArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsFindFirstOrThrowArgs} args - Arguments to find a MedicalRecords
     * @example
     * // Get one MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalRecordsFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalRecordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordsWithIdOnly = await prisma.medicalRecords.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalRecordsFindManyArgs>(args?: SelectSubset<T, MedicalRecordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalRecords.
     * @param {MedicalRecordsCreateArgs} args - Arguments to create a MedicalRecords.
     * @example
     * // Create one MedicalRecords
     * const MedicalRecords = await prisma.medicalRecords.create({
     *   data: {
     *     // ... data to create a MedicalRecords
     *   }
     * })
     * 
     */
    create<T extends MedicalRecordsCreateArgs>(args: SelectSubset<T, MedicalRecordsCreateArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalRecords.
     * @param {MedicalRecordsCreateManyArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalRecordsCreateManyArgs>(args?: SelectSubset<T, MedicalRecordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalRecords and returns the data saved in the database.
     * @param {MedicalRecordsCreateManyAndReturnArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalRecords and only return the `id`
     * const medicalRecordsWithIdOnly = await prisma.medicalRecords.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalRecordsCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalRecordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalRecords.
     * @param {MedicalRecordsDeleteArgs} args - Arguments to delete one MedicalRecords.
     * @example
     * // Delete one MedicalRecords
     * const MedicalRecords = await prisma.medicalRecords.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecords
     *   }
     * })
     * 
     */
    delete<T extends MedicalRecordsDeleteArgs>(args: SelectSubset<T, MedicalRecordsDeleteArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalRecords.
     * @param {MedicalRecordsUpdateArgs} args - Arguments to update one MedicalRecords.
     * @example
     * // Update one MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalRecordsUpdateArgs>(args: SelectSubset<T, MedicalRecordsUpdateArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordsDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalRecordsDeleteManyArgs>(args?: SelectSubset<T, MedicalRecordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalRecordsUpdateManyArgs>(args: SelectSubset<T, MedicalRecordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords and returns the data updated in the database.
     * @param {MedicalRecordsUpdateManyAndReturnArgs} args - Arguments to update many MedicalRecords.
     * @example
     * // Update many MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalRecords and only return the `id`
     * const medicalRecordsWithIdOnly = await prisma.medicalRecords.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalRecordsUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalRecordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalRecords.
     * @param {MedicalRecordsUpsertArgs} args - Arguments to update or create a MedicalRecords.
     * @example
     * // Update or create a MedicalRecords
     * const medicalRecords = await prisma.medicalRecords.upsert({
     *   create: {
     *     // ... data to create a MedicalRecords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecords we want to update
     *   }
     * })
     */
    upsert<T extends MedicalRecordsUpsertArgs>(args: SelectSubset<T, MedicalRecordsUpsertArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecords.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordsCountArgs>(
      args?: Subset<T, MedicalRecordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordsAggregateArgs>(args: Subset<T, MedicalRecordsAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordsAggregateType<T>>

    /**
     * Group by MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordsGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalRecords model
   */
  readonly fields: MedicalRecordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalRecordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lab_test<T extends MedicalRecords$lab_testArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecords$lab_testArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vital_signs<T extends MedicalRecords$vital_signsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecords$vital_signsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnosis<T extends MedicalRecords$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecords$diagnosisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalRecords model
   */
  interface MedicalRecordsFieldRefs {
    readonly id: FieldRef<"MedicalRecords", 'Int'>
    readonly patient_id: FieldRef<"MedicalRecords", 'String'>
    readonly appointment_id: FieldRef<"MedicalRecords", 'Int'>
    readonly doctor_id: FieldRef<"MedicalRecords", 'String'>
    readonly treatment_plan: FieldRef<"MedicalRecords", 'String'>
    readonly prescriptions: FieldRef<"MedicalRecords", 'String'>
    readonly lab_request: FieldRef<"MedicalRecords", 'String'>
    readonly notes: FieldRef<"MedicalRecords", 'String'>
    readonly created_at: FieldRef<"MedicalRecords", 'DateTime'>
    readonly updated_at: FieldRef<"MedicalRecords", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalRecords findUnique
   */
  export type MedicalRecordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where: MedicalRecordsWhereUniqueInput
  }

  /**
   * MedicalRecords findUniqueOrThrow
   */
  export type MedicalRecordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where: MedicalRecordsWhereUniqueInput
  }

  /**
   * MedicalRecords findFirst
   */
  export type MedicalRecordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordsScalarFieldEnum | MedicalRecordsScalarFieldEnum[]
  }

  /**
   * MedicalRecords findFirstOrThrow
   */
  export type MedicalRecordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordsScalarFieldEnum | MedicalRecordsScalarFieldEnum[]
  }

  /**
   * MedicalRecords findMany
   */
  export type MedicalRecordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordsOrderByWithRelationInput | MedicalRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: MedicalRecordsScalarFieldEnum | MedicalRecordsScalarFieldEnum[]
  }

  /**
   * MedicalRecords create
   */
  export type MedicalRecordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecords.
     */
    data: XOR<MedicalRecordsCreateInput, MedicalRecordsUncheckedCreateInput>
  }

  /**
   * MedicalRecords createMany
   */
  export type MedicalRecordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordsCreateManyInput | MedicalRecordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalRecords createManyAndReturn
   */
  export type MedicalRecordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordsCreateManyInput | MedicalRecordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecords update
   */
  export type MedicalRecordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecords.
     */
    data: XOR<MedicalRecordsUpdateInput, MedicalRecordsUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecords to update.
     */
    where: MedicalRecordsWhereUniqueInput
  }

  /**
   * MedicalRecords updateMany
   */
  export type MedicalRecordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordsUpdateManyMutationInput, MedicalRecordsUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordsWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
  }

  /**
   * MedicalRecords updateManyAndReturn
   */
  export type MedicalRecordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordsUpdateManyMutationInput, MedicalRecordsUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordsWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecords upsert
   */
  export type MedicalRecordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecords to update in case it exists.
     */
    where: MedicalRecordsWhereUniqueInput
    /**
     * In case the MedicalRecords found by the `where` argument doesn't exist, create a new MedicalRecords with this data.
     */
    create: XOR<MedicalRecordsCreateInput, MedicalRecordsUncheckedCreateInput>
    /**
     * In case the MedicalRecords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordsUpdateInput, MedicalRecordsUncheckedUpdateInput>
  }

  /**
   * MedicalRecords delete
   */
  export type MedicalRecordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecords to delete.
     */
    where: MedicalRecordsWhereUniqueInput
  }

  /**
   * MedicalRecords deleteMany
   */
  export type MedicalRecordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordsWhereInput
    /**
     * Limit how many MedicalRecords to delete.
     */
    limit?: number
  }

  /**
   * MedicalRecords.lab_test
   */
  export type MedicalRecords$lab_testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    where?: LabTestWhereInput
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    cursor?: LabTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * MedicalRecords.vital_signs
   */
  export type MedicalRecords$vital_signsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    cursor?: VitalSignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * MedicalRecords.diagnosis
   */
  export type MedicalRecords$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * MedicalRecords without action
   */
  export type MedicalRecordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecords
     */
    select?: MedicalRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecords
     */
    omit?: MedicalRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordsInclude<ExtArgs> | null
  }


  /**
   * Model VitalSigns
   */

  export type AggregateVitalSigns = {
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  export type VitalSignsAvgAggregateOutputType = {
    id: number | null
    medical_id: number | null
    body_temperature: number | null
    systolic: number | null
    diastolic: number | null
    respiratoryRate: number | null
    oxygen_saturation: number | null
    weight: number | null
    height: number | null
  }

  export type VitalSignsSumAggregateOutputType = {
    id: number | null
    medical_id: number | null
    body_temperature: number | null
    systolic: number | null
    diastolic: number | null
    respiratoryRate: number | null
    oxygen_saturation: number | null
    weight: number | null
    height: number | null
  }

  export type VitalSignsMinAggregateOutputType = {
    id: number | null
    patient_id: string | null
    medical_id: number | null
    body_temperature: number | null
    systolic: number | null
    diastolic: number | null
    heartRate: string | null
    respiratoryRate: number | null
    oxygen_saturation: number | null
    weight: number | null
    height: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VitalSignsMaxAggregateOutputType = {
    id: number | null
    patient_id: string | null
    medical_id: number | null
    body_temperature: number | null
    systolic: number | null
    diastolic: number | null
    heartRate: string | null
    respiratoryRate: number | null
    oxygen_saturation: number | null
    weight: number | null
    height: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VitalSignsCountAggregateOutputType = {
    id: number
    patient_id: number
    medical_id: number
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: number
    respiratoryRate: number
    oxygen_saturation: number
    weight: number
    height: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VitalSignsAvgAggregateInputType = {
    id?: true
    medical_id?: true
    body_temperature?: true
    systolic?: true
    diastolic?: true
    respiratoryRate?: true
    oxygen_saturation?: true
    weight?: true
    height?: true
  }

  export type VitalSignsSumAggregateInputType = {
    id?: true
    medical_id?: true
    body_temperature?: true
    systolic?: true
    diastolic?: true
    respiratoryRate?: true
    oxygen_saturation?: true
    weight?: true
    height?: true
  }

  export type VitalSignsMinAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    body_temperature?: true
    systolic?: true
    diastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygen_saturation?: true
    weight?: true
    height?: true
    created_at?: true
    updated_at?: true
  }

  export type VitalSignsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    body_temperature?: true
    systolic?: true
    diastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygen_saturation?: true
    weight?: true
    height?: true
    created_at?: true
    updated_at?: true
  }

  export type VitalSignsCountAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    body_temperature?: true
    systolic?: true
    diastolic?: true
    heartRate?: true
    respiratoryRate?: true
    oxygen_saturation?: true
    weight?: true
    height?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VitalSignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to aggregate.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignsMaxAggregateInputType
  }

  export type GetVitalSignsAggregateType<T extends VitalSignsAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSigns[P]>
      : GetScalarType<T[P], AggregateVitalSigns[P]>
  }




  export type VitalSignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithAggregationInput | VitalSignsOrderByWithAggregationInput[]
    by: VitalSignsScalarFieldEnum[] | VitalSignsScalarFieldEnum
    having?: VitalSignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignsCountAggregateInputType | true
    _avg?: VitalSignsAvgAggregateInputType
    _sum?: VitalSignsSumAggregateInputType
    _min?: VitalSignsMinAggregateInputType
    _max?: VitalSignsMaxAggregateInputType
  }

  export type VitalSignsGroupByOutputType = {
    id: number
    patient_id: string
    medical_id: number
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate: number | null
    oxygen_saturation: number | null
    weight: number | null
    height: number | null
    created_at: Date
    updated_at: Date
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  type GetVitalSignsGroupByPayload<T extends VitalSignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    body_temperature?: boolean
    systolic?: boolean
    diastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygen_saturation?: boolean
    weight?: boolean
    height?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    body_temperature?: boolean
    systolic?: boolean
    diastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygen_saturation?: boolean
    weight?: boolean
    height?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    body_temperature?: boolean
    systolic?: boolean
    diastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygen_saturation?: boolean
    weight?: boolean
    height?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    body_temperature?: boolean
    systolic?: boolean
    diastolic?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    oxygen_saturation?: boolean
    weight?: boolean
    height?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VitalSignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "medical_id" | "body_temperature" | "systolic" | "diastolic" | "heartRate" | "respiratoryRate" | "oxygen_saturation" | "weight" | "height" | "created_at" | "updated_at", ExtArgs["result"]["vitalSigns"]>
  export type VitalSignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }
  export type VitalSignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }
  export type VitalSignsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
  }

  export type $VitalSignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSigns"
    objects: {
      medical: Prisma.$MedicalRecordsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patient_id: string
      medical_id: number
      body_temperature: number
      systolic: number
      diastolic: number
      heartRate: string
      respiratoryRate: number | null
      oxygen_saturation: number | null
      weight: number | null
      height: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vitalSigns"]>
    composites: {}
  }

  type VitalSignsGetPayload<S extends boolean | null | undefined | VitalSignsDefaultArgs> = $Result.GetResult<Prisma.$VitalSignsPayload, S>

  type VitalSignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignsCountAggregateInputType | true
    }

  export interface VitalSignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSigns'], meta: { name: 'VitalSigns' } }
    /**
     * Find zero or one VitalSigns that matches the filter.
     * @param {VitalSignsFindUniqueArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignsFindUniqueArgs>(args: SelectSubset<T, VitalSignsFindUniqueArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignsFindUniqueOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignsFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignsFindFirstArgs>(args?: SelectSubset<T, VitalSignsFindFirstArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignsFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignsFindManyArgs>(args?: SelectSubset<T, VitalSignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSigns.
     * @param {VitalSignsCreateArgs} args - Arguments to create a VitalSigns.
     * @example
     * // Create one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.create({
     *   data: {
     *     // ... data to create a VitalSigns
     *   }
     * })
     * 
     */
    create<T extends VitalSignsCreateArgs>(args: SelectSubset<T, VitalSignsCreateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignsCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignsCreateManyArgs>(args?: SelectSubset<T, VitalSignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VitalSigns and returns the data saved in the database.
     * @param {VitalSignsCreateManyAndReturnArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VitalSigns and only return the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalSignsCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalSignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VitalSigns.
     * @param {VitalSignsDeleteArgs} args - Arguments to delete one VitalSigns.
     * @example
     * // Delete one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.delete({
     *   where: {
     *     // ... filter to delete one VitalSigns
     *   }
     * })
     * 
     */
    delete<T extends VitalSignsDeleteArgs>(args: SelectSubset<T, VitalSignsDeleteArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSigns.
     * @param {VitalSignsUpdateArgs} args - Arguments to update one VitalSigns.
     * @example
     * // Update one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignsUpdateArgs>(args: SelectSubset<T, VitalSignsUpdateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignsDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignsDeleteManyArgs>(args?: SelectSubset<T, VitalSignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignsUpdateManyArgs>(args: SelectSubset<T, VitalSignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns and returns the data updated in the database.
     * @param {VitalSignsUpdateManyAndReturnArgs} args - Arguments to update many VitalSigns.
     * @example
     * // Update many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VitalSigns and only return the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalSignsUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalSignsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VitalSigns.
     * @param {VitalSignsUpsertArgs} args - Arguments to update or create a VitalSigns.
     * @example
     * // Update or create a VitalSigns
     * const vitalSigns = await prisma.vitalSigns.upsert({
     *   create: {
     *     // ... data to create a VitalSigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSigns we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignsUpsertArgs>(args: SelectSubset<T, VitalSignsUpsertArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSigns.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignsCountArgs>(
      args?: Subset<T, VitalSignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignsAggregateArgs>(args: Subset<T, VitalSignsAggregateArgs>): Prisma.PrismaPromise<GetVitalSignsAggregateType<T>>

    /**
     * Group by VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignsGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSigns model
   */
  readonly fields: VitalSignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medical<T extends MedicalRecordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecordsDefaultArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSigns model
   */
  interface VitalSignsFieldRefs {
    readonly id: FieldRef<"VitalSigns", 'Int'>
    readonly patient_id: FieldRef<"VitalSigns", 'String'>
    readonly medical_id: FieldRef<"VitalSigns", 'Int'>
    readonly body_temperature: FieldRef<"VitalSigns", 'Float'>
    readonly systolic: FieldRef<"VitalSigns", 'Int'>
    readonly diastolic: FieldRef<"VitalSigns", 'Int'>
    readonly heartRate: FieldRef<"VitalSigns", 'String'>
    readonly respiratoryRate: FieldRef<"VitalSigns", 'Int'>
    readonly oxygen_saturation: FieldRef<"VitalSigns", 'Int'>
    readonly weight: FieldRef<"VitalSigns", 'Float'>
    readonly height: FieldRef<"VitalSigns", 'Float'>
    readonly created_at: FieldRef<"VitalSigns", 'DateTime'>
    readonly updated_at: FieldRef<"VitalSigns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VitalSigns findUnique
   */
  export type VitalSignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findUniqueOrThrow
   */
  export type VitalSignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findFirst
   */
  export type VitalSignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findFirstOrThrow
   */
  export type VitalSignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findMany
   */
  export type VitalSignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns create
   */
  export type VitalSignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSigns.
     */
    data: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
  }

  /**
   * VitalSigns createMany
   */
  export type VitalSignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignsCreateManyInput | VitalSignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VitalSigns createManyAndReturn
   */
  export type VitalSignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignsCreateManyInput | VitalSignsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSigns update
   */
  export type VitalSignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSigns.
     */
    data: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
    /**
     * Choose, which VitalSigns to update.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns updateMany
   */
  export type VitalSignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSigns updateManyAndReturn
   */
  export type VitalSignsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSigns upsert
   */
  export type VitalSignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSigns to update in case it exists.
     */
    where: VitalSignsWhereUniqueInput
    /**
     * In case the VitalSigns found by the `where` argument doesn't exist, create a new VitalSigns with this data.
     */
    create: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
    /**
     * In case the VitalSigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
  }

  /**
   * VitalSigns delete
   */
  export type VitalSignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter which VitalSigns to delete.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns deleteMany
   */
  export type VitalSignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSigns without action
   */
  export type VitalSignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisAvgAggregateOutputType = {
    id: number | null
    medical_id: number | null
  }

  export type DiagnosisSumAggregateOutputType = {
    id: number | null
    medical_id: number | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: number | null
    patient_id: string | null
    medical_id: number | null
    diagnosis: string | null
    doctor_id: string | null
    symptoms: string | null
    notes: string | null
    prescribed_medications: string | null
    follow_up_plan: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: number | null
    patient_id: string | null
    medical_id: number | null
    diagnosis: string | null
    doctor_id: string | null
    symptoms: string | null
    notes: string | null
    prescribed_medications: string | null
    follow_up_plan: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    patient_id: number
    medical_id: number
    diagnosis: number
    doctor_id: number
    symptoms: number
    notes: number
    prescribed_medications: number
    follow_up_plan: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DiagnosisAvgAggregateInputType = {
    id?: true
    medical_id?: true
  }

  export type DiagnosisSumAggregateInputType = {
    id?: true
    medical_id?: true
  }

  export type DiagnosisMinAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    diagnosis?: true
    doctor_id?: true
    symptoms?: true
    notes?: true
    prescribed_medications?: true
    follow_up_plan?: true
    created_at?: true
    updated_at?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    diagnosis?: true
    doctor_id?: true
    symptoms?: true
    notes?: true
    prescribed_medications?: true
    follow_up_plan?: true
    created_at?: true
    updated_at?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    patient_id?: true
    medical_id?: true
    diagnosis?: true
    doctor_id?: true
    symptoms?: true
    notes?: true
    prescribed_medications?: true
    follow_up_plan?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _avg?: DiagnosisAvgAggregateInputType
    _sum?: DiagnosisSumAggregateInputType
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: number
    patient_id: string
    medical_id: number
    diagnosis: string
    doctor_id: string
    symptoms: string
    notes: string | null
    prescribed_medications: string | null
    follow_up_plan: string | null
    created_at: Date
    updated_at: Date
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    diagnosis?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    notes?: boolean
    prescribed_medications?: boolean
    follow_up_plan?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    diagnosis?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    notes?: boolean
    prescribed_medications?: boolean
    follow_up_plan?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    diagnosis?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    notes?: boolean
    prescribed_medications?: boolean
    follow_up_plan?: boolean
    created_at?: boolean
    updated_at?: boolean
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    patient_id?: boolean
    medical_id?: boolean
    diagnosis?: boolean
    doctor_id?: boolean
    symptoms?: boolean
    notes?: boolean
    prescribed_medications?: boolean
    follow_up_plan?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DiagnosisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "medical_id" | "diagnosis" | "doctor_id" | "symptoms" | "notes" | "prescribed_medications" | "follow_up_plan" | "created_at" | "updated_at", ExtArgs["result"]["diagnosis"]>
  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type DiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }
  export type DiagnosisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medical?: boolean | MedicalRecordsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
  }

  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      medical: Prisma.$MedicalRecordsPayload<ExtArgs>
      doctor: Prisma.$DoctorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patient_id: string
      medical_id: number
      diagnosis: string
      doctor_id: string
      symptoms: string
      notes: string | null
      prescribed_medications: string | null
      follow_up_plan: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }

  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisFindManyArgs>(args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
     */
    create<T extends DiagnosisCreateArgs>(args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisCreateManyArgs>(args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisDeleteArgs>(args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisUpdateArgs>(args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses and returns the data updated in the database.
     * @param {DiagnosisUpdateManyAndReturnArgs} args - Arguments to update many Diagnoses.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiagnosisUpdateManyAndReturnArgs>(args: SelectSubset<T, DiagnosisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medical<T extends MedicalRecordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecordsDefaultArgs<ExtArgs>>): Prisma__MedicalRecordsClient<$Result.GetResult<Prisma.$MedicalRecordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diagnosis model
   */
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'Int'>
    readonly patient_id: FieldRef<"Diagnosis", 'String'>
    readonly medical_id: FieldRef<"Diagnosis", 'Int'>
    readonly diagnosis: FieldRef<"Diagnosis", 'String'>
    readonly doctor_id: FieldRef<"Diagnosis", 'String'>
    readonly symptoms: FieldRef<"Diagnosis", 'String'>
    readonly notes: FieldRef<"Diagnosis", 'String'>
    readonly prescribed_medications: FieldRef<"Diagnosis", 'String'>
    readonly follow_up_plan: FieldRef<"Diagnosis", 'String'>
    readonly created_at: FieldRef<"Diagnosis", 'DateTime'>
    readonly updated_at: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number
  }

  /**
   * Diagnosis updateManyAndReturn
   */
  export type DiagnosisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
    /**
     * Limit how many Diagnoses to delete.
     */
    limit?: number
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diagnosis
     */
    omit?: DiagnosisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    record_id: string | null
    action: string | null
    details: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    record_id: string | null
    action: string | null
    details: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    user_id: number
    record_id: number
    action: number
    details: number
    model: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    user_id?: true
    record_id?: true
    action?: true
    details?: true
    model?: true
    created_at?: true
    updated_at?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    user_id?: true
    record_id?: true
    action?: true
    details?: true
    model?: true
    created_at?: true
    updated_at?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    user_id?: true
    record_id?: true
    action?: true
    details?: true
    model?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    user_id: string
    record_id: string
    action: string
    details: string | null
    model: string
    created_at: Date
    updated_at: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    record_id?: boolean
    action?: boolean
    details?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    record_id?: boolean
    action?: boolean
    details?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    record_id?: boolean
    action?: boolean
    details?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    user_id?: boolean
    record_id?: boolean
    action?: boolean
    details?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "record_id" | "action" | "details" | "model" | "created_at" | "updated_at", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      record_id: string
      action: string
      details: string | null
      model: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly user_id: FieldRef<"AuditLog", 'String'>
    readonly record_id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly model: FieldRef<"AuditLog", 'String'>
    readonly created_at: FieldRef<"AuditLog", 'DateTime'>
    readonly updated_at: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: number | null
    patient_id: string | null
    staff_id: string | null
    rating: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: number | null
    patient_id: string | null
    staff_id: string | null
    rating: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    patient_id: number
    staff_id: number
    rating: number
    comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    patient_id?: true
    staff_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    patient_id?: true
    staff_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    patient_id?: true
    staff_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: number
    patient_id: string
    staff_id: string
    rating: number
    comment: string | null
    created_at: Date
    updated_at: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "staff_id" | "rating" | "comment" | "created_at" | "updated_at", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patient_id: string
      staff_id: string
      rating: number
      comment: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'Int'>
    readonly patient_id: FieldRef<"Rating", 'String'>
    readonly staff_id: FieldRef<"Rating", 'String'>
    readonly rating: FieldRef<"Rating", 'Int'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly created_at: FieldRef<"Rating", 'DateTime'>
    readonly updated_at: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model Services
   */

  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServicesSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: number | null
    service_name: string | null
    description: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: number | null
    service_name: string | null
    description: string | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    service_name: number
    description: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServicesSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    service_name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    service_name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    service_name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to aggregate.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhereInput
    orderBy?: ServicesOrderByWithAggregationInput | ServicesOrderByWithAggregationInput[]
    by: ServicesScalarFieldEnum[] | ServicesScalarFieldEnum
    having?: ServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }

  export type ServicesGroupByOutputType = {
    id: number
    service_name: string
    description: string
    price: number
    created_at: Date
    updated_at: Date
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type ServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    labtest?: boolean | Services$labtestArgs<ExtArgs>
    bills?: boolean | Services$billsArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectScalar = {
    id?: boolean
    service_name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_name" | "description" | "price" | "created_at" | "updated_at", ExtArgs["result"]["services"]>
  export type ServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labtest?: boolean | Services$labtestArgs<ExtArgs>
    bills?: boolean | Services$billsArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Services"
    objects: {
      labtest: Prisma.$LabTestPayload<ExtArgs> | null
      bills: Prisma.$PatientBillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      service_name: string
      description: string
      price: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["services"]>
    composites: {}
  }

  type ServicesGetPayload<S extends boolean | null | undefined | ServicesDefaultArgs> = $Result.GetResult<Prisma.$ServicesPayload, S>

  type ServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface ServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Services'], meta: { name: 'Services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {ServicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesFindUniqueArgs>(args: SelectSubset<T, ServicesFindUniqueArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Services that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesFindFirstArgs>(args?: SelectSubset<T, ServicesFindFirstArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesFindManyArgs>(args?: SelectSubset<T, ServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Services.
     * @param {ServicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
     */
    create<T extends ServicesCreateArgs>(args: SelectSubset<T, ServicesCreateArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServicesCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesCreateManyArgs>(args?: SelectSubset<T, ServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServicesCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Services.
     * @param {ServicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
     */
    delete<T extends ServicesDeleteArgs>(args: SelectSubset<T, ServicesDeleteArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Services.
     * @param {ServicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesUpdateArgs>(args: SelectSubset<T, ServicesUpdateArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesDeleteManyArgs>(args?: SelectSubset<T, ServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesUpdateManyArgs>(args: SelectSubset<T, ServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServicesUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Services.
     * @param {ServicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
     */
    upsert<T extends ServicesUpsertArgs>(args: SelectSubset<T, ServicesUpsertArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServicesCountArgs>(
      args?: Subset<T, ServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Services model
   */
  readonly fields: ServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    labtest<T extends Services$labtestArgs<ExtArgs> = {}>(args?: Subset<T, Services$labtestArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bills<T extends Services$billsArgs<ExtArgs> = {}>(args?: Subset<T, Services$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Services model
   */
  interface ServicesFieldRefs {
    readonly id: FieldRef<"Services", 'Int'>
    readonly service_name: FieldRef<"Services", 'String'>
    readonly description: FieldRef<"Services", 'String'>
    readonly price: FieldRef<"Services", 'Float'>
    readonly created_at: FieldRef<"Services", 'DateTime'>
    readonly updated_at: FieldRef<"Services", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Services findUnique
   */
  export type ServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services findUniqueOrThrow
   */
  export type ServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services findFirst
   */
  export type ServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services findFirstOrThrow
   */
  export type ServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services findMany
   */
  export type ServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services create
   */
  export type ServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a Services.
     */
    data: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
  }

  /**
   * Services createMany
   */
  export type ServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServicesCreateManyInput | ServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Services createManyAndReturn
   */
  export type ServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServicesCreateManyInput | ServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Services update
   */
  export type ServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a Services.
     */
    data: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
    /**
     * Choose, which Services to update.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services updateMany
   */
  export type ServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Services updateManyAndReturn
   */
  export type ServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Services upsert
   */
  export type ServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the Services to update in case it exists.
     */
    where: ServicesWhereUniqueInput
    /**
     * In case the Services found by the `where` argument doesn't exist, create a new Services with this data.
     */
    create: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
    /**
     * In case the Services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
  }

  /**
   * Services delete
   */
  export type ServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter which Services to delete.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services deleteMany
   */
  export type ServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Services.labtest
   */
  export type Services$labtestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    where?: LabTestWhereInput
  }

  /**
   * Services.bills
   */
  export type Services$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBills
     */
    select?: PatientBillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientBills
     */
    omit?: PatientBillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBillsInclude<ExtArgs> | null
    where?: PatientBillsWhereInput
    orderBy?: PatientBillsOrderByWithRelationInput | PatientBillsOrderByWithRelationInput[]
    cursor?: PatientBillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientBillsScalarFieldEnum | PatientBillsScalarFieldEnum[]
  }

  /**
   * Services without action
   */
  export type ServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PatientScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    date_of_birth: 'date_of_birth',
    gender: 'gender',
    phone: 'phone',
    email: 'email',
    marital_status: 'marital_status',
    address: 'address',
    emergency_contact_name: 'emergency_contact_name',
    emergency_contact_number: 'emergency_contact_number',
    relation: 'relation',
    blood_group: 'blood_group',
    allergies: 'allergies',
    medical_conditions: 'medical_conditions',
    medical_history: 'medical_history',
    insurance_provider: 'insurance_provider',
    insurance_number: 'insurance_number',
    privacy_consent: 'privacy_consent',
    service_consent: 'service_consent',
    medical_consent: 'medical_consent',
    img: 'img',
    colorCode: 'colorCode',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    specialization: 'specialization',
    license_number: 'license_number',
    phone: 'phone',
    address: 'address',
    department: 'department',
    img: 'img',
    availability_status: 'availability_status',
    type: 'type',
    colorCode: 'colorCode',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const WorkingDaysScalarFieldEnum: {
    id: 'id',
    doctor_id: 'doctor_id',
    day: 'day',
    start_time: 'start_time',
    close_time: 'close_time',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WorkingDaysScalarFieldEnum = (typeof WorkingDaysScalarFieldEnum)[keyof typeof WorkingDaysScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    department: 'department',
    img: 'img',
    license_number: 'license_number',
    role: 'role',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    doctor_id: 'doctor_id',
    appointmentDate: 'appointmentDate',
    appointmentTime: 'appointmentTime',
    status: 'status',
    type: 'type',
    note: 'note',
    reason: 'reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bill_id: 'bill_id',
    patient_id: 'patient_id',
    appointment_Id: 'appointment_Id',
    bill_date: 'bill_date',
    payment_Date: 'payment_Date',
    discount: 'discount',
    total_amount: 'total_amount',
    amount_paid: 'amount_paid',
    payment_method: 'payment_method',
    status: 'status',
    receipt_number: 'receipt_number',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PatientBillsScalarFieldEnum: {
    id: 'id',
    bill_id: 'bill_id',
    service_id: 'service_id',
    service_date: 'service_date',
    quantity: 'quantity',
    unit_cost: 'unit_cost',
    total_cost: 'total_cost',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PatientBillsScalarFieldEnum = (typeof PatientBillsScalarFieldEnum)[keyof typeof PatientBillsScalarFieldEnum]


  export const LabTestScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    test_date: 'test_date',
    result: 'result',
    status: 'status',
    notes: 'notes',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LabTestScalarFieldEnum = (typeof LabTestScalarFieldEnum)[keyof typeof LabTestScalarFieldEnum]


  export const MedicalRecordsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    appointment_id: 'appointment_id',
    doctor_id: 'doctor_id',
    treatment_plan: 'treatment_plan',
    prescriptions: 'prescriptions',
    lab_request: 'lab_request',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MedicalRecordsScalarFieldEnum = (typeof MedicalRecordsScalarFieldEnum)[keyof typeof MedicalRecordsScalarFieldEnum]


  export const VitalSignsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    medical_id: 'medical_id',
    body_temperature: 'body_temperature',
    systolic: 'systolic',
    diastolic: 'diastolic',
    heartRate: 'heartRate',
    respiratoryRate: 'respiratoryRate',
    oxygen_saturation: 'oxygen_saturation',
    weight: 'weight',
    height: 'height',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VitalSignsScalarFieldEnum = (typeof VitalSignsScalarFieldEnum)[keyof typeof VitalSignsScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    medical_id: 'medical_id',
    diagnosis: 'diagnosis',
    doctor_id: 'doctor_id',
    symptoms: 'symptoms',
    notes: 'notes',
    prescribed_medications: 'prescribed_medications',
    follow_up_plan: 'follow_up_plan',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    record_id: 'record_id',
    action: 'action',
    details: 'details',
    model: 'model',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    staff_id: 'staff_id',
    rating: 'rating',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    service_name: 'service_name',
    description: 'description',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'GENDER'
   */
  export type EnumGENDERFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GENDER'>
    


  /**
   * Reference to a field of type 'GENDER[]'
   */
  export type ListEnumGENDERFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GENDER[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'JOBTYPE'
   */
  export type EnumJOBTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JOBTYPE'>
    


  /**
   * Reference to a field of type 'JOBTYPE[]'
   */
  export type ListEnumJOBTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JOBTYPE[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    first_name?: StringFilter<"Patient"> | string
    last_name?: StringFilter<"Patient"> | string
    date_of_birth?: DateTimeFilter<"Patient"> | Date | string
    gender?: EnumGENDERFilter<"Patient"> | $Enums.GENDER
    phone?: StringFilter<"Patient"> | string
    email?: StringFilter<"Patient"> | string
    marital_status?: StringFilter<"Patient"> | string
    address?: StringFilter<"Patient"> | string
    emergency_contact_name?: StringFilter<"Patient"> | string
    emergency_contact_number?: StringFilter<"Patient"> | string
    relation?: StringFilter<"Patient"> | string
    blood_group?: StringNullableFilter<"Patient"> | string | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    medical_conditions?: StringNullableFilter<"Patient"> | string | null
    medical_history?: StringNullableFilter<"Patient"> | string | null
    insurance_provider?: StringNullableFilter<"Patient"> | string | null
    insurance_number?: StringNullableFilter<"Patient"> | string | null
    privacy_consent?: BoolFilter<"Patient"> | boolean
    service_consent?: BoolFilter<"Patient"> | boolean
    medical_consent?: BoolFilter<"Patient"> | boolean
    img?: StringNullableFilter<"Patient"> | string | null
    colorCode?: StringNullableFilter<"Patient"> | string | null
    created_at?: DateTimeFilter<"Patient"> | Date | string
    updated_at?: DateTimeFilter<"Patient"> | Date | string
    appointments?: AppointmentListRelationFilter
    medical?: MedicalRecordsListRelationFilter
    payments?: PaymentListRelationFilter
    ratings?: RatingListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    marital_status?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_number?: SortOrder
    relation?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medical_conditions?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    insurance_provider?: SortOrderInput | SortOrder
    insurance_number?: SortOrderInput | SortOrder
    privacy_consent?: SortOrder
    service_consent?: SortOrder
    medical_consent?: SortOrder
    img?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    medical?: MedicalRecordsOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    first_name?: StringFilter<"Patient"> | string
    last_name?: StringFilter<"Patient"> | string
    date_of_birth?: DateTimeFilter<"Patient"> | Date | string
    gender?: EnumGENDERFilter<"Patient"> | $Enums.GENDER
    phone?: StringFilter<"Patient"> | string
    marital_status?: StringFilter<"Patient"> | string
    address?: StringFilter<"Patient"> | string
    emergency_contact_name?: StringFilter<"Patient"> | string
    emergency_contact_number?: StringFilter<"Patient"> | string
    relation?: StringFilter<"Patient"> | string
    blood_group?: StringNullableFilter<"Patient"> | string | null
    allergies?: StringNullableFilter<"Patient"> | string | null
    medical_conditions?: StringNullableFilter<"Patient"> | string | null
    medical_history?: StringNullableFilter<"Patient"> | string | null
    insurance_provider?: StringNullableFilter<"Patient"> | string | null
    insurance_number?: StringNullableFilter<"Patient"> | string | null
    privacy_consent?: BoolFilter<"Patient"> | boolean
    service_consent?: BoolFilter<"Patient"> | boolean
    medical_consent?: BoolFilter<"Patient"> | boolean
    img?: StringNullableFilter<"Patient"> | string | null
    colorCode?: StringNullableFilter<"Patient"> | string | null
    created_at?: DateTimeFilter<"Patient"> | Date | string
    updated_at?: DateTimeFilter<"Patient"> | Date | string
    appointments?: AppointmentListRelationFilter
    medical?: MedicalRecordsListRelationFilter
    payments?: PaymentListRelationFilter
    ratings?: RatingListRelationFilter
  }, "id" | "email">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    marital_status?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_number?: SortOrder
    relation?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medical_conditions?: SortOrderInput | SortOrder
    medical_history?: SortOrderInput | SortOrder
    insurance_provider?: SortOrderInput | SortOrder
    insurance_number?: SortOrderInput | SortOrder
    privacy_consent?: SortOrder
    service_consent?: SortOrder
    medical_consent?: SortOrder
    img?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    first_name?: StringWithAggregatesFilter<"Patient"> | string
    last_name?: StringWithAggregatesFilter<"Patient"> | string
    date_of_birth?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    gender?: EnumGENDERWithAggregatesFilter<"Patient"> | $Enums.GENDER
    phone?: StringWithAggregatesFilter<"Patient"> | string
    email?: StringWithAggregatesFilter<"Patient"> | string
    marital_status?: StringWithAggregatesFilter<"Patient"> | string
    address?: StringWithAggregatesFilter<"Patient"> | string
    emergency_contact_name?: StringWithAggregatesFilter<"Patient"> | string
    emergency_contact_number?: StringWithAggregatesFilter<"Patient"> | string
    relation?: StringWithAggregatesFilter<"Patient"> | string
    blood_group?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    medical_conditions?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    medical_history?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insurance_provider?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insurance_number?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    privacy_consent?: BoolWithAggregatesFilter<"Patient"> | boolean
    service_consent?: BoolWithAggregatesFilter<"Patient"> | boolean
    medical_consent?: BoolWithAggregatesFilter<"Patient"> | boolean
    img?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    colorCode?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: StringFilter<"Doctor"> | string
    email?: StringFilter<"Doctor"> | string
    name?: StringFilter<"Doctor"> | string
    specialization?: StringFilter<"Doctor"> | string
    license_number?: StringFilter<"Doctor"> | string
    phone?: StringFilter<"Doctor"> | string
    address?: StringFilter<"Doctor"> | string
    department?: StringNullableFilter<"Doctor"> | string | null
    img?: StringNullableFilter<"Doctor"> | string | null
    availability_status?: StringNullableFilter<"Doctor"> | string | null
    type?: EnumJOBTYPEFilter<"Doctor"> | $Enums.JOBTYPE
    colorCode?: StringNullableFilter<"Doctor"> | string | null
    created_at?: DateTimeFilter<"Doctor"> | Date | string
    updated_at?: DateTimeFilter<"Doctor"> | Date | string
    working_days?: WorkingDaysListRelationFilter
    appointments?: AppointmentListRelationFilter
    ratings?: RatingListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    license_number?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    availability_status?: SortOrderInput | SortOrder
    type?: SortOrder
    colorCode?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    working_days?: WorkingDaysOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    diagnosis?: DiagnosisOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    name?: StringFilter<"Doctor"> | string
    specialization?: StringFilter<"Doctor"> | string
    license_number?: StringFilter<"Doctor"> | string
    phone?: StringFilter<"Doctor"> | string
    address?: StringFilter<"Doctor"> | string
    department?: StringNullableFilter<"Doctor"> | string | null
    img?: StringNullableFilter<"Doctor"> | string | null
    availability_status?: StringNullableFilter<"Doctor"> | string | null
    type?: EnumJOBTYPEFilter<"Doctor"> | $Enums.JOBTYPE
    colorCode?: StringNullableFilter<"Doctor"> | string | null
    created_at?: DateTimeFilter<"Doctor"> | Date | string
    updated_at?: DateTimeFilter<"Doctor"> | Date | string
    working_days?: WorkingDaysListRelationFilter
    appointments?: AppointmentListRelationFilter
    ratings?: RatingListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
  }, "id" | "email">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    license_number?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    availability_status?: SortOrderInput | SortOrder
    type?: SortOrder
    colorCode?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Doctor"> | string
    email?: StringWithAggregatesFilter<"Doctor"> | string
    name?: StringWithAggregatesFilter<"Doctor"> | string
    specialization?: StringWithAggregatesFilter<"Doctor"> | string
    license_number?: StringWithAggregatesFilter<"Doctor"> | string
    phone?: StringWithAggregatesFilter<"Doctor"> | string
    address?: StringWithAggregatesFilter<"Doctor"> | string
    department?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    img?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    availability_status?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    type?: EnumJOBTYPEWithAggregatesFilter<"Doctor"> | $Enums.JOBTYPE
    colorCode?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
  }

  export type WorkingDaysWhereInput = {
    AND?: WorkingDaysWhereInput | WorkingDaysWhereInput[]
    OR?: WorkingDaysWhereInput[]
    NOT?: WorkingDaysWhereInput | WorkingDaysWhereInput[]
    id?: IntFilter<"WorkingDays"> | number
    doctor_id?: StringFilter<"WorkingDays"> | string
    day?: StringFilter<"WorkingDays"> | string
    start_time?: StringFilter<"WorkingDays"> | string
    close_time?: StringFilter<"WorkingDays"> | string
    created_at?: DateTimeFilter<"WorkingDays"> | Date | string
    updated_at?: DateTimeFilter<"WorkingDays"> | Date | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }

  export type WorkingDaysOrderByWithRelationInput = {
    id?: SortOrder
    doctor_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    close_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
  }

  export type WorkingDaysWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkingDaysWhereInput | WorkingDaysWhereInput[]
    OR?: WorkingDaysWhereInput[]
    NOT?: WorkingDaysWhereInput | WorkingDaysWhereInput[]
    doctor_id?: StringFilter<"WorkingDays"> | string
    day?: StringFilter<"WorkingDays"> | string
    start_time?: StringFilter<"WorkingDays"> | string
    close_time?: StringFilter<"WorkingDays"> | string
    created_at?: DateTimeFilter<"WorkingDays"> | Date | string
    updated_at?: DateTimeFilter<"WorkingDays"> | Date | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }, "id">

  export type WorkingDaysOrderByWithAggregationInput = {
    id?: SortOrder
    doctor_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    close_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WorkingDaysCountOrderByAggregateInput
    _avg?: WorkingDaysAvgOrderByAggregateInput
    _max?: WorkingDaysMaxOrderByAggregateInput
    _min?: WorkingDaysMinOrderByAggregateInput
    _sum?: WorkingDaysSumOrderByAggregateInput
  }

  export type WorkingDaysScalarWhereWithAggregatesInput = {
    AND?: WorkingDaysScalarWhereWithAggregatesInput | WorkingDaysScalarWhereWithAggregatesInput[]
    OR?: WorkingDaysScalarWhereWithAggregatesInput[]
    NOT?: WorkingDaysScalarWhereWithAggregatesInput | WorkingDaysScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkingDays"> | number
    doctor_id?: StringWithAggregatesFilter<"WorkingDays"> | string
    day?: StringWithAggregatesFilter<"WorkingDays"> | string
    start_time?: StringWithAggregatesFilter<"WorkingDays"> | string
    close_time?: StringWithAggregatesFilter<"WorkingDays"> | string
    created_at?: DateTimeWithAggregatesFilter<"WorkingDays"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WorkingDays"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    email?: StringFilter<"Staff"> | string
    phone?: StringFilter<"Staff"> | string
    address?: StringFilter<"Staff"> | string
    department?: StringNullableFilter<"Staff"> | string | null
    img?: StringNullableFilter<"Staff"> | string | null
    license_number?: StringNullableFilter<"Staff"> | string | null
    role?: EnumRoleFilter<"Staff"> | $Enums.Role
    status?: EnumStatusFilter<"Staff"> | $Enums.Status
    created_at?: DateTimeFilter<"Staff"> | Date | string
    updated_at?: DateTimeFilter<"Staff"> | Date | string
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    license_number?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    name?: StringFilter<"Staff"> | string
    phone?: StringFilter<"Staff"> | string
    address?: StringFilter<"Staff"> | string
    department?: StringNullableFilter<"Staff"> | string | null
    img?: StringNullableFilter<"Staff"> | string | null
    license_number?: StringNullableFilter<"Staff"> | string | null
    role?: EnumRoleFilter<"Staff"> | $Enums.Role
    status?: EnumStatusFilter<"Staff"> | $Enums.Status
    created_at?: DateTimeFilter<"Staff"> | Date | string
    updated_at?: DateTimeFilter<"Staff"> | Date | string
  }, "id" | "email">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    license_number?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    name?: StringWithAggregatesFilter<"Staff"> | string
    email?: StringWithAggregatesFilter<"Staff"> | string
    phone?: StringWithAggregatesFilter<"Staff"> | string
    address?: StringWithAggregatesFilter<"Staff"> | string
    department?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    img?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    license_number?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    role?: EnumRoleWithAggregatesFilter<"Staff"> | $Enums.Role
    status?: EnumStatusWithAggregatesFilter<"Staff"> | $Enums.Status
    created_at?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patient_id?: StringFilter<"Appointment"> | string
    doctor_id?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: StringFilter<"Appointment"> | string
    note?: StringNullableFilter<"Appointment"> | string | null
    reason?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    updated_at?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    bills?: PaymentListRelationFilter
    medical?: MedicalRecordsListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    bills?: PaymentOrderByRelationAggregateInput
    medical?: MedicalRecordsOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patient_id?: StringFilter<"Appointment"> | string
    doctor_id?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: StringFilter<"Appointment"> | string
    note?: StringNullableFilter<"Appointment"> | string | null
    reason?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    updated_at?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    bills?: PaymentListRelationFilter
    medical?: MedicalRecordsListRelationFilter
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    patient_id?: StringWithAggregatesFilter<"Appointment"> | string
    doctor_id?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    appointmentTime?: StringWithAggregatesFilter<"Appointment"> | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: StringWithAggregatesFilter<"Appointment"> | string
    note?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bill_id?: IntNullableFilter<"Payment"> | number | null
    patient_id?: StringFilter<"Payment"> | string
    appointment_Id?: IntFilter<"Payment"> | number
    bill_date?: DateTimeFilter<"Payment"> | Date | string
    payment_Date?: DateTimeFilter<"Payment"> | Date | string
    discount?: FloatFilter<"Payment"> | number
    total_amount?: FloatFilter<"Payment"> | number
    amount_paid?: FloatFilter<"Payment"> | number
    payment_method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    receipt_number?: IntFilter<"Payment"> | number
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    bills?: PatientBillsListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bill_id?: SortOrderInput | SortOrder
    patient_id?: SortOrder
    appointment_Id?: SortOrder
    bill_date?: SortOrder
    payment_Date?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    receipt_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    bills?: PatientBillsOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    appointment_Id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bill_id?: IntNullableFilter<"Payment"> | number | null
    patient_id?: StringFilter<"Payment"> | string
    bill_date?: DateTimeFilter<"Payment"> | Date | string
    payment_Date?: DateTimeFilter<"Payment"> | Date | string
    discount?: FloatFilter<"Payment"> | number
    total_amount?: FloatFilter<"Payment"> | number
    amount_paid?: FloatFilter<"Payment"> | number
    payment_method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    receipt_number?: IntFilter<"Payment"> | number
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    bills?: PatientBillsListRelationFilter
  }, "id" | "appointment_Id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bill_id?: SortOrderInput | SortOrder
    patient_id?: SortOrder
    appointment_Id?: SortOrder
    bill_date?: SortOrder
    payment_Date?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    receipt_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bill_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    patient_id?: StringWithAggregatesFilter<"Payment"> | string
    appointment_Id?: IntWithAggregatesFilter<"Payment"> | number
    bill_date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    payment_Date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    discount?: FloatWithAggregatesFilter<"Payment"> | number
    total_amount?: FloatWithAggregatesFilter<"Payment"> | number
    amount_paid?: FloatWithAggregatesFilter<"Payment"> | number
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    receipt_number?: IntWithAggregatesFilter<"Payment"> | number
    created_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PatientBillsWhereInput = {
    AND?: PatientBillsWhereInput | PatientBillsWhereInput[]
    OR?: PatientBillsWhereInput[]
    NOT?: PatientBillsWhereInput | PatientBillsWhereInput[]
    id?: IntFilter<"PatientBills"> | number
    bill_id?: IntFilter<"PatientBills"> | number
    service_id?: IntFilter<"PatientBills"> | number
    service_date?: DateTimeFilter<"PatientBills"> | Date | string
    quantity?: IntFilter<"PatientBills"> | number
    unit_cost?: FloatFilter<"PatientBills"> | number
    total_cost?: FloatFilter<"PatientBills"> | number
    created_at?: DateTimeFilter<"PatientBills"> | Date | string
    updated_at?: DateTimeFilter<"PatientBills"> | Date | string
    service?: XOR<ServicesScalarRelationFilter, ServicesWhereInput>
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type PatientBillsOrderByWithRelationInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    service_date?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service?: ServicesOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type PatientBillsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientBillsWhereInput | PatientBillsWhereInput[]
    OR?: PatientBillsWhereInput[]
    NOT?: PatientBillsWhereInput | PatientBillsWhereInput[]
    bill_id?: IntFilter<"PatientBills"> | number
    service_id?: IntFilter<"PatientBills"> | number
    service_date?: DateTimeFilter<"PatientBills"> | Date | string
    quantity?: IntFilter<"PatientBills"> | number
    unit_cost?: FloatFilter<"PatientBills"> | number
    total_cost?: FloatFilter<"PatientBills"> | number
    created_at?: DateTimeFilter<"PatientBills"> | Date | string
    updated_at?: DateTimeFilter<"PatientBills"> | Date | string
    service?: XOR<ServicesScalarRelationFilter, ServicesWhereInput>
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id">

  export type PatientBillsOrderByWithAggregationInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    service_date?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PatientBillsCountOrderByAggregateInput
    _avg?: PatientBillsAvgOrderByAggregateInput
    _max?: PatientBillsMaxOrderByAggregateInput
    _min?: PatientBillsMinOrderByAggregateInput
    _sum?: PatientBillsSumOrderByAggregateInput
  }

  export type PatientBillsScalarWhereWithAggregatesInput = {
    AND?: PatientBillsScalarWhereWithAggregatesInput | PatientBillsScalarWhereWithAggregatesInput[]
    OR?: PatientBillsScalarWhereWithAggregatesInput[]
    NOT?: PatientBillsScalarWhereWithAggregatesInput | PatientBillsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientBills"> | number
    bill_id?: IntWithAggregatesFilter<"PatientBills"> | number
    service_id?: IntWithAggregatesFilter<"PatientBills"> | number
    service_date?: DateTimeWithAggregatesFilter<"PatientBills"> | Date | string
    quantity?: IntWithAggregatesFilter<"PatientBills"> | number
    unit_cost?: FloatWithAggregatesFilter<"PatientBills"> | number
    total_cost?: FloatWithAggregatesFilter<"PatientBills"> | number
    created_at?: DateTimeWithAggregatesFilter<"PatientBills"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PatientBills"> | Date | string
  }

  export type LabTestWhereInput = {
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    id?: IntFilter<"LabTest"> | number
    record_id?: IntFilter<"LabTest"> | number
    test_date?: DateTimeFilter<"LabTest"> | Date | string
    result?: StringFilter<"LabTest"> | string
    status?: StringFilter<"LabTest"> | string
    notes?: StringFilter<"LabTest"> | string
    service_id?: IntFilter<"LabTest"> | number
    created_at?: DateTimeFilter<"LabTest"> | Date | string
    updated_at?: DateTimeFilter<"LabTest"> | Date | string
    services?: XOR<ServicesScalarRelationFilter, ServicesWhereInput>
    medical_record?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
  }

  export type LabTestOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrder
    test_date?: SortOrder
    result?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: ServicesOrderByWithRelationInput
    medical_record?: MedicalRecordsOrderByWithRelationInput
  }

  export type LabTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    service_id?: number
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    record_id?: IntFilter<"LabTest"> | number
    test_date?: DateTimeFilter<"LabTest"> | Date | string
    result?: StringFilter<"LabTest"> | string
    status?: StringFilter<"LabTest"> | string
    notes?: StringFilter<"LabTest"> | string
    created_at?: DateTimeFilter<"LabTest"> | Date | string
    updated_at?: DateTimeFilter<"LabTest"> | Date | string
    services?: XOR<ServicesScalarRelationFilter, ServicesWhereInput>
    medical_record?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
  }, "id" | "service_id">

  export type LabTestOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrder
    test_date?: SortOrder
    result?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LabTestCountOrderByAggregateInput
    _avg?: LabTestAvgOrderByAggregateInput
    _max?: LabTestMaxOrderByAggregateInput
    _min?: LabTestMinOrderByAggregateInput
    _sum?: LabTestSumOrderByAggregateInput
  }

  export type LabTestScalarWhereWithAggregatesInput = {
    AND?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    OR?: LabTestScalarWhereWithAggregatesInput[]
    NOT?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabTest"> | number
    record_id?: IntWithAggregatesFilter<"LabTest"> | number
    test_date?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
    result?: StringWithAggregatesFilter<"LabTest"> | string
    status?: StringWithAggregatesFilter<"LabTest"> | string
    notes?: StringWithAggregatesFilter<"LabTest"> | string
    service_id?: IntWithAggregatesFilter<"LabTest"> | number
    created_at?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
  }

  export type MedicalRecordsWhereInput = {
    AND?: MedicalRecordsWhereInput | MedicalRecordsWhereInput[]
    OR?: MedicalRecordsWhereInput[]
    NOT?: MedicalRecordsWhereInput | MedicalRecordsWhereInput[]
    id?: IntFilter<"MedicalRecords"> | number
    patient_id?: StringFilter<"MedicalRecords"> | string
    appointment_id?: IntFilter<"MedicalRecords"> | number
    doctor_id?: StringFilter<"MedicalRecords"> | string
    treatment_plan?: StringNullableFilter<"MedicalRecords"> | string | null
    prescriptions?: StringNullableFilter<"MedicalRecords"> | string | null
    lab_request?: StringNullableFilter<"MedicalRecords"> | string | null
    notes?: StringNullableFilter<"MedicalRecords"> | string | null
    created_at?: DateTimeFilter<"MedicalRecords"> | Date | string
    updated_at?: DateTimeFilter<"MedicalRecords"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lab_test?: LabTestListRelationFilter
    vital_signs?: VitalSignsListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
  }

  export type MedicalRecordsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    appointment_id?: SortOrder
    doctor_id?: SortOrder
    treatment_plan?: SortOrderInput | SortOrder
    prescriptions?: SortOrderInput | SortOrder
    lab_request?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    lab_test?: LabTestOrderByRelationAggregateInput
    vital_signs?: VitalSignsOrderByRelationAggregateInput
    diagnosis?: DiagnosisOrderByRelationAggregateInput
  }

  export type MedicalRecordsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicalRecordsWhereInput | MedicalRecordsWhereInput[]
    OR?: MedicalRecordsWhereInput[]
    NOT?: MedicalRecordsWhereInput | MedicalRecordsWhereInput[]
    patient_id?: StringFilter<"MedicalRecords"> | string
    appointment_id?: IntFilter<"MedicalRecords"> | number
    doctor_id?: StringFilter<"MedicalRecords"> | string
    treatment_plan?: StringNullableFilter<"MedicalRecords"> | string | null
    prescriptions?: StringNullableFilter<"MedicalRecords"> | string | null
    lab_request?: StringNullableFilter<"MedicalRecords"> | string | null
    notes?: StringNullableFilter<"MedicalRecords"> | string | null
    created_at?: DateTimeFilter<"MedicalRecords"> | Date | string
    updated_at?: DateTimeFilter<"MedicalRecords"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lab_test?: LabTestListRelationFilter
    vital_signs?: VitalSignsListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
  }, "id">

  export type MedicalRecordsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    appointment_id?: SortOrder
    doctor_id?: SortOrder
    treatment_plan?: SortOrderInput | SortOrder
    prescriptions?: SortOrderInput | SortOrder
    lab_request?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MedicalRecordsCountOrderByAggregateInput
    _avg?: MedicalRecordsAvgOrderByAggregateInput
    _max?: MedicalRecordsMaxOrderByAggregateInput
    _min?: MedicalRecordsMinOrderByAggregateInput
    _sum?: MedicalRecordsSumOrderByAggregateInput
  }

  export type MedicalRecordsScalarWhereWithAggregatesInput = {
    AND?: MedicalRecordsScalarWhereWithAggregatesInput | MedicalRecordsScalarWhereWithAggregatesInput[]
    OR?: MedicalRecordsScalarWhereWithAggregatesInput[]
    NOT?: MedicalRecordsScalarWhereWithAggregatesInput | MedicalRecordsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicalRecords"> | number
    patient_id?: StringWithAggregatesFilter<"MedicalRecords"> | string
    appointment_id?: IntWithAggregatesFilter<"MedicalRecords"> | number
    doctor_id?: StringWithAggregatesFilter<"MedicalRecords"> | string
    treatment_plan?: StringNullableWithAggregatesFilter<"MedicalRecords"> | string | null
    prescriptions?: StringNullableWithAggregatesFilter<"MedicalRecords"> | string | null
    lab_request?: StringNullableWithAggregatesFilter<"MedicalRecords"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MedicalRecords"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MedicalRecords"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MedicalRecords"> | Date | string
  }

  export type VitalSignsWhereInput = {
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    id?: IntFilter<"VitalSigns"> | number
    patient_id?: StringFilter<"VitalSigns"> | string
    medical_id?: IntFilter<"VitalSigns"> | number
    body_temperature?: FloatFilter<"VitalSigns"> | number
    systolic?: IntFilter<"VitalSigns"> | number
    diastolic?: IntFilter<"VitalSigns"> | number
    heartRate?: StringFilter<"VitalSigns"> | string
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    oxygen_saturation?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    created_at?: DateTimeFilter<"VitalSigns"> | Date | string
    updated_at?: DateTimeFilter<"VitalSigns"> | Date | string
    medical?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
  }

  export type VitalSignsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    oxygen_saturation?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    medical?: MedicalRecordsOrderByWithRelationInput
  }

  export type VitalSignsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    patient_id?: StringFilter<"VitalSigns"> | string
    medical_id?: IntFilter<"VitalSigns"> | number
    body_temperature?: FloatFilter<"VitalSigns"> | number
    systolic?: IntFilter<"VitalSigns"> | number
    diastolic?: IntFilter<"VitalSigns"> | number
    heartRate?: StringFilter<"VitalSigns"> | string
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    oxygen_saturation?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    created_at?: DateTimeFilter<"VitalSigns"> | Date | string
    updated_at?: DateTimeFilter<"VitalSigns"> | Date | string
    medical?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
  }, "id">

  export type VitalSignsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    oxygen_saturation?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VitalSignsCountOrderByAggregateInput
    _avg?: VitalSignsAvgOrderByAggregateInput
    _max?: VitalSignsMaxOrderByAggregateInput
    _min?: VitalSignsMinOrderByAggregateInput
    _sum?: VitalSignsSumOrderByAggregateInput
  }

  export type VitalSignsScalarWhereWithAggregatesInput = {
    AND?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    OR?: VitalSignsScalarWhereWithAggregatesInput[]
    NOT?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VitalSigns"> | number
    patient_id?: StringWithAggregatesFilter<"VitalSigns"> | string
    medical_id?: IntWithAggregatesFilter<"VitalSigns"> | number
    body_temperature?: FloatWithAggregatesFilter<"VitalSigns"> | number
    systolic?: IntWithAggregatesFilter<"VitalSigns"> | number
    diastolic?: IntWithAggregatesFilter<"VitalSigns"> | number
    heartRate?: StringWithAggregatesFilter<"VitalSigns"> | string
    respiratoryRate?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    oxygen_saturation?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    height?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"VitalSigns"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VitalSigns"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: IntFilter<"Diagnosis"> | number
    patient_id?: StringFilter<"Diagnosis"> | string
    medical_id?: IntFilter<"Diagnosis"> | number
    diagnosis?: StringFilter<"Diagnosis"> | string
    doctor_id?: StringFilter<"Diagnosis"> | string
    symptoms?: StringFilter<"Diagnosis"> | string
    notes?: StringNullableFilter<"Diagnosis"> | string | null
    prescribed_medications?: StringNullableFilter<"Diagnosis"> | string | null
    follow_up_plan?: StringNullableFilter<"Diagnosis"> | string | null
    created_at?: DateTimeFilter<"Diagnosis"> | Date | string
    updated_at?: DateTimeFilter<"Diagnosis"> | Date | string
    medical?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    diagnosis?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrderInput | SortOrder
    prescribed_medications?: SortOrderInput | SortOrder
    follow_up_plan?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    medical?: MedicalRecordsOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    patient_id?: StringFilter<"Diagnosis"> | string
    medical_id?: IntFilter<"Diagnosis"> | number
    diagnosis?: StringFilter<"Diagnosis"> | string
    doctor_id?: StringFilter<"Diagnosis"> | string
    symptoms?: StringFilter<"Diagnosis"> | string
    notes?: StringNullableFilter<"Diagnosis"> | string | null
    prescribed_medications?: StringNullableFilter<"Diagnosis"> | string | null
    follow_up_plan?: StringNullableFilter<"Diagnosis"> | string | null
    created_at?: DateTimeFilter<"Diagnosis"> | Date | string
    updated_at?: DateTimeFilter<"Diagnosis"> | Date | string
    medical?: XOR<MedicalRecordsScalarRelationFilter, MedicalRecordsWhereInput>
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
  }, "id">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    diagnosis?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrderInput | SortOrder
    prescribed_medications?: SortOrderInput | SortOrder
    follow_up_plan?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _avg?: DiagnosisAvgOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
    _sum?: DiagnosisSumOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diagnosis"> | number
    patient_id?: StringWithAggregatesFilter<"Diagnosis"> | string
    medical_id?: IntWithAggregatesFilter<"Diagnosis"> | number
    diagnosis?: StringWithAggregatesFilter<"Diagnosis"> | string
    doctor_id?: StringWithAggregatesFilter<"Diagnosis"> | string
    symptoms?: StringWithAggregatesFilter<"Diagnosis"> | string
    notes?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    prescribed_medications?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    follow_up_plan?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    user_id?: StringFilter<"AuditLog"> | string
    record_id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    model?: StringFilter<"AuditLog"> | string
    created_at?: DateTimeFilter<"AuditLog"> | Date | string
    updated_at?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    record_id?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    user_id?: StringFilter<"AuditLog"> | string
    record_id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    model?: StringFilter<"AuditLog"> | string
    created_at?: DateTimeFilter<"AuditLog"> | Date | string
    updated_at?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    record_id?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    user_id?: StringWithAggregatesFilter<"AuditLog"> | string
    record_id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    model?: StringWithAggregatesFilter<"AuditLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: IntFilter<"Rating"> | number
    patient_id?: StringFilter<"Rating"> | string
    staff_id?: StringFilter<"Rating"> | string
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    created_at?: DateTimeFilter<"Rating"> | Date | string
    updated_at?: DateTimeFilter<"Rating"> | Date | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    patient_id?: StringFilter<"Rating"> | string
    staff_id?: StringFilter<"Rating"> | string
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    created_at?: DateTimeFilter<"Rating"> | Date | string
    updated_at?: DateTimeFilter<"Rating"> | Date | string
    doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rating"> | number
    patient_id?: StringWithAggregatesFilter<"Rating"> | string
    staff_id?: StringWithAggregatesFilter<"Rating"> | string
    rating?: IntWithAggregatesFilter<"Rating"> | number
    comment?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type ServicesWhereInput = {
    AND?: ServicesWhereInput | ServicesWhereInput[]
    OR?: ServicesWhereInput[]
    NOT?: ServicesWhereInput | ServicesWhereInput[]
    id?: IntFilter<"Services"> | number
    service_name?: StringFilter<"Services"> | string
    description?: StringFilter<"Services"> | string
    price?: FloatFilter<"Services"> | number
    created_at?: DateTimeFilter<"Services"> | Date | string
    updated_at?: DateTimeFilter<"Services"> | Date | string
    labtest?: XOR<LabTestNullableScalarRelationFilter, LabTestWhereInput> | null
    bills?: PatientBillsListRelationFilter
  }

  export type ServicesOrderByWithRelationInput = {
    id?: SortOrder
    service_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    labtest?: LabTestOrderByWithRelationInput
    bills?: PatientBillsOrderByRelationAggregateInput
  }

  export type ServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServicesWhereInput | ServicesWhereInput[]
    OR?: ServicesWhereInput[]
    NOT?: ServicesWhereInput | ServicesWhereInput[]
    service_name?: StringFilter<"Services"> | string
    description?: StringFilter<"Services"> | string
    price?: FloatFilter<"Services"> | number
    created_at?: DateTimeFilter<"Services"> | Date | string
    updated_at?: DateTimeFilter<"Services"> | Date | string
    labtest?: XOR<LabTestNullableScalarRelationFilter, LabTestWhereInput> | null
    bills?: PatientBillsListRelationFilter
  }, "id">

  export type ServicesOrderByWithAggregationInput = {
    id?: SortOrder
    service_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ServicesCountOrderByAggregateInput
    _avg?: ServicesAvgOrderByAggregateInput
    _max?: ServicesMaxOrderByAggregateInput
    _min?: ServicesMinOrderByAggregateInput
    _sum?: ServicesSumOrderByAggregateInput
  }

  export type ServicesScalarWhereWithAggregatesInput = {
    AND?: ServicesScalarWhereWithAggregatesInput | ServicesScalarWhereWithAggregatesInput[]
    OR?: ServicesScalarWhereWithAggregatesInput[]
    NOT?: ServicesScalarWhereWithAggregatesInput | ServicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Services"> | number
    service_name?: StringWithAggregatesFilter<"Services"> | string
    description?: StringWithAggregatesFilter<"Services"> | string
    price?: FloatWithAggregatesFilter<"Services"> | number
    created_at?: DateTimeWithAggregatesFilter<"Services"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Services"> | Date | string
  }

  export type PatientCreateInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    ratings?: RatingCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    ratings?: RatingUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    ratings?: RatingUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorCreateInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    ratings?: RatingCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    ratings?: RatingUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysCreateInput = {
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
    doctor: DoctorCreateNestedOneWithoutWorking_daysInput
  }

  export type WorkingDaysUncheckedCreateInput = {
    id?: number
    doctor_id: string
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkingDaysUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutWorking_daysNestedInput
  }

  export type WorkingDaysUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysCreateManyInput = {
    id?: number
    doctor_id: string
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkingDaysUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id: string
    name: string
    email: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    license_number?: string | null
    role: $Enums.Role
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StaffUncheckedCreateInput = {
    id: string
    name: string
    email: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    license_number?: string | null
    role: $Enums.Role
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyInput = {
    id: string
    name: string
    email: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    license_number?: string | null
    role: $Enums.Role
    status?: $Enums.Status
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    license_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    bills?: PaymentCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    patient_id: string
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    bills?: PaymentUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: number
    patient_id: string
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    bill_id?: number | null
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutBillsInput
    patient: PatientCreateNestedOneWithoutPaymentsInput
    bills?: PatientBillsCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bill_id?: number | null
    patient_id: string
    appointment_Id: number
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PatientBillsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutBillsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPaymentsNestedInput
    bills?: PatientBillsUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_Id?: IntFieldUpdateOperationsInput | number
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PatientBillsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: number
    bill_id?: number | null
    patient_id: string
    appointment_Id: number
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_Id?: IntFieldUpdateOperationsInput | number
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsCreateInput = {
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
    service: ServicesCreateNestedOneWithoutBillsInput
    payment: PaymentCreateNestedOneWithoutBillsInput
  }

  export type PatientBillsUncheckedCreateInput = {
    id?: number
    bill_id: number
    service_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsUpdateInput = {
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServicesUpdateOneRequiredWithoutBillsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBillsNestedInput
  }

  export type PatientBillsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsCreateManyInput = {
    id?: number
    bill_id: number
    service_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsUpdateManyMutationInput = {
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestCreateInput = {
    test_date: Date | string
    result: string
    status: string
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
    services: ServicesCreateNestedOneWithoutLabtestInput
    medical_record: MedicalRecordsCreateNestedOneWithoutLab_testInput
  }

  export type LabTestUncheckedCreateInput = {
    id?: number
    record_id: number
    test_date: Date | string
    result: string
    status: string
    notes: string
    service_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabTestUpdateInput = {
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicesUpdateOneRequiredWithoutLabtestNestedInput
    medical_record?: MedicalRecordsUpdateOneRequiredWithoutLab_testNestedInput
  }

  export type LabTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestCreateManyInput = {
    id?: number
    record_id: number
    test_date: Date | string
    result: string
    status: string
    notes: string
    service_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabTestUpdateManyMutationInput = {
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordsCreateInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutMedicalInput
    patient: PatientCreateNestedOneWithoutMedicalInput
    lab_test?: LabTestCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateInput = {
    id?: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lab_test?: LabTestUncheckedCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsUncheckedCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUpdateInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutMedicalNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalNestedInput
    lab_test?: LabTestUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lab_test?: LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsCreateManyInput = {
    id?: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MedicalRecordsUpdateManyMutationInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsCreateInput = {
    patient_id: string
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    medical: MedicalRecordsCreateNestedOneWithoutVital_signsInput
  }

  export type VitalSignsUncheckedCreateInput = {
    id?: number
    patient_id: string
    medical_id: number
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VitalSignsUpdateInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUpdateOneRequiredWithoutVital_signsNestedInput
  }

  export type VitalSignsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsCreateManyInput = {
    id?: number
    patient_id: string
    medical_id: number
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VitalSignsUpdateManyMutationInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    patient_id: string
    diagnosis: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    medical: MedicalRecordsCreateNestedOneWithoutDiagnosisInput
    doctor: DoctorCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: number
    patient_id: string
    medical_id: number
    diagnosis: string
    doctor_id: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisUpdateInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUpdateOneRequiredWithoutDiagnosisNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateManyInput = {
    id?: number
    patient_id: string
    medical_id: number
    diagnosis: string
    doctor_id: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    user_id: string
    record_id: string
    action: string
    details?: string | null
    model: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    user_id: string
    record_id: string
    action: string
    details?: string | null
    model: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AuditLogUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    user_id: string
    record_id: string
    action: string
    details?: string | null
    model: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    doctor: DoctorCreateNestedOneWithoutRatingsInput
    patient: PatientCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: number
    patient_id: string
    staff_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutRatingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    staff_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: number
    patient_id: string
    staff_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    staff_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesCreateInput = {
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    labtest?: LabTestCreateNestedOneWithoutServicesInput
    bills?: PatientBillsCreateNestedManyWithoutServiceInput
  }

  export type ServicesUncheckedCreateInput = {
    id?: number
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    labtest?: LabTestUncheckedCreateNestedOneWithoutServicesInput
    bills?: PatientBillsUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServicesUpdateInput = {
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    labtest?: LabTestUpdateOneWithoutServicesNestedInput
    bills?: PatientBillsUpdateManyWithoutServiceNestedInput
  }

  export type ServicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    labtest?: LabTestUncheckedUpdateOneWithoutServicesNestedInput
    bills?: PatientBillsUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServicesCreateManyInput = {
    id?: number
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServicesUpdateManyMutationInput = {
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumGENDERFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    notIn?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    not?: NestedEnumGENDERFilter<$PrismaModel> | $Enums.GENDER
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type MedicalRecordsListRelationFilter = {
    every?: MedicalRecordsWhereInput
    some?: MedicalRecordsWhereInput
    none?: MedicalRecordsWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    marital_status?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_number?: SortOrder
    relation?: SortOrder
    blood_group?: SortOrder
    allergies?: SortOrder
    medical_conditions?: SortOrder
    medical_history?: SortOrder
    insurance_provider?: SortOrder
    insurance_number?: SortOrder
    privacy_consent?: SortOrder
    service_consent?: SortOrder
    medical_consent?: SortOrder
    img?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    marital_status?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_number?: SortOrder
    relation?: SortOrder
    blood_group?: SortOrder
    allergies?: SortOrder
    medical_conditions?: SortOrder
    medical_history?: SortOrder
    insurance_provider?: SortOrder
    insurance_number?: SortOrder
    privacy_consent?: SortOrder
    service_consent?: SortOrder
    medical_consent?: SortOrder
    img?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    marital_status?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_number?: SortOrder
    relation?: SortOrder
    blood_group?: SortOrder
    allergies?: SortOrder
    medical_conditions?: SortOrder
    medical_history?: SortOrder
    insurance_provider?: SortOrder
    insurance_number?: SortOrder
    privacy_consent?: SortOrder
    service_consent?: SortOrder
    medical_consent?: SortOrder
    img?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGENDERWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    notIn?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    not?: NestedEnumGENDERWithAggregatesFilter<$PrismaModel> | $Enums.GENDER
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGENDERFilter<$PrismaModel>
    _max?: NestedEnumGENDERFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumJOBTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.JOBTYPE | EnumJOBTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumJOBTYPEFilter<$PrismaModel> | $Enums.JOBTYPE
  }

  export type WorkingDaysListRelationFilter = {
    every?: WorkingDaysWhereInput
    some?: WorkingDaysWhereInput
    none?: WorkingDaysWhereInput
  }

  export type DiagnosisListRelationFilter = {
    every?: DiagnosisWhereInput
    some?: DiagnosisWhereInput
    none?: DiagnosisWhereInput
  }

  export type WorkingDaysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    license_number?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    availability_status?: SortOrder
    type?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    license_number?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    availability_status?: SortOrder
    type?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    license_number?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    availability_status?: SortOrder
    type?: SortOrder
    colorCode?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumJOBTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JOBTYPE | EnumJOBTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumJOBTYPEWithAggregatesFilter<$PrismaModel> | $Enums.JOBTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJOBTYPEFilter<$PrismaModel>
    _max?: NestedEnumJOBTYPEFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DoctorScalarRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type WorkingDaysCountOrderByAggregateInput = {
    id?: SortOrder
    doctor_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    close_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkingDaysAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkingDaysMaxOrderByAggregateInput = {
    id?: SortOrder
    doctor_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    close_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkingDaysMinOrderByAggregateInput = {
    id?: SortOrder
    doctor_id?: SortOrder
    day?: SortOrder
    start_time?: SortOrder
    close_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkingDaysSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    license_number?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    license_number?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    department?: SortOrder
    img?: SortOrder
    license_number?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    note?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    note?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    status?: SortOrder
    type?: SortOrder
    note?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type PatientBillsListRelationFilter = {
    every?: PatientBillsWhereInput
    some?: PatientBillsWhereInput
    none?: PatientBillsWhereInput
  }

  export type PatientBillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    patient_id?: SortOrder
    appointment_Id?: SortOrder
    bill_date?: SortOrder
    payment_Date?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    receipt_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    appointment_Id?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    receipt_number?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    patient_id?: SortOrder
    appointment_Id?: SortOrder
    bill_date?: SortOrder
    payment_Date?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    receipt_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    patient_id?: SortOrder
    appointment_Id?: SortOrder
    bill_date?: SortOrder
    payment_Date?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    receipt_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    appointment_Id?: SortOrder
    discount?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
    receipt_number?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ServicesScalarRelationFilter = {
    is?: ServicesWhereInput
    isNot?: ServicesWhereInput
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PatientBillsCountOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    service_date?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PatientBillsAvgOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
  }

  export type PatientBillsMaxOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    service_date?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PatientBillsMinOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    service_date?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PatientBillsSumOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
  }

  export type MedicalRecordsScalarRelationFilter = {
    is?: MedicalRecordsWhereInput
    isNot?: MedicalRecordsWhereInput
  }

  export type LabTestCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    test_date?: SortOrder
    result?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabTestAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    service_id?: SortOrder
  }

  export type LabTestMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    test_date?: SortOrder
    result?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabTestMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    test_date?: SortOrder
    result?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabTestSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    service_id?: SortOrder
  }

  export type LabTestListRelationFilter = {
    every?: LabTestWhereInput
    some?: LabTestWhereInput
    none?: LabTestWhereInput
  }

  export type VitalSignsListRelationFilter = {
    every?: VitalSignsWhereInput
    some?: VitalSignsWhereInput
    none?: VitalSignsWhereInput
  }

  export type LabTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    appointment_id?: SortOrder
    doctor_id?: SortOrder
    treatment_plan?: SortOrder
    prescriptions?: SortOrder
    lab_request?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MedicalRecordsAvgOrderByAggregateInput = {
    id?: SortOrder
    appointment_id?: SortOrder
  }

  export type MedicalRecordsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    appointment_id?: SortOrder
    doctor_id?: SortOrder
    treatment_plan?: SortOrder
    prescriptions?: SortOrder
    lab_request?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MedicalRecordsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    appointment_id?: SortOrder
    doctor_id?: SortOrder
    treatment_plan?: SortOrder
    prescriptions?: SortOrder
    lab_request?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MedicalRecordsSumOrderByAggregateInput = {
    id?: SortOrder
    appointment_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VitalSignsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygen_saturation?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VitalSignsAvgOrderByAggregateInput = {
    id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    respiratoryRate?: SortOrder
    oxygen_saturation?: SortOrder
    weight?: SortOrder
    height?: SortOrder
  }

  export type VitalSignsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygen_saturation?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VitalSignsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    oxygen_saturation?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VitalSignsSumOrderByAggregateInput = {
    id?: SortOrder
    medical_id?: SortOrder
    body_temperature?: SortOrder
    systolic?: SortOrder
    diastolic?: SortOrder
    respiratoryRate?: SortOrder
    oxygen_saturation?: SortOrder
    weight?: SortOrder
    height?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    diagnosis?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    prescribed_medications?: SortOrder
    follow_up_plan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiagnosisAvgOrderByAggregateInput = {
    id?: SortOrder
    medical_id?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    diagnosis?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    prescribed_medications?: SortOrder
    follow_up_plan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    medical_id?: SortOrder
    diagnosis?: SortOrder
    doctor_id?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    prescribed_medications?: SortOrder
    follow_up_plan?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiagnosisSumOrderByAggregateInput = {
    id?: SortOrder
    medical_id?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    record_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    record_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    record_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type LabTestNullableScalarRelationFilter = {
    is?: LabTestWhereInput | null
    isNot?: LabTestWhereInput | null
  }

  export type ServicesCountOrderByAggregateInput = {
    id?: SortOrder
    service_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServicesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    service_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServicesMinOrderByAggregateInput = {
    id?: SortOrder
    service_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServicesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicalRecordsCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput> | MedicalRecordsCreateWithoutPatientInput[] | MedicalRecordsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutPatientInput | MedicalRecordsCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalRecordsCreateManyPatientInputEnvelope
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutPatientInput = {
    create?: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput> | RatingCreateWithoutPatientInput[] | RatingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutPatientInput | RatingCreateOrConnectWithoutPatientInput[]
    createMany?: RatingCreateManyPatientInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicalRecordsUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput> | MedicalRecordsCreateWithoutPatientInput[] | MedicalRecordsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutPatientInput | MedicalRecordsCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalRecordsCreateManyPatientInputEnvelope
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput> | RatingCreateWithoutPatientInput[] | RatingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutPatientInput | RatingCreateOrConnectWithoutPatientInput[]
    createMany?: RatingCreateManyPatientInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumGENDERFieldUpdateOperationsInput = {
    set?: $Enums.GENDER
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicalRecordsUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput> | MedicalRecordsCreateWithoutPatientInput[] | MedicalRecordsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutPatientInput | MedicalRecordsCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalRecordsUpsertWithWhereUniqueWithoutPatientInput | MedicalRecordsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalRecordsCreateManyPatientInputEnvelope
    set?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    disconnect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    delete?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    update?: MedicalRecordsUpdateWithWhereUniqueWithoutPatientInput | MedicalRecordsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalRecordsUpdateManyWithWhereWithoutPatientInput | MedicalRecordsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput> | RatingCreateWithoutPatientInput[] | RatingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutPatientInput | RatingCreateOrConnectWithoutPatientInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutPatientInput | RatingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RatingCreateManyPatientInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutPatientInput | RatingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutPatientInput | RatingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicalRecordsUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput> | MedicalRecordsCreateWithoutPatientInput[] | MedicalRecordsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutPatientInput | MedicalRecordsCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalRecordsUpsertWithWhereUniqueWithoutPatientInput | MedicalRecordsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalRecordsCreateManyPatientInputEnvelope
    set?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    disconnect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    delete?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    update?: MedicalRecordsUpdateWithWhereUniqueWithoutPatientInput | MedicalRecordsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalRecordsUpdateManyWithWhereWithoutPatientInput | MedicalRecordsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput> | RatingCreateWithoutPatientInput[] | RatingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutPatientInput | RatingCreateOrConnectWithoutPatientInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutPatientInput | RatingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RatingCreateManyPatientInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutPatientInput | RatingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutPatientInput | RatingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type WorkingDaysCreateNestedManyWithoutDoctorInput = {
    create?: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput> | WorkingDaysCreateWithoutDoctorInput[] | WorkingDaysUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: WorkingDaysCreateOrConnectWithoutDoctorInput | WorkingDaysCreateOrConnectWithoutDoctorInput[]
    createMany?: WorkingDaysCreateManyDoctorInputEnvelope
    connect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput> | RatingCreateWithoutDoctorInput[] | RatingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutDoctorInput | RatingCreateOrConnectWithoutDoctorInput[]
    createMany?: RatingCreateManyDoctorInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type WorkingDaysUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput> | WorkingDaysCreateWithoutDoctorInput[] | WorkingDaysUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: WorkingDaysCreateOrConnectWithoutDoctorInput | WorkingDaysCreateOrConnectWithoutDoctorInput[]
    createMany?: WorkingDaysCreateManyDoctorInputEnvelope
    connect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput> | RatingCreateWithoutDoctorInput[] | RatingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutDoctorInput | RatingCreateOrConnectWithoutDoctorInput[]
    createMany?: RatingCreateManyDoctorInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type EnumJOBTYPEFieldUpdateOperationsInput = {
    set?: $Enums.JOBTYPE
  }

  export type WorkingDaysUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput> | WorkingDaysCreateWithoutDoctorInput[] | WorkingDaysUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: WorkingDaysCreateOrConnectWithoutDoctorInput | WorkingDaysCreateOrConnectWithoutDoctorInput[]
    upsert?: WorkingDaysUpsertWithWhereUniqueWithoutDoctorInput | WorkingDaysUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: WorkingDaysCreateManyDoctorInputEnvelope
    set?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    disconnect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    delete?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    connect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    update?: WorkingDaysUpdateWithWhereUniqueWithoutDoctorInput | WorkingDaysUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: WorkingDaysUpdateManyWithWhereWithoutDoctorInput | WorkingDaysUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: WorkingDaysScalarWhereInput | WorkingDaysScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput> | RatingCreateWithoutDoctorInput[] | RatingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutDoctorInput | RatingCreateOrConnectWithoutDoctorInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutDoctorInput | RatingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RatingCreateManyDoctorInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutDoctorInput | RatingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutDoctorInput | RatingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type WorkingDaysUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput> | WorkingDaysCreateWithoutDoctorInput[] | WorkingDaysUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: WorkingDaysCreateOrConnectWithoutDoctorInput | WorkingDaysCreateOrConnectWithoutDoctorInput[]
    upsert?: WorkingDaysUpsertWithWhereUniqueWithoutDoctorInput | WorkingDaysUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: WorkingDaysCreateManyDoctorInputEnvelope
    set?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    disconnect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    delete?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    connect?: WorkingDaysWhereUniqueInput | WorkingDaysWhereUniqueInput[]
    update?: WorkingDaysUpdateWithWhereUniqueWithoutDoctorInput | WorkingDaysUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: WorkingDaysUpdateManyWithWhereWithoutDoctorInput | WorkingDaysUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: WorkingDaysScalarWhereInput | WorkingDaysScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput> | RatingCreateWithoutDoctorInput[] | RatingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutDoctorInput | RatingCreateOrConnectWithoutDoctorInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutDoctorInput | RatingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RatingCreateManyDoctorInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutDoctorInput | RatingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutDoctorInput | RatingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type DoctorCreateNestedOneWithoutWorking_daysInput = {
    create?: XOR<DoctorCreateWithoutWorking_daysInput, DoctorUncheckedCreateWithoutWorking_daysInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutWorking_daysInput
    connect?: DoctorWhereUniqueInput
  }

  export type DoctorUpdateOneRequiredWithoutWorking_daysNestedInput = {
    create?: XOR<DoctorCreateWithoutWorking_daysInput, DoctorUncheckedCreateWithoutWorking_daysInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutWorking_daysInput
    upsert?: DoctorUpsertWithoutWorking_daysInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutWorking_daysInput, DoctorUpdateWithoutWorking_daysInput>, DoctorUncheckedUpdateWithoutWorking_daysInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicalRecordsCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput> | MedicalRecordsCreateWithoutAppointmentInput[] | MedicalRecordsUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutAppointmentInput | MedicalRecordsCreateOrConnectWithoutAppointmentInput[]
    createMany?: MedicalRecordsCreateManyAppointmentInputEnvelope
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicalRecordsUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput> | MedicalRecordsCreateWithoutAppointmentInput[] | MedicalRecordsUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutAppointmentInput | MedicalRecordsCreateOrConnectWithoutAppointmentInput[]
    createMany?: MedicalRecordsCreateManyAppointmentInputEnvelope
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorUpsertWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAppointmentsInput, DoctorUpdateWithoutAppointmentsInput>, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PaymentUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAppointmentInput | PaymentUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAppointmentInput | PaymentUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAppointmentInput | PaymentUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicalRecordsUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput> | MedicalRecordsCreateWithoutAppointmentInput[] | MedicalRecordsUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutAppointmentInput | MedicalRecordsCreateOrConnectWithoutAppointmentInput[]
    upsert?: MedicalRecordsUpsertWithWhereUniqueWithoutAppointmentInput | MedicalRecordsUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: MedicalRecordsCreateManyAppointmentInputEnvelope
    set?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    disconnect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    delete?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    update?: MedicalRecordsUpdateWithWhereUniqueWithoutAppointmentInput | MedicalRecordsUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: MedicalRecordsUpdateManyWithWhereWithoutAppointmentInput | MedicalRecordsUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput> | PaymentCreateWithoutAppointmentInput[] | PaymentUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput | PaymentCreateOrConnectWithoutAppointmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAppointmentInput | PaymentUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: PaymentCreateManyAppointmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAppointmentInput | PaymentUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAppointmentInput | PaymentUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicalRecordsUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput> | MedicalRecordsCreateWithoutAppointmentInput[] | MedicalRecordsUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutAppointmentInput | MedicalRecordsCreateOrConnectWithoutAppointmentInput[]
    upsert?: MedicalRecordsUpsertWithWhereUniqueWithoutAppointmentInput | MedicalRecordsUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: MedicalRecordsCreateManyAppointmentInputEnvelope
    set?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    disconnect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    delete?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    connect?: MedicalRecordsWhereUniqueInput | MedicalRecordsWhereUniqueInput[]
    update?: MedicalRecordsUpdateWithWhereUniqueWithoutAppointmentInput | MedicalRecordsUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: MedicalRecordsUpdateManyWithWhereWithoutAppointmentInput | MedicalRecordsUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutBillsInput = {
    create?: XOR<AppointmentCreateWithoutBillsInput, AppointmentUncheckedCreateWithoutBillsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutBillsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientBillsCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput> | PatientBillsCreateWithoutPaymentInput[] | PatientBillsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutPaymentInput | PatientBillsCreateOrConnectWithoutPaymentInput[]
    createMany?: PatientBillsCreateManyPaymentInputEnvelope
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
  }

  export type PatientBillsUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput> | PatientBillsCreateWithoutPaymentInput[] | PatientBillsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutPaymentInput | PatientBillsCreateOrConnectWithoutPaymentInput[]
    createMany?: PatientBillsCreateManyPaymentInputEnvelope
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type AppointmentUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<AppointmentCreateWithoutBillsInput, AppointmentUncheckedCreateWithoutBillsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutBillsInput
    upsert?: AppointmentUpsertWithoutBillsInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutBillsInput, AppointmentUpdateWithoutBillsInput>, AppointmentUncheckedUpdateWithoutBillsInput>
  }

  export type PatientUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    upsert?: PatientUpsertWithoutPaymentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPaymentsInput, PatientUpdateWithoutPaymentsInput>, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientBillsUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput> | PatientBillsCreateWithoutPaymentInput[] | PatientBillsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutPaymentInput | PatientBillsCreateOrConnectWithoutPaymentInput[]
    upsert?: PatientBillsUpsertWithWhereUniqueWithoutPaymentInput | PatientBillsUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PatientBillsCreateManyPaymentInputEnvelope
    set?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    disconnect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    delete?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    update?: PatientBillsUpdateWithWhereUniqueWithoutPaymentInput | PatientBillsUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PatientBillsUpdateManyWithWhereWithoutPaymentInput | PatientBillsUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
  }

  export type PatientBillsUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput> | PatientBillsCreateWithoutPaymentInput[] | PatientBillsUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutPaymentInput | PatientBillsCreateOrConnectWithoutPaymentInput[]
    upsert?: PatientBillsUpsertWithWhereUniqueWithoutPaymentInput | PatientBillsUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PatientBillsCreateManyPaymentInputEnvelope
    set?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    disconnect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    delete?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    update?: PatientBillsUpdateWithWhereUniqueWithoutPaymentInput | PatientBillsUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PatientBillsUpdateManyWithWhereWithoutPaymentInput | PatientBillsUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
  }

  export type ServicesCreateNestedOneWithoutBillsInput = {
    create?: XOR<ServicesCreateWithoutBillsInput, ServicesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutBillsInput
    connect?: ServicesWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutBillsInput = {
    create?: XOR<PaymentCreateWithoutBillsInput, PaymentUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBillsInput
    connect?: PaymentWhereUniqueInput
  }

  export type ServicesUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<ServicesCreateWithoutBillsInput, ServicesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutBillsInput
    upsert?: ServicesUpsertWithoutBillsInput
    connect?: ServicesWhereUniqueInput
    update?: XOR<XOR<ServicesUpdateToOneWithWhereWithoutBillsInput, ServicesUpdateWithoutBillsInput>, ServicesUncheckedUpdateWithoutBillsInput>
  }

  export type PaymentUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<PaymentCreateWithoutBillsInput, PaymentUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBillsInput
    upsert?: PaymentUpsertWithoutBillsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBillsInput, PaymentUpdateWithoutBillsInput>, PaymentUncheckedUpdateWithoutBillsInput>
  }

  export type ServicesCreateNestedOneWithoutLabtestInput = {
    create?: XOR<ServicesCreateWithoutLabtestInput, ServicesUncheckedCreateWithoutLabtestInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutLabtestInput
    connect?: ServicesWhereUniqueInput
  }

  export type MedicalRecordsCreateNestedOneWithoutLab_testInput = {
    create?: XOR<MedicalRecordsCreateWithoutLab_testInput, MedicalRecordsUncheckedCreateWithoutLab_testInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutLab_testInput
    connect?: MedicalRecordsWhereUniqueInput
  }

  export type ServicesUpdateOneRequiredWithoutLabtestNestedInput = {
    create?: XOR<ServicesCreateWithoutLabtestInput, ServicesUncheckedCreateWithoutLabtestInput>
    connectOrCreate?: ServicesCreateOrConnectWithoutLabtestInput
    upsert?: ServicesUpsertWithoutLabtestInput
    connect?: ServicesWhereUniqueInput
    update?: XOR<XOR<ServicesUpdateToOneWithWhereWithoutLabtestInput, ServicesUpdateWithoutLabtestInput>, ServicesUncheckedUpdateWithoutLabtestInput>
  }

  export type MedicalRecordsUpdateOneRequiredWithoutLab_testNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutLab_testInput, MedicalRecordsUncheckedCreateWithoutLab_testInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutLab_testInput
    upsert?: MedicalRecordsUpsertWithoutLab_testInput
    connect?: MedicalRecordsWhereUniqueInput
    update?: XOR<XOR<MedicalRecordsUpdateToOneWithWhereWithoutLab_testInput, MedicalRecordsUpdateWithoutLab_testInput>, MedicalRecordsUncheckedUpdateWithoutLab_testInput>
  }

  export type AppointmentCreateNestedOneWithoutMedicalInput = {
    create?: XOR<AppointmentCreateWithoutMedicalInput, AppointmentUncheckedCreateWithoutMedicalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutMedicalInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutMedicalInput = {
    create?: XOR<PatientCreateWithoutMedicalInput, PatientUncheckedCreateWithoutMedicalInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalInput
    connect?: PatientWhereUniqueInput
  }

  export type LabTestCreateNestedManyWithoutMedical_recordInput = {
    create?: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput> | LabTestCreateWithoutMedical_recordInput[] | LabTestUncheckedCreateWithoutMedical_recordInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutMedical_recordInput | LabTestCreateOrConnectWithoutMedical_recordInput[]
    createMany?: LabTestCreateManyMedical_recordInputEnvelope
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
  }

  export type VitalSignsCreateNestedManyWithoutMedicalInput = {
    create?: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput> | VitalSignsCreateWithoutMedicalInput[] | VitalSignsUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutMedicalInput | VitalSignsCreateOrConnectWithoutMedicalInput[]
    createMany?: VitalSignsCreateManyMedicalInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutMedicalInput = {
    create?: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput> | DiagnosisCreateWithoutMedicalInput[] | DiagnosisUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutMedicalInput | DiagnosisCreateOrConnectWithoutMedicalInput[]
    createMany?: DiagnosisCreateManyMedicalInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type LabTestUncheckedCreateNestedManyWithoutMedical_recordInput = {
    create?: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput> | LabTestCreateWithoutMedical_recordInput[] | LabTestUncheckedCreateWithoutMedical_recordInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutMedical_recordInput | LabTestCreateOrConnectWithoutMedical_recordInput[]
    createMany?: LabTestCreateManyMedical_recordInputEnvelope
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
  }

  export type VitalSignsUncheckedCreateNestedManyWithoutMedicalInput = {
    create?: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput> | VitalSignsCreateWithoutMedicalInput[] | VitalSignsUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutMedicalInput | VitalSignsCreateOrConnectWithoutMedicalInput[]
    createMany?: VitalSignsCreateManyMedicalInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutMedicalInput = {
    create?: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput> | DiagnosisCreateWithoutMedicalInput[] | DiagnosisUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutMedicalInput | DiagnosisCreateOrConnectWithoutMedicalInput[]
    createMany?: DiagnosisCreateManyMedicalInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type AppointmentUpdateOneRequiredWithoutMedicalNestedInput = {
    create?: XOR<AppointmentCreateWithoutMedicalInput, AppointmentUncheckedCreateWithoutMedicalInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutMedicalInput
    upsert?: AppointmentUpsertWithoutMedicalInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutMedicalInput, AppointmentUpdateWithoutMedicalInput>, AppointmentUncheckedUpdateWithoutMedicalInput>
  }

  export type PatientUpdateOneRequiredWithoutMedicalNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalInput, PatientUncheckedCreateWithoutMedicalInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalInput
    upsert?: PatientUpsertWithoutMedicalInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalInput, PatientUpdateWithoutMedicalInput>, PatientUncheckedUpdateWithoutMedicalInput>
  }

  export type LabTestUpdateManyWithoutMedical_recordNestedInput = {
    create?: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput> | LabTestCreateWithoutMedical_recordInput[] | LabTestUncheckedCreateWithoutMedical_recordInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutMedical_recordInput | LabTestCreateOrConnectWithoutMedical_recordInput[]
    upsert?: LabTestUpsertWithWhereUniqueWithoutMedical_recordInput | LabTestUpsertWithWhereUniqueWithoutMedical_recordInput[]
    createMany?: LabTestCreateManyMedical_recordInputEnvelope
    set?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    disconnect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    delete?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    update?: LabTestUpdateWithWhereUniqueWithoutMedical_recordInput | LabTestUpdateWithWhereUniqueWithoutMedical_recordInput[]
    updateMany?: LabTestUpdateManyWithWhereWithoutMedical_recordInput | LabTestUpdateManyWithWhereWithoutMedical_recordInput[]
    deleteMany?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
  }

  export type VitalSignsUpdateManyWithoutMedicalNestedInput = {
    create?: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput> | VitalSignsCreateWithoutMedicalInput[] | VitalSignsUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutMedicalInput | VitalSignsCreateOrConnectWithoutMedicalInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutMedicalInput | VitalSignsUpsertWithWhereUniqueWithoutMedicalInput[]
    createMany?: VitalSignsCreateManyMedicalInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutMedicalInput | VitalSignsUpdateWithWhereUniqueWithoutMedicalInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutMedicalInput | VitalSignsUpdateManyWithWhereWithoutMedicalInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutMedicalNestedInput = {
    create?: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput> | DiagnosisCreateWithoutMedicalInput[] | DiagnosisUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutMedicalInput | DiagnosisCreateOrConnectWithoutMedicalInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutMedicalInput | DiagnosisUpsertWithWhereUniqueWithoutMedicalInput[]
    createMany?: DiagnosisCreateManyMedicalInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutMedicalInput | DiagnosisUpdateWithWhereUniqueWithoutMedicalInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutMedicalInput | DiagnosisUpdateManyWithWhereWithoutMedicalInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput = {
    create?: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput> | LabTestCreateWithoutMedical_recordInput[] | LabTestUncheckedCreateWithoutMedical_recordInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutMedical_recordInput | LabTestCreateOrConnectWithoutMedical_recordInput[]
    upsert?: LabTestUpsertWithWhereUniqueWithoutMedical_recordInput | LabTestUpsertWithWhereUniqueWithoutMedical_recordInput[]
    createMany?: LabTestCreateManyMedical_recordInputEnvelope
    set?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    disconnect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    delete?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    update?: LabTestUpdateWithWhereUniqueWithoutMedical_recordInput | LabTestUpdateWithWhereUniqueWithoutMedical_recordInput[]
    updateMany?: LabTestUpdateManyWithWhereWithoutMedical_recordInput | LabTestUpdateManyWithWhereWithoutMedical_recordInput[]
    deleteMany?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
  }

  export type VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput = {
    create?: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput> | VitalSignsCreateWithoutMedicalInput[] | VitalSignsUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutMedicalInput | VitalSignsCreateOrConnectWithoutMedicalInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutMedicalInput | VitalSignsUpsertWithWhereUniqueWithoutMedicalInput[]
    createMany?: VitalSignsCreateManyMedicalInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutMedicalInput | VitalSignsUpdateWithWhereUniqueWithoutMedicalInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutMedicalInput | VitalSignsUpdateManyWithWhereWithoutMedicalInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput = {
    create?: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput> | DiagnosisCreateWithoutMedicalInput[] | DiagnosisUncheckedCreateWithoutMedicalInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutMedicalInput | DiagnosisCreateOrConnectWithoutMedicalInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutMedicalInput | DiagnosisUpsertWithWhereUniqueWithoutMedicalInput[]
    createMany?: DiagnosisCreateManyMedicalInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutMedicalInput | DiagnosisUpdateWithWhereUniqueWithoutMedicalInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutMedicalInput | DiagnosisUpdateManyWithWhereWithoutMedicalInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type MedicalRecordsCreateNestedOneWithoutVital_signsInput = {
    create?: XOR<MedicalRecordsCreateWithoutVital_signsInput, MedicalRecordsUncheckedCreateWithoutVital_signsInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutVital_signsInput
    connect?: MedicalRecordsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MedicalRecordsUpdateOneRequiredWithoutVital_signsNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutVital_signsInput, MedicalRecordsUncheckedCreateWithoutVital_signsInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutVital_signsInput
    upsert?: MedicalRecordsUpsertWithoutVital_signsInput
    connect?: MedicalRecordsWhereUniqueInput
    update?: XOR<XOR<MedicalRecordsUpdateToOneWithWhereWithoutVital_signsInput, MedicalRecordsUpdateWithoutVital_signsInput>, MedicalRecordsUncheckedUpdateWithoutVital_signsInput>
  }

  export type MedicalRecordsCreateNestedOneWithoutDiagnosisInput = {
    create?: XOR<MedicalRecordsCreateWithoutDiagnosisInput, MedicalRecordsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutDiagnosisInput
    connect?: MedicalRecordsWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutDiagnosisInput = {
    create?: XOR<DoctorCreateWithoutDiagnosisInput, DoctorUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDiagnosisInput
    connect?: DoctorWhereUniqueInput
  }

  export type MedicalRecordsUpdateOneRequiredWithoutDiagnosisNestedInput = {
    create?: XOR<MedicalRecordsCreateWithoutDiagnosisInput, MedicalRecordsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: MedicalRecordsCreateOrConnectWithoutDiagnosisInput
    upsert?: MedicalRecordsUpsertWithoutDiagnosisInput
    connect?: MedicalRecordsWhereUniqueInput
    update?: XOR<XOR<MedicalRecordsUpdateToOneWithWhereWithoutDiagnosisInput, MedicalRecordsUpdateWithoutDiagnosisInput>, MedicalRecordsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DoctorUpdateOneRequiredWithoutDiagnosisNestedInput = {
    create?: XOR<DoctorCreateWithoutDiagnosisInput, DoctorUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDiagnosisInput
    upsert?: DoctorUpsertWithoutDiagnosisInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutDiagnosisInput, DoctorUpdateWithoutDiagnosisInput>, DoctorUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DoctorCreateNestedOneWithoutRatingsInput = {
    create?: XOR<DoctorCreateWithoutRatingsInput, DoctorUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRatingsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutRatingsInput = {
    create?: XOR<PatientCreateWithoutRatingsInput, PatientUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRatingsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<DoctorCreateWithoutRatingsInput, DoctorUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutRatingsInput
    upsert?: DoctorUpsertWithoutRatingsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutRatingsInput, DoctorUpdateWithoutRatingsInput>, DoctorUncheckedUpdateWithoutRatingsInput>
  }

  export type PatientUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<PatientCreateWithoutRatingsInput, PatientUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRatingsInput
    upsert?: PatientUpsertWithoutRatingsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRatingsInput, PatientUpdateWithoutRatingsInput>, PatientUncheckedUpdateWithoutRatingsInput>
  }

  export type LabTestCreateNestedOneWithoutServicesInput = {
    create?: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutServicesInput
    connect?: LabTestWhereUniqueInput
  }

  export type PatientBillsCreateNestedManyWithoutServiceInput = {
    create?: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput> | PatientBillsCreateWithoutServiceInput[] | PatientBillsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutServiceInput | PatientBillsCreateOrConnectWithoutServiceInput[]
    createMany?: PatientBillsCreateManyServiceInputEnvelope
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
  }

  export type LabTestUncheckedCreateNestedOneWithoutServicesInput = {
    create?: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutServicesInput
    connect?: LabTestWhereUniqueInput
  }

  export type PatientBillsUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput> | PatientBillsCreateWithoutServiceInput[] | PatientBillsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutServiceInput | PatientBillsCreateOrConnectWithoutServiceInput[]
    createMany?: PatientBillsCreateManyServiceInputEnvelope
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
  }

  export type LabTestUpdateOneWithoutServicesNestedInput = {
    create?: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutServicesInput
    upsert?: LabTestUpsertWithoutServicesInput
    disconnect?: LabTestWhereInput | boolean
    delete?: LabTestWhereInput | boolean
    connect?: LabTestWhereUniqueInput
    update?: XOR<XOR<LabTestUpdateToOneWithWhereWithoutServicesInput, LabTestUpdateWithoutServicesInput>, LabTestUncheckedUpdateWithoutServicesInput>
  }

  export type PatientBillsUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput> | PatientBillsCreateWithoutServiceInput[] | PatientBillsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutServiceInput | PatientBillsCreateOrConnectWithoutServiceInput[]
    upsert?: PatientBillsUpsertWithWhereUniqueWithoutServiceInput | PatientBillsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PatientBillsCreateManyServiceInputEnvelope
    set?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    disconnect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    delete?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    update?: PatientBillsUpdateWithWhereUniqueWithoutServiceInput | PatientBillsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PatientBillsUpdateManyWithWhereWithoutServiceInput | PatientBillsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
  }

  export type LabTestUncheckedUpdateOneWithoutServicesNestedInput = {
    create?: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutServicesInput
    upsert?: LabTestUpsertWithoutServicesInput
    disconnect?: LabTestWhereInput | boolean
    delete?: LabTestWhereInput | boolean
    connect?: LabTestWhereUniqueInput
    update?: XOR<XOR<LabTestUpdateToOneWithWhereWithoutServicesInput, LabTestUpdateWithoutServicesInput>, LabTestUncheckedUpdateWithoutServicesInput>
  }

  export type PatientBillsUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput> | PatientBillsCreateWithoutServiceInput[] | PatientBillsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PatientBillsCreateOrConnectWithoutServiceInput | PatientBillsCreateOrConnectWithoutServiceInput[]
    upsert?: PatientBillsUpsertWithWhereUniqueWithoutServiceInput | PatientBillsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PatientBillsCreateManyServiceInputEnvelope
    set?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    disconnect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    delete?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    connect?: PatientBillsWhereUniqueInput | PatientBillsWhereUniqueInput[]
    update?: PatientBillsUpdateWithWhereUniqueWithoutServiceInput | PatientBillsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PatientBillsUpdateManyWithWhereWithoutServiceInput | PatientBillsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumGENDERFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    notIn?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    not?: NestedEnumGENDERFilter<$PrismaModel> | $Enums.GENDER
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGENDERWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    notIn?: $Enums.GENDER[] | ListEnumGENDERFieldRefInput<$PrismaModel>
    not?: NestedEnumGENDERWithAggregatesFilter<$PrismaModel> | $Enums.GENDER
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGENDERFilter<$PrismaModel>
    _max?: NestedEnumGENDERFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumJOBTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.JOBTYPE | EnumJOBTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumJOBTYPEFilter<$PrismaModel> | $Enums.JOBTYPE
  }

  export type NestedEnumJOBTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JOBTYPE | EnumJOBTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.JOBTYPE[] | ListEnumJOBTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumJOBTYPEWithAggregatesFilter<$PrismaModel> | $Enums.JOBTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJOBTYPEFilter<$PrismaModel>
    _max?: NestedEnumJOBTYPEFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AppointmentCreateWithoutPatientInput = {
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    bills?: PaymentCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: number
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordsCreateWithoutPatientInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutMedicalInput
    lab_test?: LabTestCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateWithoutPatientInput = {
    id?: number
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lab_test?: LabTestUncheckedCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsUncheckedCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsCreateOrConnectWithoutPatientInput = {
    where: MedicalRecordsWhereUniqueInput
    create: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput>
  }

  export type MedicalRecordsCreateManyPatientInputEnvelope = {
    data: MedicalRecordsCreateManyPatientInput | MedicalRecordsCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPatientInput = {
    bill_id?: number | null
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutBillsInput
    bills?: PatientBillsCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPatientInput = {
    id?: number
    bill_id?: number | null
    appointment_Id: number
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PatientBillsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentCreateManyPatientInputEnvelope = {
    data: PaymentCreateManyPatientInput | PaymentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutPatientInput = {
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    doctor: DoctorCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutPatientInput = {
    id?: number
    staff_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingCreateOrConnectWithoutPatientInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput>
  }

  export type RatingCreateManyPatientInputEnvelope = {
    data: RatingCreateManyPatientInput | RatingCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patient_id?: StringFilter<"Appointment"> | string
    doctor_id?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: StringFilter<"Appointment"> | string
    note?: StringNullableFilter<"Appointment"> | string | null
    reason?: StringNullableFilter<"Appointment"> | string | null
    created_at?: DateTimeFilter<"Appointment"> | Date | string
    updated_at?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type MedicalRecordsUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalRecordsWhereUniqueInput
    update: XOR<MedicalRecordsUpdateWithoutPatientInput, MedicalRecordsUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalRecordsCreateWithoutPatientInput, MedicalRecordsUncheckedCreateWithoutPatientInput>
  }

  export type MedicalRecordsUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalRecordsWhereUniqueInput
    data: XOR<MedicalRecordsUpdateWithoutPatientInput, MedicalRecordsUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalRecordsUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalRecordsScalarWhereInput
    data: XOR<MedicalRecordsUpdateManyMutationInput, MedicalRecordsUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalRecordsScalarWhereInput = {
    AND?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
    OR?: MedicalRecordsScalarWhereInput[]
    NOT?: MedicalRecordsScalarWhereInput | MedicalRecordsScalarWhereInput[]
    id?: IntFilter<"MedicalRecords"> | number
    patient_id?: StringFilter<"MedicalRecords"> | string
    appointment_id?: IntFilter<"MedicalRecords"> | number
    doctor_id?: StringFilter<"MedicalRecords"> | string
    treatment_plan?: StringNullableFilter<"MedicalRecords"> | string | null
    prescriptions?: StringNullableFilter<"MedicalRecords"> | string | null
    lab_request?: StringNullableFilter<"MedicalRecords"> | string | null
    notes?: StringNullableFilter<"MedicalRecords"> | string | null
    created_at?: DateTimeFilter<"MedicalRecords"> | Date | string
    updated_at?: DateTimeFilter<"MedicalRecords"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPatientInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    bill_id?: IntNullableFilter<"Payment"> | number | null
    patient_id?: StringFilter<"Payment"> | string
    appointment_Id?: IntFilter<"Payment"> | number
    bill_date?: DateTimeFilter<"Payment"> | Date | string
    payment_Date?: DateTimeFilter<"Payment"> | Date | string
    discount?: FloatFilter<"Payment"> | number
    total_amount?: FloatFilter<"Payment"> | number
    amount_paid?: FloatFilter<"Payment"> | number
    payment_method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    receipt_number?: IntFilter<"Payment"> | number
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutPatientInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutPatientInput, RatingUncheckedUpdateWithoutPatientInput>
    create: XOR<RatingCreateWithoutPatientInput, RatingUncheckedCreateWithoutPatientInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutPatientInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutPatientInput, RatingUncheckedUpdateWithoutPatientInput>
  }

  export type RatingUpdateManyWithWhereWithoutPatientInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutPatientInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: IntFilter<"Rating"> | number
    patient_id?: StringFilter<"Rating"> | string
    staff_id?: StringFilter<"Rating"> | string
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    created_at?: DateTimeFilter<"Rating"> | Date | string
    updated_at?: DateTimeFilter<"Rating"> | Date | string
  }

  export type WorkingDaysCreateWithoutDoctorInput = {
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkingDaysUncheckedCreateWithoutDoctorInput = {
    id?: number
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkingDaysCreateOrConnectWithoutDoctorInput = {
    where: WorkingDaysWhereUniqueInput
    create: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput>
  }

  export type WorkingDaysCreateManyDoctorInputEnvelope = {
    data: WorkingDaysCreateManyDoctorInput | WorkingDaysCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    bills?: PaymentCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    patient_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutDoctorInput = {
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutDoctorInput = {
    id?: number
    patient_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingCreateOrConnectWithoutDoctorInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput>
  }

  export type RatingCreateManyDoctorInputEnvelope = {
    data: RatingCreateManyDoctorInput | RatingCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutDoctorInput = {
    patient_id: string
    diagnosis: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    medical: MedicalRecordsCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutDoctorInput = {
    id?: number
    patient_id: string
    medical_id: number
    diagnosis: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisCreateManyDoctorInputEnvelope = {
    data: DiagnosisCreateManyDoctorInput | DiagnosisCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type WorkingDaysUpsertWithWhereUniqueWithoutDoctorInput = {
    where: WorkingDaysWhereUniqueInput
    update: XOR<WorkingDaysUpdateWithoutDoctorInput, WorkingDaysUncheckedUpdateWithoutDoctorInput>
    create: XOR<WorkingDaysCreateWithoutDoctorInput, WorkingDaysUncheckedCreateWithoutDoctorInput>
  }

  export type WorkingDaysUpdateWithWhereUniqueWithoutDoctorInput = {
    where: WorkingDaysWhereUniqueInput
    data: XOR<WorkingDaysUpdateWithoutDoctorInput, WorkingDaysUncheckedUpdateWithoutDoctorInput>
  }

  export type WorkingDaysUpdateManyWithWhereWithoutDoctorInput = {
    where: WorkingDaysScalarWhereInput
    data: XOR<WorkingDaysUpdateManyMutationInput, WorkingDaysUncheckedUpdateManyWithoutDoctorInput>
  }

  export type WorkingDaysScalarWhereInput = {
    AND?: WorkingDaysScalarWhereInput | WorkingDaysScalarWhereInput[]
    OR?: WorkingDaysScalarWhereInput[]
    NOT?: WorkingDaysScalarWhereInput | WorkingDaysScalarWhereInput[]
    id?: IntFilter<"WorkingDays"> | number
    doctor_id?: StringFilter<"WorkingDays"> | string
    day?: StringFilter<"WorkingDays"> | string
    start_time?: StringFilter<"WorkingDays"> | string
    close_time?: StringFilter<"WorkingDays"> | string
    created_at?: DateTimeFilter<"WorkingDays"> | Date | string
    updated_at?: DateTimeFilter<"WorkingDays"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutDoctorInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutDoctorInput, RatingUncheckedUpdateWithoutDoctorInput>
    create: XOR<RatingCreateWithoutDoctorInput, RatingUncheckedCreateWithoutDoctorInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutDoctorInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutDoctorInput, RatingUncheckedUpdateWithoutDoctorInput>
  }

  export type RatingUpdateManyWithWhereWithoutDoctorInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutDoctorInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DiagnosisScalarWhereInput = {
    AND?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    OR?: DiagnosisScalarWhereInput[]
    NOT?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    id?: IntFilter<"Diagnosis"> | number
    patient_id?: StringFilter<"Diagnosis"> | string
    medical_id?: IntFilter<"Diagnosis"> | number
    diagnosis?: StringFilter<"Diagnosis"> | string
    doctor_id?: StringFilter<"Diagnosis"> | string
    symptoms?: StringFilter<"Diagnosis"> | string
    notes?: StringNullableFilter<"Diagnosis"> | string | null
    prescribed_medications?: StringNullableFilter<"Diagnosis"> | string | null
    follow_up_plan?: StringNullableFilter<"Diagnosis"> | string | null
    created_at?: DateTimeFilter<"Diagnosis"> | Date | string
    updated_at?: DateTimeFilter<"Diagnosis"> | Date | string
  }

  export type DoctorCreateWithoutWorking_daysInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    ratings?: RatingCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutWorking_daysInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    ratings?: RatingUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutWorking_daysInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutWorking_daysInput, DoctorUncheckedCreateWithoutWorking_daysInput>
  }

  export type DoctorUpsertWithoutWorking_daysInput = {
    update: XOR<DoctorUpdateWithoutWorking_daysInput, DoctorUncheckedUpdateWithoutWorking_daysInput>
    create: XOR<DoctorCreateWithoutWorking_daysInput, DoctorUncheckedCreateWithoutWorking_daysInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutWorking_daysInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutWorking_daysInput, DoctorUncheckedUpdateWithoutWorking_daysInput>
  }

  export type DoctorUpdateWithoutWorking_daysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutWorking_daysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    medical?: MedicalRecordsCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    ratings?: RatingCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    ratings?: RatingUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type DoctorCreateWithoutAppointmentsInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysCreateNestedManyWithoutDoctorInput
    ratings?: RatingCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAppointmentsInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysUncheckedCreateNestedManyWithoutDoctorInput
    ratings?: RatingUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type PaymentCreateWithoutAppointmentInput = {
    bill_id?: number | null
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutPaymentsInput
    bills?: PatientBillsCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutAppointmentInput = {
    id?: number
    bill_id?: number | null
    patient_id: string
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PatientBillsUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>
  }

  export type PaymentCreateManyAppointmentInputEnvelope = {
    data: PaymentCreateManyAppointmentInput | PaymentCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordsCreateWithoutAppointmentInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutMedicalInput
    lab_test?: LabTestCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patient_id: string
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lab_test?: LabTestUncheckedCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsUncheckedCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsCreateOrConnectWithoutAppointmentInput = {
    where: MedicalRecordsWhereUniqueInput
    create: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput>
  }

  export type MedicalRecordsCreateManyAppointmentInputEnvelope = {
    data: MedicalRecordsCreateManyAppointmentInput | MedicalRecordsCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    ratings?: RatingUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUncheckedUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutAppointmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type MedicalRecordsUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: MedicalRecordsWhereUniqueInput
    update: XOR<MedicalRecordsUpdateWithoutAppointmentInput, MedicalRecordsUncheckedUpdateWithoutAppointmentInput>
    create: XOR<MedicalRecordsCreateWithoutAppointmentInput, MedicalRecordsUncheckedCreateWithoutAppointmentInput>
  }

  export type MedicalRecordsUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: MedicalRecordsWhereUniqueInput
    data: XOR<MedicalRecordsUpdateWithoutAppointmentInput, MedicalRecordsUncheckedUpdateWithoutAppointmentInput>
  }

  export type MedicalRecordsUpdateManyWithWhereWithoutAppointmentInput = {
    where: MedicalRecordsScalarWhereInput
    data: XOR<MedicalRecordsUpdateManyMutationInput, MedicalRecordsUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentCreateWithoutBillsInput = {
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    medical?: MedicalRecordsCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutBillsInput = {
    id?: number
    patient_id: string
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutBillsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutBillsInput, AppointmentUncheckedCreateWithoutBillsInput>
  }

  export type PatientCreateWithoutPaymentsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsCreateNestedManyWithoutPatientInput
    ratings?: RatingCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPaymentsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutPatientInput
    ratings?: RatingUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPaymentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
  }

  export type PatientBillsCreateWithoutPaymentInput = {
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
    service: ServicesCreateNestedOneWithoutBillsInput
  }

  export type PatientBillsUncheckedCreateWithoutPaymentInput = {
    id?: number
    service_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsCreateOrConnectWithoutPaymentInput = {
    where: PatientBillsWhereUniqueInput
    create: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput>
  }

  export type PatientBillsCreateManyPaymentInputEnvelope = {
    data: PatientBillsCreateManyPaymentInput | PatientBillsCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithoutBillsInput = {
    update: XOR<AppointmentUpdateWithoutBillsInput, AppointmentUncheckedUpdateWithoutBillsInput>
    create: XOR<AppointmentCreateWithoutBillsInput, AppointmentUncheckedCreateWithoutBillsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutBillsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutBillsInput, AppointmentUncheckedUpdateWithoutBillsInput>
  }

  export type AppointmentUpdateWithoutBillsInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    medical?: MedicalRecordsUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type PatientUpsertWithoutPaymentsInput = {
    update: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUpdateManyWithoutPatientNestedInput
    ratings?: RatingUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutPatientNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientBillsUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PatientBillsWhereUniqueInput
    update: XOR<PatientBillsUpdateWithoutPaymentInput, PatientBillsUncheckedUpdateWithoutPaymentInput>
    create: XOR<PatientBillsCreateWithoutPaymentInput, PatientBillsUncheckedCreateWithoutPaymentInput>
  }

  export type PatientBillsUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PatientBillsWhereUniqueInput
    data: XOR<PatientBillsUpdateWithoutPaymentInput, PatientBillsUncheckedUpdateWithoutPaymentInput>
  }

  export type PatientBillsUpdateManyWithWhereWithoutPaymentInput = {
    where: PatientBillsScalarWhereInput
    data: XOR<PatientBillsUpdateManyMutationInput, PatientBillsUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PatientBillsScalarWhereInput = {
    AND?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
    OR?: PatientBillsScalarWhereInput[]
    NOT?: PatientBillsScalarWhereInput | PatientBillsScalarWhereInput[]
    id?: IntFilter<"PatientBills"> | number
    bill_id?: IntFilter<"PatientBills"> | number
    service_id?: IntFilter<"PatientBills"> | number
    service_date?: DateTimeFilter<"PatientBills"> | Date | string
    quantity?: IntFilter<"PatientBills"> | number
    unit_cost?: FloatFilter<"PatientBills"> | number
    total_cost?: FloatFilter<"PatientBills"> | number
    created_at?: DateTimeFilter<"PatientBills"> | Date | string
    updated_at?: DateTimeFilter<"PatientBills"> | Date | string
  }

  export type ServicesCreateWithoutBillsInput = {
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    labtest?: LabTestCreateNestedOneWithoutServicesInput
  }

  export type ServicesUncheckedCreateWithoutBillsInput = {
    id?: number
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    labtest?: LabTestUncheckedCreateNestedOneWithoutServicesInput
  }

  export type ServicesCreateOrConnectWithoutBillsInput = {
    where: ServicesWhereUniqueInput
    create: XOR<ServicesCreateWithoutBillsInput, ServicesUncheckedCreateWithoutBillsInput>
  }

  export type PaymentCreateWithoutBillsInput = {
    bill_id?: number | null
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutBillsInput
    patient: PatientCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBillsInput = {
    id?: number
    bill_id?: number | null
    patient_id: string
    appointment_Id: number
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBillsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBillsInput, PaymentUncheckedCreateWithoutBillsInput>
  }

  export type ServicesUpsertWithoutBillsInput = {
    update: XOR<ServicesUpdateWithoutBillsInput, ServicesUncheckedUpdateWithoutBillsInput>
    create: XOR<ServicesCreateWithoutBillsInput, ServicesUncheckedCreateWithoutBillsInput>
    where?: ServicesWhereInput
  }

  export type ServicesUpdateToOneWithWhereWithoutBillsInput = {
    where?: ServicesWhereInput
    data: XOR<ServicesUpdateWithoutBillsInput, ServicesUncheckedUpdateWithoutBillsInput>
  }

  export type ServicesUpdateWithoutBillsInput = {
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    labtest?: LabTestUpdateOneWithoutServicesNestedInput
  }

  export type ServicesUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    labtest?: LabTestUncheckedUpdateOneWithoutServicesNestedInput
  }

  export type PaymentUpsertWithoutBillsInput = {
    update: XOR<PaymentUpdateWithoutBillsInput, PaymentUncheckedUpdateWithoutBillsInput>
    create: XOR<PaymentCreateWithoutBillsInput, PaymentUncheckedCreateWithoutBillsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutBillsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutBillsInput, PaymentUncheckedUpdateWithoutBillsInput>
  }

  export type PaymentUpdateWithoutBillsInput = {
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutBillsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_Id?: IntFieldUpdateOperationsInput | number
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesCreateWithoutLabtestInput = {
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PatientBillsCreateNestedManyWithoutServiceInput
  }

  export type ServicesUncheckedCreateWithoutLabtestInput = {
    id?: number
    service_name: string
    description: string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PatientBillsUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServicesCreateOrConnectWithoutLabtestInput = {
    where: ServicesWhereUniqueInput
    create: XOR<ServicesCreateWithoutLabtestInput, ServicesUncheckedCreateWithoutLabtestInput>
  }

  export type MedicalRecordsCreateWithoutLab_testInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutMedicalInput
    patient: PatientCreateNestedOneWithoutMedicalInput
    vital_signs?: VitalSignsCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateWithoutLab_testInput = {
    id?: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    vital_signs?: VitalSignsUncheckedCreateNestedManyWithoutMedicalInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsCreateOrConnectWithoutLab_testInput = {
    where: MedicalRecordsWhereUniqueInput
    create: XOR<MedicalRecordsCreateWithoutLab_testInput, MedicalRecordsUncheckedCreateWithoutLab_testInput>
  }

  export type ServicesUpsertWithoutLabtestInput = {
    update: XOR<ServicesUpdateWithoutLabtestInput, ServicesUncheckedUpdateWithoutLabtestInput>
    create: XOR<ServicesCreateWithoutLabtestInput, ServicesUncheckedCreateWithoutLabtestInput>
    where?: ServicesWhereInput
  }

  export type ServicesUpdateToOneWithWhereWithoutLabtestInput = {
    where?: ServicesWhereInput
    data: XOR<ServicesUpdateWithoutLabtestInput, ServicesUncheckedUpdateWithoutLabtestInput>
  }

  export type ServicesUpdateWithoutLabtestInput = {
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PatientBillsUpdateManyWithoutServiceNestedInput
  }

  export type ServicesUncheckedUpdateWithoutLabtestInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PatientBillsUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type MedicalRecordsUpsertWithoutLab_testInput = {
    update: XOR<MedicalRecordsUpdateWithoutLab_testInput, MedicalRecordsUncheckedUpdateWithoutLab_testInput>
    create: XOR<MedicalRecordsCreateWithoutLab_testInput, MedicalRecordsUncheckedCreateWithoutLab_testInput>
    where?: MedicalRecordsWhereInput
  }

  export type MedicalRecordsUpdateToOneWithWhereWithoutLab_testInput = {
    where?: MedicalRecordsWhereInput
    data: XOR<MedicalRecordsUpdateWithoutLab_testInput, MedicalRecordsUncheckedUpdateWithoutLab_testInput>
  }

  export type MedicalRecordsUpdateWithoutLab_testInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutMedicalNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalNestedInput
    vital_signs?: VitalSignsUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateWithoutLab_testInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vital_signs?: VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type AppointmentCreateWithoutMedicalInput = {
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    bills?: PaymentCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutMedicalInput = {
    id?: number
    patient_id: string
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bills?: PaymentUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutMedicalInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutMedicalInput, AppointmentUncheckedCreateWithoutMedicalInput>
  }

  export type PatientCreateWithoutMedicalInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
    ratings?: RatingCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
    ratings?: RatingUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalInput, PatientUncheckedCreateWithoutMedicalInput>
  }

  export type LabTestCreateWithoutMedical_recordInput = {
    test_date: Date | string
    result: string
    status: string
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
    services: ServicesCreateNestedOneWithoutLabtestInput
  }

  export type LabTestUncheckedCreateWithoutMedical_recordInput = {
    id?: number
    test_date: Date | string
    result: string
    status: string
    notes: string
    service_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabTestCreateOrConnectWithoutMedical_recordInput = {
    where: LabTestWhereUniqueInput
    create: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput>
  }

  export type LabTestCreateManyMedical_recordInputEnvelope = {
    data: LabTestCreateManyMedical_recordInput | LabTestCreateManyMedical_recordInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignsCreateWithoutMedicalInput = {
    patient_id: string
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VitalSignsUncheckedCreateWithoutMedicalInput = {
    id?: number
    patient_id: string
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VitalSignsCreateOrConnectWithoutMedicalInput = {
    where: VitalSignsWhereUniqueInput
    create: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput>
  }

  export type VitalSignsCreateManyMedicalInputEnvelope = {
    data: VitalSignsCreateManyMedicalInput | VitalSignsCreateManyMedicalInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutMedicalInput = {
    patient_id: string
    diagnosis: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    doctor: DoctorCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutMedicalInput = {
    id?: number
    patient_id: string
    diagnosis: string
    doctor_id: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutMedicalInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput>
  }

  export type DiagnosisCreateManyMedicalInputEnvelope = {
    data: DiagnosisCreateManyMedicalInput | DiagnosisCreateManyMedicalInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithoutMedicalInput = {
    update: XOR<AppointmentUpdateWithoutMedicalInput, AppointmentUncheckedUpdateWithoutMedicalInput>
    create: XOR<AppointmentCreateWithoutMedicalInput, AppointmentUncheckedCreateWithoutMedicalInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutMedicalInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutMedicalInput, AppointmentUncheckedUpdateWithoutMedicalInput>
  }

  export type AppointmentUpdateWithoutMedicalInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    bills?: PaymentUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutMedicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type PatientUpsertWithoutMedicalInput = {
    update: XOR<PatientUpdateWithoutMedicalInput, PatientUncheckedUpdateWithoutMedicalInput>
    create: XOR<PatientCreateWithoutMedicalInput, PatientUncheckedCreateWithoutMedicalInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalInput, PatientUncheckedUpdateWithoutMedicalInput>
  }

  export type PatientUpdateWithoutMedicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
    ratings?: RatingUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LabTestUpsertWithWhereUniqueWithoutMedical_recordInput = {
    where: LabTestWhereUniqueInput
    update: XOR<LabTestUpdateWithoutMedical_recordInput, LabTestUncheckedUpdateWithoutMedical_recordInput>
    create: XOR<LabTestCreateWithoutMedical_recordInput, LabTestUncheckedCreateWithoutMedical_recordInput>
  }

  export type LabTestUpdateWithWhereUniqueWithoutMedical_recordInput = {
    where: LabTestWhereUniqueInput
    data: XOR<LabTestUpdateWithoutMedical_recordInput, LabTestUncheckedUpdateWithoutMedical_recordInput>
  }

  export type LabTestUpdateManyWithWhereWithoutMedical_recordInput = {
    where: LabTestScalarWhereInput
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyWithoutMedical_recordInput>
  }

  export type LabTestScalarWhereInput = {
    AND?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
    OR?: LabTestScalarWhereInput[]
    NOT?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
    id?: IntFilter<"LabTest"> | number
    record_id?: IntFilter<"LabTest"> | number
    test_date?: DateTimeFilter<"LabTest"> | Date | string
    result?: StringFilter<"LabTest"> | string
    status?: StringFilter<"LabTest"> | string
    notes?: StringFilter<"LabTest"> | string
    service_id?: IntFilter<"LabTest"> | number
    created_at?: DateTimeFilter<"LabTest"> | Date | string
    updated_at?: DateTimeFilter<"LabTest"> | Date | string
  }

  export type VitalSignsUpsertWithWhereUniqueWithoutMedicalInput = {
    where: VitalSignsWhereUniqueInput
    update: XOR<VitalSignsUpdateWithoutMedicalInput, VitalSignsUncheckedUpdateWithoutMedicalInput>
    create: XOR<VitalSignsCreateWithoutMedicalInput, VitalSignsUncheckedCreateWithoutMedicalInput>
  }

  export type VitalSignsUpdateWithWhereUniqueWithoutMedicalInput = {
    where: VitalSignsWhereUniqueInput
    data: XOR<VitalSignsUpdateWithoutMedicalInput, VitalSignsUncheckedUpdateWithoutMedicalInput>
  }

  export type VitalSignsUpdateManyWithWhereWithoutMedicalInput = {
    where: VitalSignsScalarWhereInput
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyWithoutMedicalInput>
  }

  export type VitalSignsScalarWhereInput = {
    AND?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    OR?: VitalSignsScalarWhereInput[]
    NOT?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    id?: IntFilter<"VitalSigns"> | number
    patient_id?: StringFilter<"VitalSigns"> | string
    medical_id?: IntFilter<"VitalSigns"> | number
    body_temperature?: FloatFilter<"VitalSigns"> | number
    systolic?: IntFilter<"VitalSigns"> | number
    diastolic?: IntFilter<"VitalSigns"> | number
    heartRate?: StringFilter<"VitalSigns"> | string
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    oxygen_saturation?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    created_at?: DateTimeFilter<"VitalSigns"> | Date | string
    updated_at?: DateTimeFilter<"VitalSigns"> | Date | string
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutMedicalInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutMedicalInput, DiagnosisUncheckedUpdateWithoutMedicalInput>
    create: XOR<DiagnosisCreateWithoutMedicalInput, DiagnosisUncheckedCreateWithoutMedicalInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutMedicalInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutMedicalInput, DiagnosisUncheckedUpdateWithoutMedicalInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutMedicalInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutMedicalInput>
  }

  export type MedicalRecordsCreateWithoutVital_signsInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutMedicalInput
    patient: PatientCreateNestedOneWithoutMedicalInput
    lab_test?: LabTestCreateNestedManyWithoutMedical_recordInput
    diagnosis?: DiagnosisCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateWithoutVital_signsInput = {
    id?: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lab_test?: LabTestUncheckedCreateNestedManyWithoutMedical_recordInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsCreateOrConnectWithoutVital_signsInput = {
    where: MedicalRecordsWhereUniqueInput
    create: XOR<MedicalRecordsCreateWithoutVital_signsInput, MedicalRecordsUncheckedCreateWithoutVital_signsInput>
  }

  export type MedicalRecordsUpsertWithoutVital_signsInput = {
    update: XOR<MedicalRecordsUpdateWithoutVital_signsInput, MedicalRecordsUncheckedUpdateWithoutVital_signsInput>
    create: XOR<MedicalRecordsCreateWithoutVital_signsInput, MedicalRecordsUncheckedCreateWithoutVital_signsInput>
    where?: MedicalRecordsWhereInput
  }

  export type MedicalRecordsUpdateToOneWithWhereWithoutVital_signsInput = {
    where?: MedicalRecordsWhereInput
    data: XOR<MedicalRecordsUpdateWithoutVital_signsInput, MedicalRecordsUncheckedUpdateWithoutVital_signsInput>
  }

  export type MedicalRecordsUpdateWithoutVital_signsInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutMedicalNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalNestedInput
    lab_test?: LabTestUpdateManyWithoutMedical_recordNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateWithoutVital_signsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lab_test?: LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsCreateWithoutDiagnosisInput = {
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointment: AppointmentCreateNestedOneWithoutMedicalInput
    patient: PatientCreateNestedOneWithoutMedicalInput
    lab_test?: LabTestCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsUncheckedCreateWithoutDiagnosisInput = {
    id?: number
    patient_id: string
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lab_test?: LabTestUncheckedCreateNestedManyWithoutMedical_recordInput
    vital_signs?: VitalSignsUncheckedCreateNestedManyWithoutMedicalInput
  }

  export type MedicalRecordsCreateOrConnectWithoutDiagnosisInput = {
    where: MedicalRecordsWhereUniqueInput
    create: XOR<MedicalRecordsCreateWithoutDiagnosisInput, MedicalRecordsUncheckedCreateWithoutDiagnosisInput>
  }

  export type DoctorCreateWithoutDiagnosisInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    ratings?: RatingCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutDiagnosisInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    ratings?: RatingUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutDiagnosisInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutDiagnosisInput, DoctorUncheckedCreateWithoutDiagnosisInput>
  }

  export type MedicalRecordsUpsertWithoutDiagnosisInput = {
    update: XOR<MedicalRecordsUpdateWithoutDiagnosisInput, MedicalRecordsUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<MedicalRecordsCreateWithoutDiagnosisInput, MedicalRecordsUncheckedCreateWithoutDiagnosisInput>
    where?: MedicalRecordsWhereInput
  }

  export type MedicalRecordsUpdateToOneWithWhereWithoutDiagnosisInput = {
    where?: MedicalRecordsWhereInput
    data: XOR<MedicalRecordsUpdateWithoutDiagnosisInput, MedicalRecordsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type MedicalRecordsUpdateWithoutDiagnosisInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutMedicalNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalNestedInput
    lab_test?: LabTestUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lab_test?: LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type DoctorUpsertWithoutDiagnosisInput = {
    update: XOR<DoctorUpdateWithoutDiagnosisInput, DoctorUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<DoctorCreateWithoutDiagnosisInput, DoctorUncheckedCreateWithoutDiagnosisInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutDiagnosisInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutDiagnosisInput, DoctorUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DoctorUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutDiagnosisInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateWithoutRatingsInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutRatingsInput = {
    id: string
    email: string
    name: string
    specialization: string
    license_number: string
    phone: string
    address: string
    department?: string | null
    img?: string | null
    availability_status?: string | null
    type?: $Enums.JOBTYPE
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    working_days?: WorkingDaysUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutRatingsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutRatingsInput, DoctorUncheckedCreateWithoutRatingsInput>
  }

  export type PatientCreateWithoutRatingsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsCreateNestedManyWithoutPatientInput
    payments?: PaymentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRatingsInput = {
    id: string
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender?: $Enums.GENDER
    phone: string
    email: string
    marital_status: string
    address: string
    emergency_contact_name: string
    emergency_contact_number: string
    relation: string
    blood_group?: string | null
    allergies?: string | null
    medical_conditions?: string | null
    medical_history?: string | null
    insurance_provider?: string | null
    insurance_number?: string | null
    privacy_consent: boolean
    service_consent: boolean
    medical_consent: boolean
    img?: string | null
    colorCode?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medical?: MedicalRecordsUncheckedCreateNestedManyWithoutPatientInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRatingsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRatingsInput, PatientUncheckedCreateWithoutRatingsInput>
  }

  export type DoctorUpsertWithoutRatingsInput = {
    update: XOR<DoctorUpdateWithoutRatingsInput, DoctorUncheckedUpdateWithoutRatingsInput>
    create: XOR<DoctorCreateWithoutRatingsInput, DoctorUncheckedCreateWithoutRatingsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutRatingsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutRatingsInput, DoctorUncheckedUpdateWithoutRatingsInput>
  }

  export type DoctorUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    availability_status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJOBTYPEFieldUpdateOperationsInput | $Enums.JOBTYPE
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    working_days?: WorkingDaysUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientUpsertWithoutRatingsInput = {
    update: XOR<PatientUpdateWithoutRatingsInput, PatientUncheckedUpdateWithoutRatingsInput>
    create: XOR<PatientCreateWithoutRatingsInput, PatientUncheckedCreateWithoutRatingsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRatingsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRatingsInput, PatientUncheckedUpdateWithoutRatingsInput>
  }

  export type PatientUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUpdateManyWithoutPatientNestedInput
    payments?: PaymentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    marital_status?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_number?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medical_conditions?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_provider?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_number?: NullableStringFieldUpdateOperationsInput | string | null
    privacy_consent?: BoolFieldUpdateOperationsInput | boolean
    service_consent?: BoolFieldUpdateOperationsInput | boolean
    medical_consent?: BoolFieldUpdateOperationsInput | boolean
    img?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutPatientNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LabTestCreateWithoutServicesInput = {
    test_date: Date | string
    result: string
    status: string
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
    medical_record: MedicalRecordsCreateNestedOneWithoutLab_testInput
  }

  export type LabTestUncheckedCreateWithoutServicesInput = {
    id?: number
    record_id: number
    test_date: Date | string
    result: string
    status: string
    notes: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabTestCreateOrConnectWithoutServicesInput = {
    where: LabTestWhereUniqueInput
    create: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
  }

  export type PatientBillsCreateWithoutServiceInput = {
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
    payment: PaymentCreateNestedOneWithoutBillsInput
  }

  export type PatientBillsUncheckedCreateWithoutServiceInput = {
    id?: number
    bill_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsCreateOrConnectWithoutServiceInput = {
    where: PatientBillsWhereUniqueInput
    create: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput>
  }

  export type PatientBillsCreateManyServiceInputEnvelope = {
    data: PatientBillsCreateManyServiceInput | PatientBillsCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type LabTestUpsertWithoutServicesInput = {
    update: XOR<LabTestUpdateWithoutServicesInput, LabTestUncheckedUpdateWithoutServicesInput>
    create: XOR<LabTestCreateWithoutServicesInput, LabTestUncheckedCreateWithoutServicesInput>
    where?: LabTestWhereInput
  }

  export type LabTestUpdateToOneWithWhereWithoutServicesInput = {
    where?: LabTestWhereInput
    data: XOR<LabTestUpdateWithoutServicesInput, LabTestUncheckedUpdateWithoutServicesInput>
  }

  export type LabTestUpdateWithoutServicesInput = {
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical_record?: MedicalRecordsUpdateOneRequiredWithoutLab_testNestedInput
  }

  export type LabTestUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsUpsertWithWhereUniqueWithoutServiceInput = {
    where: PatientBillsWhereUniqueInput
    update: XOR<PatientBillsUpdateWithoutServiceInput, PatientBillsUncheckedUpdateWithoutServiceInput>
    create: XOR<PatientBillsCreateWithoutServiceInput, PatientBillsUncheckedCreateWithoutServiceInput>
  }

  export type PatientBillsUpdateWithWhereUniqueWithoutServiceInput = {
    where: PatientBillsWhereUniqueInput
    data: XOR<PatientBillsUpdateWithoutServiceInput, PatientBillsUncheckedUpdateWithoutServiceInput>
  }

  export type PatientBillsUpdateManyWithWhereWithoutServiceInput = {
    where: PatientBillsScalarWhereInput
    data: XOR<PatientBillsUpdateManyMutationInput, PatientBillsUncheckedUpdateManyWithoutServiceInput>
  }

  export type AppointmentCreateManyPatientInput = {
    id?: number
    doctor_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MedicalRecordsCreateManyPatientInput = {
    id?: number
    appointment_id: number
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateManyPatientInput = {
    id?: number
    bill_id?: number | null
    appointment_Id: number
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingCreateManyPatientInput = {
    id?: number
    staff_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    bills?: PaymentUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordsUpdateWithoutPatientInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutMedicalNestedInput
    lab_test?: LabTestUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lab_test?: LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPatientInput = {
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutBillsNestedInput
    bills?: PatientBillsUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_Id?: IntFieldUpdateOperationsInput | number
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PatientBillsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_Id?: IntFieldUpdateOperationsInput | number
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutPatientInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    staff_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    staff_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysCreateManyDoctorInput = {
    id?: number
    day: string
    start_time: string
    close_time: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: number
    patient_id: string
    appointmentDate: Date | string
    appointmentTime: string
    status?: $Enums.AppointmentStatus
    type: string
    note?: string | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RatingCreateManyDoctorInput = {
    id?: number
    patient_id: string
    rating: number
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisCreateManyDoctorInput = {
    id?: number
    patient_id: string
    medical_id: number
    diagnosis: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkingDaysUpdateWithoutDoctorInput = {
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingDaysUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    close_time?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    bills?: PaymentUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PaymentUncheckedUpdateManyWithoutAppointmentNestedInput
    medical?: MedicalRecordsUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutDoctorInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUpdateWithoutDoctorInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    medical?: MedicalRecordsUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    medical_id?: IntFieldUpdateOperationsInput | number
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyAppointmentInput = {
    id?: number
    bill_id?: number | null
    patient_id: string
    bill_date: Date | string
    payment_Date: Date | string
    discount: number
    total_amount: number
    amount_paid: number
    payment_method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    receipt_number?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MedicalRecordsCreateManyAppointmentInput = {
    id?: number
    patient_id: string
    doctor_id: string
    treatment_plan?: string | null
    prescriptions?: string | null
    lab_request?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentUpdateWithoutAppointmentInput = {
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPaymentsNestedInput
    bills?: PatientBillsUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: StringFieldUpdateOperationsInput | string
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: PatientBillsUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: NullableIntFieldUpdateOperationsInput | number | null
    patient_id?: StringFieldUpdateOperationsInput | string
    bill_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    amount_paid?: FloatFieldUpdateOperationsInput | number
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    receipt_number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordsUpdateWithoutAppointmentInput = {
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicalNestedInput
    lab_test?: LabTestUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lab_test?: LabTestUncheckedUpdateManyWithoutMedical_recordNestedInput
    vital_signs?: VitalSignsUncheckedUpdateManyWithoutMedicalNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutMedicalNestedInput
  }

  export type MedicalRecordsUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    treatment_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableStringFieldUpdateOperationsInput | string | null
    lab_request?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsCreateManyPaymentInput = {
    id?: number
    service_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsUpdateWithoutPaymentInput = {
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServicesUpdateOneRequiredWithoutBillsNestedInput
  }

  export type PatientBillsUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestCreateManyMedical_recordInput = {
    id?: number
    test_date: Date | string
    result: string
    status: string
    notes: string
    service_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VitalSignsCreateManyMedicalInput = {
    id?: number
    patient_id: string
    body_temperature: number
    systolic: number
    diastolic: number
    heartRate: string
    respiratoryRate?: number | null
    oxygen_saturation?: number | null
    weight?: number | null
    height?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiagnosisCreateManyMedicalInput = {
    id?: number
    patient_id: string
    diagnosis: string
    doctor_id: string
    symptoms: string
    notes?: string | null
    prescribed_medications?: string | null
    follow_up_plan?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabTestUpdateWithoutMedical_recordInput = {
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicesUpdateOneRequiredWithoutLabtestNestedInput
  }

  export type LabTestUncheckedUpdateWithoutMedical_recordInput = {
    id?: IntFieldUpdateOperationsInput | number
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestUncheckedUpdateManyWithoutMedical_recordInput = {
    id?: IntFieldUpdateOperationsInput | number
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    result?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsUpdateWithoutMedicalInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsUncheckedUpdateWithoutMedicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VitalSignsUncheckedUpdateManyWithoutMedicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    body_temperature?: FloatFieldUpdateOperationsInput | number
    systolic?: IntFieldUpdateOperationsInput | number
    diastolic?: IntFieldUpdateOperationsInput | number
    heartRate?: StringFieldUpdateOperationsInput | string
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    oxygen_saturation?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUpdateWithoutMedicalInput = {
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutMedicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyWithoutMedicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_id?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    doctor_id?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescribed_medications?: NullableStringFieldUpdateOperationsInput | string | null
    follow_up_plan?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsCreateManyServiceInput = {
    id?: number
    bill_id: number
    service_date: Date | string
    quantity: number
    unit_cost: number
    total_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PatientBillsUpdateWithoutServiceInput = {
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutBillsNestedInput
  }

  export type PatientBillsUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBillsUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bill_id?: IntFieldUpdateOperationsInput | number
    service_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
```

## 📄 lib\generated\prisma\index.js

```js

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  objectEnumValues,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require('./runtime/library.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 6.6.0
 * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
 */
Prisma.prismaVersion = {
  client: "6.6.0",
  engine: "f676762280b54cd07c770017ed3711ddde35f37a"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}




  const path = require('path')

/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.PatientScalarFieldEnum = {
  id: 'id',
  first_name: 'first_name',
  last_name: 'last_name',
  date_of_birth: 'date_of_birth',
  gender: 'gender',
  phone: 'phone',
  email: 'email',
  marital_status: 'marital_status',
  address: 'address',
  emergency_contact_name: 'emergency_contact_name',
  emergency_contact_number: 'emergency_contact_number',
  relation: 'relation',
  blood_group: 'blood_group',
  allergies: 'allergies',
  medical_conditions: 'medical_conditions',
  medical_history: 'medical_history',
  insurance_provider: 'insurance_provider',
  insurance_number: 'insurance_number',
  privacy_consent: 'privacy_consent',
  service_consent: 'service_consent',
  medical_consent: 'medical_consent',
  img: 'img',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DoctorScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  specialization: 'specialization',
  license_number: 'license_number',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  availability_status: 'availability_status',
  type: 'type',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.WorkingDaysScalarFieldEnum = {
  id: 'id',
  doctor_id: 'doctor_id',
  day: 'day',
  start_time: 'start_time',
  close_time: 'close_time',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.StaffScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  license_number: 'license_number',
  role: 'role',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AppointmentScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  doctor_id: 'doctor_id',
  appointmentDate: 'appointmentDate',
  appointmentTime: 'appointmentTime',
  status: 'status',
  type: 'type',
  note: 'note',
  reason: 'reason',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PaymentScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  patient_id: 'patient_id',
  appointment_Id: 'appointment_Id',
  bill_date: 'bill_date',
  payment_Date: 'payment_Date',
  discount: 'discount',
  total_amount: 'total_amount',
  amount_paid: 'amount_paid',
  payment_method: 'payment_method',
  status: 'status',
  receipt_number: 'receipt_number',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PatientBillsScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  service_id: 'service_id',
  service_date: 'service_date',
  quantity: 'quantity',
  unit_cost: 'unit_cost',
  total_cost: 'total_cost',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.LabTestScalarFieldEnum = {
  id: 'id',
  record_id: 'record_id',
  test_date: 'test_date',
  result: 'result',
  status: 'status',
  notes: 'notes',
  service_id: 'service_id',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.MedicalRecordsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  appointment_id: 'appointment_id',
  doctor_id: 'doctor_id',
  treatment_plan: 'treatment_plan',
  prescriptions: 'prescriptions',
  lab_request: 'lab_request',
  notes: 'notes',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.VitalSignsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  body_temperature: 'body_temperature',
  systolic: 'systolic',
  diastolic: 'diastolic',
  heartRate: 'heartRate',
  respiratoryRate: 'respiratoryRate',
  oxygen_saturation: 'oxygen_saturation',
  weight: 'weight',
  height: 'height',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DiagnosisScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  diagnosis: 'diagnosis',
  doctor_id: 'doctor_id',
  symptoms: 'symptoms',
  notes: 'notes',
  prescribed_medications: 'prescribed_medications',
  follow_up_plan: 'follow_up_plan',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AuditLogScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  record_id: 'record_id',
  action: 'action',
  details: 'details',
  model: 'model',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.RatingScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  staff_id: 'staff_id',
  rating: 'rating',
  comment: 'comment',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.ServicesScalarFieldEnum = {
  id: 'id',
  service_name: 'service_name',
  description: 'description',
  price: 'price',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};
exports.Role = exports.$Enums.Role = {
  ADMIN: 'ADMIN',
  NURSE: 'NURSE',
  DOCTOR: 'DOCTOR',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  PATIENT: 'PATIENT',
  CASHIER: 'CASHIER'
};

exports.Status = exports.$Enums.Status = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DORMANT: 'DORMANT'
};

exports.JOBTYPE = exports.$Enums.JOBTYPE = {
  FULL: 'FULL',
  PART: 'PART'
};

exports.GENDER = exports.$Enums.GENDER = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

exports.AppointmentStatus = exports.$Enums.AppointmentStatus = {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

exports.PaymentMethod = exports.$Enums.PaymentMethod = {
  CASH: 'CASH',
  CARD: 'CARD',
  UPI: 'UPI'
};

exports.PaymentStatus = exports.$Enums.PaymentStatus = {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  PART: 'PART'
};

exports.Prisma.ModelName = {
  Patient: 'Patient',
  Doctor: 'Doctor',
  WorkingDays: 'WorkingDays',
  Staff: 'Staff',
  Appointment: 'Appointment',
  Payment: 'Payment',
  PatientBills: 'PatientBills',
  LabTest: 'LabTest',
  MedicalRecords: 'MedicalRecords',
  VitalSigns: 'VitalSigns',
  Diagnosis: 'Diagnosis',
  AuditLog: 'AuditLog',
  Rating: 'Rating',
  Services: 'Services'
};
/**
 * Create the Client
 */
const config = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client-js"
    },
    "output": {
      "value": "C:\\Users\\dell\\Desktop\\fuckin_dbms\\lib\\generated\\prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "windows",
        "native": true
      }
    ],
    "previewFeatures": [],
    "sourceFilePath": "C:\\Users\\dell\\Desktop\\fuckin_dbms\\prisma\\schema.prisma",
    "isCustomOutput": true
  },
  "relativeEnvPaths": {
    "rootEnvPath": null,
    "schemaEnvPath": "../../../.env"
  },
  "relativePath": "../../../prisma",
  "clientVersion": "6.6.0",
  "engineVersion": "f676762280b54cd07c770017ed3711ddde35f37a",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider = \"prisma-client-js\"\n  output   = \"../lib/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nenum Role {\n  ADMIN\n  NURSE\n  DOCTOR\n  LAB_TECHNICIAN\n  PATIENT\n  CASHIER\n}\n\nenum Status {\n  ACTIVE\n  INACTIVE\n  DORMANT\n}\n\nenum JOBTYPE {\n  FULL\n  PART\n}\n\nenum GENDER {\n  MALE\n  FEMALE\n  OTHER\n}\n\nenum AppointmentStatus {\n  PENDING\n  SCHEDULED\n  CANCELLED\n  COMPLETED\n}\n\nenum PaymentMethod {\n  CASH\n  CARD\n  UPI\n}\n\nenum PaymentStatus {\n  PAID\n  UNPAID\n  PART\n}\n\nmodel Patient {\n  id                       String   @id\n  first_name               String\n  last_name                String\n  date_of_birth            DateTime\n  gender                   GENDER   @default(MALE)\n  phone                    String\n  email                    String   @unique\n  marital_status           String\n  address                  String\n  emergency_contact_name   String\n  emergency_contact_number String\n  relation                 String\n  blood_group              String?\n  allergies                String?\n  medical_conditions       String?\n  medical_history          String?\n  insurance_provider       String?\n  insurance_number         String?\n  privacy_consent          Boolean\n  service_consent          Boolean\n  medical_consent          Boolean\n  img                      String?\n  colorCode                String?\n\n  appointments Appointment[]\n  medical      MedicalRecords[]\n  payments     Payment[]\n  ratings      Rating[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Doctor {\n  id                  String  @id\n  email               String  @unique\n  name                String\n  specialization      String\n  license_number      String\n  phone               String\n  address             String\n  department          String?\n  img                 String?\n  availability_status String?\n  type                JOBTYPE @default(FULL)\n  colorCode           String?\n\n  working_days WorkingDays[]\n  appointments Appointment[]\n  ratings      Rating[]\n  diagnosis    Diagnosis[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel WorkingDays {\n  id         Int    @id @default(autoincrement())\n  doctor_id  String\n  day        String\n  start_time String\n  close_time String\n\n  doctor Doctor @relation(fields: [doctor_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Staff {\n  id             String  @id\n  name           String\n  email          String  @unique\n  phone          String\n  address        String\n  department     String?\n  img            String?\n  license_number String?\n\n  role   Role\n  status Status @default(ACTIVE)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Appointment {\n  id              Int               @id @default(autoincrement())\n  patient_id      String\n  doctor_id       String\n  appointmentDate DateTime\n  appointmentTime String\n  status          AppointmentStatus @default(PENDING)\n  type            String\n  note            String?\n  patient         Patient           @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  doctor          Doctor            @relation(fields: [doctor_id], references: [id])\n\n  bills   Payment[]\n  medical MedicalRecords[]\n\n  reason     String?\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Payment {\n  id             Int      @id @default(autoincrement())\n  bill_id        Int?\n  patient_id     String\n  appointment_Id Int      @unique\n  bill_date      DateTime\n  payment_Date   DateTime\n  discount       Float\n  total_amount   Float\n  amount_paid    Float\n\n  payment_method PaymentMethod @default(CASH)\n  status         PaymentStatus @default(UNPAID)\n  receipt_number Int           @default(autoincrement())\n\n  appointment Appointment    @relation(fields: [appointment_Id], references: [id], onDelete: Cascade)\n  patient     Patient        @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  bills       PatientBills[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel PatientBills {\n  id           Int      @id @default(autoincrement())\n  bill_id      Int\n  service_id   Int\n  service_date DateTime\n  quantity     Int\n  unit_cost    Float\n  total_cost   Float\n  service      Services @relation(fields: [service_id], references: [id])\n  payment      Payment  @relation(fields: [bill_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel LabTest {\n  id         Int      @id @default(autoincrement())\n  record_id  Int\n  test_date  DateTime\n  result     String\n  status     String\n  notes      String\n  service_id Int      @unique\n  services   Services @relation(fields: [service_id], references: [id])\n\n  medical_record MedicalRecords @relation(fields: [record_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel MedicalRecords {\n  id             Int     @id @default(autoincrement())\n  patient_id     String\n  appointment_id Int\n  doctor_id      String\n  treatment_plan String?\n  prescriptions  String?\n  lab_request    String?\n\n  appointment Appointment @relation(fields: [appointment_id], references: [id], onDelete: Cascade)\n  patient     Patient     @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n  lab_test    LabTest[]\n  notes       String?\n\n  vital_signs VitalSigns[]\n  diagnosis   Diagnosis[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel VitalSigns {\n  id                Int            @id @default(autoincrement())\n  patient_id        String\n  medical_id        Int\n  medical           MedicalRecords @relation(fields: [medical_id], references: [id], onDelete: Cascade)\n  body_temperature  Float\n  systolic          Int\n  diastolic         Int\n  heartRate         String\n  respiratoryRate   Int?\n  oxygen_saturation Int?\n  weight            Float?\n  height            Float?\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Diagnosis {\n  id                     Int            @id @default(autoincrement())\n  patient_id             String\n  medical_id             Int\n  medical                MedicalRecords @relation(fields: [medical_id], references: [id])\n  diagnosis              String\n  doctor_id              String\n  doctor                 Doctor         @relation(fields: [doctor_id], references: [id], onDelete: Cascade)\n  symptoms               String\n  notes                  String?\n  prescribed_medications String?\n  follow_up_plan         String?\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel AuditLog {\n  id        Int     @id @default(autoincrement())\n  user_id   String\n  record_id String\n  action    String\n  details   String?\n  model     String\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Rating {\n  id         Int     @id @default(autoincrement())\n  patient_id String\n  staff_id   String\n  rating     Int\n  comment    String?\n\n  doctor  Doctor  @relation(fields: [staff_id], references: [id], onDelete: Cascade)\n  patient Patient @relation(fields: [patient_id], references: [id], onDelete: Cascade)\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Services {\n  id           Int            @id @default(autoincrement())\n  service_name String\n  description  String\n  price        Float\n  labtest      LabTest?\n  bills        PatientBills[]\n\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n",
  "inlineSchemaHash": "d5d257b0852a4d9033b89e8f82d0278da94847994f9f67d5c910c19f30df7d4f",
  "copyEngine": true
}

const fs = require('fs')

config.dirname = __dirname
if (!fs.existsSync(path.join(__dirname, 'schema.prisma'))) {
  const alternativePaths = [
    "lib/generated/prisma",
    "generated/prisma",
  ]
  
  const alternativePath = alternativePaths.find((altPath) => {
    return fs.existsSync(path.join(process.cwd(), altPath, 'schema.prisma'))
  }) ?? alternativePaths[0]

  config.dirname = path.join(process.cwd(), alternativePath)
  config.isBundled = true
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"Patient\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"first_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"last_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"date_of_birth\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"gender\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"GENDER\",\"nativeType\":null,\"default\":\"MALE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"marital_status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emergency_contact_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emergency_contact_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"relation\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"blood_group\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"allergies\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_conditions\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_history\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"insurance_provider\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"insurance_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"privacy_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_consent\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"colorCode\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToPatient\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToPatient\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"PatientToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"ratings\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Rating\",\"nativeType\":null,\"relationName\":\"PatientToRating\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Doctor\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"specialization\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"license_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"department\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"availability_status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"JOBTYPE\",\"nativeType\":null,\"default\":\"FULL\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"colorCode\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"working_days\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"WorkingDays\",\"nativeType\":null,\"relationName\":\"DoctorToWorkingDays\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToDoctor\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"ratings\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Rating\",\"nativeType\":null,\"relationName\":\"DoctorToRating\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Diagnosis\",\"nativeType\":null,\"relationName\":\"DiagnosisToDoctor\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"WorkingDays\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"day\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"start_time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"close_time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DoctorToWorkingDays\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Staff\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"phone\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"department\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"img\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"license_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Role\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Status\",\"nativeType\":null,\"default\":\"ACTIVE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Appointment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointmentDate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointmentTime\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"AppointmentStatus\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"note\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"AppointmentToPatient\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"AppointmentToDoctor\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"AppointmentToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"AppointmentToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"reason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Payment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment_Id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment_Date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"discount\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"total_amount\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"amount_paid\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment_method\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"PaymentMethod\",\"nativeType\":null,\"default\":\"CASH\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"PaymentStatus\",\"nativeType\":null,\"default\":\"UNPAID\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"receipt_number\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToPayment\",\"relationFromFields\":[\"appointment_Id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"PatientToPayment\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PatientBills\",\"nativeType\":null,\"relationName\":\"PatientBillsToPayment\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"PatientBills\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bill_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"quantity\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"unit_cost\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"total_cost\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Services\",\"nativeType\":null,\"relationName\":\"PatientBillsToServices\",\"relationFromFields\":[\"service_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"payment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Payment\",\"nativeType\":null,\"relationName\":\"PatientBillsToPayment\",\"relationFromFields\":[\"bill_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"LabTest\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"record_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"test_date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"result\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"services\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Services\",\"nativeType\":null,\"relationName\":\"LabTestToServices\",\"relationFromFields\":[\"service_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_record\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"LabTestToMedicalRecords\",\"relationFromFields\":[\"record_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"MedicalRecords\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"treatment_plan\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"prescriptions\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"lab_request\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"appointment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Appointment\",\"nativeType\":null,\"relationName\":\"AppointmentToMedicalRecords\",\"relationFromFields\":[\"appointment_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToPatient\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"lab_test\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"LabTest\",\"nativeType\":null,\"relationName\":\"LabTestToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"vital_signs\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"VitalSigns\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToVitalSigns\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Diagnosis\",\"nativeType\":null,\"relationName\":\"DiagnosisToMedicalRecords\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"VitalSigns\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"MedicalRecordsToVitalSigns\",\"relationFromFields\":[\"medical_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"body_temperature\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"systolic\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diastolic\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"heartRate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"respiratoryRate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"oxygen_saturation\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"weight\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"height\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Diagnosis\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"medical\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"MedicalRecords\",\"nativeType\":null,\"relationName\":\"DiagnosisToMedicalRecords\",\"relationFromFields\":[\"medical_id\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"diagnosis\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DiagnosisToDoctor\",\"relationFromFields\":[\"doctor_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"symptoms\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"prescribed_medications\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"follow_up_plan\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"AuditLog\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"record_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"action\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"details\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"model\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Rating\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"staff_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"rating\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comment\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"doctor\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Doctor\",\"nativeType\":null,\"relationName\":\"DoctorToRating\",\"relationFromFields\":[\"staff_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"patient\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Patient\",\"nativeType\":null,\"relationName\":\"PatientToRating\",\"relationFromFields\":[\"patient_id\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Services\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"service_name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"price\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"labtest\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"LabTest\",\"nativeType\":null,\"relationName\":\"LabTestToServices\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bills\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PatientBills\",\"nativeType\":null,\"relationName\":\"PatientBillsToServices\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"Role\":{\"values\":[{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"NURSE\",\"dbName\":null},{\"name\":\"DOCTOR\",\"dbName\":null},{\"name\":\"LAB_TECHNICIAN\",\"dbName\":null},{\"name\":\"PATIENT\",\"dbName\":null},{\"name\":\"CASHIER\",\"dbName\":null}],\"dbName\":null},\"Status\":{\"values\":[{\"name\":\"ACTIVE\",\"dbName\":null},{\"name\":\"INACTIVE\",\"dbName\":null},{\"name\":\"DORMANT\",\"dbName\":null}],\"dbName\":null},\"JOBTYPE\":{\"values\":[{\"name\":\"FULL\",\"dbName\":null},{\"name\":\"PART\",\"dbName\":null}],\"dbName\":null},\"GENDER\":{\"values\":[{\"name\":\"MALE\",\"dbName\":null},{\"name\":\"FEMALE\",\"dbName\":null},{\"name\":\"OTHER\",\"dbName\":null}],\"dbName\":null},\"AppointmentStatus\":{\"values\":[{\"name\":\"PENDING\",\"dbName\":null},{\"name\":\"SCHEDULED\",\"dbName\":null},{\"name\":\"CANCELLED\",\"dbName\":null},{\"name\":\"COMPLETED\",\"dbName\":null}],\"dbName\":null},\"PaymentMethod\":{\"values\":[{\"name\":\"CASH\",\"dbName\":null},{\"name\":\"CARD\",\"dbName\":null},{\"name\":\"UPI\",\"dbName\":null}],\"dbName\":null},\"PaymentStatus\":{\"values\":[{\"name\":\"PAID\",\"dbName\":null},{\"name\":\"UNPAID\",\"dbName\":null},{\"name\":\"PART\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}")
defineDmmfProperty(exports.Prisma, config.runtimeDataModel)
config.engineWasm = undefined
config.compilerWasm = undefined


const { warnEnvConflicts } = require('./runtime/library.js')

warnEnvConflicts({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
})

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient
Object.assign(exports, Prisma)

// file annotations for bundling tools to include these files
path.join(__dirname, "query_engine-windows.dll.node");
path.join(process.cwd(), "lib/generated/prisma/query_engine-windows.dll.node")
// file annotations for bundling tools to include these files
path.join(__dirname, "schema.prisma");
path.join(process.cwd(), "lib/generated/prisma/schema.prisma")

```

## 📄 lib\generated\prisma\package.json

```json
{
  "name": "prisma-client-66b3be386e4134668e605e5e987f2f4b720a32b0e12f5231640964d565e5dcbc",
  "main": "index.js",
  "types": "index.d.ts",
  "browser": "index-browser.js",
  "exports": {
    "./client": {
      "require": {
        "node": "./index.js",
        "edge-light": "./wasm.js",
        "workerd": "./wasm.js",
        "worker": "./wasm.js",
        "browser": "./index-browser.js",
        "default": "./index.js"
      },
      "import": {
        "node": "./index.js",
        "edge-light": "./wasm.js",
        "workerd": "./wasm.js",
        "worker": "./wasm.js",
        "browser": "./index-browser.js",
        "default": "./index.js"
      },
      "default": "./index.js"
    },
    "./package.json": "./package.json",
    ".": {
      "require": {
        "node": "./index.js",
        "edge-light": "./wasm.js",
        "workerd": "./wasm.js",
        "worker": "./wasm.js",
        "browser": "./index-browser.js",
        "default": "./index.js"
      },
      "import": {
        "node": "./index.js",
        "edge-light": "./wasm.js",
        "workerd": "./wasm.js",
        "worker": "./wasm.js",
        "browser": "./index-browser.js",
        "default": "./index.js"
      },
      "default": "./index.js"
    },
    "./edge": {
      "types": "./edge.d.ts",
      "require": "./edge.js",
      "import": "./edge.js",
      "default": "./edge.js"
    },
    "./react-native": {
      "types": "./react-native.d.ts",
      "require": "./react-native.js",
      "import": "./react-native.js",
      "default": "./react-native.js"
    },
    "./extension": {
      "types": "./extension.d.ts",
      "require": "./extension.js",
      "import": "./extension.js",
      "default": "./extension.js"
    },
    "./index-browser": {
      "types": "./index.d.ts",
      "require": "./index-browser.js",
      "import": "./index-browser.js",
      "default": "./index-browser.js"
    },
    "./index": {
      "types": "./index.d.ts",
      "require": "./index.js",
      "import": "./index.js",
      "default": "./index.js"
    },
    "./wasm": {
      "types": "./wasm.d.ts",
      "require": "./wasm.js",
      "import": "./wasm.mjs",
      "default": "./wasm.mjs"
    },
    "./runtime/client": {
      "types": "./runtime/client.d.ts",
      "require": "./runtime/client.js",
      "import": "./runtime/client.mjs",
      "default": "./runtime/client.mjs"
    },
    "./runtime/library": {
      "types": "./runtime/library.d.ts",
      "require": "./runtime/library.js",
      "import": "./runtime/library.mjs",
      "default": "./runtime/library.mjs"
    },
    "./runtime/binary": {
      "types": "./runtime/binary.d.ts",
      "require": "./runtime/binary.js",
      "import": "./runtime/binary.mjs",
      "default": "./runtime/binary.mjs"
    },
    "./runtime/wasm": {
      "types": "./runtime/wasm.d.ts",
      "require": "./runtime/wasm.js",
      "import": "./runtime/wasm.mjs",
      "default": "./runtime/wasm.mjs"
    },
    "./runtime/edge": {
      "types": "./runtime/edge.d.ts",
      "require": "./runtime/edge.js",
      "import": "./runtime/edge-esm.js",
      "default": "./runtime/edge-esm.js"
    },
    "./runtime/react-native": {
      "types": "./runtime/react-native.d.ts",
      "require": "./runtime/react-native.js",
      "import": "./runtime/react-native.js",
      "default": "./runtime/react-native.js"
    },
    "./generator-build": {
      "require": "./generator-build/index.js",
      "import": "./generator-build/index.js",
      "default": "./generator-build/index.js"
    },
    "./sql": {
      "require": {
        "types": "./sql.d.ts",
        "node": "./sql.js",
        "default": "./sql.js"
      },
      "import": {
        "types": "./sql.d.ts",
        "node": "./sql.mjs",
        "default": "./sql.mjs"
      },
      "default": "./sql.js"
    },
    "./*": "./*"
  },
  "version": "6.6.0",
  "sideEffects": false
}
```

## 📄 lib\generated\prisma\runtime\edge-esm.js

```js
var aa=Object.create;var en=Object.defineProperty;var la=Object.getOwnPropertyDescriptor;var ua=Object.getOwnPropertyNames;var ca=Object.getPrototypeOf,pa=Object.prototype.hasOwnProperty;var me=(e,t)=>()=>(e&&(t=e(e=0)),t);var Fe=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ir=(e,t)=>{for(var r in t)en(e,r,{get:t[r],enumerable:!0})},ma=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ua(t))!pa.call(e,i)&&i!==r&&en(e,i,{get:()=>t[i],enumerable:!(n=la(t,i))||n.enumerable});return e};var Qe=(e,t,r)=>(r=e!=null?aa(ca(e)):{},ma(t||!e||!e.__esModule?en(r,"default",{value:e,enumerable:!0}):r,e));var y,u=me(()=>{"use strict";y={nextTick:(e,...t)=>{setTimeout(()=>{e(...t)},0)},env:{},version:"",cwd:()=>"/",stderr:{},argv:["/bin/node"]}});var b,c=me(()=>{"use strict";b=globalThis.performance??(()=>{let e=Date.now();return{now:()=>Date.now()-e}})()});var E,p=me(()=>{"use strict";E=()=>{};E.prototype=E});var m=me(()=>{"use strict"});var Ei=Fe(Ke=>{"use strict";d();u();c();p();m();var oi=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),da=oi(e=>{"use strict";e.byteLength=l,e.toByteArray=g,e.fromByteArray=S;var t=[],r=[],n=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(o=0,s=i.length;o<s;++o)t[o]=i[o],r[i.charCodeAt(o)]=o;var o,s;r[45]=62,r[95]=63;function a(A){var R=A.length;if(R%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var D=A.indexOf("=");D===-1&&(D=R);var M=D===R?0:4-D%4;return[D,M]}function l(A){var R=a(A),D=R[0],M=R[1];return(D+M)*3/4-M}function f(A,R,D){return(R+D)*3/4-D}function g(A){var R,D=a(A),M=D[0],B=D[1],k=new n(f(A,M,B)),F=0,ie=B>0?M-4:M,G;for(G=0;G<ie;G+=4)R=r[A.charCodeAt(G)]<<18|r[A.charCodeAt(G+1)]<<12|r[A.charCodeAt(G+2)]<<6|r[A.charCodeAt(G+3)],k[F++]=R>>16&255,k[F++]=R>>8&255,k[F++]=R&255;return B===2&&(R=r[A.charCodeAt(G)]<<2|r[A.charCodeAt(G+1)]>>4,k[F++]=R&255),B===1&&(R=r[A.charCodeAt(G)]<<10|r[A.charCodeAt(G+1)]<<4|r[A.charCodeAt(G+2)]>>2,k[F++]=R>>8&255,k[F++]=R&255),k}function h(A){return t[A>>18&63]+t[A>>12&63]+t[A>>6&63]+t[A&63]}function v(A,R,D){for(var M,B=[],k=R;k<D;k+=3)M=(A[k]<<16&16711680)+(A[k+1]<<8&65280)+(A[k+2]&255),B.push(h(M));return B.join("")}function S(A){for(var R,D=A.length,M=D%3,B=[],k=16383,F=0,ie=D-M;F<ie;F+=k)B.push(v(A,F,F+k>ie?ie:F+k));return M===1?(R=A[D-1],B.push(t[R>>2]+t[R<<4&63]+"==")):M===2&&(R=(A[D-2]<<8)+A[D-1],B.push(t[R>>10]+t[R>>4&63]+t[R<<2&63]+"=")),B.join("")}}),fa=oi(e=>{e.read=function(t,r,n,i,o){var s,a,l=o*8-i-1,f=(1<<l)-1,g=f>>1,h=-7,v=n?o-1:0,S=n?-1:1,A=t[r+v];for(v+=S,s=A&(1<<-h)-1,A>>=-h,h+=l;h>0;s=s*256+t[r+v],v+=S,h-=8);for(a=s&(1<<-h)-1,s>>=-h,h+=i;h>0;a=a*256+t[r+v],v+=S,h-=8);if(s===0)s=1-g;else{if(s===f)return a?NaN:(A?-1:1)*(1/0);a=a+Math.pow(2,i),s=s-g}return(A?-1:1)*a*Math.pow(2,s-i)},e.write=function(t,r,n,i,o,s){var a,l,f,g=s*8-o-1,h=(1<<g)-1,v=h>>1,S=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,A=i?0:s-1,R=i?1:-1,D=r<0||r===0&&1/r<0?1:0;for(r=Math.abs(r),isNaN(r)||r===1/0?(l=isNaN(r)?1:0,a=h):(a=Math.floor(Math.log(r)/Math.LN2),r*(f=Math.pow(2,-a))<1&&(a--,f*=2),a+v>=1?r+=S/f:r+=S*Math.pow(2,1-v),r*f>=2&&(a++,f/=2),a+v>=h?(l=0,a=h):a+v>=1?(l=(r*f-1)*Math.pow(2,o),a=a+v):(l=r*Math.pow(2,v-1)*Math.pow(2,o),a=0));o>=8;t[n+A]=l&255,A+=R,l/=256,o-=8);for(a=a<<o|l,g+=o;g>0;t[n+A]=a&255,A+=R,a/=256,g-=8);t[n+A-R]|=D*128}}),tn=da(),We=fa(),ti=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=T;Ke.SlowBuffer=ba;Ke.INSPECT_MAX_BYTES=50;var or=2147483647;Ke.kMaxLength=or;T.TYPED_ARRAY_SUPPORT=ga();!T.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function ga(){try{let e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),e.foo()===42}catch{return!1}}Object.defineProperty(T.prototype,"parent",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.buffer}});Object.defineProperty(T.prototype,"offset",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.byteOffset}});function be(e){if(e>or)throw new RangeError('The value "'+e+'" is invalid for option "size"');let t=new Uint8Array(e);return Object.setPrototypeOf(t,T.prototype),t}function T(e,t,r){if(typeof e=="number"){if(typeof t=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return on(e)}return si(e,t,r)}T.poolSize=8192;function si(e,t,r){if(typeof e=="string")return ya(e,t);if(ArrayBuffer.isView(e))return wa(e);if(e==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(de(e,ArrayBuffer)||e&&de(e.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(de(e,SharedArrayBuffer)||e&&de(e.buffer,SharedArrayBuffer)))return li(e,t,r);if(typeof e=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');let n=e.valueOf&&e.valueOf();if(n!=null&&n!==e)return T.from(n,t,r);let i=Ea(e);if(i)return i;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]=="function")return T.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}T.from=function(e,t,r){return si(e,t,r)};Object.setPrototypeOf(T.prototype,Uint8Array.prototype);Object.setPrototypeOf(T,Uint8Array);function ai(e){if(typeof e!="number")throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function ha(e,t,r){return ai(e),e<=0?be(e):t!==void 0?typeof r=="string"?be(e).fill(t,r):be(e).fill(t):be(e)}T.alloc=function(e,t,r){return ha(e,t,r)};function on(e){return ai(e),be(e<0?0:sn(e)|0)}T.allocUnsafe=function(e){return on(e)};T.allocUnsafeSlow=function(e){return on(e)};function ya(e,t){if((typeof t!="string"||t==="")&&(t="utf8"),!T.isEncoding(t))throw new TypeError("Unknown encoding: "+t);let r=ui(e,t)|0,n=be(r),i=n.write(e,t);return i!==r&&(n=n.slice(0,i)),n}function rn(e){let t=e.length<0?0:sn(e.length)|0,r=be(t);for(let n=0;n<t;n+=1)r[n]=e[n]&255;return r}function wa(e){if(de(e,Uint8Array)){let t=new Uint8Array(e);return li(t.buffer,t.byteOffset,t.byteLength)}return rn(e)}function li(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return t===void 0&&r===void 0?n=new Uint8Array(e):r===void 0?n=new Uint8Array(e,t):n=new Uint8Array(e,t,r),Object.setPrototypeOf(n,T.prototype),n}function Ea(e){if(T.isBuffer(e)){let t=sn(e.length)|0,r=be(t);return r.length===0||e.copy(r,0,0,t),r}if(e.length!==void 0)return typeof e.length!="number"||ln(e.length)?be(0):rn(e);if(e.type==="Buffer"&&Array.isArray(e.data))return rn(e.data)}function sn(e){if(e>=or)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+or.toString(16)+" bytes");return e|0}function ba(e){return+e!=e&&(e=0),T.alloc(+e)}T.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==T.prototype};T.compare=function(e,t){if(de(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),de(t,Uint8Array)&&(t=T.from(t,t.offset,t.byteLength)),!T.isBuffer(e)||!T.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0};T.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}};T.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return T.alloc(0);let r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;let n=T.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){let o=e[r];if(de(o,Uint8Array))i+o.length>n.length?(T.isBuffer(o)||(o=T.from(o)),o.copy(n,i)):Uint8Array.prototype.set.call(n,o,i);else if(T.isBuffer(o))o.copy(n,i);else throw new TypeError('"list" argument must be an Array of Buffers');i+=o.length}return n};function ui(e,t){if(T.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||de(e,ArrayBuffer))return e.byteLength;if(typeof e!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);let r=e.length,n=arguments.length>2&&arguments[2]===!0;if(!n&&r===0)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return nn(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return wi(e).length;default:if(i)return n?-1:nn(e).length;t=(""+t).toLowerCase(),i=!0}}T.byteLength=ui;function xa(e,t,r){let n=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,t>>>=0,r<=t))return"";for(e||(e="utf8");;)switch(e){case"hex":return Oa(this,t,r);case"utf8":case"utf-8":return pi(this,t,r);case"ascii":return ka(this,t,r);case"latin1":case"binary":return Ia(this,t,r);case"base64":return Ra(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Da(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}T.prototype._isBuffer=!0;function Le(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}T.prototype.swap16=function(){let e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)Le(this,t,t+1);return this};T.prototype.swap32=function(){let e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)Le(this,t,t+3),Le(this,t+1,t+2);return this};T.prototype.swap64=function(){let e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)Le(this,t,t+7),Le(this,t+1,t+6),Le(this,t+2,t+5),Le(this,t+3,t+4);return this};T.prototype.toString=function(){let e=this.length;return e===0?"":arguments.length===0?pi(this,0,e):xa.apply(this,arguments)};T.prototype.toLocaleString=T.prototype.toString;T.prototype.equals=function(e){if(!T.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:T.compare(this,e)===0};T.prototype.inspect=function(){let e="",t=Ke.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"};ti&&(T.prototype[ti]=T.prototype.inspect);T.prototype.compare=function(e,t,r,n,i){if(de(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),!T.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(t===void 0&&(t=0),r===void 0&&(r=e?e.length:0),n===void 0&&(n=0),i===void 0&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;let o=i-n,s=r-t,a=Math.min(o,s),l=this.slice(n,i),f=e.slice(t,r);for(let g=0;g<a;++g)if(l[g]!==f[g]){o=l[g],s=f[g];break}return o<s?-1:s<o?1:0};function ci(e,t,r,n,i){if(e.length===0)return-1;if(typeof r=="string"?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,ln(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0)if(i)r=0;else return-1;if(typeof t=="string"&&(t=T.from(t,n)),T.isBuffer(t))return t.length===0?-1:ri(e,t,r,n,i);if(typeof t=="number")return t=t&255,typeof Uint8Array.prototype.indexOf=="function"?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):ri(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function ri(e,t,r,n,i){let o=1,s=e.length,a=t.length;if(n!==void 0&&(n=String(n).toLowerCase(),n==="ucs2"||n==="ucs-2"||n==="utf16le"||n==="utf-16le")){if(e.length<2||t.length<2)return-1;o=2,s/=2,a/=2,r/=2}function l(g,h){return o===1?g[h]:g.readUInt16BE(h*o)}let f;if(i){let g=-1;for(f=r;f<s;f++)if(l(e,f)===l(t,g===-1?0:f-g)){if(g===-1&&(g=f),f-g+1===a)return g*o}else g!==-1&&(f-=f-g),g=-1}else for(r+a>s&&(r=s-a),f=r;f>=0;f--){let g=!0;for(let h=0;h<a;h++)if(l(e,f+h)!==l(t,h)){g=!1;break}if(g)return f}return-1}T.prototype.includes=function(e,t,r){return this.indexOf(e,t,r)!==-1};T.prototype.indexOf=function(e,t,r){return ci(this,e,t,r,!0)};T.prototype.lastIndexOf=function(e,t,r){return ci(this,e,t,r,!1)};function Pa(e,t,r,n){r=Number(r)||0;let i=e.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;let o=t.length;n>o/2&&(n=o/2);let s;for(s=0;s<n;++s){let a=parseInt(t.substr(s*2,2),16);if(ln(a))return s;e[r+s]=a}return s}function va(e,t,r,n){return sr(nn(t,e.length-r),e,r,n)}function Ta(e,t,r,n){return sr(Fa(t),e,r,n)}function Ca(e,t,r,n){return sr(wi(t),e,r,n)}function Aa(e,t,r,n){return sr(La(t,e.length-r),e,r,n)}T.prototype.write=function(e,t,r,n){if(t===void 0)n="utf8",r=this.length,t=0;else if(r===void 0&&typeof t=="string")n=t,r=this.length,t=0;else if(isFinite(t))t=t>>>0,isFinite(r)?(r=r>>>0,n===void 0&&(n="utf8")):(n=r,r=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let i=this.length-t;if((r===void 0||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return Pa(this,e,t,r);case"utf8":case"utf-8":return va(this,e,t,r);case"ascii":case"latin1":case"binary":return Ta(this,e,t,r);case"base64":return Ca(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Aa(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}};T.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Ra(e,t,r){return t===0&&r===e.length?tn.fromByteArray(e):tn.fromByteArray(e.slice(t,r))}function pi(e,t,r){r=Math.min(e.length,r);let n=[],i=t;for(;i<r;){let o=e[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(i+a<=r){let l,f,g,h;switch(a){case 1:o<128&&(s=o);break;case 2:l=e[i+1],(l&192)===128&&(h=(o&31)<<6|l&63,h>127&&(s=h));break;case 3:l=e[i+1],f=e[i+2],(l&192)===128&&(f&192)===128&&(h=(o&15)<<12|(l&63)<<6|f&63,h>2047&&(h<55296||h>57343)&&(s=h));break;case 4:l=e[i+1],f=e[i+2],g=e[i+3],(l&192)===128&&(f&192)===128&&(g&192)===128&&(h=(o&15)<<18|(l&63)<<12|(f&63)<<6|g&63,h>65535&&h<1114112&&(s=h))}}s===null?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),i+=a}return Sa(n)}var ni=4096;function Sa(e){let t=e.length;if(t<=ni)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=ni));return r}function ka(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]&127);return n}function Ia(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function Oa(e,t,r){let n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let i="";for(let o=t;o<r;++o)i+=Ba[e[o]];return i}function Da(e,t,r){let n=e.slice(t,r),i="";for(let o=0;o<n.length-1;o+=2)i+=String.fromCharCode(n[o]+n[o+1]*256);return i}T.prototype.slice=function(e,t){let r=this.length;e=~~e,t=t===void 0?r:~~t,e<0?(e+=r,e<0&&(e=0)):e>r&&(e=r),t<0?(t+=r,t<0&&(t=0)):t>r&&(t=r),t<e&&(t=e);let n=this.subarray(e,t);return Object.setPrototypeOf(n,T.prototype),n};function W(e,t,r){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}T.prototype.readUintLE=T.prototype.readUIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return n};T.prototype.readUintBE=T.prototype.readUIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e+--t],i=1;for(;t>0&&(i*=256);)n+=this[e+--t]*i;return n};T.prototype.readUint8=T.prototype.readUInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]};T.prototype.readUint16LE=T.prototype.readUInt16LE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]|this[e+1]<<8};T.prototype.readUint16BE=T.prototype.readUInt16BE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]<<8|this[e+1]};T.prototype.readUint32LE=T.prototype.readUInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};T.prototype.readUint32BE=T.prototype.readUInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};T.prototype.readBigUInt64LE=Ae(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&bt(e,this.length-8);let n=t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,i=this[++e]+this[++e]*2**8+this[++e]*2**16+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))});T.prototype.readBigUInt64BE=Ae(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&bt(e,this.length-8);let n=t*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],i=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r;return(BigInt(n)<<BigInt(32))+BigInt(i)});T.prototype.readIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n};T.prototype.readIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=t,i=1,o=this[e+--n];for(;n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o};T.prototype.readInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]};T.prototype.readInt16LE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e]|this[e+1]<<8;return r&32768?r|4294901760:r};T.prototype.readInt16BE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e+1]|this[e]<<8;return r&32768?r|4294901760:r};T.prototype.readInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};T.prototype.readInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};T.prototype.readBigInt64LE=Ae(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&bt(e,this.length-8);let n=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)});T.prototype.readBigInt64BE=Ae(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&bt(e,this.length-8);let n=(t<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r)});T.prototype.readFloatLE=function(e,t){return e=e>>>0,t||W(e,4,this.length),We.read(this,e,!0,23,4)};T.prototype.readFloatBE=function(e,t){return e=e>>>0,t||W(e,4,this.length),We.read(this,e,!1,23,4)};T.prototype.readDoubleLE=function(e,t){return e=e>>>0,t||W(e,8,this.length),We.read(this,e,!0,52,8)};T.prototype.readDoubleBE=function(e,t){return e=e>>>0,t||W(e,8,this.length),We.read(this,e,!1,52,8)};function te(e,t,r,n,i,o){if(!T.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}T.prototype.writeUintLE=T.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;te(this,e,t,r,s,0)}let i=1,o=0;for(this[t]=e&255;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r};T.prototype.writeUintBE=T.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;te(this,e,t,r,s,0)}let i=r-1,o=1;for(this[t+i]=e&255;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r};T.prototype.writeUint8=T.prototype.writeUInt8=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,1,255,0),this[t]=e&255,t+1};T.prototype.writeUint16LE=T.prototype.writeUInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,65535,0),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeUint16BE=T.prototype.writeUInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeUint32LE=T.prototype.writeUInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=e&255,t+4};T.prototype.writeUint32BE=T.prototype.writeUInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};function mi(e,t,r,n,i){yi(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,r}function di(e,t,r,n,i){yi(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r+7]=o,o=o>>8,e[r+6]=o,o=o>>8,e[r+5]=o,o=o>>8,e[r+4]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=s,s=s>>8,e[r+2]=s,s=s>>8,e[r+1]=s,s=s>>8,e[r]=s,r+8}T.prototype.writeBigUInt64LE=Ae(function(e,t=0){return mi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeBigUInt64BE=Ae(function(e,t=0){return di(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);te(this,e,t,r,a-1,-a)}let i=0,o=1,s=0;for(this[t]=e&255;++i<r&&(o*=256);)e<0&&s===0&&this[t+i-1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);te(this,e,t,r,a-1,-a)}let i=r-1,o=1,s=0;for(this[t+i]=e&255;--i>=0&&(o*=256);)e<0&&s===0&&this[t+i+1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeInt8=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=e&255,t+1};T.prototype.writeInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,32767,-32768),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,2147483647,-2147483648),this[t]=e&255,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4};T.prototype.writeInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};T.prototype.writeBigInt64LE=Ae(function(e,t=0){return mi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});T.prototype.writeBigInt64BE=Ae(function(e,t=0){return di(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function fi(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function gi(e,t,r,n,i){return t=+t,r=r>>>0,i||fi(e,t,r,4,34028234663852886e22,-34028234663852886e22),We.write(e,t,r,n,23,4),r+4}T.prototype.writeFloatLE=function(e,t,r){return gi(this,e,t,!0,r)};T.prototype.writeFloatBE=function(e,t,r){return gi(this,e,t,!1,r)};function hi(e,t,r,n,i){return t=+t,r=r>>>0,i||fi(e,t,r,8,17976931348623157e292,-17976931348623157e292),We.write(e,t,r,n,52,8),r+8}T.prototype.writeDoubleLE=function(e,t,r){return hi(this,e,t,!0,r)};T.prototype.writeDoubleBE=function(e,t,r){return hi(this,e,t,!1,r)};T.prototype.copy=function(e,t,r,n){if(!T.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),!n&&n!==0&&(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r||e.length===0||this.length===0)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);let i=n-r;return this===e&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i};T.prototype.fill=function(e,t,r,n){if(typeof e=="string"){if(typeof t=="string"?(n=t,t=0,r=this.length):typeof r=="string"&&(n=r,r=this.length),n!==void 0&&typeof n!="string")throw new TypeError("encoding must be a string");if(typeof n=="string"&&!T.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(e.length===1){let o=e.charCodeAt(0);(n==="utf8"&&o<128||n==="latin1")&&(e=o)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;t=t>>>0,r=r===void 0?this.length:r>>>0,e||(e=0);let i;if(typeof e=="number")for(i=t;i<r;++i)this[i]=e;else{let o=T.isBuffer(e)?e:T.from(e,n),s=o.length;if(s===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<r-t;++i)this[i+t]=o[i%s]}return this};var Je={};function an(e,t,r){Je[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(n){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:n,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}an("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError);an("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError);an("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=ii(String(r)):typeof r=="bigint"&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=ii(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n},RangeError);function ii(e){let t="",r=e.length,n=e[0]==="-"?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function Ma(e,t,r){He(t,"offset"),(e[t]===void 0||e[t+r]===void 0)&&bt(t,e.length-(r+1))}function yi(e,t,r,n,i,o){if(e>r||e<t){let s=typeof t=="bigint"?"n":"",a;throw o>3?t===0||t===BigInt(0)?a=`>= 0${s} and < 2${s} ** ${(o+1)*8}${s}`:a=`>= -(2${s} ** ${(o+1)*8-1}${s}) and < 2 ** ${(o+1)*8-1}${s}`:a=`>= ${t}${s} and <= ${r}${s}`,new Je.ERR_OUT_OF_RANGE("value",a,e)}Ma(n,i,o)}function He(e,t){if(typeof e!="number")throw new Je.ERR_INVALID_ARG_TYPE(t,"number",e)}function bt(e,t,r){throw Math.floor(e)!==e?(He(e,r),new Je.ERR_OUT_OF_RANGE(r||"offset","an integer",e)):t<0?new Je.ERR_BUFFER_OUT_OF_BOUNDS:new Je.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}var _a=/[^+/0-9A-Za-z-_]/g;function Na(e){if(e=e.split("=")[0],e=e.trim().replace(_a,""),e.length<2)return"";for(;e.length%4!==0;)e=e+"=";return e}function nn(e,t){t=t||1/0;let r,n=e.length,i=null,o=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return o}function Fa(e){let t=[];for(let r=0;r<e.length;++r)t.push(e.charCodeAt(r)&255);return t}function La(e,t){let r,n,i,o=[];for(let s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function wi(e){return tn.toByteArray(Na(e))}function sr(e,t,r,n){let i;for(i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function de(e,t){return e instanceof t||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===t.name}function ln(e){return e!==e}var Ba=function(){let e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){let n=r*16;for(let i=0;i<16;++i)t[n+i]=e[r]+e[i]}return t}();function Ae(e){return typeof BigInt>"u"?Ua:e}function Ua(){throw new Error("BigInt not supported")}});var w,d=me(()=>{"use strict";w=Qe(Ei())});function Qa(){return!1}function Bi(){return{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}function Ja(){return Bi()}function Wa(){return[]}function Ha(e){e(null,[])}function Ka(){return""}function za(){return""}function Ya(){}function Za(){}function Xa(){}function el(){}function tl(){}function rl(){}var nl,il,Ui,qi=me(()=>{"use strict";d();u();c();p();m();nl={},il={existsSync:Qa,lstatSync:Bi,statSync:Ja,readdirSync:Wa,readdir:Ha,readlinkSync:Ka,realpathSync:za,chmodSync:Ya,renameSync:Za,mkdirSync:Xa,rmdirSync:el,rmSync:tl,unlinkSync:rl,promises:nl},Ui=il});function ol(...e){return e.join("/")}function sl(...e){return e.join("/")}function al(e){let t=$i(e),r=ji(e),[n,i]=t.split(".");return{root:"/",dir:r,base:t,ext:i,name:n}}function $i(e){let t=e.split("/");return t[t.length-1]}function ji(e){return e.split("/").slice(0,-1).join("/")}var Vi,ll,ul,cr,Gi=me(()=>{"use strict";d();u();c();p();m();Vi="/",ll={sep:Vi},ul={basename:$i,dirname:ji,join:sl,parse:al,posix:ll,resolve:ol,sep:Vi},cr=ul});var Qi=Fe((sd,cl)=>{cl.exports={name:"@prisma/internals",version:"6.6.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.4.7",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-engine-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Ki=Fe((Cd,Hi)=>{"use strict";d();u();c();p();m();Hi.exports=(e,t=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;let n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))}});var Zi=Fe((Ld,Yi)=>{"use strict";d();u();c();p();m();Yi.exports=({onlyFirst:e=!1}={})=>{let t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(t,e?void 0:"g")}});var eo=Fe((Vd,Xi)=>{"use strict";d();u();c();p();m();var yl=Zi();Xi.exports=e=>typeof e=="string"?e.replace(yl(),""):e});var Pn=Fe((Dy,Eo)=>{"use strict";d();u();c();p();m();Eo.exports=function(){function e(t,r,n,i,o){return t<r||n<r?t>n?n+1:t+1:i===o?r:r+1}return function(t,r){if(t===r)return 0;if(t.length>r.length){var n=t;t=r,r=n}for(var i=t.length,o=r.length;i>0&&t.charCodeAt(i-1)===r.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&t.charCodeAt(s)===r.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,l,f,g,h,v,S,A,R,D,M,B,k,F=[];for(l=0;l<i;l++)F.push(l+1),F.push(t.charCodeAt(s+l));for(var ie=F.length-1;a<o-3;)for(D=r.charCodeAt(s+(f=a)),M=r.charCodeAt(s+(g=a+1)),B=r.charCodeAt(s+(h=a+2)),k=r.charCodeAt(s+(v=a+3)),S=a+=4,l=0;l<ie;l+=2)A=F[l],R=F[l+1],f=e(A,f,g,D,R),g=e(f,g,h,M,R),h=e(g,h,v,B,R),S=e(h,v,S,k,R),F[l]=S,v=h,h=g,g=f,f=A;for(;a<o;)for(D=r.charCodeAt(s+(f=a)),S=++a,l=0;l<ie;l+=2)A=F[l],F[l]=S=e(A,f,S,D,F[l+1]),f=A;return S}}()});var To=me(()=>{"use strict";d();u();c();p();m()});var Co=me(()=>{"use strict";d();u();c();p();m()});var Jo=Fe((e1,ac)=>{ac.exports={name:"@prisma/engines-version",version:"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"f676762280b54cd07c770017ed3711ddde35f37a"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var Lr,Wo=me(()=>{"use strict";d();u();c();p();m();Lr=class{events={};on(t,r){return this.events[t]||(this.events[t]=[]),this.events[t].push(r),this}emit(t,...r){return this.events[t]?(this.events[t].forEach(n=>{n(...r)}),!0):!1}}});d();u();c();p();m();var Pi={};ir(Pi,{defineExtension:()=>bi,getExtensionContext:()=>xi});d();u();c();p();m();d();u();c();p();m();function bi(e){return typeof e=="function"?e:t=>t.$extends(e)}d();u();c();p();m();function xi(e){return e}var Ti={};ir(Ti,{validator:()=>vi});d();u();c();p();m();d();u();c();p();m();function vi(...e){return t=>t}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var un,Ci,Ai,Ri,Si=!0;typeof y<"u"&&({FORCE_COLOR:un,NODE_DISABLE_COLORS:Ci,NO_COLOR:Ai,TERM:Ri}=y.env||{},Si=y.stdout&&y.stdout.isTTY);var qa={enabled:!Ci&&Ai==null&&Ri!=="dumb"&&(un!=null&&un!=="0"||Si)};function j(e,t){let r=new RegExp(`\\x1b\\[${t}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${t}m`;return function(o){return!qa.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}}var um=j(0,0),ar=j(1,22),lr=j(2,22),cm=j(3,23),ki=j(4,24),pm=j(7,27),mm=j(8,28),dm=j(9,29),fm=j(30,39),ze=j(31,39),Ii=j(32,39),Oi=j(33,39),Di=j(34,39),gm=j(35,39),Mi=j(36,39),hm=j(37,39),_i=j(90,39),ym=j(90,39),wm=j(40,49),Em=j(41,49),bm=j(42,49),xm=j(43,49),Pm=j(44,49),vm=j(45,49),Tm=j(46,49),Cm=j(47,49);d();u();c();p();m();var $a=100,Ni=["green","yellow","blue","magenta","cyan","red"],ur=[],Fi=Date.now(),ja=0,cn=typeof y<"u"?y.env:{};globalThis.DEBUG??=cn.DEBUG??"";globalThis.DEBUG_COLORS??=cn.DEBUG_COLORS?cn.DEBUG_COLORS==="true":!0;var xt={enable(e){typeof e=="string"&&(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},enabled(e){let t=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),r=t.some(i=>i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n=t.some(i=>i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return r&&!n},log:(...e)=>{let[t,r,...n]=e;(console.warn??console.log)(`${t} ${r}`,...n)},formatters:{}};function Va(e){let t={color:Ni[ja++%Ni.length],enabled:xt.enabled(e),namespace:e,log:xt.log,extend:()=>{}},r=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=t;if(n.length!==0&&ur.push([o,...n]),ur.length>$a&&ur.shift(),xt.enabled(o)||i){let l=n.map(g=>typeof g=="string"?g:Ga(g)),f=`+${Date.now()-Fi}ms`;Fi=Date.now(),a(o,...l,f)}};return new Proxy(r,{get:(n,i)=>t[i],set:(n,i,o)=>t[i]=o})}var Y=new Proxy(Va,{get:(e,t)=>xt[t],set:(e,t,r)=>xt[t]=r});function Ga(e,t=2){let r=new Set;return JSON.stringify(e,(n,i)=>{if(typeof i=="object"&&i!==null){if(r.has(i))return"[Circular *]";r.add(i)}else if(typeof i=="bigint")return i.toString();return i},t)}function Li(){ur.length=0}d();u();c();p();m();d();u();c();p();m();var pl=Qi(),pn=pl.version;d();u();c();p();m();var Ji="library";function Ye(e){let t=ml();return t||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Ji)}function ml(){let e=y.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}d();u();c();p();m();var Wi="prisma+postgres",pr=`${Wi}:`;function mn(e){return e?.startsWith(`${pr}//`)??!1}var vt={};ir(vt,{error:()=>gl,info:()=>fl,log:()=>dl,query:()=>hl,should:()=>zi,tags:()=>Pt,warn:()=>dn});d();u();c();p();m();var Pt={error:ze("prisma:error"),warn:Oi("prisma:warn"),info:Mi("prisma:info"),query:Di("prisma:query")},zi={warn:()=>!y.env.PRISMA_DISABLE_WARNINGS};function dl(...e){console.log(...e)}function dn(e,...t){zi.warn()&&console.warn(`${Pt.warn} ${e}`,...t)}function fl(e,...t){console.info(`${Pt.info} ${e}`,...t)}function gl(e,...t){console.error(`${Pt.error} ${e}`,...t)}function hl(e,...t){console.log(`${Pt.query} ${e}`,...t)}d();u();c();p();m();function xe(e,t){throw new Error(t)}d();u();c();p();m();function fn(e,t){return Object.prototype.hasOwnProperty.call(e,t)}d();u();c();p();m();function Ze(e,t){let r={};for(let n of Object.keys(e))r[n]=t(e[n],n);return r}d();u();c();p();m();function gn(e,t){if(e.length===0)return;let r=e[0];for(let n=1;n<e.length;n++)t(r,e[n])<0&&(r=e[n]);return r}d();u();c();p();m();function N(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}d();u();c();p();m();var to=new Set,mr=(e,t,...r)=>{to.has(e)||(to.add(e),dn(t,...r))};var Q=class e extends Error{clientVersion;errorCode;retryable;constructor(t,r,n){super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};N(Q,"PrismaClientInitializationError");d();u();c();p();m();var oe=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};N(oe,"PrismaClientKnownRequestError");d();u();c();p();m();var Re=class extends Error{clientVersion;constructor(t,r){super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};N(Re,"PrismaClientRustPanicError");d();u();c();p();m();var se=class extends Error{clientVersion;batchRequestIdx;constructor(t,{clientVersion:r,batchRequestIdx:n}){super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};N(se,"PrismaClientUnknownRequestError");d();u();c();p();m();var X=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(t,{clientVersion:r}){super(t),this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};N(X,"PrismaClientValidationError");d();u();c();p();m();d();u();c();p();m();var Xe=9e15,Oe=1e9,hn="0123456789abcdef",gr="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",hr="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",yn={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Xe,maxE:Xe,crypto:!1},so,Pe,_=!0,wr="[DecimalError] ",Ie=wr+"Invalid argument: ",ao=wr+"Precision limit exceeded",lo=wr+"crypto unavailable",uo="[object Decimal]",Z=Math.floor,J=Math.pow,wl=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,El=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,bl=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,co=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,ce=1e7,O=7,xl=9007199254740991,Pl=gr.length-1,wn=hr.length-1,C={toStringTag:uo};C.absoluteValue=C.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),I(e)};C.ceil=function(){return I(new this.constructor(this),this.e+1,2)};C.clampedTo=C.clamp=function(e,t){var r,n=this,i=n.constructor;if(e=new i(e),t=new i(t),!e.s||!t.s)return new i(NaN);if(e.gt(t))throw Error(Ie+t);return r=n.cmp(e),r<0?e:n.cmp(t)>0?t:new i(n)};C.comparedTo=C.cmp=function(e){var t,r,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,f=e.s;if(!s||!a)return!l||!f?NaN:l!==f?l:s===a?0:!s^l<0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-f:0;if(l!==f)return l;if(o.e!==e.e)return o.e>e.e^l<0?1:-1;for(n=s.length,i=a.length,t=0,r=n<i?n:i;t<r;++t)if(s[t]!==a[t])return s[t]>a[t]^l<0?1:-1;return n===i?0:n>i^l<0?1:-1};C.cosine=C.cos=function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=vl(n,ho(n,r)),n.precision=e,n.rounding=t,I(Pe==2||Pe==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)};C.cubeRoot=C.cbrt=function(){var e,t,r,n,i,o,s,a,l,f,g=this,h=g.constructor;if(!g.isFinite()||g.isZero())return new h(g);for(_=!1,o=g.s*J(g.s*g,1/3),!o||Math.abs(o)==1/0?(r=K(g.d),e=g.e,(o=(e-r.length+1)%3)&&(r+=o==1||o==-2?"0":"00"),o=J(r,1/3),e=Z((e+1)/3)-(e%3==(e<0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new h(r),n.s=g.s):n=new h(o.toString()),s=(e=h.precision)+3;;)if(a=n,l=a.times(a).times(a),f=l.plus(g),n=q(f.plus(g).times(a),f.plus(l),s+2,1),K(a.d).slice(0,s)===(r=K(n.d)).slice(0,s))if(r=r.slice(s-3,s+1),r=="9999"||!i&&r=="4999"){if(!i&&(I(a,e+1,0),a.times(a).times(a).eq(g))){n=a;break}s+=4,i=1}else{(!+r||!+r.slice(1)&&r.charAt(0)=="5")&&(I(n,e+1,1),t=!n.times(n).times(n).eq(g));break}return _=!0,I(n,e,h.rounding,t)};C.decimalPlaces=C.dp=function(){var e,t=this.d,r=NaN;if(t){if(e=t.length-1,r=(e-Z(this.e/O))*O,e=t[e],e)for(;e%10==0;e/=10)r--;r<0&&(r=0)}return r};C.dividedBy=C.div=function(e){return q(this,new this.constructor(e))};C.dividedToIntegerBy=C.divToInt=function(e){var t=this,r=t.constructor;return I(q(t,new r(e),0,1,1),r.precision,r.rounding)};C.equals=C.eq=function(e){return this.cmp(e)===0};C.floor=function(){return I(new this.constructor(this),this.e+1,3)};C.greaterThan=C.gt=function(e){return this.cmp(e)>0};C.greaterThanOrEqualTo=C.gte=function(e){var t=this.cmp(e);return t==1||t===0};C.hyperbolicCosine=C.cosh=function(){var e,t,r,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;r=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i<32?(e=Math.ceil(i/3),t=(1/br(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=et(s,1,o.times(t),new s(1),!0);for(var l,f=e,g=new s(8);f--;)l=o.times(o),o=a.minus(l.times(g.minus(l.times(g))));return I(o,s.precision=r,s.rounding=n,!0)};C.hyperbolicSine=C.sinh=function(){var e,t,r,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n<3)i=et(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e>16?16:e|0,i=i.times(1/br(5,e)),i=et(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),f=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(f))))}return o.precision=t,o.rounding=r,I(i,t,r,!0)};C.hyperbolicTangent=C.tanh=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,q(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)};C.inverseCosine=C.acos=function(){var e=this,t=e.constructor,r=e.abs().cmp(1),n=t.precision,i=t.rounding;return r!==-1?r===0?e.isNeg()?fe(t,n,i):new t(0):new t(NaN):e.isZero()?fe(t,n+4,i).times(.5):(t.precision=n+6,t.rounding=1,e=new t(1).minus(e).div(e.plus(1)).sqrt().atan(),t.precision=n,t.rounding=i,e.times(2))};C.inverseHyperbolicCosine=C.acosh=function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,_=!1,r=r.times(r).minus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)};C.inverseHyperbolicSine=C.asinh=function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,_=!1,r=r.times(r).plus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln())};C.inverseHyperbolicTangent=C.atanh=function(){var e,t,r,n,i=this,o=i.constructor;return i.isFinite()?i.e>=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?I(new o(i),e,t,!0):(o.precision=r=n-i.e,i=q(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)};C.inverseSine=C.asin=function(){var e,t,r,n,i=this,o=i.constructor;return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=fe(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))};C.inverseTangent=C.atan=function(){var e,t,r,n,i,o,s,a,l,f=this,g=f.constructor,h=g.precision,v=g.rounding;if(f.isFinite()){if(f.isZero())return new g(f);if(f.abs().eq(1)&&h+4<=wn)return s=fe(g,h+4,v).times(.25),s.s=f.s,s}else{if(!f.s)return new g(NaN);if(h+4<=wn)return s=fe(g,h+4,v).times(.5),s.s=f.s,s}for(g.precision=a=h+10,g.rounding=1,r=Math.min(28,a/O+2|0),e=r;e;--e)f=f.div(f.times(f).plus(1).sqrt().plus(1));for(_=!1,t=Math.ceil(a/O),n=1,l=f.times(f),s=new g(f),i=f;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)for(e=t;s.d[e]===o.d[e]&&e--;);return r&&(s=s.times(2<<r-1)),_=!0,I(s,g.precision=h,g.rounding=v,!0)};C.isFinite=function(){return!!this.d};C.isInteger=C.isInt=function(){return!!this.d&&Z(this.e/O)>this.d.length-2};C.isNaN=function(){return!this.s};C.isNegative=C.isNeg=function(){return this.s<0};C.isPositive=C.isPos=function(){return this.s>0};C.isZero=function(){return!!this.d&&this.d[0]===0};C.lessThan=C.lt=function(e){return this.cmp(e)<0};C.lessThanOrEqualTo=C.lte=function(e){return this.cmp(e)<1};C.logarithm=C.log=function(e){var t,r,n,i,o,s,a,l,f=this,g=f.constructor,h=g.precision,v=g.rounding,S=5;if(e==null)e=new g(10),t=!0;else{if(e=new g(e),r=e.d,e.s<0||!r||!r[0]||e.eq(1))return new g(NaN);t=e.eq(10)}if(r=f.d,f.s<0||!r||!r[0]||f.eq(1))return new g(r&&!r[0]?-1/0:f.s!=1?NaN:r?0:1/0);if(t)if(r.length>1)o=!0;else{for(i=r[0];i%10===0;)i/=10;o=i!==1}if(_=!1,a=h+S,s=ke(f,a),n=t?yr(g,a+10):ke(e,a),l=q(s,n,a,1),Tt(l.d,i=h,v))do if(a+=10,s=ke(f,a),n=t?yr(g,a+10):ke(e,a),l=q(s,n,a,1),!o){+K(l.d).slice(i+1,i+15)+1==1e14&&(l=I(l,h+1,0));break}while(Tt(l.d,i+=10,v));return _=!0,I(l,h,v)};C.minus=C.sub=function(e){var t,r,n,i,o,s,a,l,f,g,h,v,S=this,A=S.constructor;if(e=new A(e),!S.d||!e.d)return!S.s||!e.s?e=new A(NaN):S.d?e.s=-e.s:e=new A(e.d||S.s!==e.s?S:NaN),e;if(S.s!=e.s)return e.s=-e.s,S.plus(e);if(f=S.d,v=e.d,a=A.precision,l=A.rounding,!f[0]||!v[0]){if(v[0])e.s=-e.s;else if(f[0])e=new A(S);else return new A(l===3?-0:0);return _?I(e,a,l):e}if(r=Z(e.e/O),g=Z(S.e/O),f=f.slice(),o=g-r,o){for(h=o<0,h?(t=f,o=-o,s=v.length):(t=v,r=g,s=f.length),n=Math.max(Math.ceil(a/O),s)+2,o>n&&(o=n,t.length=1),t.reverse(),n=o;n--;)t.push(0);t.reverse()}else{for(n=f.length,s=v.length,h=n<s,h&&(s=n),n=0;n<s;n++)if(f[n]!=v[n]){h=f[n]<v[n];break}o=0}for(h&&(t=f,f=v,v=t,e.s=-e.s),s=f.length,n=v.length-s;n>0;--n)f[s++]=0;for(n=v.length;n>o;){if(f[--n]<v[n]){for(i=n;i&&f[--i]===0;)f[i]=ce-1;--f[i],f[n]+=ce}f[n]-=v[n]}for(;f[--s]===0;)f.pop();for(;f[0]===0;f.shift())--r;return f[0]?(e.d=f,e.e=Er(f,r),_?I(e,a,l):e):new A(l===3?-0:0)};C.modulo=C.mod=function(e){var t,r=this,n=r.constructor;return e=new n(e),!r.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||r.d&&!r.d[0]?I(new n(r),n.precision,n.rounding):(_=!1,n.modulo==9?(t=q(r,e.abs(),0,3,1),t.s*=e.s):t=q(r,e,0,n.modulo,1),t=t.times(e),_=!0,r.minus(t))};C.naturalExponential=C.exp=function(){return En(this)};C.naturalLogarithm=C.ln=function(){return ke(this)};C.negated=C.neg=function(){var e=new this.constructor(this);return e.s=-e.s,I(e)};C.plus=C.add=function(e){var t,r,n,i,o,s,a,l,f,g,h=this,v=h.constructor;if(e=new v(e),!h.d||!e.d)return!h.s||!e.s?e=new v(NaN):h.d||(e=new v(e.d||h.s===e.s?h:NaN)),e;if(h.s!=e.s)return e.s=-e.s,h.minus(e);if(f=h.d,g=e.d,a=v.precision,l=v.rounding,!f[0]||!g[0])return g[0]||(e=new v(h)),_?I(e,a,l):e;if(o=Z(h.e/O),n=Z(e.e/O),f=f.slice(),i=o-n,i){for(i<0?(r=f,i=-i,s=g.length):(r=g,n=o,s=f.length),o=Math.ceil(a/O),s=o>s?o+1:s+1,i>s&&(i=s,r.length=1),r.reverse();i--;)r.push(0);r.reverse()}for(s=f.length,i=g.length,s-i<0&&(i=s,r=g,g=f,f=r),t=0;i;)t=(f[--i]=f[i]+g[i]+t)/ce|0,f[i]%=ce;for(t&&(f.unshift(t),++n),s=f.length;f[--s]==0;)f.pop();return e.d=f,e.e=Er(f,n),_?I(e,a,l):e};C.precision=C.sd=function(e){var t,r=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error(Ie+e);return r.d?(t=po(r.d),e&&r.e+1>t&&(t=r.e+1)):t=NaN,t};C.round=function(){var e=this,t=e.constructor;return I(new t(e),e.e+1,t.rounding)};C.sine=C.sin=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=Cl(n,ho(n,r)),n.precision=e,n.rounding=t,I(Pe>2?r.neg():r,e,t,!0)):new n(NaN)};C.squareRoot=C.sqrt=function(){var e,t,r,n,i,o,s=this,a=s.d,l=s.e,f=s.s,g=s.constructor;if(f!==1||!a||!a[0])return new g(!f||f<0&&(!a||a[0])?NaN:a?s:1/0);for(_=!1,f=Math.sqrt(+s),f==0||f==1/0?(t=K(a),(t.length+l)%2==0&&(t+="0"),f=Math.sqrt(t),l=Z((l+1)/2)-(l<0||l%2),f==1/0?t="5e"+l:(t=f.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new g(t)):n=new g(f.toString()),r=(l=g.precision)+3;;)if(o=n,n=o.plus(q(s,o,r+2,1)).times(.5),K(o.d).slice(0,r)===(t=K(n.d)).slice(0,r))if(t=t.slice(r-3,r+1),t=="9999"||!i&&t=="4999"){if(!i&&(I(o,l+1,0),o.times(o).eq(s))){n=o;break}r+=4,i=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(I(n,l+1,1),e=!n.times(n).eq(s));break}return _=!0,I(n,l,g.rounding,e)};C.tangent=C.tan=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=q(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,I(Pe==2||Pe==4?r.neg():r,e,t,!0)):new n(NaN)};C.times=C.mul=function(e){var t,r,n,i,o,s,a,l,f,g=this,h=g.constructor,v=g.d,S=(e=new h(e)).d;if(e.s*=g.s,!v||!v[0]||!S||!S[0])return new h(!e.s||v&&!v[0]&&!S||S&&!S[0]&&!v?NaN:!v||!S?e.s/0:e.s*0);for(r=Z(g.e/O)+Z(e.e/O),l=v.length,f=S.length,l<f&&(o=v,v=S,S=o,s=l,l=f,f=s),o=[],s=l+f,n=s;n--;)o.push(0);for(n=f;--n>=0;){for(t=0,i=l+n;i>n;)a=o[i]+S[n]*v[i-n-1]+t,o[i--]=a%ce|0,t=a/ce|0;o[i]=(o[i]+t)%ce|0}for(;!o[--s];)o.pop();return t?++r:o.shift(),e.d=o,e.e=Er(o,r),_?I(e,h.precision,h.rounding):e};C.toBinary=function(e,t){return bn(this,2,e,t)};C.toDecimalPlaces=C.toDP=function(e,t){var r=this,n=r.constructor;return r=new n(r),e===void 0?r:(re(e,0,Oe),t===void 0?t=n.rounding:re(t,0,8),I(r,e+r.e+1,t))};C.toExponential=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=ge(n,!0):(re(e,0,Oe),t===void 0?t=i.rounding:re(t,0,8),n=I(new i(n),e+1,t),r=ge(n,!0,e+1)),n.isNeg()&&!n.isZero()?"-"+r:r};C.toFixed=function(e,t){var r,n,i=this,o=i.constructor;return e===void 0?r=ge(i):(re(e,0,Oe),t===void 0?t=o.rounding:re(t,0,8),n=I(new o(i),e+i.e+1,t),r=ge(n,!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+r:r};C.toFraction=function(e){var t,r,n,i,o,s,a,l,f,g,h,v,S=this,A=S.d,R=S.constructor;if(!A)return new R(S);if(f=r=new R(1),n=l=new R(0),t=new R(n),o=t.e=po(A)-S.e-1,s=o%O,t.d[0]=J(10,s<0?O+s:s),e==null)e=o>0?t:f;else{if(a=new R(e),!a.isInt()||a.lt(f))throw Error(Ie+a);e=a.gt(t)?o>0?t:f:a}for(_=!1,a=new R(K(A)),g=R.precision,R.precision=o=A.length*O*2;h=q(a,t,0,1,1),i=r.plus(h.times(n)),i.cmp(e)!=1;)r=n,n=i,i=f,f=l.plus(h.times(i)),l=i,i=t,t=a.minus(h.times(i)),a=i;return i=q(e.minus(r),n,0,1,1),l=l.plus(i.times(f)),r=r.plus(i.times(n)),l.s=f.s=S.s,v=q(f,n,o,1).minus(S).abs().cmp(q(l,r,o,1).minus(S).abs())<1?[f,n]:[l,r],R.precision=g,_=!0,v};C.toHexadecimal=C.toHex=function(e,t){return bn(this,16,e,t)};C.toNearest=function(e,t){var r=this,n=r.constructor;if(r=new n(r),e==null){if(!r.d)return r;e=new n(1),t=n.rounding}else{if(e=new n(e),t===void 0?t=n.rounding:re(t,0,8),!r.d)return e.s?r:e;if(!e.d)return e.s&&(e.s=r.s),e}return e.d[0]?(_=!1,r=q(r,e,0,t,1).times(e),_=!0,I(r)):(e.s=r.s,r=e),r};C.toNumber=function(){return+this};C.toOctal=function(e,t){return bn(this,8,e,t)};C.toPower=C.pow=function(e){var t,r,n,i,o,s,a=this,l=a.constructor,f=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(J(+a,f));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return I(a,n,o);if(t=Z(e.e/O),t>=e.d.length-1&&(r=f<0?-f:f)<=xl)return i=mo(l,a,r,n),e.s<0?new l(1).div(i):I(i,n,o);if(s=a.s,s<0){if(t<e.d.length-1)return new l(NaN);if((e.d[t]&1)==0&&(s=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=s,a}return r=J(+a,f),t=r==0||!isFinite(r)?Z(f*(Math.log("0."+K(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t>l.maxE+1||t<l.minE-1?new l(t>0?s/0:0):(_=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=En(e.times(ke(a,n+r)),n),i.d&&(i=I(i,n+5,1),Tt(i.d,n,o)&&(t=n+10,i=I(En(e.times(ke(a,t+r)),t),t+5,1),+K(i.d).slice(n+1,n+15)+1==1e14&&(i=I(i,n+1,0)))),i.s=s,_=!0,l.rounding=o,I(i,n,o))};C.toPrecision=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=ge(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(re(e,1,Oe),t===void 0?t=i.rounding:re(t,0,8),n=I(new i(n),e,t),r=ge(n,e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+r:r};C.toSignificantDigits=C.toSD=function(e,t){var r=this,n=r.constructor;return e===void 0?(e=n.precision,t=n.rounding):(re(e,1,Oe),t===void 0?t=n.rounding:re(t,0,8)),I(new n(r),e,t)};C.toString=function(){var e=this,t=e.constructor,r=ge(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+r:r};C.truncated=C.trunc=function(){return I(new this.constructor(this),this.e+1,1)};C.valueOf=C.toJSON=function(){var e=this,t=e.constructor,r=ge(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+r:r};function K(e){var t,r,n,i=e.length-1,o="",s=e[0];if(i>0){for(o+=s,t=1;t<i;t++)n=e[t]+"",r=O-n.length,r&&(o+=Se(r)),o+=n;s=e[t],n=s+"",r=O-n.length,r&&(o+=Se(r))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function re(e,t,r){if(e!==~~e||e<t||e>r)throw Error(Ie+e)}function Tt(e,t,r,n){var i,o,s,a;for(o=e[0];o>=10;o/=10)--t;return--t<0?(t+=O,i=0):(i=Math.ceil((t+1)/O),t%=O),o=J(10,O-t),a=e[i]%o|0,n==null?t<3?(t==0?a=a/100|0:t==1&&(a=a/10|0),s=r<4&&a==99999||r>3&&a==49999||a==5e4||a==0):s=(r<4&&a+1==o||r>3&&a+1==o/2)&&(e[i+1]/o/100|0)==J(10,t-2)-1||(a==o/2||a==0)&&(e[i+1]/o/100|0)==0:t<4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&&(a=a/10|0),s=(n||r<4)&&a==9999||!n&&r>3&&a==4999):s=((n||r<4)&&a+1==o||!n&&r>3&&a+1==o/2)&&(e[i+1]/o/1e3|0)==J(10,t-3)-1,s}function dr(e,t,r){for(var n,i=[0],o,s=0,a=e.length;s<a;){for(o=i.length;o--;)i[o]*=t;for(i[0]+=hn.indexOf(e.charAt(s++)),n=0;n<i.length;n++)i[n]>r-1&&(i[n+1]===void 0&&(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}return i.reverse()}function vl(e,t){var r,n,i;if(t.isZero())return t;n=t.d.length,n<32?(r=Math.ceil(n/3),i=(1/br(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=et(e,1,t.times(i),new e(1));for(var o=r;o--;){var s=t.times(t);t=s.times(s).minus(s).times(8).plus(1)}return e.precision-=r,t}var q=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&&n.unshift(a),n}function t(n,i,o,s){var a,l;if(o!=s)l=o>s?1:-1;else for(a=l=0;a<o;a++)if(n[a]!=i[a]){l=n[a]>i[a]?1:-1;break}return l}function r(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]<i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s,a,l){var f,g,h,v,S,A,R,D,M,B,k,F,ie,G,Yr,tr,Et,Zr,ue,rr,nr=n.constructor,Xr=n.s==i.s?1:-1,z=n.d,$=i.d;if(!z||!z[0]||!$||!$[0])return new nr(!n.s||!i.s||(z?$&&z[0]==$[0]:!$)?NaN:z&&z[0]==0||!$?Xr*0:Xr/0);for(l?(S=1,g=n.e-i.e):(l=ce,S=O,g=Z(n.e/S)-Z(i.e/S)),ue=$.length,Et=z.length,M=new nr(Xr),B=M.d=[],h=0;$[h]==(z[h]||0);h++);if($[h]>(z[h]||0)&&g--,o==null?(G=o=nr.precision,s=nr.rounding):a?G=o+(n.e-i.e)+1:G=o,G<0)B.push(1),A=!0;else{if(G=G/S+2|0,h=0,ue==1){for(v=0,$=$[0],G++;(h<Et||v)&&G--;h++)Yr=v*l+(z[h]||0),B[h]=Yr/$|0,v=Yr%$|0;A=v||h<Et}else{for(v=l/($[0]+1)|0,v>1&&($=e($,v,l),z=e(z,v,l),ue=$.length,Et=z.length),tr=ue,k=z.slice(0,ue),F=k.length;F<ue;)k[F++]=0;rr=$.slice(),rr.unshift(0),Zr=$[0],$[1]>=l/2&&++Zr;do v=0,f=t($,k,ue,F),f<0?(ie=k[0],ue!=F&&(ie=ie*l+(k[1]||0)),v=ie/Zr|0,v>1?(v>=l&&(v=l-1),R=e($,v,l),D=R.length,F=k.length,f=t(R,k,D,F),f==1&&(v--,r(R,ue<D?rr:$,D,l))):(v==0&&(f=v=1),R=$.slice()),D=R.length,D<F&&R.unshift(0),r(k,R,F,l),f==-1&&(F=k.length,f=t($,k,ue,F),f<1&&(v++,r(k,ue<F?rr:$,F,l))),F=k.length):f===0&&(v++,k=[0]),B[h++]=v,f&&k[0]?k[F++]=z[tr]||0:(k=[z[tr]],F=1);while((tr++<Et||k[0]!==void 0)&&G--);A=k[0]!==void 0}B[0]||B.shift()}if(S==1)M.e=g,so=A;else{for(h=1,v=B[0];v>=10;v/=10)h++;M.e=h+g*S-1,I(M,a?o+M.e+1:o,s,A)}return M}}();function I(e,t,r,n){var i,o,s,a,l,f,g,h,v,S=e.constructor;e:if(t!=null){if(h=e.d,!h)return e;for(i=1,a=h[0];a>=10;a/=10)i++;if(o=t-i,o<0)o+=O,s=t,g=h[v=0],l=g/J(10,i-s-1)%10|0;else if(v=Math.ceil((o+1)/O),a=h.length,v>=a)if(n){for(;a++<=v;)h.push(0);g=l=0,i=1,o%=O,s=o-O+1}else break e;else{for(g=a=h[v],i=1;a>=10;a/=10)i++;o%=O,s=o-O+i,l=s<0?0:g/J(10,i-s-1)%10|0}if(n=n||t<0||h[v+1]!==void 0||(s<0?g:g%J(10,i-s-1)),f=r<4?(l||n)&&(r==0||r==(e.s<0?3:2)):l>5||l==5&&(r==4||n||r==6&&(o>0?s>0?g/J(10,i-s):0:h[v-1])%10&1||r==(e.s<0?8:7)),t<1||!h[0])return h.length=0,f?(t-=e.e+1,h[0]=J(10,(O-t%O)%O),e.e=-t||0):h[0]=e.e=0,e;if(o==0?(h.length=v,a=1,v--):(h.length=v+1,a=J(10,O-o),h[v]=s>0?(g/J(10,i-s)%J(10,s)|0)*a:0),f)for(;;)if(v==0){for(o=1,s=h[0];s>=10;s/=10)o++;for(s=h[0]+=a,a=1;s>=10;s/=10)a++;o!=a&&(e.e++,h[0]==ce&&(h[0]=1));break}else{if(h[v]+=a,h[v]!=ce)break;h[v--]=0,a=1}for(o=h.length;h[--o]===0;)h.pop()}return _&&(e.e>S.maxE?(e.d=null,e.e=NaN):e.e<S.minE&&(e.e=0,e.d=[0])),e}function ge(e,t,r){if(!e.isFinite())return go(e);var n,i=e.e,o=K(e.d),s=o.length;return t?(r&&(n=r-s)>0?o=o.charAt(0)+"."+o.slice(1)+Se(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):i<0?(o="0."+Se(-i-1)+o,r&&(n=r-s)>0&&(o+=Se(n))):i>=s?(o+=Se(i+1-s),r&&(n=r-i-1)>0&&(o=o+"."+Se(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),r&&(n=r-s)>0&&(i+1===s&&(o+="."),o+=Se(n))),o}function Er(e,t){var r=e[0];for(t*=O;r>=10;r/=10)t++;return t}function yr(e,t,r){if(t>Pl)throw _=!0,r&&(e.precision=r),Error(ao);return I(new e(gr),t,1,!0)}function fe(e,t,r){if(t>wn)throw Error(ao);return I(new e(hr),t,r,!0)}function po(e){var t=e.length-1,r=t*O+1;if(t=e[t],t){for(;t%10==0;t/=10)r--;for(t=e[0];t>=10;t/=10)r++}return r}function Se(e){for(var t="";e--;)t+="0";return t}function mo(e,t,r,n){var i,o=new e(1),s=Math.ceil(n/O+4);for(_=!1;;){if(r%2&&(o=o.times(t),io(o.d,s)&&(i=!0)),r=Z(r/2),r===0){r=o.d.length-1,i&&o.d[r]===0&&++o.d[r];break}t=t.times(t),io(t.d,s)}return _=!0,o}function no(e){return e.d[e.d.length-1]&1}function fo(e,t,r){for(var n,i,o=new e(t[0]),s=0;++s<t.length;){if(i=new e(t[s]),!i.s){o=i;break}n=o.cmp(i),(n===r||n===0&&o.s===r)&&(o=i)}return o}function En(e,t){var r,n,i,o,s,a,l,f=0,g=0,h=0,v=e.constructor,S=v.rounding,A=v.precision;if(!e.d||!e.d[0]||e.e>17)return new v(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(t==null?(_=!1,l=A):l=t,a=new v(.03125);e.e>-2;)e=e.times(a),h+=5;for(n=Math.log(J(2,h))/Math.LN10*2+5|0,l+=n,r=o=s=new v(1),v.precision=l;;){if(o=I(o.times(e),l,1),r=r.times(++g),a=s.plus(q(o,r,l,1)),K(a.d).slice(0,l)===K(s.d).slice(0,l)){for(i=h;i--;)s=I(s.times(s),l,1);if(t==null)if(f<3&&Tt(s.d,l-n,S,f))v.precision=l+=10,r=o=a=new v(1),g=0,f++;else return I(s,v.precision=A,S,_=!0);else return v.precision=A,s}s=a}}function ke(e,t){var r,n,i,o,s,a,l,f,g,h,v,S=1,A=10,R=e,D=R.d,M=R.constructor,B=M.rounding,k=M.precision;if(R.s<0||!D||!D[0]||!R.e&&D[0]==1&&D.length==1)return new M(D&&!D[0]?-1/0:R.s!=1?NaN:D?0:R);if(t==null?(_=!1,g=k):g=t,M.precision=g+=A,r=K(D),n=r.charAt(0),Math.abs(o=R.e)<15e14){for(;n<7&&n!=1||n==1&&r.charAt(1)>3;)R=R.times(e),r=K(R.d),n=r.charAt(0),S++;o=R.e,n>1?(R=new M("0."+r),o++):R=new M(n+"."+r.slice(1))}else return f=yr(M,g+2,k).times(o+""),R=ke(new M(n+"."+r.slice(1)),g-A).plus(f),M.precision=k,t==null?I(R,k,B,_=!0):R;for(h=R,l=s=R=q(R.minus(1),R.plus(1),g,1),v=I(R.times(R),g,1),i=3;;){if(s=I(s.times(v),g,1),f=l.plus(q(s,new M(i),g,1)),K(f.d).slice(0,g)===K(l.d).slice(0,g))if(l=l.times(2),o!==0&&(l=l.plus(yr(M,g+2,k).times(o+""))),l=q(l,new M(S),g,1),t==null)if(Tt(l.d,g-A,B,a))M.precision=g+=A,f=s=R=q(h.minus(1),h.plus(1),g,1),v=I(R.times(R),g,1),i=a=1;else return I(l,M.precision=k,B,_=!0);else return M.precision=k,l;l=f,i+=2}}function go(e){return String(e.s*e.s/0)}function fr(e,t){var r,n,i;for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(n=t.search(/e/i))>0?(r<0&&(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r<0&&(r=t.length),n=0;t.charCodeAt(n)===48;n++);for(i=t.length;t.charCodeAt(i-1)===48;--i);if(t=t.slice(n,i),t){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%O,r<0&&(n+=O),n<i){for(n&&e.d.push(+t.slice(0,n)),i-=O;n<i;)e.d.push(+t.slice(n,n+=O));t=t.slice(n),n=O-t.length}else n-=i;for(;n--;)t+="0";e.d.push(+t),_&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Tl(e,t){var r,n,i,o,s,a,l,f,g;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),co.test(t))return fr(e,t)}else if(t==="Infinity"||t==="NaN")return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(El.test(t))r=16,t=t.toLowerCase();else if(wl.test(t))r=2;else if(bl.test(t))r=8;else throw Error(Ie+t);for(o=t.search(/p/i),o>0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o>=0,n=e.constructor,s&&(t=t.replace(".",""),a=t.length,o=a-o,i=mo(n,new n(r),o,o*2)),f=dr(t,r,ce),g=f.length-1,o=g;f[o]===0;--o)f.pop();return o<0?new n(e.s*0):(e.e=Er(f,g),e.d=f,_=!1,s&&(e=q(e,i,a*4)),l&&(e=e.times(Math.abs(l)<54?J(2,l):Be.pow(2,l))),_=!0,e)}function Cl(e,t){var r,n=t.d.length;if(n<3)return t.isZero()?t:et(e,2,t,t);r=1.4*Math.sqrt(n),r=r>16?16:r|0,t=t.times(1/br(5,r)),t=et(e,2,t,t);for(var i,o=new e(5),s=new e(16),a=new e(20);r--;)i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));return t}function et(e,t,r,n,i){var o,s,a,l,f=1,g=e.precision,h=Math.ceil(g/O);for(_=!1,l=r.times(r),a=new e(n);;){if(s=q(a.times(l),new e(t++*t++),g,1),a=i?n.plus(s):n.minus(s),n=q(s.times(l),new e(t++*t++),g,1),s=a.plus(n),s.d[h]!==void 0){for(o=h;s.d[o]===a.d[o]&&o--;);if(o==-1)break}o=a,a=n,n=s,s=o,f++}return _=!0,s.d.length=h+1,s}function br(e,t){for(var r=e;--t;)r*=e;return r}function ho(e,t){var r,n=t.s<0,i=fe(e,e.precision,1),o=i.times(.5);if(t=t.abs(),t.lte(o))return Pe=n?4:1,t;if(r=t.divToInt(i),r.isZero())Pe=n?3:2;else{if(t=t.minus(r.times(i)),t.lte(o))return Pe=no(r)?n?2:3:n?4:1,t;Pe=no(r)?n?1:4:n?3:2}return t.minus(i).abs()}function bn(e,t,r,n){var i,o,s,a,l,f,g,h,v,S=e.constructor,A=r!==void 0;if(A?(re(r,1,Oe),n===void 0?n=S.rounding:re(n,0,8)):(r=S.precision,n=S.rounding),!e.isFinite())g=go(e);else{for(g=ge(e),s=g.indexOf("."),A?(i=2,t==16?r=r*4-3:t==8&&(r=r*3-2)):i=t,s>=0&&(g=g.replace(".",""),v=new S(1),v.e=g.length-s,v.d=dr(ge(v),10,i),v.e=v.d.length),h=dr(g,10,i),o=l=h.length;h[--l]==0;)h.pop();if(!h[0])g=A?"0p+0":"0";else{if(s<0?o--:(e=new S(e),e.d=h,e.e=o,e=q(e,v,r,n,0,i),h=e.d,o=e.e,f=so),s=h[r],a=i/2,f=f||h[r+1]!==void 0,f=n<4?(s!==void 0||f)&&(n===0||n===(e.s<0?3:2)):s>a||s===a&&(n===4||f||n===6&&h[r-1]&1||n===(e.s<0?8:7)),h.length=r,f)for(;++h[--r]>i-1;)h[r]=0,r||(++o,h.unshift(1));for(l=h.length;!h[l-1];--l);for(s=0,g="";s<l;s++)g+=hn.charAt(h[s]);if(A){if(l>1)if(t==16||t==8){for(s=t==16?4:3,--l;l%s;l++)g+="0";for(h=dr(g,i,t),l=h.length;!h[l-1];--l);for(s=1,g="1.";s<l;s++)g+=hn.charAt(h[s])}else g=g.charAt(0)+"."+g.slice(1);g=g+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)g="0"+g;g="0."+g}else if(++o>l)for(o-=l;o--;)g+="0";else o<l&&(g=g.slice(0,o)+"."+g.slice(o))}g=(t==16?"0x":t==2?"0b":t==8?"0o":"")+g}return e.s<0?"-"+g:g}function io(e,t){if(e.length>t)return e.length=t,!0}function Al(e){return new this(e).abs()}function Rl(e){return new this(e).acos()}function Sl(e){return new this(e).acosh()}function kl(e,t){return new this(e).plus(t)}function Il(e){return new this(e).asin()}function Ol(e){return new this(e).asinh()}function Dl(e){return new this(e).atan()}function Ml(e){return new this(e).atanh()}function _l(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,o=n+4;return!e.s||!t.s?r=new this(NaN):!e.d&&!t.d?(r=fe(this,o,1).times(t.s>0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s<0?fe(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=fe(this,o,1).times(.5),r.s=e.s):t.s<0?(this.precision=o,this.rounding=1,r=this.atan(q(e,t,o,1)),t=fe(this,o,1),this.precision=n,this.rounding=i,r=e.s<0?r.minus(t):r.plus(t)):r=this.atan(q(e,t,o,1)),r}function Nl(e){return new this(e).cbrt()}function Fl(e){return I(e=new this(e),e.e+1,2)}function Ll(e,t,r){return new this(e).clamp(t,r)}function Bl(e){if(!e||typeof e!="object")throw Error(wr+"Object expected");var t,r,n,i=e.defaults===!0,o=["precision",1,Oe,"rounding",0,8,"toExpNeg",-Xe,0,"toExpPos",0,Xe,"maxE",0,Xe,"minE",-Xe,0,"modulo",0,9];for(t=0;t<o.length;t+=3)if(r=o[t],i&&(this[r]=yn[r]),(n=e[r])!==void 0)if(Z(n)===n&&n>=o[t+1]&&n<=o[t+2])this[r]=n;else throw Error(Ie+r+": "+n);if(r="crypto",i&&(this[r]=yn[r]),(n=e[r])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[r]=!0;else throw Error(lo);else this[r]=!1;else throw Error(Ie+r+": "+n);return this}function Ul(e){return new this(e).cos()}function ql(e){return new this(e).cosh()}function yo(e){var t,r,n;function i(o){var s,a,l,f=this;if(!(f instanceof i))return new i(o);if(f.constructor=i,oo(o)){f.s=o.s,_?!o.d||o.e>i.maxE?(f.e=NaN,f.d=null):o.e<i.minE?(f.e=0,f.d=[0]):(f.e=o.e,f.d=o.d.slice()):(f.e=o.e,f.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){f.s=1/o<0?-1:1,f.e=0,f.d=[0];return}if(o<0?(o=-o,f.s=-1):f.s=1,o===~~o&&o<1e7){for(s=0,a=o;a>=10;a/=10)s++;_?s>i.maxE?(f.e=NaN,f.d=null):s<i.minE?(f.e=0,f.d=[0]):(f.e=s,f.d=[o]):(f.e=s,f.d=[o]);return}if(o*0!==0){o||(f.s=NaN),f.e=NaN,f.d=null;return}return fr(f,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),f.s=-1):(a===43&&(o=o.slice(1)),f.s=1),co.test(o)?fr(f,o):Tl(f,o);if(l==="bigint")return o<0?(o=-o,f.s=-1):f.s=1,fr(f,o.toString());throw Error(Ie+o)}if(i.prototype=C,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Bl,i.clone=yo,i.isDecimal=oo,i.abs=Al,i.acos=Rl,i.acosh=Sl,i.add=kl,i.asin=Il,i.asinh=Ol,i.atan=Dl,i.atanh=Ml,i.atan2=_l,i.cbrt=Nl,i.ceil=Fl,i.clamp=Ll,i.cos=Ul,i.cosh=ql,i.div=$l,i.exp=jl,i.floor=Vl,i.hypot=Gl,i.ln=Ql,i.log=Jl,i.log10=Hl,i.log2=Wl,i.max=Kl,i.min=zl,i.mod=Yl,i.mul=Zl,i.pow=Xl,i.random=eu,i.round=tu,i.sign=ru,i.sin=nu,i.sinh=iu,i.sqrt=ou,i.sub=su,i.sum=au,i.tan=lu,i.tanh=uu,i.trunc=cu,e===void 0&&(e={}),e&&e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t<n.length;)e.hasOwnProperty(r=n[t++])||(e[r]=this[r]);return i.config(e),i}function $l(e,t){return new this(e).div(t)}function jl(e){return new this(e).exp()}function Vl(e){return I(e=new this(e),e.e+1,3)}function Gl(){var e,t,r=new this(0);for(_=!1,e=0;e<arguments.length;)if(t=new this(arguments[e++]),t.d)r.d&&(r=r.plus(t.times(t)));else{if(t.s)return _=!0,new this(1/0);r=t}return _=!0,r.sqrt()}function oo(e){return e instanceof Be||e&&e.toStringTag===uo||!1}function Ql(e){return new this(e).ln()}function Jl(e,t){return new this(e).log(t)}function Wl(e){return new this(e).log(2)}function Hl(e){return new this(e).log(10)}function Kl(){return fo(this,arguments,-1)}function zl(){return fo(this,arguments,1)}function Yl(e,t){return new this(e).mod(t)}function Zl(e,t){return new this(e).mul(t)}function Xl(e,t){return new this(e).pow(t)}function eu(e){var t,r,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:re(e,1,Oe),n=Math.ceil(e/O),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));o<n;)i=t[o],i>=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(t=crypto.randomBytes(n*=4);o<n;)i=t[o]+(t[o+1]<<8)+(t[o+2]<<16)+((t[o+3]&127)<<24),i>=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(lo);else for(;o<n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=O,n&&e&&(i=J(10,O-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o<0)r=0,a=[0];else{for(r=-1;a[0]===0;r-=O)a.shift();for(n=1,i=a[0];i>=10;i/=10)n++;n<O&&(r-=O-n)}return s.e=r,s.d=a,s}function tu(e){return I(e=new this(e),e.e+1,this.rounding)}function ru(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function nu(e){return new this(e).sin()}function iu(e){return new this(e).sinh()}function ou(e){return new this(e).sqrt()}function su(e,t){return new this(e).sub(t)}function au(){var e=0,t=arguments,r=new this(t[e]);for(_=!1;r.s&&++e<t.length;)r=r.plus(t[e]);return _=!0,I(r,this.precision,this.rounding)}function lu(e){return new this(e).tan()}function uu(e){return new this(e).tanh()}function cu(e){return I(e=new this(e),e.e+1,1)}C[Symbol.for("nodejs.util.inspect.custom")]=C.toString;C[Symbol.toStringTag]="Decimal";var Be=C.constructor=yo(yn);gr=new Be(gr);hr=new Be(hr);var ve=Be;function Ct(e){return e===null?e:Array.isArray(e)?e.map(Ct):typeof e=="object"?pu(e)?mu(e):Ze(e,Ct):e}function pu(e){return e!==null&&typeof e=="object"&&typeof e.$type=="string"}function mu({$type:e,value:t}){switch(e){case"BigInt":return BigInt(t);case"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"DateTime":return new Date(t);case"Decimal":return new ve(t);case"Json":return JSON.parse(t);default:xe(t,"Unknown tagged value")}}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var he=class{_map=new Map;get(t){return this._map.get(t)?.value}set(t,r){this._map.set(t,{value:r})}getOrCreate(t,r){let n=this._map.get(t);if(n)return n.value;let i=r();return this.set(t,i),i}};d();u();c();p();m();function De(e){return e.substring(0,1).toLowerCase()+e.substring(1)}d();u();c();p();m();function wo(e,t){let r={};for(let n of e){let i=n[t];r[i]=n}return r}d();u();c();p();m();function At(e){let t;return{get(){return t||(t={value:e()}),t.value}}}d();u();c();p();m();function du(e){return{models:xn(e.models),enums:xn(e.enums),types:xn(e.types)}}function xn(e){let t={};for(let{name:r,...n}of e)t[r]=n;return t}d();u();c();p();m();function tt(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function xr(e){return e.toString()!=="Invalid Date"}d();u();c();p();m();function rt(e){return Be.isDecimal(e)?!0:e!==null&&typeof e=="object"&&typeof e.s=="number"&&typeof e.e=="number"&&typeof e.toFixed=="function"&&Array.isArray(e.d)}d();u();c();p();m();d();u();c();p();m();var Pr={};ir(Pr,{ModelAction:()=>Rt,datamodelEnumToSchemaEnum:()=>fu});d();u();c();p();m();d();u();c();p();m();function fu(e){return{name:e.name,values:e.values.map(t=>t.name)}}d();u();c();p();m();var Rt=(k=>(k.findUnique="findUnique",k.findUniqueOrThrow="findUniqueOrThrow",k.findFirst="findFirst",k.findFirstOrThrow="findFirstOrThrow",k.findMany="findMany",k.create="create",k.createMany="createMany",k.createManyAndReturn="createManyAndReturn",k.update="update",k.updateMany="updateMany",k.updateManyAndReturn="updateManyAndReturn",k.upsert="upsert",k.delete="delete",k.deleteMany="deleteMany",k.groupBy="groupBy",k.count="count",k.aggregate="aggregate",k.findRaw="findRaw",k.aggregateRaw="aggregateRaw",k))(Rt||{});var gu=Qe(Ki());var hu={red:ze,gray:_i,dim:lr,bold:ar,underline:ki,highlightSource:e=>e.highlight()},yu={red:e=>e,gray:e=>e,dim:e=>e,bold:e=>e,underline:e=>e,highlightSource:e=>e};function wu({message:e,originalMethod:t,isPanic:r,callArguments:n}){return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}function Eu({functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=t?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&&a.push(s.underline(bu(t))),i){a.push("");let f=[i.toString()];o&&(f.push(o),f.push(s.dim(")"))),a.push(f.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(r),a.join(`
`)}function bu(e){let t=[e.fileName];return e.lineNumber&&t.push(String(e.lineNumber)),e.columnNumber&&t.push(String(e.columnNumber)),t.join(":")}function vr(e){let t=e.showColors?hu:yu,r;return typeof $getTemplateParameters<"u"?r=$getTemplateParameters(e,t):r=wu(e),Eu(r,t)}d();u();c();p();m();var Ro=Qe(Pn());d();u();c();p();m();function Po(e,t,r){let n=vo(e),i=xu(n),o=vu(i);o?Tr(o,t,r):t.addErrorMessage(()=>"Unknown error")}function vo(e){return e.errors.flatMap(t=>t.kind==="Union"?vo(t):[t])}function xu(e){let t=new Map,r=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){r.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=t.get(i);o?t.set(i,{...n,argument:{...n.argument,typeNames:Pu(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}return r.push(...t.values()),r}function Pu(e,t){return[...new Set(e.concat(t))]}function vu(e){return gn(e,(t,r)=>{let n=bo(t),i=bo(r);return n!==i?n-i:xo(t)-xo(r)})}function bo(e){let t=0;return Array.isArray(e.selectionPath)&&(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&&(t+=e.argumentPath.length),t}function xo(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}d();u();c();p();m();var ae=class{constructor(t,r){this.name=t;this.value=r}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(t){let{colors:{green:r}}=t.context;t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}};d();u();c();p();m();d();u();c();p();m();Co();d();u();c();p();m();var nt=class{constructor(t=0,r){this.context=r;this.currentIndent=t}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(t){return typeof t=="string"?this.currentLine+=t:t.write(this),this}writeJoined(t,r,n=(i,o)=>o.write(i)){let i=r.length-1;for(let o=0;o<r.length;o++)n(r[o],this),o!==i&&this.write(t);return this}writeLine(t){return this.write(t).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let t=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,t?.(),this}withIndent(t){return this.indent(),t(this),this.unindent(),this}afterNextNewline(t){return this.afterNextNewLineCallback=t,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(t){return this.marginSymbol=t,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let t=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+t.slice(1):t}};To();d();u();c();p();m();d();u();c();p();m();var Cr=class{constructor(t){this.value=t}write(t){t.write(this.value)}markAsError(){this.value.markAsError()}};d();u();c();p();m();var Ar=e=>e,Rr={bold:Ar,red:Ar,green:Ar,dim:Ar,enabled:!1},Ao={bold:ar,red:ze,green:Ii,dim:lr,enabled:!0},it={write(e){e.writeLine(",")}};d();u();c();p();m();var ye=class{constructor(t){this.contents=t}isUnderlined=!1;color=t=>t;underline(){return this.isUnderlined=!0,this}setColor(t){return this.color=t,this}write(t){let r=t.getCurrentLineLength();t.write(this.color(this.contents)),this.isUnderlined&&t.afterNextNewline(()=>{t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))})}};d();u();c();p();m();var Me=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var ot=class extends Me{items=[];addItem(t){return this.items.push(new Cr(t)),this}getField(t){return this.items[t]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(r=>r.value.getPrintWidth()))+2}write(t){if(this.items.length===0){this.writeEmpty(t);return}this.writeWithItems(t)}writeEmpty(t){let r=new ye("[]");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithItems(t){let{colors:r}=t.context;t.writeLine("[").withIndent(()=>t.writeJoined(it,this.items).newLine()).write("]"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(r.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var st=class e extends Me{fields={};suggestions=[];addField(t){this.fields[t.name]=t}addSuggestion(t){this.suggestions.push(t)}getField(t){return this.fields[t]}getDeepField(t){let[r,...n]=t,i=this.getField(r);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof ot&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(t){return t.length===0?this:this.getDeepField(t)?.value}hasField(t){return!!this.getField(t)}removeAllFields(){this.fields={}}removeField(t){delete this.fields[t]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(t){return this.getField(t)?.value}getDeepSubSelectionValue(t){let r=this;for(let n of t){if(!(r instanceof e))return;let i=r.getSubSelectionValue(n);if(!i)return;r=i}return r}getDeepSelectionParent(t){let r=this.getSelectionParent();if(!r)return;let n=r;for(let i of t){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let t=this.getField("select")?.value.asObject();if(t)return{kind:"select",value:t};let r=this.getField("include")?.value.asObject();if(r)return{kind:"include",value:r}}getSubSelectionValue(t){return this.getSelectionParent()?.value.fields[t].value}getPrintWidth(){let t=Object.values(this.fields);return t.length==0?2:Math.max(...t.map(n=>n.getPrintWidth()))+2}write(t){let r=Object.values(this.fields);if(r.length===0&&this.suggestions.length===0){this.writeEmpty(t);return}this.writeWithContents(t,r)}asObject(){return this}writeEmpty(t){let r=new ye("{}");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithContents(t,r){t.writeLine("{").withIndent(()=>{t.writeJoined(it,[...r,...this.suggestions]).newLine()}),t.write("}"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())))})}};d();u();c();p();m();var H=class extends Me{constructor(r){super();this.text=r}getPrintWidth(){return this.text.length}write(r){let n=new ye(this.text);this.hasError&&n.underline().setColor(r.context.colors.red),r.write(n)}asObject(){}};d();u();c();p();m();var St=class{fields=[];addField(t,r){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}}),this}write(t){let{colors:{green:r}}=t.context;t.writeLine(r("{")).withIndent(()=>{t.writeJoined(it,this.fields).newLine()}).write(r("}")).addMarginSymbol(r("+"))}};function Tr(e,t,r){switch(e.kind){case"MutuallyExclusiveFields":Tu(e,t);break;case"IncludeOnScalar":Cu(e,t);break;case"EmptySelection":Au(e,t,r);break;case"UnknownSelectionField":Iu(e,t);break;case"InvalidSelectionValue":Ou(e,t);break;case"UnknownArgument":Du(e,t);break;case"UnknownInputField":Mu(e,t);break;case"RequiredArgumentMissing":_u(e,t);break;case"InvalidArgumentType":Nu(e,t);break;case"InvalidArgumentValue":Fu(e,t);break;case"ValueTooLarge":Lu(e,t);break;case"SomeFieldsMissing":Bu(e,t);break;case"TooManyFieldsGiven":Uu(e,t);break;case"Union":Po(e,t,r);break;default:throw new Error("not implemented: "+e.kind)}}function Tu(e,t){let r=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();r&&(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function Cu(e,t){let[r,n]=kt(e.selectionPath),i=e.outputType,o=t.arguments.getDeepSelectionParent(r)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new ae(s.name,"true"));t.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${It(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function Au(e,t,r){let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){Ru(e,t,i);return}if(n.hasField("select")){Su(e,t);return}}if(r?.[De(e.outputType.name)]){ku(e,t);return}t.addErrorMessage(()=>`Unknown field at "${e.selectionPath.join(".")} selection"`)}function Ru(e,t,r){r.removeAllFields();for(let n of e.outputType.fields)r.addSuggestion(new ae(n.name,"false"));t.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}function Su(e,t){let r=e.outputType,n=t.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),Io(n,r)),t.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${It(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)}function ku(e,t){let r=new St;for(let i of e.outputType.fields)i.isRelation||r.addField(i.name,"false");let n=new ae("omit",r).makeRequired();if(e.selectionPath.length===0)t.arguments.addSuggestion(n);else{let[i,o]=kt(e.selectionPath),a=t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new st;l.addSuggestion(n),a.value=l}}t.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function Iu(e,t){let r=Oo(e.selectionPath,t);if(r.parentKind!=="unknown"){r.field.markAsError();let n=r.parent;switch(r.parentKind){case"select":Io(n,e.outputType);break;case"include":qu(n,e.outputType);break;case"omit":$u(n,e.outputType);break}}t.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];return r.parentKind!=="unknown"&&i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(It(n)),i.join(" ")})}function Ou(e,t){let r=Oo(e.selectionPath,t);r.parentKind!=="unknown"&&r.field.value.markAsError(),t.addErrorMessage(n=>`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)}function Du(e,t){let r=e.argumentPath[0],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&(n.getField(r)?.markAsError(),ju(n,e.arguments)),t.addErrorMessage(i=>So(i,r,e.arguments.map(o=>o.name)))}function Mu(e,t){let[r,n]=kt(e.argumentPath),i=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(r)?.asObject();o&&Do(o,e.inputType)}t.addErrorMessage(o=>So(o,n,e.inputType.fields.map(s=>s.name)))}function So(e,t,r){let n=[`Unknown argument \`${e.red(t)}\`.`],i=Gu(t,r);return i&&n.push(`Did you mean \`${e.green(i)}\`?`),r.length>0&&n.push(It(e)),n.join(" ")}function _u(e,t){let r;t.addErrorMessage(l=>r?.value instanceof H&&r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=kt(e.argumentPath),s=new St,a=n.getDeepFieldValue(i)?.asObject();if(a)if(r=a.getField(o),r&&a.removeField(o),e.inputTypes.length===1&&e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ae(o,s).makeRequired())}else{let l=e.inputTypes.map(ko).join(" | ");a.addSuggestion(new ae(o,l).makeRequired())}}function ko(e){return e.kind==="list"?`${ko(e.elementType)}[]`:e.name}function Nu(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=Sr("or",e.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}function Fu(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(r)}\``];if(e.underlyingError&&o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length>0){let s=Sr("or",e.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function Lu(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof H&&(i=s.text)}t.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")})}function Bu(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&&Do(i,e.inputType)}t.addErrorMessage(i=>{let o=[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Sr("or",e.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(It(i)),o.join(" ")})}function Uu(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}t.addErrorMessage(o=>{let s=[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&&e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Sr("and",i.map(a=>o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}function Io(e,t){for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ae(r.name,"true"))}function qu(e,t){for(let r of t.fields)r.isRelation&&!e.hasField(r.name)&&e.addSuggestion(new ae(r.name,"true"))}function $u(e,t){for(let r of t.fields)!e.hasField(r.name)&&!r.isRelation&&e.addSuggestion(new ae(r.name,"true"))}function ju(e,t){for(let r of t)e.hasField(r.name)||e.addSuggestion(new ae(r.name,r.typeNames.join(" | ")))}function Oo(e,t){let[r,n]=kt(e),i=t.arguments.getDeepSubSelectionValue(r)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&&l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&&l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&&l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function Do(e,t){if(t.kind==="object")for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ae(r.name,r.typeNames.join(" | ")))}function kt(e){let t=[...e],r=t.pop();if(!r)throw new Error("unexpected empty path");return[t,r]}function It({green:e,enabled:t}){return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}function Sr(e,t){if(t.length===1)return t[0];let r=[...t],n=r.pop();return`${r.join(", ")} ${e} ${n}`}var Vu=3;function Gu(e,t){let r=1/0,n;for(let i of t){let o=(0,Ro.default)(e,i);o>Vu||o<r&&(r=o,n=i)}return n}d();u();c();p();m();d();u();c();p();m();var Ot=class{modelName;name;typeName;isList;isEnum;constructor(t,r,n,i,o){this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let t=this.isList?"List":"",r=this.isEnum?"Enum":"";return`${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`}};function at(e){return e instanceof Ot}d();u();c();p();m();var kr=Symbol(),Tn=new WeakMap,Te=class{constructor(t){t===kr?Tn.set(this,`Prisma.${this._getName()}`):Tn.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return Tn.get(this)}},Dt=class extends Te{_getNamespace(){return"NullTypes"}},Mt=class extends Dt{_brand_DbNull};An(Mt,"DbNull");var _t=class extends Dt{_brand_JsonNull};An(_t,"JsonNull");var Nt=class extends Dt{_brand_AnyNull};An(Nt,"AnyNull");var Cn={classes:{DbNull:Mt,JsonNull:_t,AnyNull:Nt},instances:{DbNull:new Mt(kr),JsonNull:new _t(kr),AnyNull:new Nt(kr)}};function An(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}d();u();c();p();m();var Mo=": ",Ir=class{constructor(t,r){this.name=t;this.value=r}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+Mo.length}write(t){let r=new ye(this.name);this.hasError&&r.underline().setColor(t.context.colors.red),t.write(r).write(Mo).write(this.value)}};var Rn=class{arguments;errorMessages=[];constructor(t){this.arguments=t}write(t){t.write(this.arguments)}addErrorMessage(t){this.errorMessages.push(t)}renderAllMessages(t){return this.errorMessages.map(r=>r(t)).join(`
`)}};function lt(e){return new Rn(_o(e))}function _o(e){let t=new st;for(let[r,n]of Object.entries(e)){let i=new Ir(r,No(n));t.addField(i)}return t}function No(e){if(typeof e=="string")return new H(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new H(String(e));if(typeof e=="bigint")return new H(`${e}n`);if(e===null)return new H("null");if(e===void 0)return new H("undefined");if(rt(e))return new H(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return w.Buffer.isBuffer(e)?new H(`Buffer.alloc(${e.byteLength})`):new H(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let t=xr(e)?e.toISOString():"Invalid Date";return new H(`new Date("${t}")`)}return e instanceof Te?new H(`Prisma.${e._getName()}`):at(e)?new H(`prisma.${De(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Qu(e):typeof e=="object"?_o(e):new H(Object.prototype.toString.call(e))}function Qu(e){let t=new ot;for(let r of e)t.addItem(No(r));return t}function Or(e,t){let r=t==="pretty"?Ao:Rr,n=e.renderAllMessages(r),i=new nt(0,{colors:r}).write(e).toString();return{message:n,args:i}}function Dr({args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=lt(e);for(let h of t)Tr(h,a,s);let{message:l,args:f}=Or(a,r),g=vr({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:f});throw new X(g,{clientVersion:o})}d();u();c();p();m();d();u();c();p();m();function we(e){return e.replace(/^./,t=>t.toLowerCase())}d();u();c();p();m();function Lo(e,t,r){let n=we(r);return!t.result||!(t.result.$allModels||t.result[n])?e:Ju({...e,...Fo(t.name,e,t.result.$allModels),...Fo(t.name,e,t.result[n])})}function Ju(e){let t=new he,r=(n,i)=>t.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=>r(o,i)):[n]));return Ze(e,n=>({...n,needs:r(n.name,new Set)}))}function Fo(e,t,r){return r?Ze(r,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:Wu(t,o,i)})):{}}function Wu(e,t,r){let n=e?.[t]?.compute;return n?i=>r({...i,[t]:n(i)}):r}function Bo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(e[n.name])for(let i of n.needs)r[i]=!0;return r}function Uo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(!e[n.name])for(let i of n.needs)delete r[i];return r}var Mr=class{constructor(t,r){this.extension=t;this.previous=r}computedFieldsCache=new he;modelExtensionsCache=new he;queryCallbacksCache=new he;clientExtensions=At(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=At(()=>{let t=this.previous?.getAllBatchQueryCallbacks()??[],r=this.extension.query?.$__internalBatch;return r?t.concat(r):t});getAllComputedFields(t){return this.computedFieldsCache.getOrCreate(t,()=>Lo(this.previous?.getAllComputedFields(t),this.extension,t))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(t){return this.modelExtensionsCache.getOrCreate(t,()=>{let r=we(t);return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}})}getAllQueryCallbacks(t,r){return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,()=>{let n=this.previous?.getAllQueryCallbacks(t,r)??[],i=[],o=this.extension.query;return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&&(o[t][r]!==void 0&&i.push(o[t][r]),o[t].$allOperations!==void 0&&i.push(o[t].$allOperations)),t!=="$none"&&o.$allModels!==void 0&&(o.$allModels[r]!==void 0&&i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[r]!==void 0&&i.push(o[r]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},ut=class e{constructor(t){this.head=t}static empty(){return new e}static single(t){return new e(new Mr(t))}isEmpty(){return this.head===void 0}append(t){return new e(new Mr(t,this.head))}getAllComputedFields(t){return this.head?.getAllComputedFields(t)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(t){return this.head?.getAllModelExtensions(t)}getAllQueryCallbacks(t,r){return this.head?.getAllQueryCallbacks(t,r)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};d();u();c();p();m();var _r=class{constructor(t){this.name=t}};function qo(e){return e instanceof _r}function Hu(e){return new _r(e)}d();u();c();p();m();d();u();c();p();m();var $o=Symbol(),Ft=class{constructor(t){if(t!==$o)throw new Error("Skip instance can not be constructed directly")}ifUndefined(t){return t===void 0?Sn:t}},Sn=new Ft($o);function Ee(e){return e instanceof Ft}var Ku={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},jo="explicitly `undefined` values are not allowed";function In({modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=ut.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:f,globalOmit:g}){let h=new kn({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:f,globalOmit:g});return{modelName:e,action:Ku[t],query:Lt(r,h)}}function Lt({select:e,include:t,...r}={},n){let i=r.omit;return delete r.omit,{arguments:Go(r,n),selection:zu(e,t,i,n)}}function zu(e,t,r,n){return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),ec(e,n)):Yu(n,t,r)}function Yu(e,t,r){let n={};return e.modelOrType&&!e.isRawAction()&&(n.$composites=!0,n.$scalars=!0),t&&Zu(n,t,e),Xu(n,r,e),n}function Zu(e,t,r){for(let[n,i]of Object.entries(t)){if(Ee(i))continue;let o=r.nestSelection(n);if(On(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=r.findField(n);if(s&&s.kind!=="object"&&r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){e[n]=Lt(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=Lt(i,o)}}function Xu(e,t,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...t},o=Uo(i,n);for(let[s,a]of Object.entries(o)){if(Ee(a))continue;On(a,r.nestSelection(s));let l=r.findField(s);n?.[s]&&!l||(e[s]=!a)}}function ec(e,t){let r={},n=t.getComputedFields(),i=Bo(e,n);for(let[o,s]of Object.entries(i)){if(Ee(s))continue;let a=t.nestSelection(o);On(s,a);let l=t.findField(o);if(!(n?.[o]&&!l)){if(s===!1||s===void 0||Ee(s)){r[o]=!1;continue}if(s===!0){l?.kind==="object"?r[o]=Lt({},a):r[o]=!0;continue}r[o]=Lt(s,a)}}return r}function Vo(e,t){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(tt(e)){if(xr(e))return{$type:"DateTime",value:e.toISOString()};t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(qo(e))return{$type:"Param",value:e.name};if(at(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return tc(e,t);if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:w.Buffer.from(r,n,i).toString("base64")}}if(rc(e))return e.values;if(rt(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Te){if(e!==Cn.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(nc(e))return e.toJSON();if(typeof e=="object")return Go(e,t);t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function Go(e,t){if(e.$type)return{$type:"Raw",value:e};let r={};for(let n in e){let i=e[n],o=t.nestArgument(n);Ee(i)||(i!==void 0?r[n]=Vo(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:jo}))}return r}function tc(e,t){let r=[];for(let n=0;n<e.length;n++){let i=t.nestArgument(String(n)),o=e[n];if(o===void 0||Ee(o)){let s=o===void 0?"undefined":"Prisma.skip";t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}r.push(Vo(o,i))}return r}function rc(e){return typeof e=="object"&&e!==null&&e.__prismaRawParameters__===!0}function nc(e){return typeof e=="object"&&e!==null&&typeof e.toJSON=="function"}function On(e,t){e===void 0&&t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:jo})}var kn=class e{constructor(t){this.params=t;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(t){Dr({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(t=>({name:t.name,typeName:"boolean",isRelation:t.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(t){return this.params.previewFeatures.includes(t)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(t){return this.modelOrType?.fields.find(r=>r.name===t)}nestSelection(t){let r=this.findField(t),n=r?.kind==="object"?r.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[De(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:xe(this.params.action,"Unknown action")}}nestArgument(t){return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}};d();u();c();p();m();function Qo(e){if(!e._hasPreviewFlag("metrics"))throw new X("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var Bt=class{_client;constructor(t){this._client=t}prometheus(t){return Qo(this._client),this._client._engine.metrics({format:"prometheus",...t})}json(t){return Qo(this._client),this._client._engine.metrics({format:"json",...t})}};d();u();c();p();m();function ic(e,t){let r=At(()=>oc(t));Object.defineProperty(e,"dmmf",{get:()=>r.get()})}function oc(e){return{datamodel:{models:Dn(e.models),enums:Dn(e.enums),types:Dn(e.types)}}}function Dn(e){return Object.entries(e).map(([t,r])=>({name:t,...r}))}d();u();c();p();m();var Mn=new WeakMap,Nr="$$PrismaTypedSql",Ut=class{constructor(t,r){Mn.set(this,{sql:t,values:r}),Object.defineProperty(this,Nr,{value:Nr})}get sql(){return Mn.get(this).sql}get values(){return Mn.get(this).values}};function sc(e){return(...t)=>new Ut(e,t)}function Fr(e){return e!=null&&e[Nr]===Nr}d();u();c();p();m();var sa=Qe(Jo());d();u();c();p();m();Wo();qi();Gi();d();u();c();p();m();var le=class e{constructor(t,r){if(t.length-1!==r.length)throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);let n=r.reduce((s,a)=>s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];let i=0,o=0;for(;i<r.length;){let s=r[i++],a=t[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l<s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`?${this.strings[r++]}`;return n}get statement(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`:${r}${this.strings[r++]}`;return n}get text(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`$${r}${this.strings[r++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function lc(e,t=",",r="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new le([r,...Array(e.length-1).fill(t),n],e)}function Ho(e){return new le([e],[])}var uc=Ho("");function Ko(e,...t){return new le(e,t)}d();u();c();p();m();d();u();c();p();m();function qt(e){return{getKeys(){return Object.keys(e)},getPropertyValue(t){return e[t]}}}d();u();c();p();m();function ee(e,t){return{getKeys(){return[e]},getPropertyValue(){return t()}}}d();u();c();p();m();function Ue(e){let t=new he;return{getKeys(){return e.getKeys()},getPropertyValue(r){return t.getOrCreate(r,()=>e.getPropertyValue(r))},getPropertyDescriptor(r){return e.getPropertyDescriptor?.(r)}}}d();u();c();p();m();d();u();c();p();m();var Br={enumerable:!0,configurable:!0,writable:!0};function Ur(e){let t=new Set(e);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>Br,has:(r,n)=>t.has(n),set:(r,n,i)=>t.add(n)&&Reflect.set(r,n,i),ownKeys:()=>[...t]}}var zo=Symbol.for("nodejs.util.inspect.custom");function pe(e,t){let r=cc(t),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=r.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=r.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=Yo(Reflect.ownKeys(o),r),a=Yo(Array.from(r.keys()),r);return[...new Set([...s,...a,...n])]},set(o,s,a){return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let l=r.get(s);return l?l.getPropertyDescriptor?{...Br,...l?.getPropertyDescriptor(s)}:Br:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[zo]=function(){let o={...this};return delete o[zo],o},i}function cc(e){let t=new Map;for(let r of e){let n=r.getKeys();for(let i of n)t.set(i,r)}return t}function Yo(e,t){return e.filter(r=>t.get(r)?.has?.(r)??!0)}d();u();c();p();m();function ct(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}d();u();c();p();m();function qr(e,t){return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}d();u();c();p();m();function Zo(e){if(e===void 0)return"";let t=lt(e);return new nt(0,{colors:Rr}).write(t).toString()}d();u();c();p();m();var pc="P2037";function $r({error:e,user_facing_error:t},r,n){return t.error_code?new oe(mc(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new se(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}function mc(e,t){let r=e.message;return(t==="postgresql"||t==="postgres"||t==="mysql")&&e.error_code===pc&&(r+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var _n=class{getLocation(){return null}};function _e(e){return typeof $EnabledCallSite=="function"&&e!=="minimal"?new $EnabledCallSite:new _n}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var Xo={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function pt(e={}){let t=fc(e);return Object.entries(t).reduce((n,[i,o])=>(Xo[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function fc(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function jr(e={}){return t=>(typeof e._count=="boolean"&&(t._count=t._count._all),t)}function es(e,t){let r=jr(e);return t({action:"aggregate",unpacker:r,argsMapper:pt})(e)}d();u();c();p();m();function gc(e={}){let{select:t,...r}=e;return typeof t=="object"?pt({...r,_count:t}):pt({...r,_count:{_all:!0}})}function hc(e={}){return typeof e.select=="object"?t=>jr(e)(t)._count:t=>jr(e)(t)._count._all}function ts(e,t){return t({action:"count",unpacker:hc(e),argsMapper:gc})(e)}d();u();c();p();m();function yc(e={}){let t=pt(e);if(Array.isArray(t.by))for(let r of t.by)typeof r=="string"&&(t.select[r]=!0);else typeof t.by=="string"&&(t.select[t.by]=!0);return t}function wc(e={}){return t=>(typeof e?._count=="boolean"&&t.forEach(r=>{r._count=r._count._all}),t)}function rs(e,t){return t({action:"groupBy",unpacker:wc(e),argsMapper:yc})(e)}function ns(e,t,r){if(t==="aggregate")return n=>es(n,r);if(t==="count")return n=>ts(n,r);if(t==="groupBy")return n=>rs(n,r)}d();u();c();p();m();function is(e,t){let r=t.fields.filter(i=>!i.relationName),n=wo(r,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new Ot(e,o,s.type,s.isList,s.kind==="enum")},...Ur(Object.keys(n))})}d();u();c();p();m();d();u();c();p();m();var os=e=>Array.isArray(e)?e:e.split("."),Nn=(e,t)=>os(t).reduce((r,n)=>r&&r[n],e),ss=(e,t,r)=>os(t).reduceRight((n,i,o,s)=>Object.assign({},Nn(e,s.slice(0,o)),{[i]:n}),r);function Ec(e,t){return e===void 0||t===void 0?[]:[...t,"select",e]}function bc(e,t,r){return t===void 0?e??{}:ss(t,r,e||!0)}function Fn(e,t,r,n,i,o){let a=e._runtimeDataModel.models[t].fields.reduce((l,f)=>({...l,[f.name]:f}),{});return l=>{let f=_e(e._errorFormat),g=Ec(n,i),h=bc(l,o,g),v=r({dataPath:g,callsite:f})(h),S=xc(e,t);return new Proxy(v,{get(A,R){if(!S.includes(R))return A[R];let M=[a[R].type,r,R],B=[g,h];return Fn(e,...M,...B)},...Ur([...S,...Object.getOwnPropertyNames(v)])})}}function xc(e,t){return e._runtimeDataModel.models[t].fields.filter(r=>r.kind==="object").map(r=>r.name)}var Pc=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],vc=["aggregate","count","groupBy"];function Ln(e,t){let r=e._extensions.getAllModelExtensions(t)??{},n=[Tc(e,t),Ac(e,t),qt(r),ee("name",()=>t),ee("$name",()=>t),ee("$parent",()=>e._appliedParent)];return pe({},n)}function Tc(e,t){let r=we(t),n=Object.keys(Rt).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>l=>{let f=_e(e._errorFormat);return e._createPrismaPromise(g=>{let h={args:l,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:g,callsite:f};return e._request({...h,...a})},{action:o,args:l,model:t})};return Pc.includes(o)?Fn(e,t,s):Cc(i)?ns(e,i,s):s({})}}}function Cc(e){return vc.includes(e)}function Ac(e,t){return Ue(ee("fields",()=>{let r=e._runtimeDataModel.models[t];return is(t,r)}))}d();u();c();p();m();function as(e){return e.replace(/^./,t=>t.toUpperCase())}var Bn=Symbol();function $t(e){let t=[Rc(e),Sc(e),ee(Bn,()=>e),ee("$parent",()=>e._appliedParent)],r=e._extensions.getAllClientExtensions();return r&&t.push(qt(r)),pe(e,t)}function Rc(e){let t=Object.getPrototypeOf(e._originalClient),r=[...new Set(Object.getOwnPropertyNames(t))];return{getKeys(){return r},getPropertyValue(n){return e[n]}}}function Sc(e){let t=Object.keys(e._runtimeDataModel.models),r=t.map(we),n=[...new Set(t.concat(r))];return Ue({getKeys(){return n},getPropertyValue(i){let o=as(i);if(e._runtimeDataModel.models[o]!==void 0)return Ln(e,o);if(e._runtimeDataModel.models[i]!==void 0)return Ln(e,i)},getPropertyDescriptor(i){if(!r.includes(i))return{enumerable:!1}}})}function ls(e){return e[Bn]?e[Bn]:e}function us(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let r=e.client.__AccelerateEngine;this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}let t=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return $t(t)}d();u();c();p();m();d();u();c();p();m();function cs({result:e,modelName:t,select:r,omit:n,extensions:i}){let o=i.getAllComputedFields(t);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let f=l.needs.filter(g=>n[g]);f.length>0&&a.push(ct(f))}else if(r){if(!r[l.name])continue;let f=l.needs.filter(g=>!r[g]);f.length>0&&a.push(ct(f))}kc(e,l.needs)&&s.push(Ic(l,pe(e,s)))}return s.length>0||a.length>0?pe(e,[...s,...a]):e}function kc(e,t){return t.every(r=>fn(e,r))}function Ic(e,t){return Ue(ee(e.name,()=>e.compute(t)))}d();u();c();p();m();function Vr({visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){if(Array.isArray(t)){for(let s=0;s<t.length;s++)t[s]=Vr({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});return t}let o=e(t,i,r)??t;return r.include&&ps({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&&ps({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}function ps({includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||t[o]==null||Ee(s))continue;let l=n.models[r].fields.find(g=>g.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let f=typeof s=="object"?s:{};t[o]=Vr({visitor:i,result:t[o],args:f,modelName:l.type,runtimeDataModel:n})}}function ms({result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:Vr({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:(a,l,f)=>{let g=we(l);return cs({result:a,modelName:g,select:f.select,omit:f.select?void 0:{...o?.[g],...f.omit},extensions:n})}})}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var Oc=["$connect","$disconnect","$on","$transaction","$use","$extends"],ds=Oc;function fs(e){if(e instanceof le)return Dc(e);if(Fr(e))return Mc(e);if(Array.isArray(e)){let r=[e[0]];for(let n=1;n<e.length;n++)r[n]=jt(e[n]);return r}let t={};for(let r in e)t[r]=jt(e[r]);return t}function Dc(e){return new le(e.strings,e.values)}function Mc(e){return new Ut(e.sql,e.values)}function jt(e){if(typeof e!="object"||e==null||e instanceof Te||at(e))return e;if(rt(e))return new ve(e.toFixed());if(tt(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let t=e.length,r;for(r=Array(t);t--;)r[t]=jt(e[t]);return r}if(typeof e=="object"){let t={};for(let r in e)r==="__proto__"?Object.defineProperty(t,r,{value:jt(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=jt(e[r]);return t}xe(e,"Unknown value")}function hs(e,t,r,n=0){return e._createPrismaPromise(i=>{let o=t.customDataProxyFetch;return"transaction"in t&&i!==void 0&&(t.transaction?.kind==="batch"&&t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:fs(t.args??{}),__internalParams:t,query:(s,a=t)=>{let l=a.customDataProxyFetch;return a.customDataProxyFetch=bs(o,l),a.args=s,hs(e,a,r,n+1)}})})}function ys(e,t){let{jsModelName:r,action:n,clientMethod:i}=t,o=r?n:i;if(e._extensions.isEmpty())return e._executeRequest(t);let s=e._extensions.getAllQueryCallbacks(r??"$none",o);return hs(e,t,s)}function ws(e){return t=>{let r={requests:t},n=t[0].extensions.getAllBatchQueryCallbacks();return n.length?Es(r,n,0,e):e(r)}}function Es(e,t,r,n){if(r===t.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return t[r]({args:{queries:e.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=bs(i,l),Es(a,t,r+1,n)}})}var gs=e=>e;function bs(e=gs,t=gs){return r=>e(t(r))}d();u();c();p();m();var xs=Y("prisma:client"),Ps={Vercel:"vercel","Netlify CI":"netlify"};function vs({postinstall:e,ciName:t,clientVersion:r}){if(xs("checkPlatformCaching:postinstall",e),xs("checkPlatformCaching:ciName",t),e===!0&&t&&t in Ps){let n=`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Ps[t]}-build`;throw console.error(n),new Q(n,r)}}d();u();c();p();m();function Ts(e,t){return e?e.datasources?e.datasources:e.datasourceUrl?{[t[0]]:{url:e.datasourceUrl}}:{}:{}}d();u();c();p();m();d();u();c();p();m();var _c=()=>globalThis.process?.release?.name==="node",Nc=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,Fc=()=>!!globalThis.Deno,Lc=()=>typeof globalThis.Netlify=="object",Bc=()=>typeof globalThis.EdgeRuntime=="object",Uc=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function qc(){return[[Lc,"netlify"],[Bc,"edge-light"],[Uc,"workerd"],[Fc,"deno"],[Nc,"bun"],[_c,"node"]].flatMap(r=>r[0]()?[r[1]]:[]).at(0)??""}var $c={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function Un(){let e=qc();return{id:e,prettyName:$c[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();function mt({inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=t[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw Un().id==="workerd"?new Q(`error: Environment variable not found: ${s.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new Q(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new Q("error: Missing URL environment variable, value, or override.",n);return i}d();u();c();p();m();d();u();c();p();m();var Gr=class extends Error{clientVersion;cause;constructor(t,r){super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}get[Symbol.toStringTag](){return this.name}};var ne=class extends Gr{isRetryable;constructor(t,r){super(t,r),this.isRetryable=r.isRetryable??!0}};d();u();c();p();m();d();u();c();p();m();function L(e,t){return{...e,isRetryable:t}}var dt=class extends ne{name="ForcedRetryError";code="P5001";constructor(t){super("This request must be retried",L(t,!0))}};N(dt,"ForcedRetryError");d();u();c();p();m();var qe=class extends ne{name="InvalidDatasourceError";code="P6001";constructor(t,r){super(t,L(r,!1))}};N(qe,"InvalidDatasourceError");d();u();c();p();m();var $e=class extends ne{name="NotImplementedYetError";code="P5004";constructor(t,r){super(t,L(r,!1))}};N($e,"NotImplementedYetError");d();u();c();p();m();d();u();c();p();m();var V=class extends ne{response;constructor(t,r){super(t,r),this.response=r.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};var je=class extends V{name="SchemaMissingError";code="P5005";constructor(t){super("Schema needs to be uploaded",L(t,!0))}};N(je,"SchemaMissingError");d();u();c();p();m();d();u();c();p();m();var qn="This request could not be understood by the server",Vt=class extends V{name="BadRequestError";code="P5000";constructor(t,r,n){super(r||qn,L(t,!1)),n&&(this.code=n)}};N(Vt,"BadRequestError");d();u();c();p();m();var Gt=class extends V{name="HealthcheckTimeoutError";code="P5013";logs;constructor(t,r){super("Engine not started: healthcheck timeout",L(t,!0)),this.logs=r}};N(Gt,"HealthcheckTimeoutError");d();u();c();p();m();var Qt=class extends V{name="EngineStartupError";code="P5014";logs;constructor(t,r,n){super(r,L(t,!0)),this.logs=n}};N(Qt,"EngineStartupError");d();u();c();p();m();var Jt=class extends V{name="EngineVersionNotSupportedError";code="P5012";constructor(t){super("Engine version is not supported",L(t,!1))}};N(Jt,"EngineVersionNotSupportedError");d();u();c();p();m();var $n="Request timed out",Wt=class extends V{name="GatewayTimeoutError";code="P5009";constructor(t,r=$n){super(r,L(t,!1))}};N(Wt,"GatewayTimeoutError");d();u();c();p();m();var jc="Interactive transaction error",Ht=class extends V{name="InteractiveTransactionError";code="P5015";constructor(t,r=jc){super(r,L(t,!1))}};N(Ht,"InteractiveTransactionError");d();u();c();p();m();var Vc="Request parameters are invalid",Kt=class extends V{name="InvalidRequestError";code="P5011";constructor(t,r=Vc){super(r,L(t,!1))}};N(Kt,"InvalidRequestError");d();u();c();p();m();var jn="Requested resource does not exist",zt=class extends V{name="NotFoundError";code="P5003";constructor(t,r=jn){super(r,L(t,!1))}};N(zt,"NotFoundError");d();u();c();p();m();var Vn="Unknown server error",ft=class extends V{name="ServerError";code="P5006";logs;constructor(t,r,n){super(r||Vn,L(t,!0)),this.logs=n}};N(ft,"ServerError");d();u();c();p();m();var Gn="Unauthorized, check your connection string",Yt=class extends V{name="UnauthorizedError";code="P5007";constructor(t,r=Gn){super(r,L(t,!1))}};N(Yt,"UnauthorizedError");d();u();c();p();m();var Qn="Usage exceeded, retry again later",Zt=class extends V{name="UsageExceededError";code="P5008";constructor(t,r=Qn){super(r,L(t,!0))}};N(Zt,"UsageExceededError");async function Gc(e){let t;try{t=await e.text()}catch{return{type:"EmptyError"}}try{let r=JSON.parse(t);if(typeof r=="string")switch(r){case"InternalDataProxyError":return{type:"DataProxyError",body:r};default:return{type:"UnknownTextError",body:r}}if(typeof r=="object"&&r!==null){if("is_panic"in r&&"message"in r&&"error_code"in r)return{type:"QueryEngineError",body:r};if("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=Object.values(r)[0].reason;return typeof n=="string"&&!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}}return{type:"UnknownJsonError",body:r}}catch{return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}}async function Xt(e,t){if(e.ok)return;let r={clientVersion:t,response:e},n=await Gc(e);if(n.type==="QueryEngineError")throw new oe(n.body.message,{code:n.body.error_code,clientVersion:t});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new ft(r,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new je(r);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new Jt(r);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new Qt(r,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new Q(i,t,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new Gt(r,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new Ht(r,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new Kt(r,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new Yt(r,gt(Gn,n));if(e.status===404)return new zt(r,gt(jn,n));if(e.status===429)throw new Zt(r,gt(Qn,n));if(e.status===504)throw new Wt(r,gt($n,n));if(e.status>=500)throw new ft(r,gt(Vn,n));if(e.status>=400)throw new Vt(r,gt(qn,n))}function gt(e,t){return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}d();u();c();p();m();function Cs(e){let t=Math.pow(2,e)*50,r=Math.ceil(Math.random()*t)-Math.ceil(t/2),n=t+r;return new Promise(i=>setTimeout(()=>i(n),n))}d();u();c();p();m();var Ce="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function As(e){let t=new TextEncoder().encode(e),r="",n=t.byteLength,i=n%3,o=n-i,s,a,l,f,g;for(let h=0;h<o;h=h+3)g=t[h]<<16|t[h+1]<<8|t[h+2],s=(g&16515072)>>18,a=(g&258048)>>12,l=(g&4032)>>6,f=g&63,r+=Ce[s]+Ce[a]+Ce[l]+Ce[f];return i==1?(g=t[o],s=(g&252)>>2,a=(g&3)<<4,r+=Ce[s]+Ce[a]+"=="):i==2&&(g=t[o]<<8|t[o+1],s=(g&64512)>>10,a=(g&1008)>>4,l=(g&15)<<2,r+=Ce[s]+Ce[a]+Ce[l]+"="),r}d();u();c();p();m();function Rs(e){if(!!e.generator?.previewFeatures.some(r=>r.toLowerCase().includes("metrics")))throw new Q("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}d();u();c();p();m();function Qc(e){return e[0]*1e3+e[1]/1e6}function Jn(e){return new Date(Qc(e))}d();u();c();p();m();var Ss={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};d();u();c();p();m();d();u();c();p();m();var er=class extends ne{name="RequestError";code="P5010";constructor(t,r){super(`Cannot fetch data from service:
${t}`,L(r,!0))}};N(er,"RequestError");async function Ve(e,t,r=n=>n){let{clientVersion:n,...i}=t,o=r(fetch);try{return await o(e,i)}catch(s){let a=s.message??"Unknown error";throw new er(a,{clientVersion:n,cause:s})}}var Wc=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,ks=Y("prisma:client:dataproxyEngine");async function Hc(e,t){let r=Ss["@prisma/engines-version"],n=t.clientVersion??"unknown";if(y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&&n!=="0.0.0"&&n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&&Wc.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){if(e.startsWith("localhost")||e.startsWith("127.0.0.1"))return"0.0.0";let[s]=r.split("-")??[],[a,l,f]=s.split("."),g=Kc(`<=${a}.${l}.${f}`),h=await Ve(g,{clientVersion:n});if(!h.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${h.status} ${h.statusText}, response body: ${await h.text()||"<empty body>"}`);let v=await h.text();ks("length of body fetched from unpkg.com",v.length);let S;try{S=JSON.parse(v)}catch(A){throw console.error("JSON.parse error: body fetched from unpkg.com: ",v),A}return S.version}throw new $e("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}async function Is(e,t){let r=await Hc(e,t);return ks("version",r),r}function Kc(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}var Os=3,Qr=Y("prisma:client:dataproxyEngine"),Wn=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}build({traceparent:t,interactiveTransaction:r}={}){let n={Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};this.tracingHelper.isEnabled()&&(n.traceparent=t??this.tracingHelper.getTraceParent()),r&&(n["X-transaction-id"]=r.id);let i=this.buildCaptureSettings();return i.length>0&&(n["X-capture-telemetry"]=i.join(", ")),n}buildCaptureSettings(){let t=[];return this.tracingHelper.isEnabled()&&t.push("tracing"),this.logLevel&&t.push(this.logLevel),this.logQueries&&t.push("query"),t}},ht=class{name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;constructor(t){Rs(t),this.config=t,this.env={...t.env,...typeof y<"u"?y.env:{}},this.inlineSchema=As(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&&await this.startPromise,this.startPromise=(async()=>{let[t,r]=this.extractHostAndApiKey();this.host=t,this.headerBuilder=new Wn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Is(t,this.config),Qr("host",this.host)})(),await this.startPromise}async stop(){}propagateResponseExtensions(t){t?.logs?.length&&t.logs.forEach(r=>{switch(r.level){case"debug":case"trace":Qr(r);break;case"error":case"warn":case"info":{this.logEmitter.emit(r.level,{timestamp:Jn(r.timestamp),message:r.attributes.message??"",target:r.target});break}case"query":{this.logEmitter.emit("query",{query:r.attributes.query??"",timestamp:Jn(r.timestamp),duration:r.attributes.duration_ms??0,params:r.attributes.params??"",target:r.target});break}default:r.level}}),t?.traces?.length&&this.tracingHelper.dispatchEngineSpans(t.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(t){return await this.start(),`https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}async uploadSchema(){let t={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(t,async()=>{let r=await Ve(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});r.ok||Qr("schema response status",r.status);let n=await Xt(r,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(t,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}async requestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=qr(t,n);return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r})).map(l=>(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=>{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,interactiveTransaction:i}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);a.ok||Qr("graphql response status",a.status),await this.handleError(await Xt(a,this.clientVersion));let l=await a.json();if(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(t,r,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[t]} transaction`,callback:async({logHttpCall:o})=>{if(t==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await Ve(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await Xt(l,this.clientVersion));let f=await l.json(),{extensions:g}=f;g&&this.propagateResponseExtensions(g);let h=f.id,v=f["data-proxy"].endpoint;return{id:h,payload:{endpoint:v}}}else{let s=`${n.payload.endpoint}/${t}`;o(s);let a=await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});await this.handleError(await Xt(a,this.clientVersion));let l=await a.json(),{extensions:f}=l;f&&this.propagateResponseExtensions(f);return}}})}extractHostAndApiKey(){let t={clientVersion:this.clientVersion},r=Object.keys(this.inlineDatasources)[0],n=mt({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),i;try{i=new URL(n)}catch{throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}let{protocol:o,host:s,searchParams:a}=i;if(o!=="prisma:"&&o!==pr)throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t);let l=a.get("api_key");if(l===null||l.length<1)throw new qe(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);return[s,l]}metrics(){throw new $e("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(t){for(let r=0;;r++){let n=i=>{this.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})};try{return await t.callback({logHttpCall:n})}catch(i){if(!(i instanceof ne)||!i.isRetryable)throw i;if(r>=Os)throw i instanceof dt?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${r+1}/${Os} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await Cs(r);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(t){if(t instanceof je)throw await this.uploadSchema(),new dt({clientVersion:this.clientVersion,cause:t});if(t)throw t}convertProtocolErrorsToClientError(t){return t.length===1?$r(t[0],this.config.clientVersion,this.config.activeProvider):new se(JSON.stringify(t),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};function Ds({copyEngine:e=!0},t){let r;try{r=mt({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...y.env},clientVersion:t.clientVersion})}catch{}let n=!!(r?.startsWith("prisma://")||mn(r));e&&n&&mr("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");let i=Ye(t.generator),o=n||!e,s=!!t.adapter,a=i==="library",l=i==="binary",f=i==="client";if(o&&s||s){let g;throw g=["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."],new X(g.join(`
`),{clientVersion:t.clientVersion})}return o?new ht(t):new ht(t)}d();u();c();p();m();function Jr({generator:e}){return e?.previewFeatures??[]}d();u();c();p();m();var Ms=e=>({command:e});d();u();c();p();m();d();u();c();p();m();var _s=e=>e.strings.reduce((t,r,n)=>`${t}@P${n}${r}`);d();u();c();p();m();function yt(e){try{return Ns(e,"fast")}catch{return Ns(e,"slow")}}function Ns(e,t){return JSON.stringify(e.map(r=>Ls(r,t)))}function Ls(e,t){if(Array.isArray(e))return e.map(r=>Ls(r,t));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(tt(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(ve.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(w.Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(zc(e))return{prisma__type:"bytes",prisma__value:w.Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:w.Buffer.from(r,n,i).toString("base64")}}return typeof e=="object"&&t==="slow"?Bs(e):e}function zc(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&&e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Bs(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Fs);let t={};for(let r of Object.keys(e))t[r]=Fs(e[r]);return t}function Fs(e){return typeof e=="bigint"?e.toString():Bs(e)}var Yc=/^(\s*alter\s)/i,Us=Y("prisma:client");function Hn(e,t,r,n){if(!(e!=="postgresql"&&e!=="cockroachdb")&&r.length>0&&Yc.exec(t))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var Kn=({clientMethod:e,activeProvider:t})=>r=>{let n="",i;if(Fr(r))n=r.sql,i={values:yt(r.values),__prismaRawParameters__:!0};else if(Array.isArray(r)){let[o,...s]=r;n=o,i={values:yt(s||[]),__prismaRawParameters__:!0}}else switch(t){case"sqlite":case"mysql":{n=r.sql,i={values:yt(r.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=r.text,i={values:yt(r.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=_s(r),i={values:yt(r.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${t} provider does not support ${e}`)}return i?.values?Us(`prisma.${e}(${n}, ${i.values})`):Us(`prisma.${e}(${n})`),{query:n,parameters:i}},qs={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[t,...r]=e;return new le(t,r)}},$s={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};d();u();c();p();m();function zn(e){return function(r,n){let i,o=(s=e)=>{try{return s===void 0||s?.kind==="itx"?i??=js(r(s)):js(r(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function js(e){return typeof e.then=="function"?e:Promise.resolve(e)}d();u();c();p();m();var Zc=pn.split(".")[0],Xc={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,t){return t()}},Yn=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(t){return this.getGlobalTracingHelper().getTraceParent(t)}dispatchEngineSpans(t){return this.getGlobalTracingHelper().dispatchEngineSpans(t)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(t,r){return this.getGlobalTracingHelper().runInChildSpan(t,r)}getGlobalTracingHelper(){let t=globalThis[`V${Zc}_PRISMA_INSTRUMENTATION`],r=globalThis.PRISMA_INSTRUMENTATION;return t?.helper??r?.helper??Xc}};function Vs(){return new Yn}d();u();c();p();m();function Gs(e,t=()=>{}){let r,n=new Promise(i=>r=i);return{then(i){return--e===0&&r(t()),i?.(n)}}}d();u();c();p();m();function Qs(e){return typeof e=="string"?e:e.reduce((t,r)=>{let n=typeof r=="string"?r:r.level;return n==="query"?t:t&&(r==="info"||t==="info")?"info":n},void 0)}d();u();c();p();m();var Wr=class{_middlewares=[];use(t){this._middlewares.push(t)}get(t){return this._middlewares[t]}has(t){return!!this._middlewares[t]}length(){return this._middlewares.length}};d();u();c();p();m();var Ws=Qe(eo());d();u();c();p();m();function Hr(e){return typeof e.batchRequestIdx=="number"}d();u();c();p();m();function Js(e){if(e.action!=="findUnique"&&e.action!=="findUniqueOrThrow")return;let t=[];return e.modelName&&t.push(e.modelName),e.query.arguments&&t.push(Zn(e.query.arguments)),t.push(Zn(e.query.selection)),t.join("")}function Zn(e){return`(${Object.keys(e).sort().map(r=>{let n=e[r];return typeof n=="object"&&n!==null?`(${r} ${Zn(n)})`:r}).join(" ")})`}d();u();c();p();m();var ep={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Xn(e){return ep[e]}d();u();c();p();m();var Kr=class{constructor(t){this.options=t;this.batches={}}batches;tickActive=!1;request(t){let r=this.options.batchBy(t);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,y.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[r].push({request:t,resolve:n,reject:i})})):this.options.singleLoader(t)}dispatchBatches(){for(let t in this.batches){let r=this.batches[t];delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(n=>{n instanceof Error?r[0].reject(n):r[0].resolve(n)}).catch(n=>{r[0].reject(n)}):(r.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(r.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<r.length;i++)r[i].reject(n);else for(let i=0;i<r.length;i++){let o=n[i];o instanceof Error?r[i].reject(o):r[i].resolve(o)}}).catch(n=>{for(let i=0;i<r.length;i++)r[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};d();u();c();p();m();function Ge(e,t){if(t===null)return t;switch(e){case"bigint":return BigInt(t);case"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"decimal":return new ve(t);case"datetime":case"date":return new Date(t);case"time":return new Date(`1970-01-01T${t}Z`);case"bigint-array":return t.map(r=>Ge("bigint",r));case"bytes-array":return t.map(r=>Ge("bytes",r));case"decimal-array":return t.map(r=>Ge("decimal",r));case"datetime-array":return t.map(r=>Ge("datetime",r));case"date-array":return t.map(r=>Ge("date",r));case"time-array":return t.map(r=>Ge("time",r));default:return t}}function ei(e){let t=[],r=tp(e);for(let n=0;n<e.rows.length;n++){let i=e.rows[n],o={...r};for(let s=0;s<i.length;s++)o[e.columns[s]]=Ge(e.types[s],i[s]);t.push(o)}return t}function tp(e){let t={};for(let r=0;r<e.columns.length;r++)t[e.columns[r]]=null;return t}var rp=Y("prisma:client:request_handler"),zr=class{client;dataloader;logEmitter;constructor(t,r){this.logEmitter=r,this.client=t,this.dataloader=new Kr({batchLoader:ws(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(h=>h.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),f=n.some(h=>Xn(h.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:np(o),containsWrite:f,customDataProxyFetch:i})).map((h,v)=>{if(h instanceof Error)return h;try{return this.mapQueryEngineResult(n[v],h)}catch(S){return S}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?Hs(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Xn(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:Js(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(t){try{return await this.dataloader.request(t)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=t;this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}}mapQueryEngineResult({dataPath:t,unpacker:r},n){let i=n?.data,o=this.unpack(i,t,r);return y.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(t){try{this.handleRequestError(t)}catch(r){throw this.logEmitter&&this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}}handleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(rp(t),ip(t,i))throw t;if(t instanceof oe&&op(t)){let f=Ks(t.meta);Dr({args:o,errors:[f],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}let l=t.message;if(n&&(l=vr({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let f=s?{modelName:s,...t.meta}:t.meta;throw new oe(l,{code:t.code,clientVersion:this.client._clientVersion,meta:f,batchRequestIdx:t.batchRequestIdx})}else{if(t.isPanic)throw new Re(l,this.client._clientVersion);if(t instanceof se)throw new se(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});if(t instanceof Q)throw new Q(l,this.client._clientVersion);if(t instanceof Re)throw new Re(l,this.client._clientVersion)}throw t.clientVersion=this.client._clientVersion,t}sanitizeMessage(t){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,Ws.default)(t):t}unpack(t,r,n){if(!t||(t.data&&(t=t.data),!t))return t;let i=Object.keys(t)[0],o=Object.values(t)[0],s=r.filter(f=>f!=="select"&&f!=="include"),a=Nn(o,s),l=i==="queryRaw"?ei(a):Ct(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function np(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:Hs(e)};xe(e,"Unknown transaction kind")}}function Hs(e){return{id:e.id,payload:e.payload}}function ip(e,t){return Hr(e)&&t?.kind==="batch"&&e.batchRequestIdx!==t.index}function op(e){return e.code==="P2009"||e.code==="P2012"}function Ks(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(Ks)};if(Array.isArray(e.selectionPath)){let[,...t]=e.selectionPath;return{...e,selectionPath:t}}return e}d();u();c();p();m();var zs="6.6.0";var Ys=zs;d();u();c();p();m();var ra=Qe(Pn());d();u();c();p();m();var U=class extends Error{constructor(t){super(t+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};N(U,"PrismaClientConstructorValidationError");var Zs=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],Xs=["pretty","colorless","minimal"],ea=["info","query","warn","error"],ap={datasources:(e,{datasourceNames:t})=>{if(e){if(typeof e!="object"||Array.isArray(e))throw new U(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[r,n]of Object.entries(e)){if(!t.includes(r)){let i=wt(r,t)||` Available datasources: ${t.join(", ")}`;throw new U(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new U(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,t)=>{if(!e&&Ye(t.generator)==="client")throw new U('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new U('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Jr(t).includes("driverAdapters"))throw new U('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Ye(t.generator)==="binary")throw new U('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=>{if(typeof e<"u"&&typeof e!="string")throw new U(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=>{if(e){if(typeof e!="string")throw new U(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!Xs.includes(e)){let t=wt(e,Xs);throw new U(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}}},log:e=>{if(!e)return;if(!Array.isArray(e))throw new U(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function t(r){if(typeof r=="string"&&!ea.includes(r)){let n=wt(r,ea);throw new U(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}}for(let r of e){t(r);let n={level:t,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=wt(i,o);throw new U(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(r&&typeof r=="object")for(let[i,o]of Object.entries(r))if(n[i])n[i](o);else throw new U(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=>{if(!e)return;let t=e.maxWait;if(t!=null&&t<=0)throw new U(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let r=e.timeout;if(r!=null&&r<=0)throw new U(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,t)=>{if(typeof e!="object")throw new U('"omit" option is expected to be an object.');if(e===null)throw new U('"omit" option can not be `null`');let r=[];for(let[n,i]of Object.entries(e)){let o=up(n,t.runtimeDataModel);if(!o){r.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(f=>f.name===s);if(!l){r.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(r.length>0)throw new U(cp(e,r))},__internal:e=>{if(!e)return;let t=["debug","engine","configOverride"];if(typeof e!="object")throw new U(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[r]of Object.entries(e))if(!t.includes(r)){let n=wt(r,t);throw new U(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function na(e,t){for(let[r,n]of Object.entries(e)){if(!Zs.includes(r)){let i=wt(r,Zs);throw new U(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}ap[r](n,t)}if(e.datasourceUrl&&e.datasources)throw new U('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function wt(e,t){if(t.length===0||typeof e!="string")return"";let r=lp(e,t);return r?` Did you mean "${r}"?`:""}function lp(e,t){if(t.length===0)return null;let r=t.map(i=>({value:i,distance:(0,ra.default)(e,i)}));r.sort((i,o)=>i.distance<o.distance?-1:1);let n=r[0];return n.distance<3?n.value:null}function up(e,t){return ta(t.models,e)??ta(t.types,e)}function ta(e,t){let r=Object.keys(e).find(n=>De(n)===t);if(r)return e[r]}function cp(e,t){let r=lt(e);for(let o of t)switch(o.kind){case"UnknownModel":r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=Or(r,"colorless");return`Error validating "omit" option:

${i}

${n}`}d();u();c();p();m();function ia(e){return e.length===0?Promise.resolve([]):new Promise((t,r)=>{let n=new Array(e.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===e.length&&(o=!0,i?r(i):t(n)))},l=f=>{o||(o=!0,r(f))};for(let f=0;f<e.length;f++)e[f].then(g=>{n[f]=g,a()},g=>{if(!Hr(g)){l(g);return}g.batchRequestIdx===f?l(g):(i||(i=g),a())})})}var Ne=Y("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var pp={requestArgsToMiddlewareArgs:e=>e,middlewareArgsToRequestArgs:e=>e},mp=Symbol.for("prisma.client.transaction.id"),dp={id:0,nextId(){return++this.id}};function fp(e){class t{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new Wr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=zn();constructor(n){e=n?.__internal?.configOverride?.(e)??e,vs(e),n&&na(n,e);let i=new Lr().on("error",()=>{});this._extensions=ut.empty(),this._previewFeatures=Jr(e),this._clientVersion=e.clientVersion??Ys,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Vs();let o=e.relativeEnvPaths&&{rootEnvPath:e.relativeEnvPaths.rootEnvPath&&cr.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&&cr.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"?"postgres":e.activeProvider;if(s.provider!==l)throw new Q(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new Q("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=e.injectableEdgeEnv?.();try{let l=n??{},f=l.__internal??{},g=f.debug===!0;g&&Y.enable("prisma:client");let h=cr.resolve(e.dirname,e.relativePath);Ui.existsSync(h)||(h=e.dirname),Ne("dirname",e.dirname),Ne("relativePath",e.relativePath),Ne("cwd",h);let v=f.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat:y.env.NODE_ENV==="production"?this._errorFormat="minimal":y.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:h,dirname:e.dirname,enableDebugLogs:g,allowTriggerPanic:v.allowTriggerPanic,prismaPath:v.binaryPath??void 0,engineEndpoint:v.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&&Qs(l.log),logQueries:l.log&&!!(typeof l.log=="string"?l.log==="query":l.log.find(S=>typeof S=="string"?S==="query":S.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Ts(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:mt,getBatchRequestPayload:qr,prismaGraphQLToJSError:$r,PrismaClientUnknownRequestError:se,PrismaClientInitializationError:Q,PrismaClientKnownRequestError:oe,debug:Y("prisma:client:accelerateEngine"),engineVersion:sa.version,clientVersion:e.clientVersion}},Ne("clientVersion",e.clientVersion),this._engine=Ds(e,this._engineConfig),this._requestHandler=new zr(this,i),l.log)for(let S of l.log){let A=typeof S=="string"?S:S.emit==="stdout"?S.level:null;A&&this.$on(A,R=>{vt.log(`${vt.tags[A]??""}`,R.message||R.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=$t(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Li()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Kn({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=oa(n,i);return Hn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(Hn(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new X(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:Ms,callsite:_e(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Kn({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...oa(n,i));throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new X("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=dp.nextId(),s=Gs(n.length),a=n.map((l,f)=>{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let g=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,h={kind:"batch",id:o,index:f,isolationLevel:g,lock:s};return l.requestTransaction?.(h)??l});return ia(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let f={kind:"itx",...a};l=await n(this._createItxClient(f)),await this._engine.transaction("commit",o,a)}catch(f){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),f}return l}_createItxClient(n){return pe($t(pe(ls(this),[ee("_appliedParent",()=>this._appliedParent._createItxClient(n)),ee("_createPrismaPromise",()=>zn(n)),ee(mp,()=>n.id)])),[ct(ds)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??pp,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async f=>{let g=this._middlewares.get(++a);if(g)return this._tracingHelper.runInChildSpan(s.middleware,D=>g(f,M=>(D?.end(),l(M))));let{runInTransaction:h,args:v,...S}=f,A={...n,...S};v&&(A.args=i.middlewareArgsToRequestArgs(v)),n.transaction!==void 0&&h===!1&&delete A.transaction;let R=await ys(this,A);return A.model?ms({result:R,modelName:A.model,args:A.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):R};return this._tracingHelper.runInChildSpan(s.operation,()=>l(o))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:f,transaction:g,unpacker:h,otelParentCtx:v,customDataProxyFetch:S}){try{n=f?f(n):n;let A={name:"serialize"},R=this._tracingHelper.runInChildSpan(A,()=>In({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return Y.enabled("prisma:client")&&(Ne("Prisma Client call:"),Ne(`prisma.${i}(${Zo(n)})`),Ne("Generated request:"),Ne(JSON.stringify(R,null,2)+`
`)),g?.kind==="batch"&&await g.lock,this._requestHandler.request({protocolQuery:R,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:g,unpacker:h,otelParentCtx:v,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:S})}catch(A){throw A.clientVersion=this._clientVersion,A}}$metrics=new Bt(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=us}return t}function oa(e,t){return gp(e)?[new le(e,t),qs]:[e,$s]}function gp(e){return Array.isArray(e)&&Array.isArray(e.raw)}d();u();c();p();m();var hp=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function yp(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(!hp.has(r))throw new TypeError(`Invalid enum value: ${String(r)}`)}})}d();u();c();p();m();var export_warnEnvConflicts=void 0;export{Pr as DMMF,Y as Debug,ve as Decimal,Pi as Extensions,Bt as MetricsClient,Q as PrismaClientInitializationError,oe as PrismaClientKnownRequestError,Re as PrismaClientRustPanicError,se as PrismaClientUnknownRequestError,X as PrismaClientValidationError,Ti as Public,le as Sql,Hu as createParam,ic as defineDmmfProperty,Ct as deserializeJsonResponse,ei as deserializeRawResult,du as dmmfToRuntimeDataModel,uc as empty,fp as getPrismaClient,Un as getRuntime,lc as join,yp as makeStrictEnum,sc as makeTypedQueryFactory,Cn as objectEnumValues,Ho as raw,In as serializeJsonQuery,Sn as skip,Ko as sqltag,export_warnEnvConflicts as warnEnvConflicts,mr as warnOnce};
//# sourceMappingURL=edge-esm.js.map

```

## 📄 lib\generated\prisma\runtime\edge.js

```js
"use strict";var ya=Object.create;var ar=Object.defineProperty;var wa=Object.getOwnPropertyDescriptor;var Ea=Object.getOwnPropertyNames;var ba=Object.getPrototypeOf,xa=Object.prototype.hasOwnProperty;var me=(e,t)=>()=>(e&&(t=e(e=0)),t);var Fe=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Pt=(e,t)=>{for(var r in t)ar(e,r,{get:t[r],enumerable:!0})},oi=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Ea(t))!xa.call(e,i)&&i!==r&&ar(e,i,{get:()=>t[i],enumerable:!(n=wa(t,i))||n.enumerable});return e};var Qe=(e,t,r)=>(r=e!=null?ya(ba(e)):{},oi(t||!e||!e.__esModule?ar(r,"default",{value:e,enumerable:!0}):r,e)),Pa=e=>oi(ar({},"__esModule",{value:!0}),e);var y,u=me(()=>{"use strict";y={nextTick:(e,...t)=>{setTimeout(()=>{e(...t)},0)},env:{},version:"",cwd:()=>"/",stderr:{},argv:["/bin/node"]}});var b,c=me(()=>{"use strict";b=globalThis.performance??(()=>{let e=Date.now();return{now:()=>Date.now()-e}})()});var E,p=me(()=>{"use strict";E=()=>{};E.prototype=E});var m=me(()=>{"use strict"});var Ti=Fe(Ke=>{"use strict";d();u();c();p();m();var ci=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),va=ci(e=>{"use strict";e.byteLength=l,e.toByteArray=g,e.fromByteArray=S;var t=[],r=[],n=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(o=0,s=i.length;o<s;++o)t[o]=i[o],r[i.charCodeAt(o)]=o;var o,s;r[45]=62,r[95]=63;function a(A){var R=A.length;if(R%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var D=A.indexOf("=");D===-1&&(D=R);var M=D===R?0:4-D%4;return[D,M]}function l(A){var R=a(A),D=R[0],M=R[1];return(D+M)*3/4-M}function f(A,R,D){return(R+D)*3/4-D}function g(A){var R,D=a(A),M=D[0],B=D[1],k=new n(f(A,M,B)),F=0,ae=B>0?M-4:M,G;for(G=0;G<ae;G+=4)R=r[A.charCodeAt(G)]<<18|r[A.charCodeAt(G+1)]<<12|r[A.charCodeAt(G+2)]<<6|r[A.charCodeAt(G+3)],k[F++]=R>>16&255,k[F++]=R>>8&255,k[F++]=R&255;return B===2&&(R=r[A.charCodeAt(G)]<<2|r[A.charCodeAt(G+1)]>>4,k[F++]=R&255),B===1&&(R=r[A.charCodeAt(G)]<<10|r[A.charCodeAt(G+1)]<<4|r[A.charCodeAt(G+2)]>>2,k[F++]=R>>8&255,k[F++]=R&255),k}function h(A){return t[A>>18&63]+t[A>>12&63]+t[A>>6&63]+t[A&63]}function v(A,R,D){for(var M,B=[],k=R;k<D;k+=3)M=(A[k]<<16&16711680)+(A[k+1]<<8&65280)+(A[k+2]&255),B.push(h(M));return B.join("")}function S(A){for(var R,D=A.length,M=D%3,B=[],k=16383,F=0,ae=D-M;F<ae;F+=k)B.push(v(A,F,F+k>ae?ae:F+k));return M===1?(R=A[D-1],B.push(t[R>>2]+t[R<<4&63]+"==")):M===2&&(R=(A[D-2]<<8)+A[D-1],B.push(t[R>>10]+t[R>>4&63]+t[R<<2&63]+"=")),B.join("")}}),Ta=ci(e=>{e.read=function(t,r,n,i,o){var s,a,l=o*8-i-1,f=(1<<l)-1,g=f>>1,h=-7,v=n?o-1:0,S=n?-1:1,A=t[r+v];for(v+=S,s=A&(1<<-h)-1,A>>=-h,h+=l;h>0;s=s*256+t[r+v],v+=S,h-=8);for(a=s&(1<<-h)-1,s>>=-h,h+=i;h>0;a=a*256+t[r+v],v+=S,h-=8);if(s===0)s=1-g;else{if(s===f)return a?NaN:(A?-1:1)*(1/0);a=a+Math.pow(2,i),s=s-g}return(A?-1:1)*a*Math.pow(2,s-i)},e.write=function(t,r,n,i,o,s){var a,l,f,g=s*8-o-1,h=(1<<g)-1,v=h>>1,S=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,A=i?0:s-1,R=i?1:-1,D=r<0||r===0&&1/r<0?1:0;for(r=Math.abs(r),isNaN(r)||r===1/0?(l=isNaN(r)?1:0,a=h):(a=Math.floor(Math.log(r)/Math.LN2),r*(f=Math.pow(2,-a))<1&&(a--,f*=2),a+v>=1?r+=S/f:r+=S*Math.pow(2,1-v),r*f>=2&&(a++,f/=2),a+v>=h?(l=0,a=h):a+v>=1?(l=(r*f-1)*Math.pow(2,o),a=a+v):(l=r*Math.pow(2,v-1)*Math.pow(2,o),a=0));o>=8;t[n+A]=l&255,A+=R,l/=256,o-=8);for(a=a<<o|l,g+=o;g>0;t[n+A]=a&255,A+=R,a/=256,g-=8);t[n+A-R]|=D*128}}),an=va(),We=Ta(),si=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=T;Ke.SlowBuffer=Ia;Ke.INSPECT_MAX_BYTES=50;var lr=2147483647;Ke.kMaxLength=lr;T.TYPED_ARRAY_SUPPORT=Ca();!T.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Ca(){try{let e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),e.foo()===42}catch{return!1}}Object.defineProperty(T.prototype,"parent",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.buffer}});Object.defineProperty(T.prototype,"offset",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.byteOffset}});function xe(e){if(e>lr)throw new RangeError('The value "'+e+'" is invalid for option "size"');let t=new Uint8Array(e);return Object.setPrototypeOf(t,T.prototype),t}function T(e,t,r){if(typeof e=="number"){if(typeof t=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return cn(e)}return pi(e,t,r)}T.poolSize=8192;function pi(e,t,r){if(typeof e=="string")return Ra(e,t);if(ArrayBuffer.isView(e))return Sa(e);if(e==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(de(e,ArrayBuffer)||e&&de(e.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(de(e,SharedArrayBuffer)||e&&de(e.buffer,SharedArrayBuffer)))return di(e,t,r);if(typeof e=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');let n=e.valueOf&&e.valueOf();if(n!=null&&n!==e)return T.from(n,t,r);let i=ka(e);if(i)return i;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]=="function")return T.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}T.from=function(e,t,r){return pi(e,t,r)};Object.setPrototypeOf(T.prototype,Uint8Array.prototype);Object.setPrototypeOf(T,Uint8Array);function mi(e){if(typeof e!="number")throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function Aa(e,t,r){return mi(e),e<=0?xe(e):t!==void 0?typeof r=="string"?xe(e).fill(t,r):xe(e).fill(t):xe(e)}T.alloc=function(e,t,r){return Aa(e,t,r)};function cn(e){return mi(e),xe(e<0?0:pn(e)|0)}T.allocUnsafe=function(e){return cn(e)};T.allocUnsafeSlow=function(e){return cn(e)};function Ra(e,t){if((typeof t!="string"||t==="")&&(t="utf8"),!T.isEncoding(t))throw new TypeError("Unknown encoding: "+t);let r=fi(e,t)|0,n=xe(r),i=n.write(e,t);return i!==r&&(n=n.slice(0,i)),n}function ln(e){let t=e.length<0?0:pn(e.length)|0,r=xe(t);for(let n=0;n<t;n+=1)r[n]=e[n]&255;return r}function Sa(e){if(de(e,Uint8Array)){let t=new Uint8Array(e);return di(t.buffer,t.byteOffset,t.byteLength)}return ln(e)}function di(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return t===void 0&&r===void 0?n=new Uint8Array(e):r===void 0?n=new Uint8Array(e,t):n=new Uint8Array(e,t,r),Object.setPrototypeOf(n,T.prototype),n}function ka(e){if(T.isBuffer(e)){let t=pn(e.length)|0,r=xe(t);return r.length===0||e.copy(r,0,0,t),r}if(e.length!==void 0)return typeof e.length!="number"||dn(e.length)?xe(0):ln(e);if(e.type==="Buffer"&&Array.isArray(e.data))return ln(e.data)}function pn(e){if(e>=lr)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+lr.toString(16)+" bytes");return e|0}function Ia(e){return+e!=e&&(e=0),T.alloc(+e)}T.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==T.prototype};T.compare=function(e,t){if(de(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),de(t,Uint8Array)&&(t=T.from(t,t.offset,t.byteLength)),!T.isBuffer(e)||!T.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0};T.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}};T.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return T.alloc(0);let r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;let n=T.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){let o=e[r];if(de(o,Uint8Array))i+o.length>n.length?(T.isBuffer(o)||(o=T.from(o)),o.copy(n,i)):Uint8Array.prototype.set.call(n,o,i);else if(T.isBuffer(o))o.copy(n,i);else throw new TypeError('"list" argument must be an Array of Buffers');i+=o.length}return n};function fi(e,t){if(T.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||de(e,ArrayBuffer))return e.byteLength;if(typeof e!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);let r=e.length,n=arguments.length>2&&arguments[2]===!0;if(!n&&r===0)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return un(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return vi(e).length;default:if(i)return n?-1:un(e).length;t=(""+t).toLowerCase(),i=!0}}T.byteLength=fi;function Oa(e,t,r){let n=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,t>>>=0,r<=t))return"";for(e||(e="utf8");;)switch(e){case"hex":return $a(this,t,r);case"utf8":case"utf-8":return hi(this,t,r);case"ascii":return Ua(this,t,r);case"latin1":case"binary":return qa(this,t,r);case"base64":return La(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ja(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}T.prototype._isBuffer=!0;function Le(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}T.prototype.swap16=function(){let e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)Le(this,t,t+1);return this};T.prototype.swap32=function(){let e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)Le(this,t,t+3),Le(this,t+1,t+2);return this};T.prototype.swap64=function(){let e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)Le(this,t,t+7),Le(this,t+1,t+6),Le(this,t+2,t+5),Le(this,t+3,t+4);return this};T.prototype.toString=function(){let e=this.length;return e===0?"":arguments.length===0?hi(this,0,e):Oa.apply(this,arguments)};T.prototype.toLocaleString=T.prototype.toString;T.prototype.equals=function(e){if(!T.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:T.compare(this,e)===0};T.prototype.inspect=function(){let e="",t=Ke.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"};si&&(T.prototype[si]=T.prototype.inspect);T.prototype.compare=function(e,t,r,n,i){if(de(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),!T.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(t===void 0&&(t=0),r===void 0&&(r=e?e.length:0),n===void 0&&(n=0),i===void 0&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;let o=i-n,s=r-t,a=Math.min(o,s),l=this.slice(n,i),f=e.slice(t,r);for(let g=0;g<a;++g)if(l[g]!==f[g]){o=l[g],s=f[g];break}return o<s?-1:s<o?1:0};function gi(e,t,r,n,i){if(e.length===0)return-1;if(typeof r=="string"?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,dn(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0)if(i)r=0;else return-1;if(typeof t=="string"&&(t=T.from(t,n)),T.isBuffer(t))return t.length===0?-1:ai(e,t,r,n,i);if(typeof t=="number")return t=t&255,typeof Uint8Array.prototype.indexOf=="function"?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):ai(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function ai(e,t,r,n,i){let o=1,s=e.length,a=t.length;if(n!==void 0&&(n=String(n).toLowerCase(),n==="ucs2"||n==="ucs-2"||n==="utf16le"||n==="utf-16le")){if(e.length<2||t.length<2)return-1;o=2,s/=2,a/=2,r/=2}function l(g,h){return o===1?g[h]:g.readUInt16BE(h*o)}let f;if(i){let g=-1;for(f=r;f<s;f++)if(l(e,f)===l(t,g===-1?0:f-g)){if(g===-1&&(g=f),f-g+1===a)return g*o}else g!==-1&&(f-=f-g),g=-1}else for(r+a>s&&(r=s-a),f=r;f>=0;f--){let g=!0;for(let h=0;h<a;h++)if(l(e,f+h)!==l(t,h)){g=!1;break}if(g)return f}return-1}T.prototype.includes=function(e,t,r){return this.indexOf(e,t,r)!==-1};T.prototype.indexOf=function(e,t,r){return gi(this,e,t,r,!0)};T.prototype.lastIndexOf=function(e,t,r){return gi(this,e,t,r,!1)};function Da(e,t,r,n){r=Number(r)||0;let i=e.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;let o=t.length;n>o/2&&(n=o/2);let s;for(s=0;s<n;++s){let a=parseInt(t.substr(s*2,2),16);if(dn(a))return s;e[r+s]=a}return s}function Ma(e,t,r,n){return ur(un(t,e.length-r),e,r,n)}function _a(e,t,r,n){return ur(Ja(t),e,r,n)}function Na(e,t,r,n){return ur(vi(t),e,r,n)}function Fa(e,t,r,n){return ur(Wa(t,e.length-r),e,r,n)}T.prototype.write=function(e,t,r,n){if(t===void 0)n="utf8",r=this.length,t=0;else if(r===void 0&&typeof t=="string")n=t,r=this.length,t=0;else if(isFinite(t))t=t>>>0,isFinite(r)?(r=r>>>0,n===void 0&&(n="utf8")):(n=r,r=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let i=this.length-t;if((r===void 0||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return Da(this,e,t,r);case"utf8":case"utf-8":return Ma(this,e,t,r);case"ascii":case"latin1":case"binary":return _a(this,e,t,r);case"base64":return Na(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Fa(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}};T.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function La(e,t,r){return t===0&&r===e.length?an.fromByteArray(e):an.fromByteArray(e.slice(t,r))}function hi(e,t,r){r=Math.min(e.length,r);let n=[],i=t;for(;i<r;){let o=e[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(i+a<=r){let l,f,g,h;switch(a){case 1:o<128&&(s=o);break;case 2:l=e[i+1],(l&192)===128&&(h=(o&31)<<6|l&63,h>127&&(s=h));break;case 3:l=e[i+1],f=e[i+2],(l&192)===128&&(f&192)===128&&(h=(o&15)<<12|(l&63)<<6|f&63,h>2047&&(h<55296||h>57343)&&(s=h));break;case 4:l=e[i+1],f=e[i+2],g=e[i+3],(l&192)===128&&(f&192)===128&&(g&192)===128&&(h=(o&15)<<18|(l&63)<<12|(f&63)<<6|g&63,h>65535&&h<1114112&&(s=h))}}s===null?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),i+=a}return Ba(n)}var li=4096;function Ba(e){let t=e.length;if(t<=li)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=li));return r}function Ua(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]&127);return n}function qa(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function $a(e,t,r){let n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let i="";for(let o=t;o<r;++o)i+=Ha[e[o]];return i}function ja(e,t,r){let n=e.slice(t,r),i="";for(let o=0;o<n.length-1;o+=2)i+=String.fromCharCode(n[o]+n[o+1]*256);return i}T.prototype.slice=function(e,t){let r=this.length;e=~~e,t=t===void 0?r:~~t,e<0?(e+=r,e<0&&(e=0)):e>r&&(e=r),t<0?(t+=r,t<0&&(t=0)):t>r&&(t=r),t<e&&(t=e);let n=this.subarray(e,t);return Object.setPrototypeOf(n,T.prototype),n};function W(e,t,r){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}T.prototype.readUintLE=T.prototype.readUIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return n};T.prototype.readUintBE=T.prototype.readUIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e+--t],i=1;for(;t>0&&(i*=256);)n+=this[e+--t]*i;return n};T.prototype.readUint8=T.prototype.readUInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]};T.prototype.readUint16LE=T.prototype.readUInt16LE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]|this[e+1]<<8};T.prototype.readUint16BE=T.prototype.readUInt16BE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]<<8|this[e+1]};T.prototype.readUint32LE=T.prototype.readUInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};T.prototype.readUint32BE=T.prototype.readUInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};T.prototype.readBigUInt64LE=Re(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&vt(e,this.length-8);let n=t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,i=this[++e]+this[++e]*2**8+this[++e]*2**16+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))});T.prototype.readBigUInt64BE=Re(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&vt(e,this.length-8);let n=t*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],i=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r;return(BigInt(n)<<BigInt(32))+BigInt(i)});T.prototype.readIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n};T.prototype.readIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=t,i=1,o=this[e+--n];for(;n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o};T.prototype.readInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]};T.prototype.readInt16LE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e]|this[e+1]<<8;return r&32768?r|4294901760:r};T.prototype.readInt16BE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e+1]|this[e]<<8;return r&32768?r|4294901760:r};T.prototype.readInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};T.prototype.readInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};T.prototype.readBigInt64LE=Re(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&vt(e,this.length-8);let n=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)});T.prototype.readBigInt64BE=Re(function(e){e=e>>>0,He(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&vt(e,this.length-8);let n=(t<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r)});T.prototype.readFloatLE=function(e,t){return e=e>>>0,t||W(e,4,this.length),We.read(this,e,!0,23,4)};T.prototype.readFloatBE=function(e,t){return e=e>>>0,t||W(e,4,this.length),We.read(this,e,!1,23,4)};T.prototype.readDoubleLE=function(e,t){return e=e>>>0,t||W(e,8,this.length),We.read(this,e,!0,52,8)};T.prototype.readDoubleBE=function(e,t){return e=e>>>0,t||W(e,8,this.length),We.read(this,e,!1,52,8)};function te(e,t,r,n,i,o){if(!T.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}T.prototype.writeUintLE=T.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;te(this,e,t,r,s,0)}let i=1,o=0;for(this[t]=e&255;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r};T.prototype.writeUintBE=T.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;te(this,e,t,r,s,0)}let i=r-1,o=1;for(this[t+i]=e&255;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r};T.prototype.writeUint8=T.prototype.writeUInt8=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,1,255,0),this[t]=e&255,t+1};T.prototype.writeUint16LE=T.prototype.writeUInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,65535,0),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeUint16BE=T.prototype.writeUInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeUint32LE=T.prototype.writeUInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=e&255,t+4};T.prototype.writeUint32BE=T.prototype.writeUInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};function yi(e,t,r,n,i){Pi(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,r}function wi(e,t,r,n,i){Pi(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r+7]=o,o=o>>8,e[r+6]=o,o=o>>8,e[r+5]=o,o=o>>8,e[r+4]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=s,s=s>>8,e[r+2]=s,s=s>>8,e[r+1]=s,s=s>>8,e[r]=s,r+8}T.prototype.writeBigUInt64LE=Re(function(e,t=0){return yi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeBigUInt64BE=Re(function(e,t=0){return wi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);te(this,e,t,r,a-1,-a)}let i=0,o=1,s=0;for(this[t]=e&255;++i<r&&(o*=256);)e<0&&s===0&&this[t+i-1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);te(this,e,t,r,a-1,-a)}let i=r-1,o=1,s=0;for(this[t+i]=e&255;--i>=0&&(o*=256);)e<0&&s===0&&this[t+i+1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeInt8=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=e&255,t+1};T.prototype.writeInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,32767,-32768),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,2147483647,-2147483648),this[t]=e&255,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4};T.prototype.writeInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||te(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};T.prototype.writeBigInt64LE=Re(function(e,t=0){return yi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});T.prototype.writeBigInt64BE=Re(function(e,t=0){return wi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Ei(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function bi(e,t,r,n,i){return t=+t,r=r>>>0,i||Ei(e,t,r,4,34028234663852886e22,-34028234663852886e22),We.write(e,t,r,n,23,4),r+4}T.prototype.writeFloatLE=function(e,t,r){return bi(this,e,t,!0,r)};T.prototype.writeFloatBE=function(e,t,r){return bi(this,e,t,!1,r)};function xi(e,t,r,n,i){return t=+t,r=r>>>0,i||Ei(e,t,r,8,17976931348623157e292,-17976931348623157e292),We.write(e,t,r,n,52,8),r+8}T.prototype.writeDoubleLE=function(e,t,r){return xi(this,e,t,!0,r)};T.prototype.writeDoubleBE=function(e,t,r){return xi(this,e,t,!1,r)};T.prototype.copy=function(e,t,r,n){if(!T.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),!n&&n!==0&&(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r||e.length===0||this.length===0)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);let i=n-r;return this===e&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i};T.prototype.fill=function(e,t,r,n){if(typeof e=="string"){if(typeof t=="string"?(n=t,t=0,r=this.length):typeof r=="string"&&(n=r,r=this.length),n!==void 0&&typeof n!="string")throw new TypeError("encoding must be a string");if(typeof n=="string"&&!T.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(e.length===1){let o=e.charCodeAt(0);(n==="utf8"&&o<128||n==="latin1")&&(e=o)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;t=t>>>0,r=r===void 0?this.length:r>>>0,e||(e=0);let i;if(typeof e=="number")for(i=t;i<r;++i)this[i]=e;else{let o=T.isBuffer(e)?e:T.from(e,n),s=o.length;if(s===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<r-t;++i)this[i+t]=o[i%s]}return this};var Je={};function mn(e,t,r){Je[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(n){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:n,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}mn("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError);mn("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError);mn("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=ui(String(r)):typeof r=="bigint"&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=ui(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n},RangeError);function ui(e){let t="",r=e.length,n=e[0]==="-"?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function Va(e,t,r){He(t,"offset"),(e[t]===void 0||e[t+r]===void 0)&&vt(t,e.length-(r+1))}function Pi(e,t,r,n,i,o){if(e>r||e<t){let s=typeof t=="bigint"?"n":"",a;throw o>3?t===0||t===BigInt(0)?a=`>= 0${s} and < 2${s} ** ${(o+1)*8}${s}`:a=`>= -(2${s} ** ${(o+1)*8-1}${s}) and < 2 ** ${(o+1)*8-1}${s}`:a=`>= ${t}${s} and <= ${r}${s}`,new Je.ERR_OUT_OF_RANGE("value",a,e)}Va(n,i,o)}function He(e,t){if(typeof e!="number")throw new Je.ERR_INVALID_ARG_TYPE(t,"number",e)}function vt(e,t,r){throw Math.floor(e)!==e?(He(e,r),new Je.ERR_OUT_OF_RANGE(r||"offset","an integer",e)):t<0?new Je.ERR_BUFFER_OUT_OF_BOUNDS:new Je.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}var Ga=/[^+/0-9A-Za-z-_]/g;function Qa(e){if(e=e.split("=")[0],e=e.trim().replace(Ga,""),e.length<2)return"";for(;e.length%4!==0;)e=e+"=";return e}function un(e,t){t=t||1/0;let r,n=e.length,i=null,o=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return o}function Ja(e){let t=[];for(let r=0;r<e.length;++r)t.push(e.charCodeAt(r)&255);return t}function Wa(e,t){let r,n,i,o=[];for(let s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function vi(e){return an.toByteArray(Qa(e))}function ur(e,t,r,n){let i;for(i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function de(e,t){return e instanceof t||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===t.name}function dn(e){return e!==e}var Ha=function(){let e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){let n=r*16;for(let i=0;i<16;++i)t[n+i]=e[r]+e[i]}return t}();function Re(e){return typeof BigInt>"u"?Ka:e}function Ka(){throw new Error("BigInt not supported")}});var w,d=me(()=>{"use strict";w=Qe(Ti())});function tl(){return!1}function $i(){return{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}function rl(){return $i()}function nl(){return[]}function il(e){e(null,[])}function ol(){return""}function sl(){return""}function al(){}function ll(){}function ul(){}function cl(){}function pl(){}function ml(){}var dl,fl,ji,Vi=me(()=>{"use strict";d();u();c();p();m();dl={},fl={existsSync:tl,lstatSync:$i,statSync:rl,readdirSync:nl,readdir:il,readlinkSync:ol,realpathSync:sl,chmodSync:al,renameSync:ll,mkdirSync:ul,rmdirSync:cl,rmSync:pl,unlinkSync:ml,promises:dl},ji=fl});function gl(...e){return e.join("/")}function hl(...e){return e.join("/")}function yl(e){let t=Gi(e),r=Qi(e),[n,i]=t.split(".");return{root:"/",dir:r,base:t,ext:i,name:n}}function Gi(e){let t=e.split("/");return t[t.length-1]}function Qi(e){return e.split("/").slice(0,-1).join("/")}var Ji,wl,El,dr,Wi=me(()=>{"use strict";d();u();c();p();m();Ji="/",wl={sep:Ji},El={basename:Gi,dirname:Qi,join:hl,parse:yl,posix:wl,resolve:gl,sep:Ji},dr=El});var Hi=Fe((ld,bl)=>{bl.exports={name:"@prisma/internals",version:"6.6.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.4.7",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-engine-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Zi=Fe((Rd,Yi)=>{"use strict";d();u();c();p();m();Yi.exports=(e,t=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;let n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))}});var to=Fe((Ud,eo)=>{"use strict";d();u();c();p();m();eo.exports=({onlyFirst:e=!1}={})=>{let t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(t,e?void 0:"g")}});var no=Fe((Qd,ro)=>{"use strict";d();u();c();p();m();var Rl=to();ro.exports=e=>typeof e=="string"?e.replace(Rl(),""):e});var kn=Fe((_y,vo)=>{"use strict";d();u();c();p();m();vo.exports=function(){function e(t,r,n,i,o){return t<r||n<r?t>n?n+1:t+1:i===o?r:r+1}return function(t,r){if(t===r)return 0;if(t.length>r.length){var n=t;t=r,r=n}for(var i=t.length,o=r.length;i>0&&t.charCodeAt(i-1)===r.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&t.charCodeAt(s)===r.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,l,f,g,h,v,S,A,R,D,M,B,k,F=[];for(l=0;l<i;l++)F.push(l+1),F.push(t.charCodeAt(s+l));for(var ae=F.length-1;a<o-3;)for(D=r.charCodeAt(s+(f=a)),M=r.charCodeAt(s+(g=a+1)),B=r.charCodeAt(s+(h=a+2)),k=r.charCodeAt(s+(v=a+3)),S=a+=4,l=0;l<ae;l+=2)A=F[l],R=F[l+1],f=e(A,f,g,D,R),g=e(f,g,h,M,R),h=e(g,h,v,B,R),S=e(h,v,S,k,R),F[l]=S,v=h,h=g,g=f,f=A;for(;a<o;)for(D=r.charCodeAt(s+(f=a)),S=++a,l=0;l<ae;l+=2)A=F[l],F[l]=S=e(A,f,S,D,F[l+1]),f=A;return S}}()});var So=me(()=>{"use strict";d();u();c();p();m()});var ko=me(()=>{"use strict";d();u();c();p();m()});var Xo=Fe((r1,dc)=>{dc.exports={name:"@prisma/engines-version",version:"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"f676762280b54cd07c770017ed3711ddde35f37a"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var $r,es=me(()=>{"use strict";d();u();c();p();m();$r=class{events={};on(t,r){return this.events[t]||(this.events[t]=[]),this.events[t].push(r),this}emit(t,...r){return this.events[t]?(this.events[t].forEach(n=>{n(...r)}),!0):!1}}});var bp={};Pt(bp,{DMMF:()=>Ot,Debug:()=>K,Decimal:()=>he,Extensions:()=>fn,MetricsClient:()=>pt,PrismaClientInitializationError:()=>Q,PrismaClientKnownRequestError:()=>re,PrismaClientRustPanicError:()=>ve,PrismaClientUnknownRequestError:()=>ne,PrismaClientValidationError:()=>Z,Public:()=>gn,Sql:()=>oe,createParam:()=>Qo,defineDmmfProperty:()=>Yo,deserializeJsonResponse:()=>tt,deserializeRawResult:()=>tn,dmmfToRuntimeDataModel:()=>Po,empty:()=>rs,getPrismaClient:()=>fa,getRuntime:()=>Hr,join:()=>ts,makeStrictEnum:()=>ga,makeTypedQueryFactory:()=>Zo,objectEnumValues:()=>Or,raw:()=>Bn,serializeJsonQuery:()=>Br,skip:()=>Lr,sqltag:()=>Un,warnEnvConflicts:()=>void 0,warnOnce:()=>Rt});module.exports=Pa(bp);d();u();c();p();m();var fn={};Pt(fn,{defineExtension:()=>Ci,getExtensionContext:()=>Ai});d();u();c();p();m();d();u();c();p();m();function Ci(e){return typeof e=="function"?e:t=>t.$extends(e)}d();u();c();p();m();function Ai(e){return e}var gn={};Pt(gn,{validator:()=>Ri});d();u();c();p();m();d();u();c();p();m();function Ri(...e){return t=>t}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var hn,Si,ki,Ii,Oi=!0;typeof y<"u"&&({FORCE_COLOR:hn,NODE_DISABLE_COLORS:Si,NO_COLOR:ki,TERM:Ii}=y.env||{},Oi=y.stdout&&y.stdout.isTTY);var za={enabled:!Si&&ki==null&&Ii!=="dumb"&&(hn!=null&&hn!=="0"||Oi)};function j(e,t){let r=new RegExp(`\\x1b\\[${t}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${t}m`;return function(o){return!za.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}}var pm=j(0,0),cr=j(1,22),pr=j(2,22),mm=j(3,23),Di=j(4,24),dm=j(7,27),fm=j(8,28),gm=j(9,29),hm=j(30,39),ze=j(31,39),Mi=j(32,39),_i=j(33,39),Ni=j(34,39),ym=j(35,39),Fi=j(36,39),wm=j(37,39),Li=j(90,39),Em=j(90,39),bm=j(40,49),xm=j(41,49),Pm=j(42,49),vm=j(43,49),Tm=j(44,49),Cm=j(45,49),Am=j(46,49),Rm=j(47,49);d();u();c();p();m();var Ya=100,Bi=["green","yellow","blue","magenta","cyan","red"],mr=[],Ui=Date.now(),Za=0,yn=typeof y<"u"?y.env:{};globalThis.DEBUG??=yn.DEBUG??"";globalThis.DEBUG_COLORS??=yn.DEBUG_COLORS?yn.DEBUG_COLORS==="true":!0;var Tt={enable(e){typeof e=="string"&&(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},enabled(e){let t=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),r=t.some(i=>i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n=t.some(i=>i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return r&&!n},log:(...e)=>{let[t,r,...n]=e;(console.warn??console.log)(`${t} ${r}`,...n)},formatters:{}};function Xa(e){let t={color:Bi[Za++%Bi.length],enabled:Tt.enabled(e),namespace:e,log:Tt.log,extend:()=>{}},r=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=t;if(n.length!==0&&mr.push([o,...n]),mr.length>Ya&&mr.shift(),Tt.enabled(o)||i){let l=n.map(g=>typeof g=="string"?g:el(g)),f=`+${Date.now()-Ui}ms`;Ui=Date.now(),a(o,...l,f)}};return new Proxy(r,{get:(n,i)=>t[i],set:(n,i,o)=>t[i]=o})}var K=new Proxy(Xa,{get:(e,t)=>Tt[t],set:(e,t,r)=>Tt[t]=r});function el(e,t=2){let r=new Set;return JSON.stringify(e,(n,i)=>{if(typeof i=="object"&&i!==null){if(r.has(i))return"[Circular *]";r.add(i)}else if(typeof i=="bigint")return i.toString();return i},t)}function qi(){mr.length=0}d();u();c();p();m();d();u();c();p();m();var xl=Hi(),wn=xl.version;d();u();c();p();m();var Ki="library";function Ye(e){let t=Pl();return t||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Ki)}function Pl(){let e=y.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}d();u();c();p();m();var zi="prisma+postgres",fr=`${zi}:`;function En(e){return e?.startsWith(`${fr}//`)??!1}var At={};Pt(At,{error:()=>Cl,info:()=>Tl,log:()=>vl,query:()=>Al,should:()=>Xi,tags:()=>Ct,warn:()=>bn});d();u();c();p();m();var Ct={error:ze("prisma:error"),warn:_i("prisma:warn"),info:Fi("prisma:info"),query:Ni("prisma:query")},Xi={warn:()=>!y.env.PRISMA_DISABLE_WARNINGS};function vl(...e){console.log(...e)}function bn(e,...t){Xi.warn()&&console.warn(`${Ct.warn} ${e}`,...t)}function Tl(e,...t){console.info(`${Ct.info} ${e}`,...t)}function Cl(e,...t){console.error(`${Ct.error} ${e}`,...t)}function Al(e,...t){console.log(`${Ct.query} ${e}`,...t)}d();u();c();p();m();function Pe(e,t){throw new Error(t)}d();u();c();p();m();function xn(e,t){return Object.prototype.hasOwnProperty.call(e,t)}d();u();c();p();m();function Ze(e,t){let r={};for(let n of Object.keys(e))r[n]=t(e[n],n);return r}d();u();c();p();m();function Pn(e,t){if(e.length===0)return;let r=e[0];for(let n=1;n<e.length;n++)t(r,e[n])<0&&(r=e[n]);return r}d();u();c();p();m();function N(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}d();u();c();p();m();var io=new Set,Rt=(e,t,...r)=>{io.has(e)||(io.add(e),bn(t,...r))};var Q=class e extends Error{clientVersion;errorCode;retryable;constructor(t,r,n){super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};N(Q,"PrismaClientInitializationError");d();u();c();p();m();var re=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};N(re,"PrismaClientKnownRequestError");d();u();c();p();m();var ve=class extends Error{clientVersion;constructor(t,r){super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};N(ve,"PrismaClientRustPanicError");d();u();c();p();m();var ne=class extends Error{clientVersion;batchRequestIdx;constructor(t,{clientVersion:r,batchRequestIdx:n}){super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};N(ne,"PrismaClientUnknownRequestError");d();u();c();p();m();var Z=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(t,{clientVersion:r}){super(t),this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};N(Z,"PrismaClientValidationError");d();u();c();p();m();d();u();c();p();m();var Xe=9e15,Oe=1e9,vn="0123456789abcdef",yr="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",wr="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Tn={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Xe,maxE:Xe,crypto:!1},uo,Te,_=!0,br="[DecimalError] ",Ie=br+"Invalid argument: ",co=br+"Precision limit exceeded",po=br+"crypto unavailable",mo="[object Decimal]",X=Math.floor,J=Math.pow,Sl=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,kl=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Il=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,fo=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,ce=1e7,O=7,Ol=9007199254740991,Dl=yr.length-1,Cn=wr.length-1,C={toStringTag:mo};C.absoluteValue=C.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),I(e)};C.ceil=function(){return I(new this.constructor(this),this.e+1,2)};C.clampedTo=C.clamp=function(e,t){var r,n=this,i=n.constructor;if(e=new i(e),t=new i(t),!e.s||!t.s)return new i(NaN);if(e.gt(t))throw Error(Ie+t);return r=n.cmp(e),r<0?e:n.cmp(t)>0?t:new i(n)};C.comparedTo=C.cmp=function(e){var t,r,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,f=e.s;if(!s||!a)return!l||!f?NaN:l!==f?l:s===a?0:!s^l<0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-f:0;if(l!==f)return l;if(o.e!==e.e)return o.e>e.e^l<0?1:-1;for(n=s.length,i=a.length,t=0,r=n<i?n:i;t<r;++t)if(s[t]!==a[t])return s[t]>a[t]^l<0?1:-1;return n===i?0:n>i^l<0?1:-1};C.cosine=C.cos=function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=Ml(n,Eo(n,r)),n.precision=e,n.rounding=t,I(Te==2||Te==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)};C.cubeRoot=C.cbrt=function(){var e,t,r,n,i,o,s,a,l,f,g=this,h=g.constructor;if(!g.isFinite()||g.isZero())return new h(g);for(_=!1,o=g.s*J(g.s*g,1/3),!o||Math.abs(o)==1/0?(r=z(g.d),e=g.e,(o=(e-r.length+1)%3)&&(r+=o==1||o==-2?"0":"00"),o=J(r,1/3),e=X((e+1)/3)-(e%3==(e<0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new h(r),n.s=g.s):n=new h(o.toString()),s=(e=h.precision)+3;;)if(a=n,l=a.times(a).times(a),f=l.plus(g),n=q(f.plus(g).times(a),f.plus(l),s+2,1),z(a.d).slice(0,s)===(r=z(n.d)).slice(0,s))if(r=r.slice(s-3,s+1),r=="9999"||!i&&r=="4999"){if(!i&&(I(a,e+1,0),a.times(a).times(a).eq(g))){n=a;break}s+=4,i=1}else{(!+r||!+r.slice(1)&&r.charAt(0)=="5")&&(I(n,e+1,1),t=!n.times(n).times(n).eq(g));break}return _=!0,I(n,e,h.rounding,t)};C.decimalPlaces=C.dp=function(){var e,t=this.d,r=NaN;if(t){if(e=t.length-1,r=(e-X(this.e/O))*O,e=t[e],e)for(;e%10==0;e/=10)r--;r<0&&(r=0)}return r};C.dividedBy=C.div=function(e){return q(this,new this.constructor(e))};C.dividedToIntegerBy=C.divToInt=function(e){var t=this,r=t.constructor;return I(q(t,new r(e),0,1,1),r.precision,r.rounding)};C.equals=C.eq=function(e){return this.cmp(e)===0};C.floor=function(){return I(new this.constructor(this),this.e+1,3)};C.greaterThan=C.gt=function(e){return this.cmp(e)>0};C.greaterThanOrEqualTo=C.gte=function(e){var t=this.cmp(e);return t==1||t===0};C.hyperbolicCosine=C.cosh=function(){var e,t,r,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;r=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i<32?(e=Math.ceil(i/3),t=(1/Pr(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=et(s,1,o.times(t),new s(1),!0);for(var l,f=e,g=new s(8);f--;)l=o.times(o),o=a.minus(l.times(g.minus(l.times(g))));return I(o,s.precision=r,s.rounding=n,!0)};C.hyperbolicSine=C.sinh=function(){var e,t,r,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n<3)i=et(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e>16?16:e|0,i=i.times(1/Pr(5,e)),i=et(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),f=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(f))))}return o.precision=t,o.rounding=r,I(i,t,r,!0)};C.hyperbolicTangent=C.tanh=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,q(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)};C.inverseCosine=C.acos=function(){var e=this,t=e.constructor,r=e.abs().cmp(1),n=t.precision,i=t.rounding;return r!==-1?r===0?e.isNeg()?fe(t,n,i):new t(0):new t(NaN):e.isZero()?fe(t,n+4,i).times(.5):(t.precision=n+6,t.rounding=1,e=new t(1).minus(e).div(e.plus(1)).sqrt().atan(),t.precision=n,t.rounding=i,e.times(2))};C.inverseHyperbolicCosine=C.acosh=function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,_=!1,r=r.times(r).minus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)};C.inverseHyperbolicSine=C.asinh=function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,_=!1,r=r.times(r).plus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln())};C.inverseHyperbolicTangent=C.atanh=function(){var e,t,r,n,i=this,o=i.constructor;return i.isFinite()?i.e>=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?I(new o(i),e,t,!0):(o.precision=r=n-i.e,i=q(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)};C.inverseSine=C.asin=function(){var e,t,r,n,i=this,o=i.constructor;return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=fe(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))};C.inverseTangent=C.atan=function(){var e,t,r,n,i,o,s,a,l,f=this,g=f.constructor,h=g.precision,v=g.rounding;if(f.isFinite()){if(f.isZero())return new g(f);if(f.abs().eq(1)&&h+4<=Cn)return s=fe(g,h+4,v).times(.25),s.s=f.s,s}else{if(!f.s)return new g(NaN);if(h+4<=Cn)return s=fe(g,h+4,v).times(.5),s.s=f.s,s}for(g.precision=a=h+10,g.rounding=1,r=Math.min(28,a/O+2|0),e=r;e;--e)f=f.div(f.times(f).plus(1).sqrt().plus(1));for(_=!1,t=Math.ceil(a/O),n=1,l=f.times(f),s=new g(f),i=f;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)for(e=t;s.d[e]===o.d[e]&&e--;);return r&&(s=s.times(2<<r-1)),_=!0,I(s,g.precision=h,g.rounding=v,!0)};C.isFinite=function(){return!!this.d};C.isInteger=C.isInt=function(){return!!this.d&&X(this.e/O)>this.d.length-2};C.isNaN=function(){return!this.s};C.isNegative=C.isNeg=function(){return this.s<0};C.isPositive=C.isPos=function(){return this.s>0};C.isZero=function(){return!!this.d&&this.d[0]===0};C.lessThan=C.lt=function(e){return this.cmp(e)<0};C.lessThanOrEqualTo=C.lte=function(e){return this.cmp(e)<1};C.logarithm=C.log=function(e){var t,r,n,i,o,s,a,l,f=this,g=f.constructor,h=g.precision,v=g.rounding,S=5;if(e==null)e=new g(10),t=!0;else{if(e=new g(e),r=e.d,e.s<0||!r||!r[0]||e.eq(1))return new g(NaN);t=e.eq(10)}if(r=f.d,f.s<0||!r||!r[0]||f.eq(1))return new g(r&&!r[0]?-1/0:f.s!=1?NaN:r?0:1/0);if(t)if(r.length>1)o=!0;else{for(i=r[0];i%10===0;)i/=10;o=i!==1}if(_=!1,a=h+S,s=ke(f,a),n=t?Er(g,a+10):ke(e,a),l=q(s,n,a,1),St(l.d,i=h,v))do if(a+=10,s=ke(f,a),n=t?Er(g,a+10):ke(e,a),l=q(s,n,a,1),!o){+z(l.d).slice(i+1,i+15)+1==1e14&&(l=I(l,h+1,0));break}while(St(l.d,i+=10,v));return _=!0,I(l,h,v)};C.minus=C.sub=function(e){var t,r,n,i,o,s,a,l,f,g,h,v,S=this,A=S.constructor;if(e=new A(e),!S.d||!e.d)return!S.s||!e.s?e=new A(NaN):S.d?e.s=-e.s:e=new A(e.d||S.s!==e.s?S:NaN),e;if(S.s!=e.s)return e.s=-e.s,S.plus(e);if(f=S.d,v=e.d,a=A.precision,l=A.rounding,!f[0]||!v[0]){if(v[0])e.s=-e.s;else if(f[0])e=new A(S);else return new A(l===3?-0:0);return _?I(e,a,l):e}if(r=X(e.e/O),g=X(S.e/O),f=f.slice(),o=g-r,o){for(h=o<0,h?(t=f,o=-o,s=v.length):(t=v,r=g,s=f.length),n=Math.max(Math.ceil(a/O),s)+2,o>n&&(o=n,t.length=1),t.reverse(),n=o;n--;)t.push(0);t.reverse()}else{for(n=f.length,s=v.length,h=n<s,h&&(s=n),n=0;n<s;n++)if(f[n]!=v[n]){h=f[n]<v[n];break}o=0}for(h&&(t=f,f=v,v=t,e.s=-e.s),s=f.length,n=v.length-s;n>0;--n)f[s++]=0;for(n=v.length;n>o;){if(f[--n]<v[n]){for(i=n;i&&f[--i]===0;)f[i]=ce-1;--f[i],f[n]+=ce}f[n]-=v[n]}for(;f[--s]===0;)f.pop();for(;f[0]===0;f.shift())--r;return f[0]?(e.d=f,e.e=xr(f,r),_?I(e,a,l):e):new A(l===3?-0:0)};C.modulo=C.mod=function(e){var t,r=this,n=r.constructor;return e=new n(e),!r.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||r.d&&!r.d[0]?I(new n(r),n.precision,n.rounding):(_=!1,n.modulo==9?(t=q(r,e.abs(),0,3,1),t.s*=e.s):t=q(r,e,0,n.modulo,1),t=t.times(e),_=!0,r.minus(t))};C.naturalExponential=C.exp=function(){return An(this)};C.naturalLogarithm=C.ln=function(){return ke(this)};C.negated=C.neg=function(){var e=new this.constructor(this);return e.s=-e.s,I(e)};C.plus=C.add=function(e){var t,r,n,i,o,s,a,l,f,g,h=this,v=h.constructor;if(e=new v(e),!h.d||!e.d)return!h.s||!e.s?e=new v(NaN):h.d||(e=new v(e.d||h.s===e.s?h:NaN)),e;if(h.s!=e.s)return e.s=-e.s,h.minus(e);if(f=h.d,g=e.d,a=v.precision,l=v.rounding,!f[0]||!g[0])return g[0]||(e=new v(h)),_?I(e,a,l):e;if(o=X(h.e/O),n=X(e.e/O),f=f.slice(),i=o-n,i){for(i<0?(r=f,i=-i,s=g.length):(r=g,n=o,s=f.length),o=Math.ceil(a/O),s=o>s?o+1:s+1,i>s&&(i=s,r.length=1),r.reverse();i--;)r.push(0);r.reverse()}for(s=f.length,i=g.length,s-i<0&&(i=s,r=g,g=f,f=r),t=0;i;)t=(f[--i]=f[i]+g[i]+t)/ce|0,f[i]%=ce;for(t&&(f.unshift(t),++n),s=f.length;f[--s]==0;)f.pop();return e.d=f,e.e=xr(f,n),_?I(e,a,l):e};C.precision=C.sd=function(e){var t,r=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error(Ie+e);return r.d?(t=go(r.d),e&&r.e+1>t&&(t=r.e+1)):t=NaN,t};C.round=function(){var e=this,t=e.constructor;return I(new t(e),e.e+1,t.rounding)};C.sine=C.sin=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=Nl(n,Eo(n,r)),n.precision=e,n.rounding=t,I(Te>2?r.neg():r,e,t,!0)):new n(NaN)};C.squareRoot=C.sqrt=function(){var e,t,r,n,i,o,s=this,a=s.d,l=s.e,f=s.s,g=s.constructor;if(f!==1||!a||!a[0])return new g(!f||f<0&&(!a||a[0])?NaN:a?s:1/0);for(_=!1,f=Math.sqrt(+s),f==0||f==1/0?(t=z(a),(t.length+l)%2==0&&(t+="0"),f=Math.sqrt(t),l=X((l+1)/2)-(l<0||l%2),f==1/0?t="5e"+l:(t=f.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new g(t)):n=new g(f.toString()),r=(l=g.precision)+3;;)if(o=n,n=o.plus(q(s,o,r+2,1)).times(.5),z(o.d).slice(0,r)===(t=z(n.d)).slice(0,r))if(t=t.slice(r-3,r+1),t=="9999"||!i&&t=="4999"){if(!i&&(I(o,l+1,0),o.times(o).eq(s))){n=o;break}r+=4,i=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(I(n,l+1,1),e=!n.times(n).eq(s));break}return _=!0,I(n,l,g.rounding,e)};C.tangent=C.tan=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=q(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,I(Te==2||Te==4?r.neg():r,e,t,!0)):new n(NaN)};C.times=C.mul=function(e){var t,r,n,i,o,s,a,l,f,g=this,h=g.constructor,v=g.d,S=(e=new h(e)).d;if(e.s*=g.s,!v||!v[0]||!S||!S[0])return new h(!e.s||v&&!v[0]&&!S||S&&!S[0]&&!v?NaN:!v||!S?e.s/0:e.s*0);for(r=X(g.e/O)+X(e.e/O),l=v.length,f=S.length,l<f&&(o=v,v=S,S=o,s=l,l=f,f=s),o=[],s=l+f,n=s;n--;)o.push(0);for(n=f;--n>=0;){for(t=0,i=l+n;i>n;)a=o[i]+S[n]*v[i-n-1]+t,o[i--]=a%ce|0,t=a/ce|0;o[i]=(o[i]+t)%ce|0}for(;!o[--s];)o.pop();return t?++r:o.shift(),e.d=o,e.e=xr(o,r),_?I(e,h.precision,h.rounding):e};C.toBinary=function(e,t){return Rn(this,2,e,t)};C.toDecimalPlaces=C.toDP=function(e,t){var r=this,n=r.constructor;return r=new n(r),e===void 0?r:(ie(e,0,Oe),t===void 0?t=n.rounding:ie(t,0,8),I(r,e+r.e+1,t))};C.toExponential=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=ge(n,!0):(ie(e,0,Oe),t===void 0?t=i.rounding:ie(t,0,8),n=I(new i(n),e+1,t),r=ge(n,!0,e+1)),n.isNeg()&&!n.isZero()?"-"+r:r};C.toFixed=function(e,t){var r,n,i=this,o=i.constructor;return e===void 0?r=ge(i):(ie(e,0,Oe),t===void 0?t=o.rounding:ie(t,0,8),n=I(new o(i),e+i.e+1,t),r=ge(n,!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+r:r};C.toFraction=function(e){var t,r,n,i,o,s,a,l,f,g,h,v,S=this,A=S.d,R=S.constructor;if(!A)return new R(S);if(f=r=new R(1),n=l=new R(0),t=new R(n),o=t.e=go(A)-S.e-1,s=o%O,t.d[0]=J(10,s<0?O+s:s),e==null)e=o>0?t:f;else{if(a=new R(e),!a.isInt()||a.lt(f))throw Error(Ie+a);e=a.gt(t)?o>0?t:f:a}for(_=!1,a=new R(z(A)),g=R.precision,R.precision=o=A.length*O*2;h=q(a,t,0,1,1),i=r.plus(h.times(n)),i.cmp(e)!=1;)r=n,n=i,i=f,f=l.plus(h.times(i)),l=i,i=t,t=a.minus(h.times(i)),a=i;return i=q(e.minus(r),n,0,1,1),l=l.plus(i.times(f)),r=r.plus(i.times(n)),l.s=f.s=S.s,v=q(f,n,o,1).minus(S).abs().cmp(q(l,r,o,1).minus(S).abs())<1?[f,n]:[l,r],R.precision=g,_=!0,v};C.toHexadecimal=C.toHex=function(e,t){return Rn(this,16,e,t)};C.toNearest=function(e,t){var r=this,n=r.constructor;if(r=new n(r),e==null){if(!r.d)return r;e=new n(1),t=n.rounding}else{if(e=new n(e),t===void 0?t=n.rounding:ie(t,0,8),!r.d)return e.s?r:e;if(!e.d)return e.s&&(e.s=r.s),e}return e.d[0]?(_=!1,r=q(r,e,0,t,1).times(e),_=!0,I(r)):(e.s=r.s,r=e),r};C.toNumber=function(){return+this};C.toOctal=function(e,t){return Rn(this,8,e,t)};C.toPower=C.pow=function(e){var t,r,n,i,o,s,a=this,l=a.constructor,f=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(J(+a,f));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return I(a,n,o);if(t=X(e.e/O),t>=e.d.length-1&&(r=f<0?-f:f)<=Ol)return i=ho(l,a,r,n),e.s<0?new l(1).div(i):I(i,n,o);if(s=a.s,s<0){if(t<e.d.length-1)return new l(NaN);if((e.d[t]&1)==0&&(s=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=s,a}return r=J(+a,f),t=r==0||!isFinite(r)?X(f*(Math.log("0."+z(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t>l.maxE+1||t<l.minE-1?new l(t>0?s/0:0):(_=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=An(e.times(ke(a,n+r)),n),i.d&&(i=I(i,n+5,1),St(i.d,n,o)&&(t=n+10,i=I(An(e.times(ke(a,t+r)),t),t+5,1),+z(i.d).slice(n+1,n+15)+1==1e14&&(i=I(i,n+1,0)))),i.s=s,_=!0,l.rounding=o,I(i,n,o))};C.toPrecision=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=ge(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(ie(e,1,Oe),t===void 0?t=i.rounding:ie(t,0,8),n=I(new i(n),e,t),r=ge(n,e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+r:r};C.toSignificantDigits=C.toSD=function(e,t){var r=this,n=r.constructor;return e===void 0?(e=n.precision,t=n.rounding):(ie(e,1,Oe),t===void 0?t=n.rounding:ie(t,0,8)),I(new n(r),e,t)};C.toString=function(){var e=this,t=e.constructor,r=ge(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+r:r};C.truncated=C.trunc=function(){return I(new this.constructor(this),this.e+1,1)};C.valueOf=C.toJSON=function(){var e=this,t=e.constructor,r=ge(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+r:r};function z(e){var t,r,n,i=e.length-1,o="",s=e[0];if(i>0){for(o+=s,t=1;t<i;t++)n=e[t]+"",r=O-n.length,r&&(o+=Se(r)),o+=n;s=e[t],n=s+"",r=O-n.length,r&&(o+=Se(r))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function ie(e,t,r){if(e!==~~e||e<t||e>r)throw Error(Ie+e)}function St(e,t,r,n){var i,o,s,a;for(o=e[0];o>=10;o/=10)--t;return--t<0?(t+=O,i=0):(i=Math.ceil((t+1)/O),t%=O),o=J(10,O-t),a=e[i]%o|0,n==null?t<3?(t==0?a=a/100|0:t==1&&(a=a/10|0),s=r<4&&a==99999||r>3&&a==49999||a==5e4||a==0):s=(r<4&&a+1==o||r>3&&a+1==o/2)&&(e[i+1]/o/100|0)==J(10,t-2)-1||(a==o/2||a==0)&&(e[i+1]/o/100|0)==0:t<4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&&(a=a/10|0),s=(n||r<4)&&a==9999||!n&&r>3&&a==4999):s=((n||r<4)&&a+1==o||!n&&r>3&&a+1==o/2)&&(e[i+1]/o/1e3|0)==J(10,t-3)-1,s}function gr(e,t,r){for(var n,i=[0],o,s=0,a=e.length;s<a;){for(o=i.length;o--;)i[o]*=t;for(i[0]+=vn.indexOf(e.charAt(s++)),n=0;n<i.length;n++)i[n]>r-1&&(i[n+1]===void 0&&(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}return i.reverse()}function Ml(e,t){var r,n,i;if(t.isZero())return t;n=t.d.length,n<32?(r=Math.ceil(n/3),i=(1/Pr(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=et(e,1,t.times(i),new e(1));for(var o=r;o--;){var s=t.times(t);t=s.times(s).minus(s).times(8).plus(1)}return e.precision-=r,t}var q=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&&n.unshift(a),n}function t(n,i,o,s){var a,l;if(o!=s)l=o>s?1:-1;else for(a=l=0;a<o;a++)if(n[a]!=i[a]){l=n[a]>i[a]?1:-1;break}return l}function r(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]<i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s,a,l){var f,g,h,v,S,A,R,D,M,B,k,F,ae,G,nn,ir,xt,on,ue,or,sr=n.constructor,sn=n.s==i.s?1:-1,Y=n.d,$=i.d;if(!Y||!Y[0]||!$||!$[0])return new sr(!n.s||!i.s||(Y?$&&Y[0]==$[0]:!$)?NaN:Y&&Y[0]==0||!$?sn*0:sn/0);for(l?(S=1,g=n.e-i.e):(l=ce,S=O,g=X(n.e/S)-X(i.e/S)),ue=$.length,xt=Y.length,M=new sr(sn),B=M.d=[],h=0;$[h]==(Y[h]||0);h++);if($[h]>(Y[h]||0)&&g--,o==null?(G=o=sr.precision,s=sr.rounding):a?G=o+(n.e-i.e)+1:G=o,G<0)B.push(1),A=!0;else{if(G=G/S+2|0,h=0,ue==1){for(v=0,$=$[0],G++;(h<xt||v)&&G--;h++)nn=v*l+(Y[h]||0),B[h]=nn/$|0,v=nn%$|0;A=v||h<xt}else{for(v=l/($[0]+1)|0,v>1&&($=e($,v,l),Y=e(Y,v,l),ue=$.length,xt=Y.length),ir=ue,k=Y.slice(0,ue),F=k.length;F<ue;)k[F++]=0;or=$.slice(),or.unshift(0),on=$[0],$[1]>=l/2&&++on;do v=0,f=t($,k,ue,F),f<0?(ae=k[0],ue!=F&&(ae=ae*l+(k[1]||0)),v=ae/on|0,v>1?(v>=l&&(v=l-1),R=e($,v,l),D=R.length,F=k.length,f=t(R,k,D,F),f==1&&(v--,r(R,ue<D?or:$,D,l))):(v==0&&(f=v=1),R=$.slice()),D=R.length,D<F&&R.unshift(0),r(k,R,F,l),f==-1&&(F=k.length,f=t($,k,ue,F),f<1&&(v++,r(k,ue<F?or:$,F,l))),F=k.length):f===0&&(v++,k=[0]),B[h++]=v,f&&k[0]?k[F++]=Y[ir]||0:(k=[Y[ir]],F=1);while((ir++<xt||k[0]!==void 0)&&G--);A=k[0]!==void 0}B[0]||B.shift()}if(S==1)M.e=g,uo=A;else{for(h=1,v=B[0];v>=10;v/=10)h++;M.e=h+g*S-1,I(M,a?o+M.e+1:o,s,A)}return M}}();function I(e,t,r,n){var i,o,s,a,l,f,g,h,v,S=e.constructor;e:if(t!=null){if(h=e.d,!h)return e;for(i=1,a=h[0];a>=10;a/=10)i++;if(o=t-i,o<0)o+=O,s=t,g=h[v=0],l=g/J(10,i-s-1)%10|0;else if(v=Math.ceil((o+1)/O),a=h.length,v>=a)if(n){for(;a++<=v;)h.push(0);g=l=0,i=1,o%=O,s=o-O+1}else break e;else{for(g=a=h[v],i=1;a>=10;a/=10)i++;o%=O,s=o-O+i,l=s<0?0:g/J(10,i-s-1)%10|0}if(n=n||t<0||h[v+1]!==void 0||(s<0?g:g%J(10,i-s-1)),f=r<4?(l||n)&&(r==0||r==(e.s<0?3:2)):l>5||l==5&&(r==4||n||r==6&&(o>0?s>0?g/J(10,i-s):0:h[v-1])%10&1||r==(e.s<0?8:7)),t<1||!h[0])return h.length=0,f?(t-=e.e+1,h[0]=J(10,(O-t%O)%O),e.e=-t||0):h[0]=e.e=0,e;if(o==0?(h.length=v,a=1,v--):(h.length=v+1,a=J(10,O-o),h[v]=s>0?(g/J(10,i-s)%J(10,s)|0)*a:0),f)for(;;)if(v==0){for(o=1,s=h[0];s>=10;s/=10)o++;for(s=h[0]+=a,a=1;s>=10;s/=10)a++;o!=a&&(e.e++,h[0]==ce&&(h[0]=1));break}else{if(h[v]+=a,h[v]!=ce)break;h[v--]=0,a=1}for(o=h.length;h[--o]===0;)h.pop()}return _&&(e.e>S.maxE?(e.d=null,e.e=NaN):e.e<S.minE&&(e.e=0,e.d=[0])),e}function ge(e,t,r){if(!e.isFinite())return wo(e);var n,i=e.e,o=z(e.d),s=o.length;return t?(r&&(n=r-s)>0?o=o.charAt(0)+"."+o.slice(1)+Se(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):i<0?(o="0."+Se(-i-1)+o,r&&(n=r-s)>0&&(o+=Se(n))):i>=s?(o+=Se(i+1-s),r&&(n=r-i-1)>0&&(o=o+"."+Se(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),r&&(n=r-s)>0&&(i+1===s&&(o+="."),o+=Se(n))),o}function xr(e,t){var r=e[0];for(t*=O;r>=10;r/=10)t++;return t}function Er(e,t,r){if(t>Dl)throw _=!0,r&&(e.precision=r),Error(co);return I(new e(yr),t,1,!0)}function fe(e,t,r){if(t>Cn)throw Error(co);return I(new e(wr),t,r,!0)}function go(e){var t=e.length-1,r=t*O+1;if(t=e[t],t){for(;t%10==0;t/=10)r--;for(t=e[0];t>=10;t/=10)r++}return r}function Se(e){for(var t="";e--;)t+="0";return t}function ho(e,t,r,n){var i,o=new e(1),s=Math.ceil(n/O+4);for(_=!1;;){if(r%2&&(o=o.times(t),ao(o.d,s)&&(i=!0)),r=X(r/2),r===0){r=o.d.length-1,i&&o.d[r]===0&&++o.d[r];break}t=t.times(t),ao(t.d,s)}return _=!0,o}function so(e){return e.d[e.d.length-1]&1}function yo(e,t,r){for(var n,i,o=new e(t[0]),s=0;++s<t.length;){if(i=new e(t[s]),!i.s){o=i;break}n=o.cmp(i),(n===r||n===0&&o.s===r)&&(o=i)}return o}function An(e,t){var r,n,i,o,s,a,l,f=0,g=0,h=0,v=e.constructor,S=v.rounding,A=v.precision;if(!e.d||!e.d[0]||e.e>17)return new v(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(t==null?(_=!1,l=A):l=t,a=new v(.03125);e.e>-2;)e=e.times(a),h+=5;for(n=Math.log(J(2,h))/Math.LN10*2+5|0,l+=n,r=o=s=new v(1),v.precision=l;;){if(o=I(o.times(e),l,1),r=r.times(++g),a=s.plus(q(o,r,l,1)),z(a.d).slice(0,l)===z(s.d).slice(0,l)){for(i=h;i--;)s=I(s.times(s),l,1);if(t==null)if(f<3&&St(s.d,l-n,S,f))v.precision=l+=10,r=o=a=new v(1),g=0,f++;else return I(s,v.precision=A,S,_=!0);else return v.precision=A,s}s=a}}function ke(e,t){var r,n,i,o,s,a,l,f,g,h,v,S=1,A=10,R=e,D=R.d,M=R.constructor,B=M.rounding,k=M.precision;if(R.s<0||!D||!D[0]||!R.e&&D[0]==1&&D.length==1)return new M(D&&!D[0]?-1/0:R.s!=1?NaN:D?0:R);if(t==null?(_=!1,g=k):g=t,M.precision=g+=A,r=z(D),n=r.charAt(0),Math.abs(o=R.e)<15e14){for(;n<7&&n!=1||n==1&&r.charAt(1)>3;)R=R.times(e),r=z(R.d),n=r.charAt(0),S++;o=R.e,n>1?(R=new M("0."+r),o++):R=new M(n+"."+r.slice(1))}else return f=Er(M,g+2,k).times(o+""),R=ke(new M(n+"."+r.slice(1)),g-A).plus(f),M.precision=k,t==null?I(R,k,B,_=!0):R;for(h=R,l=s=R=q(R.minus(1),R.plus(1),g,1),v=I(R.times(R),g,1),i=3;;){if(s=I(s.times(v),g,1),f=l.plus(q(s,new M(i),g,1)),z(f.d).slice(0,g)===z(l.d).slice(0,g))if(l=l.times(2),o!==0&&(l=l.plus(Er(M,g+2,k).times(o+""))),l=q(l,new M(S),g,1),t==null)if(St(l.d,g-A,B,a))M.precision=g+=A,f=s=R=q(h.minus(1),h.plus(1),g,1),v=I(R.times(R),g,1),i=a=1;else return I(l,M.precision=k,B,_=!0);else return M.precision=k,l;l=f,i+=2}}function wo(e){return String(e.s*e.s/0)}function hr(e,t){var r,n,i;for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(n=t.search(/e/i))>0?(r<0&&(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r<0&&(r=t.length),n=0;t.charCodeAt(n)===48;n++);for(i=t.length;t.charCodeAt(i-1)===48;--i);if(t=t.slice(n,i),t){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%O,r<0&&(n+=O),n<i){for(n&&e.d.push(+t.slice(0,n)),i-=O;n<i;)e.d.push(+t.slice(n,n+=O));t=t.slice(n),n=O-t.length}else n-=i;for(;n--;)t+="0";e.d.push(+t),_&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function _l(e,t){var r,n,i,o,s,a,l,f,g;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),fo.test(t))return hr(e,t)}else if(t==="Infinity"||t==="NaN")return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(kl.test(t))r=16,t=t.toLowerCase();else if(Sl.test(t))r=2;else if(Il.test(t))r=8;else throw Error(Ie+t);for(o=t.search(/p/i),o>0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o>=0,n=e.constructor,s&&(t=t.replace(".",""),a=t.length,o=a-o,i=ho(n,new n(r),o,o*2)),f=gr(t,r,ce),g=f.length-1,o=g;f[o]===0;--o)f.pop();return o<0?new n(e.s*0):(e.e=xr(f,g),e.d=f,_=!1,s&&(e=q(e,i,a*4)),l&&(e=e.times(Math.abs(l)<54?J(2,l):Be.pow(2,l))),_=!0,e)}function Nl(e,t){var r,n=t.d.length;if(n<3)return t.isZero()?t:et(e,2,t,t);r=1.4*Math.sqrt(n),r=r>16?16:r|0,t=t.times(1/Pr(5,r)),t=et(e,2,t,t);for(var i,o=new e(5),s=new e(16),a=new e(20);r--;)i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));return t}function et(e,t,r,n,i){var o,s,a,l,f=1,g=e.precision,h=Math.ceil(g/O);for(_=!1,l=r.times(r),a=new e(n);;){if(s=q(a.times(l),new e(t++*t++),g,1),a=i?n.plus(s):n.minus(s),n=q(s.times(l),new e(t++*t++),g,1),s=a.plus(n),s.d[h]!==void 0){for(o=h;s.d[o]===a.d[o]&&o--;);if(o==-1)break}o=a,a=n,n=s,s=o,f++}return _=!0,s.d.length=h+1,s}function Pr(e,t){for(var r=e;--t;)r*=e;return r}function Eo(e,t){var r,n=t.s<0,i=fe(e,e.precision,1),o=i.times(.5);if(t=t.abs(),t.lte(o))return Te=n?4:1,t;if(r=t.divToInt(i),r.isZero())Te=n?3:2;else{if(t=t.minus(r.times(i)),t.lte(o))return Te=so(r)?n?2:3:n?4:1,t;Te=so(r)?n?1:4:n?3:2}return t.minus(i).abs()}function Rn(e,t,r,n){var i,o,s,a,l,f,g,h,v,S=e.constructor,A=r!==void 0;if(A?(ie(r,1,Oe),n===void 0?n=S.rounding:ie(n,0,8)):(r=S.precision,n=S.rounding),!e.isFinite())g=wo(e);else{for(g=ge(e),s=g.indexOf("."),A?(i=2,t==16?r=r*4-3:t==8&&(r=r*3-2)):i=t,s>=0&&(g=g.replace(".",""),v=new S(1),v.e=g.length-s,v.d=gr(ge(v),10,i),v.e=v.d.length),h=gr(g,10,i),o=l=h.length;h[--l]==0;)h.pop();if(!h[0])g=A?"0p+0":"0";else{if(s<0?o--:(e=new S(e),e.d=h,e.e=o,e=q(e,v,r,n,0,i),h=e.d,o=e.e,f=uo),s=h[r],a=i/2,f=f||h[r+1]!==void 0,f=n<4?(s!==void 0||f)&&(n===0||n===(e.s<0?3:2)):s>a||s===a&&(n===4||f||n===6&&h[r-1]&1||n===(e.s<0?8:7)),h.length=r,f)for(;++h[--r]>i-1;)h[r]=0,r||(++o,h.unshift(1));for(l=h.length;!h[l-1];--l);for(s=0,g="";s<l;s++)g+=vn.charAt(h[s]);if(A){if(l>1)if(t==16||t==8){for(s=t==16?4:3,--l;l%s;l++)g+="0";for(h=gr(g,i,t),l=h.length;!h[l-1];--l);for(s=1,g="1.";s<l;s++)g+=vn.charAt(h[s])}else g=g.charAt(0)+"."+g.slice(1);g=g+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)g="0"+g;g="0."+g}else if(++o>l)for(o-=l;o--;)g+="0";else o<l&&(g=g.slice(0,o)+"."+g.slice(o))}g=(t==16?"0x":t==2?"0b":t==8?"0o":"")+g}return e.s<0?"-"+g:g}function ao(e,t){if(e.length>t)return e.length=t,!0}function Fl(e){return new this(e).abs()}function Ll(e){return new this(e).acos()}function Bl(e){return new this(e).acosh()}function Ul(e,t){return new this(e).plus(t)}function ql(e){return new this(e).asin()}function $l(e){return new this(e).asinh()}function jl(e){return new this(e).atan()}function Vl(e){return new this(e).atanh()}function Gl(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,o=n+4;return!e.s||!t.s?r=new this(NaN):!e.d&&!t.d?(r=fe(this,o,1).times(t.s>0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s<0?fe(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=fe(this,o,1).times(.5),r.s=e.s):t.s<0?(this.precision=o,this.rounding=1,r=this.atan(q(e,t,o,1)),t=fe(this,o,1),this.precision=n,this.rounding=i,r=e.s<0?r.minus(t):r.plus(t)):r=this.atan(q(e,t,o,1)),r}function Ql(e){return new this(e).cbrt()}function Jl(e){return I(e=new this(e),e.e+1,2)}function Wl(e,t,r){return new this(e).clamp(t,r)}function Hl(e){if(!e||typeof e!="object")throw Error(br+"Object expected");var t,r,n,i=e.defaults===!0,o=["precision",1,Oe,"rounding",0,8,"toExpNeg",-Xe,0,"toExpPos",0,Xe,"maxE",0,Xe,"minE",-Xe,0,"modulo",0,9];for(t=0;t<o.length;t+=3)if(r=o[t],i&&(this[r]=Tn[r]),(n=e[r])!==void 0)if(X(n)===n&&n>=o[t+1]&&n<=o[t+2])this[r]=n;else throw Error(Ie+r+": "+n);if(r="crypto",i&&(this[r]=Tn[r]),(n=e[r])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[r]=!0;else throw Error(po);else this[r]=!1;else throw Error(Ie+r+": "+n);return this}function Kl(e){return new this(e).cos()}function zl(e){return new this(e).cosh()}function bo(e){var t,r,n;function i(o){var s,a,l,f=this;if(!(f instanceof i))return new i(o);if(f.constructor=i,lo(o)){f.s=o.s,_?!o.d||o.e>i.maxE?(f.e=NaN,f.d=null):o.e<i.minE?(f.e=0,f.d=[0]):(f.e=o.e,f.d=o.d.slice()):(f.e=o.e,f.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){f.s=1/o<0?-1:1,f.e=0,f.d=[0];return}if(o<0?(o=-o,f.s=-1):f.s=1,o===~~o&&o<1e7){for(s=0,a=o;a>=10;a/=10)s++;_?s>i.maxE?(f.e=NaN,f.d=null):s<i.minE?(f.e=0,f.d=[0]):(f.e=s,f.d=[o]):(f.e=s,f.d=[o]);return}if(o*0!==0){o||(f.s=NaN),f.e=NaN,f.d=null;return}return hr(f,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),f.s=-1):(a===43&&(o=o.slice(1)),f.s=1),fo.test(o)?hr(f,o):_l(f,o);if(l==="bigint")return o<0?(o=-o,f.s=-1):f.s=1,hr(f,o.toString());throw Error(Ie+o)}if(i.prototype=C,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Hl,i.clone=bo,i.isDecimal=lo,i.abs=Fl,i.acos=Ll,i.acosh=Bl,i.add=Ul,i.asin=ql,i.asinh=$l,i.atan=jl,i.atanh=Vl,i.atan2=Gl,i.cbrt=Ql,i.ceil=Jl,i.clamp=Wl,i.cos=Kl,i.cosh=zl,i.div=Yl,i.exp=Zl,i.floor=Xl,i.hypot=eu,i.ln=tu,i.log=ru,i.log10=iu,i.log2=nu,i.max=ou,i.min=su,i.mod=au,i.mul=lu,i.pow=uu,i.random=cu,i.round=pu,i.sign=mu,i.sin=du,i.sinh=fu,i.sqrt=gu,i.sub=hu,i.sum=yu,i.tan=wu,i.tanh=Eu,i.trunc=bu,e===void 0&&(e={}),e&&e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t<n.length;)e.hasOwnProperty(r=n[t++])||(e[r]=this[r]);return i.config(e),i}function Yl(e,t){return new this(e).div(t)}function Zl(e){return new this(e).exp()}function Xl(e){return I(e=new this(e),e.e+1,3)}function eu(){var e,t,r=new this(0);for(_=!1,e=0;e<arguments.length;)if(t=new this(arguments[e++]),t.d)r.d&&(r=r.plus(t.times(t)));else{if(t.s)return _=!0,new this(1/0);r=t}return _=!0,r.sqrt()}function lo(e){return e instanceof Be||e&&e.toStringTag===mo||!1}function tu(e){return new this(e).ln()}function ru(e,t){return new this(e).log(t)}function nu(e){return new this(e).log(2)}function iu(e){return new this(e).log(10)}function ou(){return yo(this,arguments,-1)}function su(){return yo(this,arguments,1)}function au(e,t){return new this(e).mod(t)}function lu(e,t){return new this(e).mul(t)}function uu(e,t){return new this(e).pow(t)}function cu(e){var t,r,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:ie(e,1,Oe),n=Math.ceil(e/O),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));o<n;)i=t[o],i>=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(t=crypto.randomBytes(n*=4);o<n;)i=t[o]+(t[o+1]<<8)+(t[o+2]<<16)+((t[o+3]&127)<<24),i>=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(po);else for(;o<n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=O,n&&e&&(i=J(10,O-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o<0)r=0,a=[0];else{for(r=-1;a[0]===0;r-=O)a.shift();for(n=1,i=a[0];i>=10;i/=10)n++;n<O&&(r-=O-n)}return s.e=r,s.d=a,s}function pu(e){return I(e=new this(e),e.e+1,this.rounding)}function mu(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function du(e){return new this(e).sin()}function fu(e){return new this(e).sinh()}function gu(e){return new this(e).sqrt()}function hu(e,t){return new this(e).sub(t)}function yu(){var e=0,t=arguments,r=new this(t[e]);for(_=!1;r.s&&++e<t.length;)r=r.plus(t[e]);return _=!0,I(r,this.precision,this.rounding)}function wu(e){return new this(e).tan()}function Eu(e){return new this(e).tanh()}function bu(e){return I(e=new this(e),e.e+1,1)}C[Symbol.for("nodejs.util.inspect.custom")]=C.toString;C[Symbol.toStringTag]="Decimal";var Be=C.constructor=bo(Tn);yr=new Be(yr);wr=new Be(wr);var he=Be;function tt(e){return e===null?e:Array.isArray(e)?e.map(tt):typeof e=="object"?xu(e)?Pu(e):Ze(e,tt):e}function xu(e){return e!==null&&typeof e=="object"&&typeof e.$type=="string"}function Pu({$type:e,value:t}){switch(e){case"BigInt":return BigInt(t);case"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"DateTime":return new Date(t);case"Decimal":return new he(t);case"Json":return JSON.parse(t);default:Pe(t,"Unknown tagged value")}}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var ye=class{_map=new Map;get(t){return this._map.get(t)?.value}set(t,r){this._map.set(t,{value:r})}getOrCreate(t,r){let n=this._map.get(t);if(n)return n.value;let i=r();return this.set(t,i),i}};d();u();c();p();m();function De(e){return e.substring(0,1).toLowerCase()+e.substring(1)}d();u();c();p();m();function xo(e,t){let r={};for(let n of e){let i=n[t];r[i]=n}return r}d();u();c();p();m();function kt(e){let t;return{get(){return t||(t={value:e()}),t.value}}}d();u();c();p();m();function Po(e){return{models:Sn(e.models),enums:Sn(e.enums),types:Sn(e.types)}}function Sn(e){let t={};for(let{name:r,...n}of e)t[r]=n;return t}d();u();c();p();m();function rt(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function vr(e){return e.toString()!=="Invalid Date"}d();u();c();p();m();function nt(e){return Be.isDecimal(e)?!0:e!==null&&typeof e=="object"&&typeof e.s=="number"&&typeof e.e=="number"&&typeof e.toFixed=="function"&&Array.isArray(e.d)}d();u();c();p();m();d();u();c();p();m();var Ot={};Pt(Ot,{ModelAction:()=>It,datamodelEnumToSchemaEnum:()=>vu});d();u();c();p();m();d();u();c();p();m();function vu(e){return{name:e.name,values:e.values.map(t=>t.name)}}d();u();c();p();m();var It=(k=>(k.findUnique="findUnique",k.findUniqueOrThrow="findUniqueOrThrow",k.findFirst="findFirst",k.findFirstOrThrow="findFirstOrThrow",k.findMany="findMany",k.create="create",k.createMany="createMany",k.createManyAndReturn="createManyAndReturn",k.update="update",k.updateMany="updateMany",k.updateManyAndReturn="updateManyAndReturn",k.upsert="upsert",k.delete="delete",k.deleteMany="deleteMany",k.groupBy="groupBy",k.count="count",k.aggregate="aggregate",k.findRaw="findRaw",k.aggregateRaw="aggregateRaw",k))(It||{});var Tu=Qe(Zi());var Cu={red:ze,gray:Li,dim:pr,bold:cr,underline:Di,highlightSource:e=>e.highlight()},Au={red:e=>e,gray:e=>e,dim:e=>e,bold:e=>e,underline:e=>e,highlightSource:e=>e};function Ru({message:e,originalMethod:t,isPanic:r,callArguments:n}){return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}function Su({functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=t?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&&a.push(s.underline(ku(t))),i){a.push("");let f=[i.toString()];o&&(f.push(o),f.push(s.dim(")"))),a.push(f.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(r),a.join(`
`)}function ku(e){let t=[e.fileName];return e.lineNumber&&t.push(String(e.lineNumber)),e.columnNumber&&t.push(String(e.columnNumber)),t.join(":")}function Tr(e){let t=e.showColors?Cu:Au,r;return typeof $getTemplateParameters<"u"?r=$getTemplateParameters(e,t):r=Ru(e),Su(r,t)}d();u();c();p();m();var Oo=Qe(kn());d();u();c();p();m();function Ao(e,t,r){let n=Ro(e),i=Iu(n),o=Du(i);o?Cr(o,t,r):t.addErrorMessage(()=>"Unknown error")}function Ro(e){return e.errors.flatMap(t=>t.kind==="Union"?Ro(t):[t])}function Iu(e){let t=new Map,r=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){r.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=t.get(i);o?t.set(i,{...n,argument:{...n.argument,typeNames:Ou(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}return r.push(...t.values()),r}function Ou(e,t){return[...new Set(e.concat(t))]}function Du(e){return Pn(e,(t,r)=>{let n=To(t),i=To(r);return n!==i?n-i:Co(t)-Co(r)})}function To(e){let t=0;return Array.isArray(e.selectionPath)&&(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&&(t+=e.argumentPath.length),t}function Co(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}d();u();c();p();m();var le=class{constructor(t,r){this.name=t;this.value=r}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(t){let{colors:{green:r}}=t.context;t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}};d();u();c();p();m();d();u();c();p();m();ko();d();u();c();p();m();var it=class{constructor(t=0,r){this.context=r;this.currentIndent=t}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(t){return typeof t=="string"?this.currentLine+=t:t.write(this),this}writeJoined(t,r,n=(i,o)=>o.write(i)){let i=r.length-1;for(let o=0;o<r.length;o++)n(r[o],this),o!==i&&this.write(t);return this}writeLine(t){return this.write(t).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let t=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,t?.(),this}withIndent(t){return this.indent(),t(this),this.unindent(),this}afterNextNewline(t){return this.afterNextNewLineCallback=t,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(t){return this.marginSymbol=t,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let t=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+t.slice(1):t}};So();d();u();c();p();m();d();u();c();p();m();var Ar=class{constructor(t){this.value=t}write(t){t.write(this.value)}markAsError(){this.value.markAsError()}};d();u();c();p();m();var Rr=e=>e,Sr={bold:Rr,red:Rr,green:Rr,dim:Rr,enabled:!1},Io={bold:cr,red:ze,green:Mi,dim:pr,enabled:!0},ot={write(e){e.writeLine(",")}};d();u();c();p();m();var we=class{constructor(t){this.contents=t}isUnderlined=!1;color=t=>t;underline(){return this.isUnderlined=!0,this}setColor(t){return this.color=t,this}write(t){let r=t.getCurrentLineLength();t.write(this.color(this.contents)),this.isUnderlined&&t.afterNextNewline(()=>{t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))})}};d();u();c();p();m();var Me=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var st=class extends Me{items=[];addItem(t){return this.items.push(new Ar(t)),this}getField(t){return this.items[t]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(r=>r.value.getPrintWidth()))+2}write(t){if(this.items.length===0){this.writeEmpty(t);return}this.writeWithItems(t)}writeEmpty(t){let r=new we("[]");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithItems(t){let{colors:r}=t.context;t.writeLine("[").withIndent(()=>t.writeJoined(ot,this.items).newLine()).write("]"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(r.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var at=class e extends Me{fields={};suggestions=[];addField(t){this.fields[t.name]=t}addSuggestion(t){this.suggestions.push(t)}getField(t){return this.fields[t]}getDeepField(t){let[r,...n]=t,i=this.getField(r);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof st&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(t){return t.length===0?this:this.getDeepField(t)?.value}hasField(t){return!!this.getField(t)}removeAllFields(){this.fields={}}removeField(t){delete this.fields[t]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(t){return this.getField(t)?.value}getDeepSubSelectionValue(t){let r=this;for(let n of t){if(!(r instanceof e))return;let i=r.getSubSelectionValue(n);if(!i)return;r=i}return r}getDeepSelectionParent(t){let r=this.getSelectionParent();if(!r)return;let n=r;for(let i of t){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let t=this.getField("select")?.value.asObject();if(t)return{kind:"select",value:t};let r=this.getField("include")?.value.asObject();if(r)return{kind:"include",value:r}}getSubSelectionValue(t){return this.getSelectionParent()?.value.fields[t].value}getPrintWidth(){let t=Object.values(this.fields);return t.length==0?2:Math.max(...t.map(n=>n.getPrintWidth()))+2}write(t){let r=Object.values(this.fields);if(r.length===0&&this.suggestions.length===0){this.writeEmpty(t);return}this.writeWithContents(t,r)}asObject(){return this}writeEmpty(t){let r=new we("{}");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithContents(t,r){t.writeLine("{").withIndent(()=>{t.writeJoined(ot,[...r,...this.suggestions]).newLine()}),t.write("}"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())))})}};d();u();c();p();m();var H=class extends Me{constructor(r){super();this.text=r}getPrintWidth(){return this.text.length}write(r){let n=new we(this.text);this.hasError&&n.underline().setColor(r.context.colors.red),r.write(n)}asObject(){}};d();u();c();p();m();var Dt=class{fields=[];addField(t,r){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}}),this}write(t){let{colors:{green:r}}=t.context;t.writeLine(r("{")).withIndent(()=>{t.writeJoined(ot,this.fields).newLine()}).write(r("}")).addMarginSymbol(r("+"))}};function Cr(e,t,r){switch(e.kind){case"MutuallyExclusiveFields":Mu(e,t);break;case"IncludeOnScalar":_u(e,t);break;case"EmptySelection":Nu(e,t,r);break;case"UnknownSelectionField":Uu(e,t);break;case"InvalidSelectionValue":qu(e,t);break;case"UnknownArgument":$u(e,t);break;case"UnknownInputField":ju(e,t);break;case"RequiredArgumentMissing":Vu(e,t);break;case"InvalidArgumentType":Gu(e,t);break;case"InvalidArgumentValue":Qu(e,t);break;case"ValueTooLarge":Ju(e,t);break;case"SomeFieldsMissing":Wu(e,t);break;case"TooManyFieldsGiven":Hu(e,t);break;case"Union":Ao(e,t,r);break;default:throw new Error("not implemented: "+e.kind)}}function Mu(e,t){let r=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();r&&(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function _u(e,t){let[r,n]=Mt(e.selectionPath),i=e.outputType,o=t.arguments.getDeepSelectionParent(r)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new le(s.name,"true"));t.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${_t(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function Nu(e,t,r){let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){Fu(e,t,i);return}if(n.hasField("select")){Lu(e,t);return}}if(r?.[De(e.outputType.name)]){Bu(e,t);return}t.addErrorMessage(()=>`Unknown field at "${e.selectionPath.join(".")} selection"`)}function Fu(e,t,r){r.removeAllFields();for(let n of e.outputType.fields)r.addSuggestion(new le(n.name,"false"));t.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}function Lu(e,t){let r=e.outputType,n=t.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),_o(n,r)),t.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${_t(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)}function Bu(e,t){let r=new Dt;for(let i of e.outputType.fields)i.isRelation||r.addField(i.name,"false");let n=new le("omit",r).makeRequired();if(e.selectionPath.length===0)t.arguments.addSuggestion(n);else{let[i,o]=Mt(e.selectionPath),a=t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new at;l.addSuggestion(n),a.value=l}}t.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function Uu(e,t){let r=No(e.selectionPath,t);if(r.parentKind!=="unknown"){r.field.markAsError();let n=r.parent;switch(r.parentKind){case"select":_o(n,e.outputType);break;case"include":Ku(n,e.outputType);break;case"omit":zu(n,e.outputType);break}}t.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];return r.parentKind!=="unknown"&&i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(_t(n)),i.join(" ")})}function qu(e,t){let r=No(e.selectionPath,t);r.parentKind!=="unknown"&&r.field.value.markAsError(),t.addErrorMessage(n=>`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)}function $u(e,t){let r=e.argumentPath[0],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&(n.getField(r)?.markAsError(),Yu(n,e.arguments)),t.addErrorMessage(i=>Do(i,r,e.arguments.map(o=>o.name)))}function ju(e,t){let[r,n]=Mt(e.argumentPath),i=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(r)?.asObject();o&&Fo(o,e.inputType)}t.addErrorMessage(o=>Do(o,n,e.inputType.fields.map(s=>s.name)))}function Do(e,t,r){let n=[`Unknown argument \`${e.red(t)}\`.`],i=Xu(t,r);return i&&n.push(`Did you mean \`${e.green(i)}\`?`),r.length>0&&n.push(_t(e)),n.join(" ")}function Vu(e,t){let r;t.addErrorMessage(l=>r?.value instanceof H&&r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=Mt(e.argumentPath),s=new Dt,a=n.getDeepFieldValue(i)?.asObject();if(a)if(r=a.getField(o),r&&a.removeField(o),e.inputTypes.length===1&&e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new le(o,s).makeRequired())}else{let l=e.inputTypes.map(Mo).join(" | ");a.addSuggestion(new le(o,l).makeRequired())}}function Mo(e){return e.kind==="list"?`${Mo(e.elementType)}[]`:e.name}function Gu(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=kr("or",e.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}function Qu(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(r)}\``];if(e.underlyingError&&o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length>0){let s=kr("or",e.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function Ju(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof H&&(i=s.text)}t.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")})}function Wu(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&&Fo(i,e.inputType)}t.addErrorMessage(i=>{let o=[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${kr("or",e.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(_t(i)),o.join(" ")})}function Hu(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}t.addErrorMessage(o=>{let s=[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&&e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${kr("and",i.map(a=>o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}function _o(e,t){for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new le(r.name,"true"))}function Ku(e,t){for(let r of t.fields)r.isRelation&&!e.hasField(r.name)&&e.addSuggestion(new le(r.name,"true"))}function zu(e,t){for(let r of t.fields)!e.hasField(r.name)&&!r.isRelation&&e.addSuggestion(new le(r.name,"true"))}function Yu(e,t){for(let r of t)e.hasField(r.name)||e.addSuggestion(new le(r.name,r.typeNames.join(" | ")))}function No(e,t){let[r,n]=Mt(e),i=t.arguments.getDeepSubSelectionValue(r)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&&l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&&l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&&l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function Fo(e,t){if(t.kind==="object")for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new le(r.name,r.typeNames.join(" | ")))}function Mt(e){let t=[...e],r=t.pop();if(!r)throw new Error("unexpected empty path");return[t,r]}function _t({green:e,enabled:t}){return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}function kr(e,t){if(t.length===1)return t[0];let r=[...t],n=r.pop();return`${r.join(", ")} ${e} ${n}`}var Zu=3;function Xu(e,t){let r=1/0,n;for(let i of t){let o=(0,Oo.default)(e,i);o>Zu||o<r&&(r=o,n=i)}return n}d();u();c();p();m();d();u();c();p();m();var Nt=class{modelName;name;typeName;isList;isEnum;constructor(t,r,n,i,o){this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let t=this.isList?"List":"",r=this.isEnum?"Enum":"";return`${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`}};function lt(e){return e instanceof Nt}d();u();c();p();m();var Ir=Symbol(),On=new WeakMap,Ce=class{constructor(t){t===Ir?On.set(this,`Prisma.${this._getName()}`):On.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return On.get(this)}},Ft=class extends Ce{_getNamespace(){return"NullTypes"}},Lt=class extends Ft{_brand_DbNull};Dn(Lt,"DbNull");var Bt=class extends Ft{_brand_JsonNull};Dn(Bt,"JsonNull");var Ut=class extends Ft{_brand_AnyNull};Dn(Ut,"AnyNull");var Or={classes:{DbNull:Lt,JsonNull:Bt,AnyNull:Ut},instances:{DbNull:new Lt(Ir),JsonNull:new Bt(Ir),AnyNull:new Ut(Ir)}};function Dn(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}d();u();c();p();m();var Lo=": ",Dr=class{constructor(t,r){this.name=t;this.value=r}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+Lo.length}write(t){let r=new we(this.name);this.hasError&&r.underline().setColor(t.context.colors.red),t.write(r).write(Lo).write(this.value)}};var Mn=class{arguments;errorMessages=[];constructor(t){this.arguments=t}write(t){t.write(this.arguments)}addErrorMessage(t){this.errorMessages.push(t)}renderAllMessages(t){return this.errorMessages.map(r=>r(t)).join(`
`)}};function ut(e){return new Mn(Bo(e))}function Bo(e){let t=new at;for(let[r,n]of Object.entries(e)){let i=new Dr(r,Uo(n));t.addField(i)}return t}function Uo(e){if(typeof e=="string")return new H(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new H(String(e));if(typeof e=="bigint")return new H(`${e}n`);if(e===null)return new H("null");if(e===void 0)return new H("undefined");if(nt(e))return new H(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return w.Buffer.isBuffer(e)?new H(`Buffer.alloc(${e.byteLength})`):new H(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let t=vr(e)?e.toISOString():"Invalid Date";return new H(`new Date("${t}")`)}return e instanceof Ce?new H(`Prisma.${e._getName()}`):lt(e)?new H(`prisma.${De(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?ec(e):typeof e=="object"?Bo(e):new H(Object.prototype.toString.call(e))}function ec(e){let t=new st;for(let r of e)t.addItem(Uo(r));return t}function Mr(e,t){let r=t==="pretty"?Io:Sr,n=e.renderAllMessages(r),i=new it(0,{colors:r}).write(e).toString();return{message:n,args:i}}function _r({args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=ut(e);for(let h of t)Cr(h,a,s);let{message:l,args:f}=Mr(a,r),g=Tr({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:f});throw new Z(g,{clientVersion:o})}d();u();c();p();m();d();u();c();p();m();function Ee(e){return e.replace(/^./,t=>t.toLowerCase())}d();u();c();p();m();function $o(e,t,r){let n=Ee(r);return!t.result||!(t.result.$allModels||t.result[n])?e:tc({...e,...qo(t.name,e,t.result.$allModels),...qo(t.name,e,t.result[n])})}function tc(e){let t=new ye,r=(n,i)=>t.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=>r(o,i)):[n]));return Ze(e,n=>({...n,needs:r(n.name,new Set)}))}function qo(e,t,r){return r?Ze(r,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:rc(t,o,i)})):{}}function rc(e,t,r){let n=e?.[t]?.compute;return n?i=>r({...i,[t]:n(i)}):r}function jo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(e[n.name])for(let i of n.needs)r[i]=!0;return r}function Vo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(!e[n.name])for(let i of n.needs)delete r[i];return r}var Nr=class{constructor(t,r){this.extension=t;this.previous=r}computedFieldsCache=new ye;modelExtensionsCache=new ye;queryCallbacksCache=new ye;clientExtensions=kt(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=kt(()=>{let t=this.previous?.getAllBatchQueryCallbacks()??[],r=this.extension.query?.$__internalBatch;return r?t.concat(r):t});getAllComputedFields(t){return this.computedFieldsCache.getOrCreate(t,()=>$o(this.previous?.getAllComputedFields(t),this.extension,t))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(t){return this.modelExtensionsCache.getOrCreate(t,()=>{let r=Ee(t);return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}})}getAllQueryCallbacks(t,r){return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,()=>{let n=this.previous?.getAllQueryCallbacks(t,r)??[],i=[],o=this.extension.query;return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&&(o[t][r]!==void 0&&i.push(o[t][r]),o[t].$allOperations!==void 0&&i.push(o[t].$allOperations)),t!=="$none"&&o.$allModels!==void 0&&(o.$allModels[r]!==void 0&&i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[r]!==void 0&&i.push(o[r]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},ct=class e{constructor(t){this.head=t}static empty(){return new e}static single(t){return new e(new Nr(t))}isEmpty(){return this.head===void 0}append(t){return new e(new Nr(t,this.head))}getAllComputedFields(t){return this.head?.getAllComputedFields(t)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(t){return this.head?.getAllModelExtensions(t)}getAllQueryCallbacks(t,r){return this.head?.getAllQueryCallbacks(t,r)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};d();u();c();p();m();var Fr=class{constructor(t){this.name=t}};function Go(e){return e instanceof Fr}function Qo(e){return new Fr(e)}d();u();c();p();m();d();u();c();p();m();var Jo=Symbol(),qt=class{constructor(t){if(t!==Jo)throw new Error("Skip instance can not be constructed directly")}ifUndefined(t){return t===void 0?Lr:t}},Lr=new qt(Jo);function be(e){return e instanceof qt}var nc={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},Wo="explicitly `undefined` values are not allowed";function Br({modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=ct.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:f,globalOmit:g}){let h=new _n({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:f,globalOmit:g});return{modelName:e,action:nc[t],query:$t(r,h)}}function $t({select:e,include:t,...r}={},n){let i=r.omit;return delete r.omit,{arguments:Ko(r,n),selection:ic(e,t,i,n)}}function ic(e,t,r,n){return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),lc(e,n)):oc(n,t,r)}function oc(e,t,r){let n={};return e.modelOrType&&!e.isRawAction()&&(n.$composites=!0,n.$scalars=!0),t&&sc(n,t,e),ac(n,r,e),n}function sc(e,t,r){for(let[n,i]of Object.entries(t)){if(be(i))continue;let o=r.nestSelection(n);if(Nn(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=r.findField(n);if(s&&s.kind!=="object"&&r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){e[n]=$t(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=$t(i,o)}}function ac(e,t,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...t},o=Vo(i,n);for(let[s,a]of Object.entries(o)){if(be(a))continue;Nn(a,r.nestSelection(s));let l=r.findField(s);n?.[s]&&!l||(e[s]=!a)}}function lc(e,t){let r={},n=t.getComputedFields(),i=jo(e,n);for(let[o,s]of Object.entries(i)){if(be(s))continue;let a=t.nestSelection(o);Nn(s,a);let l=t.findField(o);if(!(n?.[o]&&!l)){if(s===!1||s===void 0||be(s)){r[o]=!1;continue}if(s===!0){l?.kind==="object"?r[o]=$t({},a):r[o]=!0;continue}r[o]=$t(s,a)}}return r}function Ho(e,t){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(rt(e)){if(vr(e))return{$type:"DateTime",value:e.toISOString()};t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Go(e))return{$type:"Param",value:e.name};if(lt(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return uc(e,t);if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:w.Buffer.from(r,n,i).toString("base64")}}if(cc(e))return e.values;if(nt(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Ce){if(e!==Or.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(pc(e))return e.toJSON();if(typeof e=="object")return Ko(e,t);t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function Ko(e,t){if(e.$type)return{$type:"Raw",value:e};let r={};for(let n in e){let i=e[n],o=t.nestArgument(n);be(i)||(i!==void 0?r[n]=Ho(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:Wo}))}return r}function uc(e,t){let r=[];for(let n=0;n<e.length;n++){let i=t.nestArgument(String(n)),o=e[n];if(o===void 0||be(o)){let s=o===void 0?"undefined":"Prisma.skip";t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}r.push(Ho(o,i))}return r}function cc(e){return typeof e=="object"&&e!==null&&e.__prismaRawParameters__===!0}function pc(e){return typeof e=="object"&&e!==null&&typeof e.toJSON=="function"}function Nn(e,t){e===void 0&&t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:Wo})}var _n=class e{constructor(t){this.params=t;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(t){_r({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(t=>({name:t.name,typeName:"boolean",isRelation:t.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(t){return this.params.previewFeatures.includes(t)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(t){return this.modelOrType?.fields.find(r=>r.name===t)}nestSelection(t){let r=this.findField(t),n=r?.kind==="object"?r.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[De(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:Pe(this.params.action,"Unknown action")}}nestArgument(t){return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}};d();u();c();p();m();function zo(e){if(!e._hasPreviewFlag("metrics"))throw new Z("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var pt=class{_client;constructor(t){this._client=t}prometheus(t){return zo(this._client),this._client._engine.metrics({format:"prometheus",...t})}json(t){return zo(this._client),this._client._engine.metrics({format:"json",...t})}};d();u();c();p();m();function Yo(e,t){let r=kt(()=>mc(t));Object.defineProperty(e,"dmmf",{get:()=>r.get()})}function mc(e){return{datamodel:{models:Fn(e.models),enums:Fn(e.enums),types:Fn(e.types)}}}function Fn(e){return Object.entries(e).map(([t,r])=>({name:t,...r}))}d();u();c();p();m();var Ln=new WeakMap,Ur="$$PrismaTypedSql",jt=class{constructor(t,r){Ln.set(this,{sql:t,values:r}),Object.defineProperty(this,Ur,{value:Ur})}get sql(){return Ln.get(this).sql}get values(){return Ln.get(this).values}};function Zo(e){return(...t)=>new jt(e,t)}function qr(e){return e!=null&&e[Ur]===Ur}d();u();c();p();m();var da=Qe(Xo());d();u();c();p();m();es();Vi();Wi();d();u();c();p();m();var oe=class e{constructor(t,r){if(t.length-1!==r.length)throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);let n=r.reduce((s,a)=>s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];let i=0,o=0;for(;i<r.length;){let s=r[i++],a=t[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l<s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`?${this.strings[r++]}`;return n}get statement(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`:${r}${this.strings[r++]}`;return n}get text(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`$${r}${this.strings[r++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function ts(e,t=",",r="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new oe([r,...Array(e.length-1).fill(t),n],e)}function Bn(e){return new oe([e],[])}var rs=Bn("");function Un(e,...t){return new oe(e,t)}d();u();c();p();m();d();u();c();p();m();function Vt(e){return{getKeys(){return Object.keys(e)},getPropertyValue(t){return e[t]}}}d();u();c();p();m();function ee(e,t){return{getKeys(){return[e]},getPropertyValue(){return t()}}}d();u();c();p();m();function Ue(e){let t=new ye;return{getKeys(){return e.getKeys()},getPropertyValue(r){return t.getOrCreate(r,()=>e.getPropertyValue(r))},getPropertyDescriptor(r){return e.getPropertyDescriptor?.(r)}}}d();u();c();p();m();d();u();c();p();m();var jr={enumerable:!0,configurable:!0,writable:!0};function Vr(e){let t=new Set(e);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>jr,has:(r,n)=>t.has(n),set:(r,n,i)=>t.add(n)&&Reflect.set(r,n,i),ownKeys:()=>[...t]}}var ns=Symbol.for("nodejs.util.inspect.custom");function pe(e,t){let r=fc(t),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=r.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=r.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=is(Reflect.ownKeys(o),r),a=is(Array.from(r.keys()),r);return[...new Set([...s,...a,...n])]},set(o,s,a){return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let l=r.get(s);return l?l.getPropertyDescriptor?{...jr,...l?.getPropertyDescriptor(s)}:jr:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[ns]=function(){let o={...this};return delete o[ns],o},i}function fc(e){let t=new Map;for(let r of e){let n=r.getKeys();for(let i of n)t.set(i,r)}return t}function is(e,t){return e.filter(r=>t.get(r)?.has?.(r)??!0)}d();u();c();p();m();function mt(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}d();u();c();p();m();function Gr(e,t){return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}d();u();c();p();m();function os(e){if(e===void 0)return"";let t=ut(e);return new it(0,{colors:Sr}).write(t).toString()}d();u();c();p();m();var gc="P2037";function Qr({error:e,user_facing_error:t},r,n){return t.error_code?new re(hc(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new ne(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}function hc(e,t){let r=e.message;return(t==="postgresql"||t==="postgres"||t==="mysql")&&e.error_code===gc&&(r+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var qn=class{getLocation(){return null}};function _e(e){return typeof $EnabledCallSite=="function"&&e!=="minimal"?new $EnabledCallSite:new qn}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var ss={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function dt(e={}){let t=wc(e);return Object.entries(t).reduce((n,[i,o])=>(ss[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function wc(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function Jr(e={}){return t=>(typeof e._count=="boolean"&&(t._count=t._count._all),t)}function as(e,t){let r=Jr(e);return t({action:"aggregate",unpacker:r,argsMapper:dt})(e)}d();u();c();p();m();function Ec(e={}){let{select:t,...r}=e;return typeof t=="object"?dt({...r,_count:t}):dt({...r,_count:{_all:!0}})}function bc(e={}){return typeof e.select=="object"?t=>Jr(e)(t)._count:t=>Jr(e)(t)._count._all}function ls(e,t){return t({action:"count",unpacker:bc(e),argsMapper:Ec})(e)}d();u();c();p();m();function xc(e={}){let t=dt(e);if(Array.isArray(t.by))for(let r of t.by)typeof r=="string"&&(t.select[r]=!0);else typeof t.by=="string"&&(t.select[t.by]=!0);return t}function Pc(e={}){return t=>(typeof e?._count=="boolean"&&t.forEach(r=>{r._count=r._count._all}),t)}function us(e,t){return t({action:"groupBy",unpacker:Pc(e),argsMapper:xc})(e)}function cs(e,t,r){if(t==="aggregate")return n=>as(n,r);if(t==="count")return n=>ls(n,r);if(t==="groupBy")return n=>us(n,r)}d();u();c();p();m();function ps(e,t){let r=t.fields.filter(i=>!i.relationName),n=xo(r,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new Nt(e,o,s.type,s.isList,s.kind==="enum")},...Vr(Object.keys(n))})}d();u();c();p();m();d();u();c();p();m();var ms=e=>Array.isArray(e)?e:e.split("."),$n=(e,t)=>ms(t).reduce((r,n)=>r&&r[n],e),ds=(e,t,r)=>ms(t).reduceRight((n,i,o,s)=>Object.assign({},$n(e,s.slice(0,o)),{[i]:n}),r);function vc(e,t){return e===void 0||t===void 0?[]:[...t,"select",e]}function Tc(e,t,r){return t===void 0?e??{}:ds(t,r,e||!0)}function jn(e,t,r,n,i,o){let a=e._runtimeDataModel.models[t].fields.reduce((l,f)=>({...l,[f.name]:f}),{});return l=>{let f=_e(e._errorFormat),g=vc(n,i),h=Tc(l,o,g),v=r({dataPath:g,callsite:f})(h),S=Cc(e,t);return new Proxy(v,{get(A,R){if(!S.includes(R))return A[R];let M=[a[R].type,r,R],B=[g,h];return jn(e,...M,...B)},...Vr([...S,...Object.getOwnPropertyNames(v)])})}}function Cc(e,t){return e._runtimeDataModel.models[t].fields.filter(r=>r.kind==="object").map(r=>r.name)}var Ac=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],Rc=["aggregate","count","groupBy"];function Vn(e,t){let r=e._extensions.getAllModelExtensions(t)??{},n=[Sc(e,t),Ic(e,t),Vt(r),ee("name",()=>t),ee("$name",()=>t),ee("$parent",()=>e._appliedParent)];return pe({},n)}function Sc(e,t){let r=Ee(t),n=Object.keys(It).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>l=>{let f=_e(e._errorFormat);return e._createPrismaPromise(g=>{let h={args:l,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:g,callsite:f};return e._request({...h,...a})},{action:o,args:l,model:t})};return Ac.includes(o)?jn(e,t,s):kc(i)?cs(e,i,s):s({})}}}function kc(e){return Rc.includes(e)}function Ic(e,t){return Ue(ee("fields",()=>{let r=e._runtimeDataModel.models[t];return ps(t,r)}))}d();u();c();p();m();function fs(e){return e.replace(/^./,t=>t.toUpperCase())}var Gn=Symbol();function Gt(e){let t=[Oc(e),Dc(e),ee(Gn,()=>e),ee("$parent",()=>e._appliedParent)],r=e._extensions.getAllClientExtensions();return r&&t.push(Vt(r)),pe(e,t)}function Oc(e){let t=Object.getPrototypeOf(e._originalClient),r=[...new Set(Object.getOwnPropertyNames(t))];return{getKeys(){return r},getPropertyValue(n){return e[n]}}}function Dc(e){let t=Object.keys(e._runtimeDataModel.models),r=t.map(Ee),n=[...new Set(t.concat(r))];return Ue({getKeys(){return n},getPropertyValue(i){let o=fs(i);if(e._runtimeDataModel.models[o]!==void 0)return Vn(e,o);if(e._runtimeDataModel.models[i]!==void 0)return Vn(e,i)},getPropertyDescriptor(i){if(!r.includes(i))return{enumerable:!1}}})}function gs(e){return e[Gn]?e[Gn]:e}function hs(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let r=e.client.__AccelerateEngine;this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}let t=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return Gt(t)}d();u();c();p();m();d();u();c();p();m();function ys({result:e,modelName:t,select:r,omit:n,extensions:i}){let o=i.getAllComputedFields(t);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let f=l.needs.filter(g=>n[g]);f.length>0&&a.push(mt(f))}else if(r){if(!r[l.name])continue;let f=l.needs.filter(g=>!r[g]);f.length>0&&a.push(mt(f))}Mc(e,l.needs)&&s.push(_c(l,pe(e,s)))}return s.length>0||a.length>0?pe(e,[...s,...a]):e}function Mc(e,t){return t.every(r=>xn(e,r))}function _c(e,t){return Ue(ee(e.name,()=>e.compute(t)))}d();u();c();p();m();function Wr({visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){if(Array.isArray(t)){for(let s=0;s<t.length;s++)t[s]=Wr({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});return t}let o=e(t,i,r)??t;return r.include&&ws({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&&ws({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}function ws({includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||t[o]==null||be(s))continue;let l=n.models[r].fields.find(g=>g.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let f=typeof s=="object"?s:{};t[o]=Wr({visitor:i,result:t[o],args:f,modelName:l.type,runtimeDataModel:n})}}function Es({result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:Wr({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:(a,l,f)=>{let g=Ee(l);return ys({result:a,modelName:g,select:f.select,omit:f.select?void 0:{...o?.[g],...f.omit},extensions:n})}})}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();var Nc=["$connect","$disconnect","$on","$transaction","$use","$extends"],bs=Nc;function xs(e){if(e instanceof oe)return Fc(e);if(qr(e))return Lc(e);if(Array.isArray(e)){let r=[e[0]];for(let n=1;n<e.length;n++)r[n]=Qt(e[n]);return r}let t={};for(let r in e)t[r]=Qt(e[r]);return t}function Fc(e){return new oe(e.strings,e.values)}function Lc(e){return new jt(e.sql,e.values)}function Qt(e){if(typeof e!="object"||e==null||e instanceof Ce||lt(e))return e;if(nt(e))return new he(e.toFixed());if(rt(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let t=e.length,r;for(r=Array(t);t--;)r[t]=Qt(e[t]);return r}if(typeof e=="object"){let t={};for(let r in e)r==="__proto__"?Object.defineProperty(t,r,{value:Qt(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=Qt(e[r]);return t}Pe(e,"Unknown value")}function vs(e,t,r,n=0){return e._createPrismaPromise(i=>{let o=t.customDataProxyFetch;return"transaction"in t&&i!==void 0&&(t.transaction?.kind==="batch"&&t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:xs(t.args??{}),__internalParams:t,query:(s,a=t)=>{let l=a.customDataProxyFetch;return a.customDataProxyFetch=Rs(o,l),a.args=s,vs(e,a,r,n+1)}})})}function Ts(e,t){let{jsModelName:r,action:n,clientMethod:i}=t,o=r?n:i;if(e._extensions.isEmpty())return e._executeRequest(t);let s=e._extensions.getAllQueryCallbacks(r??"$none",o);return vs(e,t,s)}function Cs(e){return t=>{let r={requests:t},n=t[0].extensions.getAllBatchQueryCallbacks();return n.length?As(r,n,0,e):e(r)}}function As(e,t,r,n){if(r===t.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return t[r]({args:{queries:e.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=Rs(i,l),As(a,t,r+1,n)}})}var Ps=e=>e;function Rs(e=Ps,t=Ps){return r=>e(t(r))}d();u();c();p();m();var Ss=K("prisma:client"),ks={Vercel:"vercel","Netlify CI":"netlify"};function Is({postinstall:e,ciName:t,clientVersion:r}){if(Ss("checkPlatformCaching:postinstall",e),Ss("checkPlatformCaching:ciName",t),e===!0&&t&&t in ks){let n=`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ks[t]}-build`;throw console.error(n),new Q(n,r)}}d();u();c();p();m();function Os(e,t){return e?e.datasources?e.datasources:e.datasourceUrl?{[t[0]]:{url:e.datasourceUrl}}:{}:{}}d();u();c();p();m();d();u();c();p();m();var Bc=()=>globalThis.process?.release?.name==="node",Uc=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,qc=()=>!!globalThis.Deno,$c=()=>typeof globalThis.Netlify=="object",jc=()=>typeof globalThis.EdgeRuntime=="object",Vc=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function Gc(){return[[$c,"netlify"],[jc,"edge-light"],[Vc,"workerd"],[qc,"deno"],[Uc,"bun"],[Bc,"node"]].flatMap(r=>r[0]()?[r[1]]:[]).at(0)??""}var Qc={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function Hr(){let e=Gc();return{id:e,prettyName:Qc[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}d();u();c();p();m();d();u();c();p();m();d();u();c();p();m();function ft({inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=t[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw Hr().id==="workerd"?new Q(`error: Environment variable not found: ${s.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new Q(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new Q("error: Missing URL environment variable, value, or override.",n);return i}d();u();c();p();m();d();u();c();p();m();var Kr=class extends Error{clientVersion;cause;constructor(t,r){super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}get[Symbol.toStringTag](){return this.name}};var se=class extends Kr{isRetryable;constructor(t,r){super(t,r),this.isRetryable=r.isRetryable??!0}};d();u();c();p();m();d();u();c();p();m();function L(e,t){return{...e,isRetryable:t}}var gt=class extends se{name="ForcedRetryError";code="P5001";constructor(t){super("This request must be retried",L(t,!0))}};N(gt,"ForcedRetryError");d();u();c();p();m();var qe=class extends se{name="InvalidDatasourceError";code="P6001";constructor(t,r){super(t,L(r,!1))}};N(qe,"InvalidDatasourceError");d();u();c();p();m();var $e=class extends se{name="NotImplementedYetError";code="P5004";constructor(t,r){super(t,L(r,!1))}};N($e,"NotImplementedYetError");d();u();c();p();m();d();u();c();p();m();var V=class extends se{response;constructor(t,r){super(t,r),this.response=r.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};var je=class extends V{name="SchemaMissingError";code="P5005";constructor(t){super("Schema needs to be uploaded",L(t,!0))}};N(je,"SchemaMissingError");d();u();c();p();m();d();u();c();p();m();var Qn="This request could not be understood by the server",Jt=class extends V{name="BadRequestError";code="P5000";constructor(t,r,n){super(r||Qn,L(t,!1)),n&&(this.code=n)}};N(Jt,"BadRequestError");d();u();c();p();m();var Wt=class extends V{name="HealthcheckTimeoutError";code="P5013";logs;constructor(t,r){super("Engine not started: healthcheck timeout",L(t,!0)),this.logs=r}};N(Wt,"HealthcheckTimeoutError");d();u();c();p();m();var Ht=class extends V{name="EngineStartupError";code="P5014";logs;constructor(t,r,n){super(r,L(t,!0)),this.logs=n}};N(Ht,"EngineStartupError");d();u();c();p();m();var Kt=class extends V{name="EngineVersionNotSupportedError";code="P5012";constructor(t){super("Engine version is not supported",L(t,!1))}};N(Kt,"EngineVersionNotSupportedError");d();u();c();p();m();var Jn="Request timed out",zt=class extends V{name="GatewayTimeoutError";code="P5009";constructor(t,r=Jn){super(r,L(t,!1))}};N(zt,"GatewayTimeoutError");d();u();c();p();m();var Jc="Interactive transaction error",Yt=class extends V{name="InteractiveTransactionError";code="P5015";constructor(t,r=Jc){super(r,L(t,!1))}};N(Yt,"InteractiveTransactionError");d();u();c();p();m();var Wc="Request parameters are invalid",Zt=class extends V{name="InvalidRequestError";code="P5011";constructor(t,r=Wc){super(r,L(t,!1))}};N(Zt,"InvalidRequestError");d();u();c();p();m();var Wn="Requested resource does not exist",Xt=class extends V{name="NotFoundError";code="P5003";constructor(t,r=Wn){super(r,L(t,!1))}};N(Xt,"NotFoundError");d();u();c();p();m();var Hn="Unknown server error",ht=class extends V{name="ServerError";code="P5006";logs;constructor(t,r,n){super(r||Hn,L(t,!0)),this.logs=n}};N(ht,"ServerError");d();u();c();p();m();var Kn="Unauthorized, check your connection string",er=class extends V{name="UnauthorizedError";code="P5007";constructor(t,r=Kn){super(r,L(t,!1))}};N(er,"UnauthorizedError");d();u();c();p();m();var zn="Usage exceeded, retry again later",tr=class extends V{name="UsageExceededError";code="P5008";constructor(t,r=zn){super(r,L(t,!0))}};N(tr,"UsageExceededError");async function Hc(e){let t;try{t=await e.text()}catch{return{type:"EmptyError"}}try{let r=JSON.parse(t);if(typeof r=="string")switch(r){case"InternalDataProxyError":return{type:"DataProxyError",body:r};default:return{type:"UnknownTextError",body:r}}if(typeof r=="object"&&r!==null){if("is_panic"in r&&"message"in r&&"error_code"in r)return{type:"QueryEngineError",body:r};if("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=Object.values(r)[0].reason;return typeof n=="string"&&!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}}return{type:"UnknownJsonError",body:r}}catch{return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}}async function rr(e,t){if(e.ok)return;let r={clientVersion:t,response:e},n=await Hc(e);if(n.type==="QueryEngineError")throw new re(n.body.message,{code:n.body.error_code,clientVersion:t});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new ht(r,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new je(r);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new Kt(r);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new Ht(r,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new Q(i,t,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new Wt(r,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new Yt(r,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new Zt(r,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new er(r,yt(Kn,n));if(e.status===404)return new Xt(r,yt(Wn,n));if(e.status===429)throw new tr(r,yt(zn,n));if(e.status===504)throw new zt(r,yt(Jn,n));if(e.status>=500)throw new ht(r,yt(Hn,n));if(e.status>=400)throw new Jt(r,yt(Qn,n))}function yt(e,t){return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}d();u();c();p();m();function Ds(e){let t=Math.pow(2,e)*50,r=Math.ceil(Math.random()*t)-Math.ceil(t/2),n=t+r;return new Promise(i=>setTimeout(()=>i(n),n))}d();u();c();p();m();var Ae="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function Ms(e){let t=new TextEncoder().encode(e),r="",n=t.byteLength,i=n%3,o=n-i,s,a,l,f,g;for(let h=0;h<o;h=h+3)g=t[h]<<16|t[h+1]<<8|t[h+2],s=(g&16515072)>>18,a=(g&258048)>>12,l=(g&4032)>>6,f=g&63,r+=Ae[s]+Ae[a]+Ae[l]+Ae[f];return i==1?(g=t[o],s=(g&252)>>2,a=(g&3)<<4,r+=Ae[s]+Ae[a]+"=="):i==2&&(g=t[o]<<8|t[o+1],s=(g&64512)>>10,a=(g&1008)>>4,l=(g&15)<<2,r+=Ae[s]+Ae[a]+Ae[l]+"="),r}d();u();c();p();m();function _s(e){if(!!e.generator?.previewFeatures.some(r=>r.toLowerCase().includes("metrics")))throw new Q("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}d();u();c();p();m();function Kc(e){return e[0]*1e3+e[1]/1e6}function Yn(e){return new Date(Kc(e))}d();u();c();p();m();var Ns={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};d();u();c();p();m();d();u();c();p();m();var nr=class extends se{name="RequestError";code="P5010";constructor(t,r){super(`Cannot fetch data from service:
${t}`,L(r,!0))}};N(nr,"RequestError");async function Ve(e,t,r=n=>n){let{clientVersion:n,...i}=t,o=r(fetch);try{return await o(e,i)}catch(s){let a=s.message??"Unknown error";throw new nr(a,{clientVersion:n,cause:s})}}var Yc=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,Fs=K("prisma:client:dataproxyEngine");async function Zc(e,t){let r=Ns["@prisma/engines-version"],n=t.clientVersion??"unknown";if(y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&&n!=="0.0.0"&&n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&&Yc.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){if(e.startsWith("localhost")||e.startsWith("127.0.0.1"))return"0.0.0";let[s]=r.split("-")??[],[a,l,f]=s.split("."),g=Xc(`<=${a}.${l}.${f}`),h=await Ve(g,{clientVersion:n});if(!h.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${h.status} ${h.statusText}, response body: ${await h.text()||"<empty body>"}`);let v=await h.text();Fs("length of body fetched from unpkg.com",v.length);let S;try{S=JSON.parse(v)}catch(A){throw console.error("JSON.parse error: body fetched from unpkg.com: ",v),A}return S.version}throw new $e("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}async function Ls(e,t){let r=await Zc(e,t);return Fs("version",r),r}function Xc(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}var Bs=3,zr=K("prisma:client:dataproxyEngine"),Zn=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}build({traceparent:t,interactiveTransaction:r}={}){let n={Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};this.tracingHelper.isEnabled()&&(n.traceparent=t??this.tracingHelper.getTraceParent()),r&&(n["X-transaction-id"]=r.id);let i=this.buildCaptureSettings();return i.length>0&&(n["X-capture-telemetry"]=i.join(", ")),n}buildCaptureSettings(){let t=[];return this.tracingHelper.isEnabled()&&t.push("tracing"),this.logLevel&&t.push(this.logLevel),this.logQueries&&t.push("query"),t}},wt=class{name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;constructor(t){_s(t),this.config=t,this.env={...t.env,...typeof y<"u"?y.env:{}},this.inlineSchema=Ms(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&&await this.startPromise,this.startPromise=(async()=>{let[t,r]=this.extractHostAndApiKey();this.host=t,this.headerBuilder=new Zn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Ls(t,this.config),zr("host",this.host)})(),await this.startPromise}async stop(){}propagateResponseExtensions(t){t?.logs?.length&&t.logs.forEach(r=>{switch(r.level){case"debug":case"trace":zr(r);break;case"error":case"warn":case"info":{this.logEmitter.emit(r.level,{timestamp:Yn(r.timestamp),message:r.attributes.message??"",target:r.target});break}case"query":{this.logEmitter.emit("query",{query:r.attributes.query??"",timestamp:Yn(r.timestamp),duration:r.attributes.duration_ms??0,params:r.attributes.params??"",target:r.target});break}default:r.level}}),t?.traces?.length&&this.tracingHelper.dispatchEngineSpans(t.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(t){return await this.start(),`https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}async uploadSchema(){let t={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(t,async()=>{let r=await Ve(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});r.ok||zr("schema response status",r.status);let n=await rr(r,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(t,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}async requestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=Gr(t,n);return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r})).map(l=>(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=>{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,interactiveTransaction:i}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);a.ok||zr("graphql response status",a.status),await this.handleError(await rr(a,this.clientVersion));let l=await a.json();if(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(t,r,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[t]} transaction`,callback:async({logHttpCall:o})=>{if(t==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await Ve(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await rr(l,this.clientVersion));let f=await l.json(),{extensions:g}=f;g&&this.propagateResponseExtensions(g);let h=f.id,v=f["data-proxy"].endpoint;return{id:h,payload:{endpoint:v}}}else{let s=`${n.payload.endpoint}/${t}`;o(s);let a=await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});await this.handleError(await rr(a,this.clientVersion));let l=await a.json(),{extensions:f}=l;f&&this.propagateResponseExtensions(f);return}}})}extractHostAndApiKey(){let t={clientVersion:this.clientVersion},r=Object.keys(this.inlineDatasources)[0],n=ft({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),i;try{i=new URL(n)}catch{throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}let{protocol:o,host:s,searchParams:a}=i;if(o!=="prisma:"&&o!==fr)throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t);let l=a.get("api_key");if(l===null||l.length<1)throw new qe(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);return[s,l]}metrics(){throw new $e("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(t){for(let r=0;;r++){let n=i=>{this.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})};try{return await t.callback({logHttpCall:n})}catch(i){if(!(i instanceof se)||!i.isRetryable)throw i;if(r>=Bs)throw i instanceof gt?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${r+1}/${Bs} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await Ds(r);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(t){if(t instanceof je)throw await this.uploadSchema(),new gt({clientVersion:this.clientVersion,cause:t});if(t)throw t}convertProtocolErrorsToClientError(t){return t.length===1?Qr(t[0],this.config.clientVersion,this.config.activeProvider):new ne(JSON.stringify(t),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};function Us({copyEngine:e=!0},t){let r;try{r=ft({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...y.env},clientVersion:t.clientVersion})}catch{}let n=!!(r?.startsWith("prisma://")||En(r));e&&n&&Rt("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");let i=Ye(t.generator),o=n||!e,s=!!t.adapter,a=i==="library",l=i==="binary",f=i==="client";if(o&&s||s){let g;throw g=["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."],new Z(g.join(`
`),{clientVersion:t.clientVersion})}return o?new wt(t):new wt(t)}d();u();c();p();m();function Yr({generator:e}){return e?.previewFeatures??[]}d();u();c();p();m();var qs=e=>({command:e});d();u();c();p();m();d();u();c();p();m();var $s=e=>e.strings.reduce((t,r,n)=>`${t}@P${n}${r}`);d();u();c();p();m();function Et(e){try{return js(e,"fast")}catch{return js(e,"slow")}}function js(e,t){return JSON.stringify(e.map(r=>Gs(r,t)))}function Gs(e,t){if(Array.isArray(e))return e.map(r=>Gs(r,t));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(rt(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(he.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(w.Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(ep(e))return{prisma__type:"bytes",prisma__value:w.Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:w.Buffer.from(r,n,i).toString("base64")}}return typeof e=="object"&&t==="slow"?Qs(e):e}function ep(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&&e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Qs(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Vs);let t={};for(let r of Object.keys(e))t[r]=Vs(e[r]);return t}function Vs(e){return typeof e=="bigint"?e.toString():Qs(e)}var tp=/^(\s*alter\s)/i,Js=K("prisma:client");function Xn(e,t,r,n){if(!(e!=="postgresql"&&e!=="cockroachdb")&&r.length>0&&tp.exec(t))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var ei=({clientMethod:e,activeProvider:t})=>r=>{let n="",i;if(qr(r))n=r.sql,i={values:Et(r.values),__prismaRawParameters__:!0};else if(Array.isArray(r)){let[o,...s]=r;n=o,i={values:Et(s||[]),__prismaRawParameters__:!0}}else switch(t){case"sqlite":case"mysql":{n=r.sql,i={values:Et(r.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=r.text,i={values:Et(r.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=$s(r),i={values:Et(r.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${t} provider does not support ${e}`)}return i?.values?Js(`prisma.${e}(${n}, ${i.values})`):Js(`prisma.${e}(${n})`),{query:n,parameters:i}},Ws={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[t,...r]=e;return new oe(t,r)}},Hs={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};d();u();c();p();m();function ti(e){return function(r,n){let i,o=(s=e)=>{try{return s===void 0||s?.kind==="itx"?i??=Ks(r(s)):Ks(r(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function Ks(e){return typeof e.then=="function"?e:Promise.resolve(e)}d();u();c();p();m();var rp=wn.split(".")[0],np={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,t){return t()}},ri=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(t){return this.getGlobalTracingHelper().getTraceParent(t)}dispatchEngineSpans(t){return this.getGlobalTracingHelper().dispatchEngineSpans(t)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(t,r){return this.getGlobalTracingHelper().runInChildSpan(t,r)}getGlobalTracingHelper(){let t=globalThis[`V${rp}_PRISMA_INSTRUMENTATION`],r=globalThis.PRISMA_INSTRUMENTATION;return t?.helper??r?.helper??np}};function zs(){return new ri}d();u();c();p();m();function Ys(e,t=()=>{}){let r,n=new Promise(i=>r=i);return{then(i){return--e===0&&r(t()),i?.(n)}}}d();u();c();p();m();function Zs(e){return typeof e=="string"?e:e.reduce((t,r)=>{let n=typeof r=="string"?r:r.level;return n==="query"?t:t&&(r==="info"||t==="info")?"info":n},void 0)}d();u();c();p();m();var Zr=class{_middlewares=[];use(t){this._middlewares.push(t)}get(t){return this._middlewares[t]}has(t){return!!this._middlewares[t]}length(){return this._middlewares.length}};d();u();c();p();m();var ea=Qe(no());d();u();c();p();m();function Xr(e){return typeof e.batchRequestIdx=="number"}d();u();c();p();m();function Xs(e){if(e.action!=="findUnique"&&e.action!=="findUniqueOrThrow")return;let t=[];return e.modelName&&t.push(e.modelName),e.query.arguments&&t.push(ni(e.query.arguments)),t.push(ni(e.query.selection)),t.join("")}function ni(e){return`(${Object.keys(e).sort().map(r=>{let n=e[r];return typeof n=="object"&&n!==null?`(${r} ${ni(n)})`:r}).join(" ")})`}d();u();c();p();m();var ip={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function ii(e){return ip[e]}d();u();c();p();m();var en=class{constructor(t){this.options=t;this.batches={}}batches;tickActive=!1;request(t){let r=this.options.batchBy(t);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,y.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[r].push({request:t,resolve:n,reject:i})})):this.options.singleLoader(t)}dispatchBatches(){for(let t in this.batches){let r=this.batches[t];delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(n=>{n instanceof Error?r[0].reject(n):r[0].resolve(n)}).catch(n=>{r[0].reject(n)}):(r.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(r.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<r.length;i++)r[i].reject(n);else for(let i=0;i<r.length;i++){let o=n[i];o instanceof Error?r[i].reject(o):r[i].resolve(o)}}).catch(n=>{for(let i=0;i<r.length;i++)r[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};d();u();c();p();m();function Ge(e,t){if(t===null)return t;switch(e){case"bigint":return BigInt(t);case"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"decimal":return new he(t);case"datetime":case"date":return new Date(t);case"time":return new Date(`1970-01-01T${t}Z`);case"bigint-array":return t.map(r=>Ge("bigint",r));case"bytes-array":return t.map(r=>Ge("bytes",r));case"decimal-array":return t.map(r=>Ge("decimal",r));case"datetime-array":return t.map(r=>Ge("datetime",r));case"date-array":return t.map(r=>Ge("date",r));case"time-array":return t.map(r=>Ge("time",r));default:return t}}function tn(e){let t=[],r=op(e);for(let n=0;n<e.rows.length;n++){let i=e.rows[n],o={...r};for(let s=0;s<i.length;s++)o[e.columns[s]]=Ge(e.types[s],i[s]);t.push(o)}return t}function op(e){let t={};for(let r=0;r<e.columns.length;r++)t[e.columns[r]]=null;return t}var sp=K("prisma:client:request_handler"),rn=class{client;dataloader;logEmitter;constructor(t,r){this.logEmitter=r,this.client=t,this.dataloader=new en({batchLoader:Cs(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(h=>h.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),f=n.some(h=>ii(h.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:ap(o),containsWrite:f,customDataProxyFetch:i})).map((h,v)=>{if(h instanceof Error)return h;try{return this.mapQueryEngineResult(n[v],h)}catch(S){return S}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?ta(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:ii(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:Xs(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(t){try{return await this.dataloader.request(t)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=t;this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}}mapQueryEngineResult({dataPath:t,unpacker:r},n){let i=n?.data,o=this.unpack(i,t,r);return y.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(t){try{this.handleRequestError(t)}catch(r){throw this.logEmitter&&this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}}handleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(sp(t),lp(t,i))throw t;if(t instanceof re&&up(t)){let f=ra(t.meta);_r({args:o,errors:[f],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}let l=t.message;if(n&&(l=Tr({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let f=s?{modelName:s,...t.meta}:t.meta;throw new re(l,{code:t.code,clientVersion:this.client._clientVersion,meta:f,batchRequestIdx:t.batchRequestIdx})}else{if(t.isPanic)throw new ve(l,this.client._clientVersion);if(t instanceof ne)throw new ne(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});if(t instanceof Q)throw new Q(l,this.client._clientVersion);if(t instanceof ve)throw new ve(l,this.client._clientVersion)}throw t.clientVersion=this.client._clientVersion,t}sanitizeMessage(t){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,ea.default)(t):t}unpack(t,r,n){if(!t||(t.data&&(t=t.data),!t))return t;let i=Object.keys(t)[0],o=Object.values(t)[0],s=r.filter(f=>f!=="select"&&f!=="include"),a=$n(o,s),l=i==="queryRaw"?tn(a):tt(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function ap(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:ta(e)};Pe(e,"Unknown transaction kind")}}function ta(e){return{id:e.id,payload:e.payload}}function lp(e,t){return Xr(e)&&t?.kind==="batch"&&e.batchRequestIdx!==t.index}function up(e){return e.code==="P2009"||e.code==="P2012"}function ra(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(ra)};if(Array.isArray(e.selectionPath)){let[,...t]=e.selectionPath;return{...e,selectionPath:t}}return e}d();u();c();p();m();var na="6.6.0";var ia=na;d();u();c();p();m();var ua=Qe(kn());d();u();c();p();m();var U=class extends Error{constructor(t){super(t+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};N(U,"PrismaClientConstructorValidationError");var oa=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],sa=["pretty","colorless","minimal"],aa=["info","query","warn","error"],pp={datasources:(e,{datasourceNames:t})=>{if(e){if(typeof e!="object"||Array.isArray(e))throw new U(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[r,n]of Object.entries(e)){if(!t.includes(r)){let i=bt(r,t)||` Available datasources: ${t.join(", ")}`;throw new U(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new U(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,t)=>{if(!e&&Ye(t.generator)==="client")throw new U('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new U('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Yr(t).includes("driverAdapters"))throw new U('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Ye(t.generator)==="binary")throw new U('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=>{if(typeof e<"u"&&typeof e!="string")throw new U(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=>{if(e){if(typeof e!="string")throw new U(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!sa.includes(e)){let t=bt(e,sa);throw new U(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}}},log:e=>{if(!e)return;if(!Array.isArray(e))throw new U(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function t(r){if(typeof r=="string"&&!aa.includes(r)){let n=bt(r,aa);throw new U(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}}for(let r of e){t(r);let n={level:t,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=bt(i,o);throw new U(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(r&&typeof r=="object")for(let[i,o]of Object.entries(r))if(n[i])n[i](o);else throw new U(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=>{if(!e)return;let t=e.maxWait;if(t!=null&&t<=0)throw new U(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let r=e.timeout;if(r!=null&&r<=0)throw new U(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,t)=>{if(typeof e!="object")throw new U('"omit" option is expected to be an object.');if(e===null)throw new U('"omit" option can not be `null`');let r=[];for(let[n,i]of Object.entries(e)){let o=dp(n,t.runtimeDataModel);if(!o){r.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(f=>f.name===s);if(!l){r.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(r.length>0)throw new U(fp(e,r))},__internal:e=>{if(!e)return;let t=["debug","engine","configOverride"];if(typeof e!="object")throw new U(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[r]of Object.entries(e))if(!t.includes(r)){let n=bt(r,t);throw new U(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function ca(e,t){for(let[r,n]of Object.entries(e)){if(!oa.includes(r)){let i=bt(r,oa);throw new U(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}pp[r](n,t)}if(e.datasourceUrl&&e.datasources)throw new U('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function bt(e,t){if(t.length===0||typeof e!="string")return"";let r=mp(e,t);return r?` Did you mean "${r}"?`:""}function mp(e,t){if(t.length===0)return null;let r=t.map(i=>({value:i,distance:(0,ua.default)(e,i)}));r.sort((i,o)=>i.distance<o.distance?-1:1);let n=r[0];return n.distance<3?n.value:null}function dp(e,t){return la(t.models,e)??la(t.types,e)}function la(e,t){let r=Object.keys(e).find(n=>De(n)===t);if(r)return e[r]}function fp(e,t){let r=ut(e);for(let o of t)switch(o.kind){case"UnknownModel":r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=Mr(r,"colorless");return`Error validating "omit" option:

${i}

${n}`}d();u();c();p();m();function pa(e){return e.length===0?Promise.resolve([]):new Promise((t,r)=>{let n=new Array(e.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===e.length&&(o=!0,i?r(i):t(n)))},l=f=>{o||(o=!0,r(f))};for(let f=0;f<e.length;f++)e[f].then(g=>{n[f]=g,a()},g=>{if(!Xr(g)){l(g);return}g.batchRequestIdx===f?l(g):(i||(i=g),a())})})}var Ne=K("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var gp={requestArgsToMiddlewareArgs:e=>e,middlewareArgsToRequestArgs:e=>e},hp=Symbol.for("prisma.client.transaction.id"),yp={id:0,nextId(){return++this.id}};function fa(e){class t{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new Zr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=ti();constructor(n){e=n?.__internal?.configOverride?.(e)??e,Is(e),n&&ca(n,e);let i=new $r().on("error",()=>{});this._extensions=ct.empty(),this._previewFeatures=Yr(e),this._clientVersion=e.clientVersion??ia,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=zs();let o=e.relativeEnvPaths&&{rootEnvPath:e.relativeEnvPaths.rootEnvPath&&dr.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&&dr.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"?"postgres":e.activeProvider;if(s.provider!==l)throw new Q(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new Q("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=e.injectableEdgeEnv?.();try{let l=n??{},f=l.__internal??{},g=f.debug===!0;g&&K.enable("prisma:client");let h=dr.resolve(e.dirname,e.relativePath);ji.existsSync(h)||(h=e.dirname),Ne("dirname",e.dirname),Ne("relativePath",e.relativePath),Ne("cwd",h);let v=f.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat:y.env.NODE_ENV==="production"?this._errorFormat="minimal":y.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:h,dirname:e.dirname,enableDebugLogs:g,allowTriggerPanic:v.allowTriggerPanic,prismaPath:v.binaryPath??void 0,engineEndpoint:v.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&&Zs(l.log),logQueries:l.log&&!!(typeof l.log=="string"?l.log==="query":l.log.find(S=>typeof S=="string"?S==="query":S.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Os(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:ft,getBatchRequestPayload:Gr,prismaGraphQLToJSError:Qr,PrismaClientUnknownRequestError:ne,PrismaClientInitializationError:Q,PrismaClientKnownRequestError:re,debug:K("prisma:client:accelerateEngine"),engineVersion:da.version,clientVersion:e.clientVersion}},Ne("clientVersion",e.clientVersion),this._engine=Us(e,this._engineConfig),this._requestHandler=new rn(this,i),l.log)for(let S of l.log){let A=typeof S=="string"?S:S.emit==="stdout"?S.level:null;A&&this.$on(A,R=>{At.log(`${At.tags[A]??""}`,R.message||R.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=Gt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{qi()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:ei({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=ma(n,i);return Xn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(Xn(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:qs,callsite:_e(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:ei({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...ma(n,i));throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=yp.nextId(),s=Ys(n.length),a=n.map((l,f)=>{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let g=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,h={kind:"batch",id:o,index:f,isolationLevel:g,lock:s};return l.requestTransaction?.(h)??l});return pa(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let f={kind:"itx",...a};l=await n(this._createItxClient(f)),await this._engine.transaction("commit",o,a)}catch(f){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),f}return l}_createItxClient(n){return pe(Gt(pe(gs(this),[ee("_appliedParent",()=>this._appliedParent._createItxClient(n)),ee("_createPrismaPromise",()=>ti(n)),ee(hp,()=>n.id)])),[mt(bs)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??gp,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async f=>{let g=this._middlewares.get(++a);if(g)return this._tracingHelper.runInChildSpan(s.middleware,D=>g(f,M=>(D?.end(),l(M))));let{runInTransaction:h,args:v,...S}=f,A={...n,...S};v&&(A.args=i.middlewareArgsToRequestArgs(v)),n.transaction!==void 0&&h===!1&&delete A.transaction;let R=await Ts(this,A);return A.model?Es({result:R,modelName:A.model,args:A.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):R};return this._tracingHelper.runInChildSpan(s.operation,()=>l(o))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:f,transaction:g,unpacker:h,otelParentCtx:v,customDataProxyFetch:S}){try{n=f?f(n):n;let A={name:"serialize"},R=this._tracingHelper.runInChildSpan(A,()=>Br({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return K.enabled("prisma:client")&&(Ne("Prisma Client call:"),Ne(`prisma.${i}(${os(n)})`),Ne("Generated request:"),Ne(JSON.stringify(R,null,2)+`
`)),g?.kind==="batch"&&await g.lock,this._requestHandler.request({protocolQuery:R,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:g,unpacker:h,otelParentCtx:v,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:S})}catch(A){throw A.clientVersion=this._clientVersion,A}}$metrics=new pt(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=hs}return t}function ma(e,t){return wp(e)?[new oe(e,t),Ws]:[e,Hs]}function wp(e){return Array.isArray(e)&&Array.isArray(e.raw)}d();u();c();p();m();var Ep=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function ga(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(!Ep.has(r))throw new TypeError(`Invalid enum value: ${String(r)}`)}})}d();u();c();p();m();0&&(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});
//# sourceMappingURL=edge.js.map

```

## 📄 lib\generated\prisma\runtime\index-browser.d.ts

```ts
declare class AnyNull extends NullTypesEnumValue {
    private readonly _brand_AnyNull;
}

declare type Args<T, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            operations: {
                [K in F]: {
                    args: any;
                };
            };
        };
    };
} ? T[symbol]['types']['operations'][F]['args'] : any;

declare class DbNull extends NullTypesEnumValue {
    private readonly _brand_DbNull;
}

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
    export type Constructor = typeof Decimal;
    export type Instance = Decimal;
    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    export type Modulo = Rounding | 9;
    export type Value = string | number | Decimal;

    // http://mikemcl.github.io/decimal.js/#constructor-properties
    export interface Config {
        precision?: number;
        rounding?: Rounding;
        toExpNeg?: number;
        toExpPos?: number;
        minE?: number;
        maxE?: number;
        crypto?: boolean;
        modulo?: Modulo;
        defaults?: boolean;
    }
}

export declare class Decimal {
    readonly d: number[];
    readonly e: number;
    readonly s: number;

    constructor(n: Decimal.Value);

    absoluteValue(): Decimal;
    abs(): Decimal;

    ceil(): Decimal;

    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

    comparedTo(n: Decimal.Value): number;
    cmp(n: Decimal.Value): number;

    cosine(): Decimal;
    cos(): Decimal;

    cubeRoot(): Decimal;
    cbrt(): Decimal;

    decimalPlaces(): number;
    dp(): number;

    dividedBy(n: Decimal.Value): Decimal;
    div(n: Decimal.Value): Decimal;

    dividedToIntegerBy(n: Decimal.Value): Decimal;
    divToInt(n: Decimal.Value): Decimal;

    equals(n: Decimal.Value): boolean;
    eq(n: Decimal.Value): boolean;

    floor(): Decimal;

    greaterThan(n: Decimal.Value): boolean;
    gt(n: Decimal.Value): boolean;

    greaterThanOrEqualTo(n: Decimal.Value): boolean;
    gte(n: Decimal.Value): boolean;

    hyperbolicCosine(): Decimal;
    cosh(): Decimal;

    hyperbolicSine(): Decimal;
    sinh(): Decimal;

    hyperbolicTangent(): Decimal;
    tanh(): Decimal;

    inverseCosine(): Decimal;
    acos(): Decimal;

    inverseHyperbolicCosine(): Decimal;
    acosh(): Decimal;

    inverseHyperbolicSine(): Decimal;
    asinh(): Decimal;

    inverseHyperbolicTangent(): Decimal;
    atanh(): Decimal;

    inverseSine(): Decimal;
    asin(): Decimal;

    inverseTangent(): Decimal;
    atan(): Decimal;

    isFinite(): boolean;

    isInteger(): boolean;
    isInt(): boolean;

    isNaN(): boolean;

    isNegative(): boolean;
    isNeg(): boolean;

    isPositive(): boolean;
    isPos(): boolean;

    isZero(): boolean;

    lessThan(n: Decimal.Value): boolean;
    lt(n: Decimal.Value): boolean;

    lessThanOrEqualTo(n: Decimal.Value): boolean;
    lte(n: Decimal.Value): boolean;

    logarithm(n?: Decimal.Value): Decimal;
    log(n?: Decimal.Value): Decimal;

    minus(n: Decimal.Value): Decimal;
    sub(n: Decimal.Value): Decimal;

    modulo(n: Decimal.Value): Decimal;
    mod(n: Decimal.Value): Decimal;

    naturalExponential(): Decimal;
    exp(): Decimal;

    naturalLogarithm(): Decimal;
    ln(): Decimal;

    negated(): Decimal;
    neg(): Decimal;

    plus(n: Decimal.Value): Decimal;
    add(n: Decimal.Value): Decimal;

    precision(includeZeros?: boolean): number;
    sd(includeZeros?: boolean): number;

    round(): Decimal;

    sine() : Decimal;
    sin() : Decimal;

    squareRoot(): Decimal;
    sqrt(): Decimal;

    tangent() : Decimal;
    tan() : Decimal;

    times(n: Decimal.Value): Decimal;
    mul(n: Decimal.Value) : Decimal;

    toBinary(significantDigits?: number): string;
    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

    toDecimalPlaces(decimalPlaces?: number): Decimal;
    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
    toDP(decimalPlaces?: number): Decimal;
    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

    toExponential(decimalPlaces?: number): string;
    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFixed(decimalPlaces?: number): string;
    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFraction(max_denominator?: Decimal.Value): Decimal[];

    toHexadecimal(significantDigits?: number): string;
    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
    toHex(significantDigits?: number): string;
    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

    toJSON(): string;

    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

    toNumber(): number;

    toOctal(significantDigits?: number): string;
    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

    toPower(n: Decimal.Value): Decimal;
    pow(n: Decimal.Value): Decimal;

    toPrecision(significantDigits?: number): string;
    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

    toSignificantDigits(significantDigits?: number): Decimal;
    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
    toSD(significantDigits?: number): Decimal;
    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

    toString(): string;

    truncated(): Decimal;
    trunc(): Decimal;

    valueOf(): string;

    static abs(n: Decimal.Value): Decimal;
    static acos(n: Decimal.Value): Decimal;
    static acosh(n: Decimal.Value): Decimal;
    static add(x: Decimal.Value, y: Decimal.Value): Decimal;
    static asin(n: Decimal.Value): Decimal;
    static asinh(n: Decimal.Value): Decimal;
    static atan(n: Decimal.Value): Decimal;
    static atanh(n: Decimal.Value): Decimal;
    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
    static cbrt(n: Decimal.Value): Decimal;
    static ceil(n: Decimal.Value): Decimal;
    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
    static clone(object?: Decimal.Config): Decimal.Constructor;
    static config(object: Decimal.Config): Decimal.Constructor;
    static cos(n: Decimal.Value): Decimal;
    static cosh(n: Decimal.Value): Decimal;
    static div(x: Decimal.Value, y: Decimal.Value): Decimal;
    static exp(n: Decimal.Value): Decimal;
    static floor(n: Decimal.Value): Decimal;
    static hypot(...n: Decimal.Value[]): Decimal;
    static isDecimal(object: any): object is Decimal;
    static ln(n: Decimal.Value): Decimal;
    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
    static log2(n: Decimal.Value): Decimal;
    static log10(n: Decimal.Value): Decimal;
    static max(...n: Decimal.Value[]): Decimal;
    static min(...n: Decimal.Value[]): Decimal;
    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
    static noConflict(): Decimal.Constructor;   // Browser only
    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
    static random(significantDigits?: number): Decimal;
    static round(n: Decimal.Value): Decimal;
    static set(object: Decimal.Config): Decimal.Constructor;
    static sign(n: Decimal.Value): number;
    static sin(n: Decimal.Value): Decimal;
    static sinh(n: Decimal.Value): Decimal;
    static sqrt(n: Decimal.Value): Decimal;
    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
    static sum(...n: Decimal.Value[]): Decimal;
    static tan(n: Decimal.Value): Decimal;
    static tanh(n: Decimal.Value): Decimal;
    static trunc(n: Decimal.Value): Decimal;

    static readonly default?: Decimal.Constructor;
    static readonly Decimal?: Decimal.Constructor;

    static readonly precision: number;
    static readonly rounding: Decimal.Rounding;
    static readonly toExpNeg: number;
    static readonly toExpPos: number;
    static readonly minE: number;
    static readonly maxE: number;
    static readonly crypto: boolean;
    static readonly modulo: Decimal.Modulo;

    static readonly ROUND_UP: 0;
    static readonly ROUND_DOWN: 1;
    static readonly ROUND_CEIL: 2;
    static readonly ROUND_FLOOR: 3;
    static readonly ROUND_HALF_UP: 4;
    static readonly ROUND_HALF_DOWN: 5;
    static readonly ROUND_HALF_EVEN: 6;
    static readonly ROUND_HALF_CEIL: 7;
    static readonly ROUND_HALF_FLOOR: 8;
    static readonly EUCLID: 9;
}

declare type Exact<A, W> = (A extends unknown ? (W extends A ? {
    [K in keyof A]: Exact<A[K], W[K]>;
} : W) : never) | (A extends Narrowable ? A : never);

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
    id: RuntimeName;
    prettyName: string;
    isEdge: boolean;
};

declare class JsonNull extends NullTypesEnumValue {
    private readonly _brand_JsonNull;
}

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;

declare type Narrowable = string | number | bigint | boolean | [];

declare class NullTypesEnumValue extends ObjectEnumValue {
    _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
declare abstract class ObjectEnumValue {
    constructor(arg?: symbol);
    abstract _getNamespace(): string;
    _getName(): string;
    toString(): string;
}

export declare const objectEnumValues: {
    classes: {
        DbNull: typeof DbNull;
        JsonNull: typeof JsonNull;
        AnyNull: typeof AnyNull;
    };
    instances: {
        DbNull: DbNull;
        JsonNull: JsonNull;
        AnyNull: AnyNull;
    };
};

declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';

declare namespace Public {
    export {
        validator
    }
}
export { Public }

declare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

export { }

```

## 📄 lib\generated\prisma\runtime\index-browser.js

```js
"use strict";var ne=Object.defineProperty;var We=Object.getOwnPropertyDescriptor;var Ge=Object.getOwnPropertyNames;var Je=Object.prototype.hasOwnProperty;var Xe=(e,n,i)=>n in e?ne(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i;var Ce=(e,n)=>{for(var i in n)ne(e,i,{get:n[i],enumerable:!0})},Ke=(e,n,i,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of Ge(n))!Je.call(e,r)&&r!==i&&ne(e,r,{get:()=>n[r],enumerable:!(t=We(n,r))||t.enumerable});return e};var Qe=e=>Ke(ne({},"__esModule",{value:!0}),e);var ie=(e,n,i)=>Xe(e,typeof n!="symbol"?n+"":n,i);var yn={};Ce(yn,{Decimal:()=>je,Public:()=>ge,getRuntime:()=>Re,makeStrictEnum:()=>Oe,objectEnumValues:()=>Pe});module.exports=Qe(yn);var ge={};Ce(ge,{validator:()=>be});function be(...e){return n=>n}var te=Symbol(),me=new WeakMap,we=class{constructor(n){n===te?me.set(this,"Prisma.".concat(this._getName())):me.set(this,"new Prisma.".concat(this._getNamespace(),".").concat(this._getName(),"()"))}_getName(){return this.constructor.name}toString(){return me.get(this)}},G=class extends we{_getNamespace(){return"NullTypes"}},J=class extends G{constructor(){super(...arguments);ie(this,"_brand_DbNull")}};Ne(J,"DbNull");var X=class extends G{constructor(){super(...arguments);ie(this,"_brand_JsonNull")}};Ne(X,"JsonNull");var K=class extends G{constructor(){super(...arguments);ie(this,"_brand_AnyNull")}};Ne(K,"AnyNull");var Pe={classes:{DbNull:J,JsonNull:X,AnyNull:K},instances:{DbNull:new J(te),JsonNull:new X(te),AnyNull:new K(te)}};function Ne(e,n){Object.defineProperty(e,"name",{value:n,configurable:!0})}var Ye=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Oe(e){return new Proxy(e,{get(n,i){if(i in n)return n[i];if(!Ye.has(i))throw new TypeError("Invalid enum value: ".concat(String(i)))}})}var xe=()=>{var e,n;return((n=(e=globalThis.process)==null?void 0:e.release)==null?void 0:n.name)==="node"},ze=()=>{var e,n;return!!globalThis.Bun||!!((n=(e=globalThis.process)==null?void 0:e.versions)!=null&&n.bun)},ye=()=>!!globalThis.Deno,en=()=>typeof globalThis.Netlify=="object",nn=()=>typeof globalThis.EdgeRuntime=="object",tn=()=>{var e;return((e=globalThis.navigator)==null?void 0:e.userAgent)==="Cloudflare-Workers"};function rn(){var i;return(i=[[en,"netlify"],[nn,"edge-light"],[tn,"workerd"],[ye,"deno"],[ze,"bun"],[xe,"node"]].flatMap(t=>t[0]()?[t[1]]:[]).at(0))!=null?i:""}var sn={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function Re(){let e=rn();return{id:e,prettyName:sn[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}var V=9e15,H=1e9,ve="0123456789abcdef",oe="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",ue="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Ee={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-V,maxE:V,crypto:!1},Te,Z,w=!0,ce="[DecimalError] ",$=ce+"Invalid argument: ",De=ce+"Precision limit exceeded",Fe=ce+"crypto unavailable",Le="[object Decimal]",R=Math.floor,C=Math.pow,on=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,un=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,fn=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Ie=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,D=1e7,m=7,cn=9007199254740991,ln=oe.length-1,ke=ue.length-1,h={toStringTag:Le};h.absoluteValue=h.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),p(e)};h.ceil=function(){return p(new this.constructor(this),this.e+1,2)};h.clampedTo=h.clamp=function(e,n){var i,t=this,r=t.constructor;if(e=new r(e),n=new r(n),!e.s||!n.s)return new r(NaN);if(e.gt(n))throw Error($+n);return i=t.cmp(e),i<0?e:t.cmp(n)>0?n:new r(t)};h.comparedTo=h.cmp=function(e){var n,i,t,r,s=this,o=s.d,u=(e=new s.constructor(e)).d,c=s.s,f=e.s;if(!o||!u)return!c||!f?NaN:c!==f?c:o===u?0:!o^c<0?1:-1;if(!o[0]||!u[0])return o[0]?c:u[0]?-f:0;if(c!==f)return c;if(s.e!==e.e)return s.e>e.e^c<0?1:-1;for(t=o.length,r=u.length,n=0,i=t<r?t:r;n<i;++n)if(o[n]!==u[n])return o[n]>u[n]^c<0?1:-1;return t===r?0:t>r^c<0?1:-1};h.cosine=h.cos=function(){var e,n,i=this,t=i.constructor;return i.d?i.d[0]?(e=t.precision,n=t.rounding,t.precision=e+Math.max(i.e,i.sd())+m,t.rounding=1,i=an(t,He(t,i)),t.precision=e,t.rounding=n,p(Z==2||Z==3?i.neg():i,e,n,!0)):new t(1):new t(NaN)};h.cubeRoot=h.cbrt=function(){var e,n,i,t,r,s,o,u,c,f,l=this,a=l.constructor;if(!l.isFinite()||l.isZero())return new a(l);for(w=!1,s=l.s*C(l.s*l,1/3),!s||Math.abs(s)==1/0?(i=b(l.d),e=l.e,(s=(e-i.length+1)%3)&&(i+=s==1||s==-2?"0":"00"),s=C(i,1/3),e=R((e+1)/3)-(e%3==(e<0?-1:2)),s==1/0?i="5e"+e:(i=s.toExponential(),i=i.slice(0,i.indexOf("e")+1)+e),t=new a(i),t.s=l.s):t=new a(s.toString()),o=(e=a.precision)+3;;)if(u=t,c=u.times(u).times(u),f=c.plus(l),t=k(f.plus(l).times(u),f.plus(c),o+2,1),b(u.d).slice(0,o)===(i=b(t.d)).slice(0,o))if(i=i.slice(o-3,o+1),i=="9999"||!r&&i=="4999"){if(!r&&(p(u,e+1,0),u.times(u).times(u).eq(l))){t=u;break}o+=4,r=1}else{(!+i||!+i.slice(1)&&i.charAt(0)=="5")&&(p(t,e+1,1),n=!t.times(t).times(t).eq(l));break}return w=!0,p(t,e,a.rounding,n)};h.decimalPlaces=h.dp=function(){var e,n=this.d,i=NaN;if(n){if(e=n.length-1,i=(e-R(this.e/m))*m,e=n[e],e)for(;e%10==0;e/=10)i--;i<0&&(i=0)}return i};h.dividedBy=h.div=function(e){return k(this,new this.constructor(e))};h.dividedToIntegerBy=h.divToInt=function(e){var n=this,i=n.constructor;return p(k(n,new i(e),0,1,1),i.precision,i.rounding)};h.equals=h.eq=function(e){return this.cmp(e)===0};h.floor=function(){return p(new this.constructor(this),this.e+1,3)};h.greaterThan=h.gt=function(e){return this.cmp(e)>0};h.greaterThanOrEqualTo=h.gte=function(e){var n=this.cmp(e);return n==1||n===0};h.hyperbolicCosine=h.cosh=function(){var e,n,i,t,r,s=this,o=s.constructor,u=new o(1);if(!s.isFinite())return new o(s.s?1/0:NaN);if(s.isZero())return u;i=o.precision,t=o.rounding,o.precision=i+Math.max(s.e,s.sd())+4,o.rounding=1,r=s.d.length,r<32?(e=Math.ceil(r/3),n=(1/ae(4,e)).toString()):(e=16,n="2.3283064365386962890625e-10"),s=j(o,1,s.times(n),new o(1),!0);for(var c,f=e,l=new o(8);f--;)c=s.times(s),s=u.minus(c.times(l.minus(c.times(l))));return p(s,o.precision=i,o.rounding=t,!0)};h.hyperbolicSine=h.sinh=function(){var e,n,i,t,r=this,s=r.constructor;if(!r.isFinite()||r.isZero())return new s(r);if(n=s.precision,i=s.rounding,s.precision=n+Math.max(r.e,r.sd())+4,s.rounding=1,t=r.d.length,t<3)r=j(s,2,r,r,!0);else{e=1.4*Math.sqrt(t),e=e>16?16:e|0,r=r.times(1/ae(5,e)),r=j(s,2,r,r,!0);for(var o,u=new s(5),c=new s(16),f=new s(20);e--;)o=r.times(r),r=r.times(u.plus(o.times(c.times(o).plus(f))))}return s.precision=n,s.rounding=i,p(r,n,i,!0)};h.hyperbolicTangent=h.tanh=function(){var e,n,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(e=t.precision,n=t.rounding,t.precision=e+7,t.rounding=1,k(i.sinh(),i.cosh(),t.precision=e,t.rounding=n)):new t(i.s)};h.inverseCosine=h.acos=function(){var e=this,n=e.constructor,i=e.abs().cmp(1),t=n.precision,r=n.rounding;return i!==-1?i===0?e.isNeg()?F(n,t,r):new n(0):new n(NaN):e.isZero()?F(n,t+4,r).times(.5):(n.precision=t+6,n.rounding=1,e=new n(1).minus(e).div(e.plus(1)).sqrt().atan(),n.precision=t,n.rounding=r,e.times(2))};h.inverseHyperbolicCosine=h.acosh=function(){var e,n,i=this,t=i.constructor;return i.lte(1)?new t(i.eq(1)?0:NaN):i.isFinite()?(e=t.precision,n=t.rounding,t.precision=e+Math.max(Math.abs(i.e),i.sd())+4,t.rounding=1,w=!1,i=i.times(i).minus(1).sqrt().plus(i),w=!0,t.precision=e,t.rounding=n,i.ln()):new t(i)};h.inverseHyperbolicSine=h.asinh=function(){var e,n,i=this,t=i.constructor;return!i.isFinite()||i.isZero()?new t(i):(e=t.precision,n=t.rounding,t.precision=e+2*Math.max(Math.abs(i.e),i.sd())+6,t.rounding=1,w=!1,i=i.times(i).plus(1).sqrt().plus(i),w=!0,t.precision=e,t.rounding=n,i.ln())};h.inverseHyperbolicTangent=h.atanh=function(){var e,n,i,t,r=this,s=r.constructor;return r.isFinite()?r.e>=0?new s(r.abs().eq(1)?r.s/0:r.isZero()?r:NaN):(e=s.precision,n=s.rounding,t=r.sd(),Math.max(t,e)<2*-r.e-1?p(new s(r),e,n,!0):(s.precision=i=t-r.e,r=k(r.plus(1),new s(1).minus(r),i+e,1),s.precision=e+4,s.rounding=1,r=r.ln(),s.precision=e,s.rounding=n,r.times(.5))):new s(NaN)};h.inverseSine=h.asin=function(){var e,n,i,t,r=this,s=r.constructor;return r.isZero()?new s(r):(n=r.abs().cmp(1),i=s.precision,t=s.rounding,n!==-1?n===0?(e=F(s,i+4,t).times(.5),e.s=r.s,e):new s(NaN):(s.precision=i+6,s.rounding=1,r=r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(),s.precision=i,s.rounding=t,r.times(2)))};h.inverseTangent=h.atan=function(){var e,n,i,t,r,s,o,u,c,f=this,l=f.constructor,a=l.precision,d=l.rounding;if(f.isFinite()){if(f.isZero())return new l(f);if(f.abs().eq(1)&&a+4<=ke)return o=F(l,a+4,d).times(.25),o.s=f.s,o}else{if(!f.s)return new l(NaN);if(a+4<=ke)return o=F(l,a+4,d).times(.5),o.s=f.s,o}for(l.precision=u=a+10,l.rounding=1,i=Math.min(28,u/m+2|0),e=i;e;--e)f=f.div(f.times(f).plus(1).sqrt().plus(1));for(w=!1,n=Math.ceil(u/m),t=1,c=f.times(f),o=new l(f),r=f;e!==-1;)if(r=r.times(c),s=o.minus(r.div(t+=2)),r=r.times(c),o=s.plus(r.div(t+=2)),o.d[n]!==void 0)for(e=n;o.d[e]===s.d[e]&&e--;);return i&&(o=o.times(2<<i-1)),w=!0,p(o,l.precision=a,l.rounding=d,!0)};h.isFinite=function(){return!!this.d};h.isInteger=h.isInt=function(){return!!this.d&&R(this.e/m)>this.d.length-2};h.isNaN=function(){return!this.s};h.isNegative=h.isNeg=function(){return this.s<0};h.isPositive=h.isPos=function(){return this.s>0};h.isZero=function(){return!!this.d&&this.d[0]===0};h.lessThan=h.lt=function(e){return this.cmp(e)<0};h.lessThanOrEqualTo=h.lte=function(e){return this.cmp(e)<1};h.logarithm=h.log=function(e){var n,i,t,r,s,o,u,c,f=this,l=f.constructor,a=l.precision,d=l.rounding,g=5;if(e==null)e=new l(10),n=!0;else{if(e=new l(e),i=e.d,e.s<0||!i||!i[0]||e.eq(1))return new l(NaN);n=e.eq(10)}if(i=f.d,f.s<0||!i||!i[0]||f.eq(1))return new l(i&&!i[0]?-1/0:f.s!=1?NaN:i?0:1/0);if(n)if(i.length>1)s=!0;else{for(r=i[0];r%10===0;)r/=10;s=r!==1}if(w=!1,u=a+g,o=B(f,u),t=n?fe(l,u+10):B(e,u),c=k(o,t,u,1),Q(c.d,r=a,d))do if(u+=10,o=B(f,u),t=n?fe(l,u+10):B(e,u),c=k(o,t,u,1),!s){+b(c.d).slice(r+1,r+15)+1==1e14&&(c=p(c,a+1,0));break}while(Q(c.d,r+=10,d));return w=!0,p(c,a,d)};h.minus=h.sub=function(e){var n,i,t,r,s,o,u,c,f,l,a,d,g=this,v=g.constructor;if(e=new v(e),!g.d||!e.d)return!g.s||!e.s?e=new v(NaN):g.d?e.s=-e.s:e=new v(e.d||g.s!==e.s?g:NaN),e;if(g.s!=e.s)return e.s=-e.s,g.plus(e);if(f=g.d,d=e.d,u=v.precision,c=v.rounding,!f[0]||!d[0]){if(d[0])e.s=-e.s;else if(f[0])e=new v(g);else return new v(c===3?-0:0);return w?p(e,u,c):e}if(i=R(e.e/m),l=R(g.e/m),f=f.slice(),s=l-i,s){for(a=s<0,a?(n=f,s=-s,o=d.length):(n=d,i=l,o=f.length),t=Math.max(Math.ceil(u/m),o)+2,s>t&&(s=t,n.length=1),n.reverse(),t=s;t--;)n.push(0);n.reverse()}else{for(t=f.length,o=d.length,a=t<o,a&&(o=t),t=0;t<o;t++)if(f[t]!=d[t]){a=f[t]<d[t];break}s=0}for(a&&(n=f,f=d,d=n,e.s=-e.s),o=f.length,t=d.length-o;t>0;--t)f[o++]=0;for(t=d.length;t>s;){if(f[--t]<d[t]){for(r=t;r&&f[--r]===0;)f[r]=D-1;--f[r],f[t]+=D}f[t]-=d[t]}for(;f[--o]===0;)f.pop();for(;f[0]===0;f.shift())--i;return f[0]?(e.d=f,e.e=le(f,i),w?p(e,u,c):e):new v(c===3?-0:0)};h.modulo=h.mod=function(e){var n,i=this,t=i.constructor;return e=new t(e),!i.d||!e.s||e.d&&!e.d[0]?new t(NaN):!e.d||i.d&&!i.d[0]?p(new t(i),t.precision,t.rounding):(w=!1,t.modulo==9?(n=k(i,e.abs(),0,3,1),n.s*=e.s):n=k(i,e,0,t.modulo,1),n=n.times(e),w=!0,i.minus(n))};h.naturalExponential=h.exp=function(){return Se(this)};h.naturalLogarithm=h.ln=function(){return B(this)};h.negated=h.neg=function(){var e=new this.constructor(this);return e.s=-e.s,p(e)};h.plus=h.add=function(e){var n,i,t,r,s,o,u,c,f,l,a=this,d=a.constructor;if(e=new d(e),!a.d||!e.d)return!a.s||!e.s?e=new d(NaN):a.d||(e=new d(e.d||a.s===e.s?a:NaN)),e;if(a.s!=e.s)return e.s=-e.s,a.minus(e);if(f=a.d,l=e.d,u=d.precision,c=d.rounding,!f[0]||!l[0])return l[0]||(e=new d(a)),w?p(e,u,c):e;if(s=R(a.e/m),t=R(e.e/m),f=f.slice(),r=s-t,r){for(r<0?(i=f,r=-r,o=l.length):(i=l,t=s,o=f.length),s=Math.ceil(u/m),o=s>o?s+1:o+1,r>o&&(r=o,i.length=1),i.reverse();r--;)i.push(0);i.reverse()}for(o=f.length,r=l.length,o-r<0&&(r=o,i=l,l=f,f=i),n=0;r;)n=(f[--r]=f[r]+l[r]+n)/D|0,f[r]%=D;for(n&&(f.unshift(n),++t),o=f.length;f[--o]==0;)f.pop();return e.d=f,e.e=le(f,t),w?p(e,u,c):e};h.precision=h.sd=function(e){var n,i=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error($+e);return i.d?(n=Ze(i.d),e&&i.e+1>n&&(n=i.e+1)):n=NaN,n};h.round=function(){var e=this,n=e.constructor;return p(new n(e),e.e+1,n.rounding)};h.sine=h.sin=function(){var e,n,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(e=t.precision,n=t.rounding,t.precision=e+Math.max(i.e,i.sd())+m,t.rounding=1,i=hn(t,He(t,i)),t.precision=e,t.rounding=n,p(Z>2?i.neg():i,e,n,!0)):new t(NaN)};h.squareRoot=h.sqrt=function(){var e,n,i,t,r,s,o=this,u=o.d,c=o.e,f=o.s,l=o.constructor;if(f!==1||!u||!u[0])return new l(!f||f<0&&(!u||u[0])?NaN:u?o:1/0);for(w=!1,f=Math.sqrt(+o),f==0||f==1/0?(n=b(u),(n.length+c)%2==0&&(n+="0"),f=Math.sqrt(n),c=R((c+1)/2)-(c<0||c%2),f==1/0?n="5e"+c:(n=f.toExponential(),n=n.slice(0,n.indexOf("e")+1)+c),t=new l(n)):t=new l(f.toString()),i=(c=l.precision)+3;;)if(s=t,t=s.plus(k(o,s,i+2,1)).times(.5),b(s.d).slice(0,i)===(n=b(t.d)).slice(0,i))if(n=n.slice(i-3,i+1),n=="9999"||!r&&n=="4999"){if(!r&&(p(s,c+1,0),s.times(s).eq(o))){t=s;break}i+=4,r=1}else{(!+n||!+n.slice(1)&&n.charAt(0)=="5")&&(p(t,c+1,1),e=!t.times(t).eq(o));break}return w=!0,p(t,c,l.rounding,e)};h.tangent=h.tan=function(){var e,n,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(e=t.precision,n=t.rounding,t.precision=e+10,t.rounding=1,i=i.sin(),i.s=1,i=k(i,new t(1).minus(i.times(i)).sqrt(),e+10,0),t.precision=e,t.rounding=n,p(Z==2||Z==4?i.neg():i,e,n,!0)):new t(NaN)};h.times=h.mul=function(e){var n,i,t,r,s,o,u,c,f,l=this,a=l.constructor,d=l.d,g=(e=new a(e)).d;if(e.s*=l.s,!d||!d[0]||!g||!g[0])return new a(!e.s||d&&!d[0]&&!g||g&&!g[0]&&!d?NaN:!d||!g?e.s/0:e.s*0);for(i=R(l.e/m)+R(e.e/m),c=d.length,f=g.length,c<f&&(s=d,d=g,g=s,o=c,c=f,f=o),s=[],o=c+f,t=o;t--;)s.push(0);for(t=f;--t>=0;){for(n=0,r=c+t;r>t;)u=s[r]+g[t]*d[r-t-1]+n,s[r--]=u%D|0,n=u/D|0;s[r]=(s[r]+n)%D|0}for(;!s[--o];)s.pop();return n?++i:s.shift(),e.d=s,e.e=le(s,i),w?p(e,a.precision,a.rounding):e};h.toBinary=function(e,n){return Me(this,2,e,n)};h.toDecimalPlaces=h.toDP=function(e,n){var i=this,t=i.constructor;return i=new t(i),e===void 0?i:(q(e,0,H),n===void 0?n=t.rounding:q(n,0,8),p(i,e+i.e+1,n))};h.toExponential=function(e,n){var i,t=this,r=t.constructor;return e===void 0?i=L(t,!0):(q(e,0,H),n===void 0?n=r.rounding:q(n,0,8),t=p(new r(t),e+1,n),i=L(t,!0,e+1)),t.isNeg()&&!t.isZero()?"-"+i:i};h.toFixed=function(e,n){var i,t,r=this,s=r.constructor;return e===void 0?i=L(r):(q(e,0,H),n===void 0?n=s.rounding:q(n,0,8),t=p(new s(r),e+r.e+1,n),i=L(t,!1,e+t.e+1)),r.isNeg()&&!r.isZero()?"-"+i:i};h.toFraction=function(e){var n,i,t,r,s,o,u,c,f,l,a,d,g=this,v=g.d,N=g.constructor;if(!v)return new N(g);if(f=i=new N(1),t=c=new N(0),n=new N(t),s=n.e=Ze(v)-g.e-1,o=s%m,n.d[0]=C(10,o<0?m+o:o),e==null)e=s>0?n:f;else{if(u=new N(e),!u.isInt()||u.lt(f))throw Error($+u);e=u.gt(n)?s>0?n:f:u}for(w=!1,u=new N(b(v)),l=N.precision,N.precision=s=v.length*m*2;a=k(u,n,0,1,1),r=i.plus(a.times(t)),r.cmp(e)!=1;)i=t,t=r,r=f,f=c.plus(a.times(r)),c=r,r=n,n=u.minus(a.times(r)),u=r;return r=k(e.minus(i),t,0,1,1),c=c.plus(r.times(f)),i=i.plus(r.times(t)),c.s=f.s=g.s,d=k(f,t,s,1).minus(g).abs().cmp(k(c,i,s,1).minus(g).abs())<1?[f,t]:[c,i],N.precision=l,w=!0,d};h.toHexadecimal=h.toHex=function(e,n){return Me(this,16,e,n)};h.toNearest=function(e,n){var i=this,t=i.constructor;if(i=new t(i),e==null){if(!i.d)return i;e=new t(1),n=t.rounding}else{if(e=new t(e),n===void 0?n=t.rounding:q(n,0,8),!i.d)return e.s?i:e;if(!e.d)return e.s&&(e.s=i.s),e}return e.d[0]?(w=!1,i=k(i,e,0,n,1).times(e),w=!0,p(i)):(e.s=i.s,i=e),i};h.toNumber=function(){return+this};h.toOctal=function(e,n){return Me(this,8,e,n)};h.toPower=h.pow=function(e){var n,i,t,r,s,o,u=this,c=u.constructor,f=+(e=new c(e));if(!u.d||!e.d||!u.d[0]||!e.d[0])return new c(C(+u,f));if(u=new c(u),u.eq(1))return u;if(t=c.precision,s=c.rounding,e.eq(1))return p(u,t,s);if(n=R(e.e/m),n>=e.d.length-1&&(i=f<0?-f:f)<=cn)return r=Ue(c,u,i,t),e.s<0?new c(1).div(r):p(r,t,s);if(o=u.s,o<0){if(n<e.d.length-1)return new c(NaN);if((e.d[n]&1)==0&&(o=1),u.e==0&&u.d[0]==1&&u.d.length==1)return u.s=o,u}return i=C(+u,f),n=i==0||!isFinite(i)?R(f*(Math.log("0."+b(u.d))/Math.LN10+u.e+1)):new c(i+"").e,n>c.maxE+1||n<c.minE-1?new c(n>0?o/0:0):(w=!1,c.rounding=u.s=1,i=Math.min(12,(n+"").length),r=Se(e.times(B(u,t+i)),t),r.d&&(r=p(r,t+5,1),Q(r.d,t,s)&&(n=t+10,r=p(Se(e.times(B(u,n+i)),n),n+5,1),+b(r.d).slice(t+1,t+15)+1==1e14&&(r=p(r,t+1,0)))),r.s=o,w=!0,c.rounding=s,p(r,t,s))};h.toPrecision=function(e,n){var i,t=this,r=t.constructor;return e===void 0?i=L(t,t.e<=r.toExpNeg||t.e>=r.toExpPos):(q(e,1,H),n===void 0?n=r.rounding:q(n,0,8),t=p(new r(t),e,n),i=L(t,e<=t.e||t.e<=r.toExpNeg,e)),t.isNeg()&&!t.isZero()?"-"+i:i};h.toSignificantDigits=h.toSD=function(e,n){var i=this,t=i.constructor;return e===void 0?(e=t.precision,n=t.rounding):(q(e,1,H),n===void 0?n=t.rounding:q(n,0,8)),p(new t(i),e,n)};h.toString=function(){var e=this,n=e.constructor,i=L(e,e.e<=n.toExpNeg||e.e>=n.toExpPos);return e.isNeg()&&!e.isZero()?"-"+i:i};h.truncated=h.trunc=function(){return p(new this.constructor(this),this.e+1,1)};h.valueOf=h.toJSON=function(){var e=this,n=e.constructor,i=L(e,e.e<=n.toExpNeg||e.e>=n.toExpPos);return e.isNeg()?"-"+i:i};function b(e){var n,i,t,r=e.length-1,s="",o=e[0];if(r>0){for(s+=o,n=1;n<r;n++)t=e[n]+"",i=m-t.length,i&&(s+=U(i)),s+=t;o=e[n],t=o+"",i=m-t.length,i&&(s+=U(i))}else if(o===0)return"0";for(;o%10===0;)o/=10;return s+o}function q(e,n,i){if(e!==~~e||e<n||e>i)throw Error($+e)}function Q(e,n,i,t){var r,s,o,u;for(s=e[0];s>=10;s/=10)--n;return--n<0?(n+=m,r=0):(r=Math.ceil((n+1)/m),n%=m),s=C(10,m-n),u=e[r]%s|0,t==null?n<3?(n==0?u=u/100|0:n==1&&(u=u/10|0),o=i<4&&u==99999||i>3&&u==49999||u==5e4||u==0):o=(i<4&&u+1==s||i>3&&u+1==s/2)&&(e[r+1]/s/100|0)==C(10,n-2)-1||(u==s/2||u==0)&&(e[r+1]/s/100|0)==0:n<4?(n==0?u=u/1e3|0:n==1?u=u/100|0:n==2&&(u=u/10|0),o=(t||i<4)&&u==9999||!t&&i>3&&u==4999):o=((t||i<4)&&u+1==s||!t&&i>3&&u+1==s/2)&&(e[r+1]/s/1e3|0)==C(10,n-3)-1,o}function re(e,n,i){for(var t,r=[0],s,o=0,u=e.length;o<u;){for(s=r.length;s--;)r[s]*=n;for(r[0]+=ve.indexOf(e.charAt(o++)),t=0;t<r.length;t++)r[t]>i-1&&(r[t+1]===void 0&&(r[t+1]=0),r[t+1]+=r[t]/i|0,r[t]%=i)}return r.reverse()}function an(e,n){var i,t,r;if(n.isZero())return n;t=n.d.length,t<32?(i=Math.ceil(t/3),r=(1/ae(4,i)).toString()):(i=16,r="2.3283064365386962890625e-10"),e.precision+=i,n=j(e,1,n.times(r),new e(1));for(var s=i;s--;){var o=n.times(n);n=o.times(o).minus(o).times(8).plus(1)}return e.precision-=i,n}var k=function(){function e(t,r,s){var o,u=0,c=t.length;for(t=t.slice();c--;)o=t[c]*r+u,t[c]=o%s|0,u=o/s|0;return u&&t.unshift(u),t}function n(t,r,s,o){var u,c;if(s!=o)c=s>o?1:-1;else for(u=c=0;u<s;u++)if(t[u]!=r[u]){c=t[u]>r[u]?1:-1;break}return c}function i(t,r,s,o){for(var u=0;s--;)t[s]-=u,u=t[s]<r[s]?1:0,t[s]=u*o+t[s]-r[s];for(;!t[0]&&t.length>1;)t.shift()}return function(t,r,s,o,u,c){var f,l,a,d,g,v,N,A,M,_,E,P,x,I,de,z,W,he,T,y,ee=t.constructor,pe=t.s==r.s?1:-1,O=t.d,S=r.d;if(!O||!O[0]||!S||!S[0])return new ee(!t.s||!r.s||(O?S&&O[0]==S[0]:!S)?NaN:O&&O[0]==0||!S?pe*0:pe/0);for(c?(g=1,l=t.e-r.e):(c=D,g=m,l=R(t.e/g)-R(r.e/g)),T=S.length,W=O.length,M=new ee(pe),_=M.d=[],a=0;S[a]==(O[a]||0);a++);if(S[a]>(O[a]||0)&&l--,s==null?(I=s=ee.precision,o=ee.rounding):u?I=s+(t.e-r.e)+1:I=s,I<0)_.push(1),v=!0;else{if(I=I/g+2|0,a=0,T==1){for(d=0,S=S[0],I++;(a<W||d)&&I--;a++)de=d*c+(O[a]||0),_[a]=de/S|0,d=de%S|0;v=d||a<W}else{for(d=c/(S[0]+1)|0,d>1&&(S=e(S,d,c),O=e(O,d,c),T=S.length,W=O.length),z=T,E=O.slice(0,T),P=E.length;P<T;)E[P++]=0;y=S.slice(),y.unshift(0),he=S[0],S[1]>=c/2&&++he;do d=0,f=n(S,E,T,P),f<0?(x=E[0],T!=P&&(x=x*c+(E[1]||0)),d=x/he|0,d>1?(d>=c&&(d=c-1),N=e(S,d,c),A=N.length,P=E.length,f=n(N,E,A,P),f==1&&(d--,i(N,T<A?y:S,A,c))):(d==0&&(f=d=1),N=S.slice()),A=N.length,A<P&&N.unshift(0),i(E,N,P,c),f==-1&&(P=E.length,f=n(S,E,T,P),f<1&&(d++,i(E,T<P?y:S,P,c))),P=E.length):f===0&&(d++,E=[0]),_[a++]=d,f&&E[0]?E[P++]=O[z]||0:(E=[O[z]],P=1);while((z++<W||E[0]!==void 0)&&I--);v=E[0]!==void 0}_[0]||_.shift()}if(g==1)M.e=l,Te=v;else{for(a=1,d=_[0];d>=10;d/=10)a++;M.e=a+l*g-1,p(M,u?s+M.e+1:s,o,v)}return M}}();function p(e,n,i,t){var r,s,o,u,c,f,l,a,d,g=e.constructor;e:if(n!=null){if(a=e.d,!a)return e;for(r=1,u=a[0];u>=10;u/=10)r++;if(s=n-r,s<0)s+=m,o=n,l=a[d=0],c=l/C(10,r-o-1)%10|0;else if(d=Math.ceil((s+1)/m),u=a.length,d>=u)if(t){for(;u++<=d;)a.push(0);l=c=0,r=1,s%=m,o=s-m+1}else break e;else{for(l=u=a[d],r=1;u>=10;u/=10)r++;s%=m,o=s-m+r,c=o<0?0:l/C(10,r-o-1)%10|0}if(t=t||n<0||a[d+1]!==void 0||(o<0?l:l%C(10,r-o-1)),f=i<4?(c||t)&&(i==0||i==(e.s<0?3:2)):c>5||c==5&&(i==4||t||i==6&&(s>0?o>0?l/C(10,r-o):0:a[d-1])%10&1||i==(e.s<0?8:7)),n<1||!a[0])return a.length=0,f?(n-=e.e+1,a[0]=C(10,(m-n%m)%m),e.e=-n||0):a[0]=e.e=0,e;if(s==0?(a.length=d,u=1,d--):(a.length=d+1,u=C(10,m-s),a[d]=o>0?(l/C(10,r-o)%C(10,o)|0)*u:0),f)for(;;)if(d==0){for(s=1,o=a[0];o>=10;o/=10)s++;for(o=a[0]+=u,u=1;o>=10;o/=10)u++;s!=u&&(e.e++,a[0]==D&&(a[0]=1));break}else{if(a[d]+=u,a[d]!=D)break;a[d--]=0,u=1}for(s=a.length;a[--s]===0;)a.pop()}return w&&(e.e>g.maxE?(e.d=null,e.e=NaN):e.e<g.minE&&(e.e=0,e.d=[0])),e}function L(e,n,i){if(!e.isFinite())return $e(e);var t,r=e.e,s=b(e.d),o=s.length;return n?(i&&(t=i-o)>0?s=s.charAt(0)+"."+s.slice(1)+U(t):o>1&&(s=s.charAt(0)+"."+s.slice(1)),s=s+(e.e<0?"e":"e+")+e.e):r<0?(s="0."+U(-r-1)+s,i&&(t=i-o)>0&&(s+=U(t))):r>=o?(s+=U(r+1-o),i&&(t=i-r-1)>0&&(s=s+"."+U(t))):((t=r+1)<o&&(s=s.slice(0,t)+"."+s.slice(t)),i&&(t=i-o)>0&&(r+1===o&&(s+="."),s+=U(t))),s}function le(e,n){var i=e[0];for(n*=m;i>=10;i/=10)n++;return n}function fe(e,n,i){if(n>ln)throw w=!0,i&&(e.precision=i),Error(De);return p(new e(oe),n,1,!0)}function F(e,n,i){if(n>ke)throw Error(De);return p(new e(ue),n,i,!0)}function Ze(e){var n=e.length-1,i=n*m+1;if(n=e[n],n){for(;n%10==0;n/=10)i--;for(n=e[0];n>=10;n/=10)i++}return i}function U(e){for(var n="";e--;)n+="0";return n}function Ue(e,n,i,t){var r,s=new e(1),o=Math.ceil(t/m+4);for(w=!1;;){if(i%2&&(s=s.times(n),qe(s.d,o)&&(r=!0)),i=R(i/2),i===0){i=s.d.length-1,r&&s.d[i]===0&&++s.d[i];break}n=n.times(n),qe(n.d,o)}return w=!0,s}function Ae(e){return e.d[e.d.length-1]&1}function Be(e,n,i){for(var t,r,s=new e(n[0]),o=0;++o<n.length;){if(r=new e(n[o]),!r.s){s=r;break}t=s.cmp(r),(t===i||t===0&&s.s===i)&&(s=r)}return s}function Se(e,n){var i,t,r,s,o,u,c,f=0,l=0,a=0,d=e.constructor,g=d.rounding,v=d.precision;if(!e.d||!e.d[0]||e.e>17)return new d(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(n==null?(w=!1,c=v):c=n,u=new d(.03125);e.e>-2;)e=e.times(u),a+=5;for(t=Math.log(C(2,a))/Math.LN10*2+5|0,c+=t,i=s=o=new d(1),d.precision=c;;){if(s=p(s.times(e),c,1),i=i.times(++l),u=o.plus(k(s,i,c,1)),b(u.d).slice(0,c)===b(o.d).slice(0,c)){for(r=a;r--;)o=p(o.times(o),c,1);if(n==null)if(f<3&&Q(o.d,c-t,g,f))d.precision=c+=10,i=s=u=new d(1),l=0,f++;else return p(o,d.precision=v,g,w=!0);else return d.precision=v,o}o=u}}function B(e,n){var i,t,r,s,o,u,c,f,l,a,d,g=1,v=10,N=e,A=N.d,M=N.constructor,_=M.rounding,E=M.precision;if(N.s<0||!A||!A[0]||!N.e&&A[0]==1&&A.length==1)return new M(A&&!A[0]?-1/0:N.s!=1?NaN:A?0:N);if(n==null?(w=!1,l=E):l=n,M.precision=l+=v,i=b(A),t=i.charAt(0),Math.abs(s=N.e)<15e14){for(;t<7&&t!=1||t==1&&i.charAt(1)>3;)N=N.times(e),i=b(N.d),t=i.charAt(0),g++;s=N.e,t>1?(N=new M("0."+i),s++):N=new M(t+"."+i.slice(1))}else return f=fe(M,l+2,E).times(s+""),N=B(new M(t+"."+i.slice(1)),l-v).plus(f),M.precision=E,n==null?p(N,E,_,w=!0):N;for(a=N,c=o=N=k(N.minus(1),N.plus(1),l,1),d=p(N.times(N),l,1),r=3;;){if(o=p(o.times(d),l,1),f=c.plus(k(o,new M(r),l,1)),b(f.d).slice(0,l)===b(c.d).slice(0,l))if(c=c.times(2),s!==0&&(c=c.plus(fe(M,l+2,E).times(s+""))),c=k(c,new M(g),l,1),n==null)if(Q(c.d,l-v,_,u))M.precision=l+=v,f=o=N=k(a.minus(1),a.plus(1),l,1),d=p(N.times(N),l,1),r=u=1;else return p(c,M.precision=E,_,w=!0);else return M.precision=E,c;c=f,r+=2}}function $e(e){return String(e.s*e.s/0)}function se(e,n){var i,t,r;for((i=n.indexOf("."))>-1&&(n=n.replace(".","")),(t=n.search(/e/i))>0?(i<0&&(i=t),i+=+n.slice(t+1),n=n.substring(0,t)):i<0&&(i=n.length),t=0;n.charCodeAt(t)===48;t++);for(r=n.length;n.charCodeAt(r-1)===48;--r);if(n=n.slice(t,r),n){if(r-=t,e.e=i=i-t-1,e.d=[],t=(i+1)%m,i<0&&(t+=m),t<r){for(t&&e.d.push(+n.slice(0,t)),r-=m;t<r;)e.d.push(+n.slice(t,t+=m));n=n.slice(t),t=m-n.length}else t-=r;for(;t--;)n+="0";e.d.push(+n),w&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function dn(e,n){var i,t,r,s,o,u,c,f,l;if(n.indexOf("_")>-1){if(n=n.replace(/(\d)_(?=\d)/g,"$1"),Ie.test(n))return se(e,n)}else if(n==="Infinity"||n==="NaN")return+n||(e.s=NaN),e.e=NaN,e.d=null,e;if(un.test(n))i=16,n=n.toLowerCase();else if(on.test(n))i=2;else if(fn.test(n))i=8;else throw Error($+n);for(s=n.search(/p/i),s>0?(c=+n.slice(s+1),n=n.substring(2,s)):n=n.slice(2),s=n.indexOf("."),o=s>=0,t=e.constructor,o&&(n=n.replace(".",""),u=n.length,s=u-s,r=Ue(t,new t(i),s,s*2)),f=re(n,i,D),l=f.length-1,s=l;f[s]===0;--s)f.pop();return s<0?new t(e.s*0):(e.e=le(f,l),e.d=f,w=!1,o&&(e=k(e,r,u*4)),c&&(e=e.times(Math.abs(c)<54?C(2,c):Y.pow(2,c))),w=!0,e)}function hn(e,n){var i,t=n.d.length;if(t<3)return n.isZero()?n:j(e,2,n,n);i=1.4*Math.sqrt(t),i=i>16?16:i|0,n=n.times(1/ae(5,i)),n=j(e,2,n,n);for(var r,s=new e(5),o=new e(16),u=new e(20);i--;)r=n.times(n),n=n.times(s.plus(r.times(o.times(r).minus(u))));return n}function j(e,n,i,t,r){var s,o,u,c,f=1,l=e.precision,a=Math.ceil(l/m);for(w=!1,c=i.times(i),u=new e(t);;){if(o=k(u.times(c),new e(n++*n++),l,1),u=r?t.plus(o):t.minus(o),t=k(o.times(c),new e(n++*n++),l,1),o=u.plus(t),o.d[a]!==void 0){for(s=a;o.d[s]===u.d[s]&&s--;);if(s==-1)break}s=u,u=t,t=o,o=s,f++}return w=!0,o.d.length=a+1,o}function ae(e,n){for(var i=e;--n;)i*=e;return i}function He(e,n){var i,t=n.s<0,r=F(e,e.precision,1),s=r.times(.5);if(n=n.abs(),n.lte(s))return Z=t?4:1,n;if(i=n.divToInt(r),i.isZero())Z=t?3:2;else{if(n=n.minus(i.times(r)),n.lte(s))return Z=Ae(i)?t?2:3:t?4:1,n;Z=Ae(i)?t?1:4:t?3:2}return n.minus(r).abs()}function Me(e,n,i,t){var r,s,o,u,c,f,l,a,d,g=e.constructor,v=i!==void 0;if(v?(q(i,1,H),t===void 0?t=g.rounding:q(t,0,8)):(i=g.precision,t=g.rounding),!e.isFinite())l=$e(e);else{for(l=L(e),o=l.indexOf("."),v?(r=2,n==16?i=i*4-3:n==8&&(i=i*3-2)):r=n,o>=0&&(l=l.replace(".",""),d=new g(1),d.e=l.length-o,d.d=re(L(d),10,r),d.e=d.d.length),a=re(l,10,r),s=c=a.length;a[--c]==0;)a.pop();if(!a[0])l=v?"0p+0":"0";else{if(o<0?s--:(e=new g(e),e.d=a,e.e=s,e=k(e,d,i,t,0,r),a=e.d,s=e.e,f=Te),o=a[i],u=r/2,f=f||a[i+1]!==void 0,f=t<4?(o!==void 0||f)&&(t===0||t===(e.s<0?3:2)):o>u||o===u&&(t===4||f||t===6&&a[i-1]&1||t===(e.s<0?8:7)),a.length=i,f)for(;++a[--i]>r-1;)a[i]=0,i||(++s,a.unshift(1));for(c=a.length;!a[c-1];--c);for(o=0,l="";o<c;o++)l+=ve.charAt(a[o]);if(v){if(c>1)if(n==16||n==8){for(o=n==16?4:3,--c;c%o;c++)l+="0";for(a=re(l,r,n),c=a.length;!a[c-1];--c);for(o=1,l="1.";o<c;o++)l+=ve.charAt(a[o])}else l=l.charAt(0)+"."+l.slice(1);l=l+(s<0?"p":"p+")+s}else if(s<0){for(;++s;)l="0"+l;l="0."+l}else if(++s>c)for(s-=c;s--;)l+="0";else s<c&&(l=l.slice(0,s)+"."+l.slice(s))}l=(n==16?"0x":n==2?"0b":n==8?"0o":"")+l}return e.s<0?"-"+l:l}function qe(e,n){if(e.length>n)return e.length=n,!0}function pn(e){return new this(e).abs()}function gn(e){return new this(e).acos()}function mn(e){return new this(e).acosh()}function wn(e,n){return new this(e).plus(n)}function Nn(e){return new this(e).asin()}function vn(e){return new this(e).asinh()}function En(e){return new this(e).atan()}function kn(e){return new this(e).atanh()}function Sn(e,n){e=new this(e),n=new this(n);var i,t=this.precision,r=this.rounding,s=t+4;return!e.s||!n.s?i=new this(NaN):!e.d&&!n.d?(i=F(this,s,1).times(n.s>0?.25:.75),i.s=e.s):!n.d||e.isZero()?(i=n.s<0?F(this,t,r):new this(0),i.s=e.s):!e.d||n.isZero()?(i=F(this,s,1).times(.5),i.s=e.s):n.s<0?(this.precision=s,this.rounding=1,i=this.atan(k(e,n,s,1)),n=F(this,s,1),this.precision=t,this.rounding=r,i=e.s<0?i.minus(n):i.plus(n)):i=this.atan(k(e,n,s,1)),i}function Mn(e){return new this(e).cbrt()}function Cn(e){return p(e=new this(e),e.e+1,2)}function bn(e,n,i){return new this(e).clamp(n,i)}function Pn(e){if(!e||typeof e!="object")throw Error(ce+"Object expected");var n,i,t,r=e.defaults===!0,s=["precision",1,H,"rounding",0,8,"toExpNeg",-V,0,"toExpPos",0,V,"maxE",0,V,"minE",-V,0,"modulo",0,9];for(n=0;n<s.length;n+=3)if(i=s[n],r&&(this[i]=Ee[i]),(t=e[i])!==void 0)if(R(t)===t&&t>=s[n+1]&&t<=s[n+2])this[i]=t;else throw Error($+i+": "+t);if(i="crypto",r&&(this[i]=Ee[i]),(t=e[i])!==void 0)if(t===!0||t===!1||t===0||t===1)if(t)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[i]=!0;else throw Error(Fe);else this[i]=!1;else throw Error($+i+": "+t);return this}function On(e){return new this(e).cos()}function Rn(e){return new this(e).cosh()}function Ve(e){var n,i,t;function r(s){var o,u,c,f=this;if(!(f instanceof r))return new r(s);if(f.constructor=r,_e(s)){f.s=s.s,w?!s.d||s.e>r.maxE?(f.e=NaN,f.d=null):s.e<r.minE?(f.e=0,f.d=[0]):(f.e=s.e,f.d=s.d.slice()):(f.e=s.e,f.d=s.d?s.d.slice():s.d);return}if(c=typeof s,c==="number"){if(s===0){f.s=1/s<0?-1:1,f.e=0,f.d=[0];return}if(s<0?(s=-s,f.s=-1):f.s=1,s===~~s&&s<1e7){for(o=0,u=s;u>=10;u/=10)o++;w?o>r.maxE?(f.e=NaN,f.d=null):o<r.minE?(f.e=0,f.d=[0]):(f.e=o,f.d=[s]):(f.e=o,f.d=[s]);return}if(s*0!==0){s||(f.s=NaN),f.e=NaN,f.d=null;return}return se(f,s.toString())}if(c==="string")return(u=s.charCodeAt(0))===45?(s=s.slice(1),f.s=-1):(u===43&&(s=s.slice(1)),f.s=1),Ie.test(s)?se(f,s):dn(f,s);if(c==="bigint")return s<0?(s=-s,f.s=-1):f.s=1,se(f,s.toString());throw Error($+s)}if(r.prototype=h,r.ROUND_UP=0,r.ROUND_DOWN=1,r.ROUND_CEIL=2,r.ROUND_FLOOR=3,r.ROUND_HALF_UP=4,r.ROUND_HALF_DOWN=5,r.ROUND_HALF_EVEN=6,r.ROUND_HALF_CEIL=7,r.ROUND_HALF_FLOOR=8,r.EUCLID=9,r.config=r.set=Pn,r.clone=Ve,r.isDecimal=_e,r.abs=pn,r.acos=gn,r.acosh=mn,r.add=wn,r.asin=Nn,r.asinh=vn,r.atan=En,r.atanh=kn,r.atan2=Sn,r.cbrt=Mn,r.ceil=Cn,r.clamp=bn,r.cos=On,r.cosh=Rn,r.div=An,r.exp=qn,r.floor=_n,r.hypot=Tn,r.ln=Dn,r.log=Fn,r.log10=In,r.log2=Ln,r.max=Zn,r.min=Un,r.mod=Bn,r.mul=$n,r.pow=Hn,r.random=Vn,r.round=jn,r.sign=Wn,r.sin=Gn,r.sinh=Jn,r.sqrt=Xn,r.sub=Kn,r.sum=Qn,r.tan=Yn,r.tanh=xn,r.trunc=zn,e===void 0&&(e={}),e&&e.defaults!==!0)for(t=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],n=0;n<t.length;)e.hasOwnProperty(i=t[n++])||(e[i]=this[i]);return r.config(e),r}function An(e,n){return new this(e).div(n)}function qn(e){return new this(e).exp()}function _n(e){return p(e=new this(e),e.e+1,3)}function Tn(){var e,n,i=new this(0);for(w=!1,e=0;e<arguments.length;)if(n=new this(arguments[e++]),n.d)i.d&&(i=i.plus(n.times(n)));else{if(n.s)return w=!0,new this(1/0);i=n}return w=!0,i.sqrt()}function _e(e){return e instanceof Y||e&&e.toStringTag===Le||!1}function Dn(e){return new this(e).ln()}function Fn(e,n){return new this(e).log(n)}function Ln(e){return new this(e).log(2)}function In(e){return new this(e).log(10)}function Zn(){return Be(this,arguments,-1)}function Un(){return Be(this,arguments,1)}function Bn(e,n){return new this(e).mod(n)}function $n(e,n){return new this(e).mul(n)}function Hn(e,n){return new this(e).pow(n)}function Vn(e){var n,i,t,r,s=0,o=new this(1),u=[];if(e===void 0?e=this.precision:q(e,1,H),t=Math.ceil(e/m),this.crypto)if(crypto.getRandomValues)for(n=crypto.getRandomValues(new Uint32Array(t));s<t;)r=n[s],r>=429e7?n[s]=crypto.getRandomValues(new Uint32Array(1))[0]:u[s++]=r%1e7;else if(crypto.randomBytes){for(n=crypto.randomBytes(t*=4);s<t;)r=n[s]+(n[s+1]<<8)+(n[s+2]<<16)+((n[s+3]&127)<<24),r>=214e7?crypto.randomBytes(4).copy(n,s):(u.push(r%1e7),s+=4);s=t/4}else throw Error(Fe);else for(;s<t;)u[s++]=Math.random()*1e7|0;for(t=u[--s],e%=m,t&&e&&(r=C(10,m-e),u[s]=(t/r|0)*r);u[s]===0;s--)u.pop();if(s<0)i=0,u=[0];else{for(i=-1;u[0]===0;i-=m)u.shift();for(t=1,r=u[0];r>=10;r/=10)t++;t<m&&(i-=m-t)}return o.e=i,o.d=u,o}function jn(e){return p(e=new this(e),e.e+1,this.rounding)}function Wn(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function Gn(e){return new this(e).sin()}function Jn(e){return new this(e).sinh()}function Xn(e){return new this(e).sqrt()}function Kn(e,n){return new this(e).sub(n)}function Qn(){var e=0,n=arguments,i=new this(n[e]);for(w=!1;i.s&&++e<n.length;)i=i.plus(n[e]);return w=!0,p(i,this.precision,this.rounding)}function Yn(e){return new this(e).tan()}function xn(e){return new this(e).tanh()}function zn(e){return p(e=new this(e),e.e+1,1)}h[Symbol.for("nodejs.util.inspect.custom")]=h.toString;h[Symbol.toStringTag]="Decimal";var Y=h.constructor=Ve(Ee);oe=new Y(oe);ue=new Y(ue);var je=Y;0&&(module.exports={Decimal,Public,getRuntime,makeStrictEnum,objectEnumValues});
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=index-browser.js.map

```

## 📄 lib\generated\prisma\runtime\library.d.ts

```ts
/**
 * @param this
 */
declare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;

declare type AccelerateEngineConfig = {
    inlineSchema: EngineConfig['inlineSchema'];
    inlineSchemaHash: EngineConfig['inlineSchemaHash'];
    env: EngineConfig['env'];
    generator?: {
        previewFeatures: string[];
    };
    inlineDatasources: EngineConfig['inlineDatasources'];
    overrideDatasources: EngineConfig['overrideDatasources'];
    clientVersion: EngineConfig['clientVersion'];
    engineVersion: EngineConfig['engineVersion'];
    logEmitter: EngineConfig['logEmitter'];
    logQueries?: EngineConfig['logQueries'];
    logLevel?: EngineConfig['logLevel'];
    tracingHelper: EngineConfig['tracingHelper'];
    accelerateUtils?: AccelerateUtils;
};

declare type AccelerateUtils = EngineConfig['accelerateUtils'];

export declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';

declare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;

/**
 * An interface that exposes some basic information about the
 * adapter like its name and provider type.
 */
declare interface AdapterInfo {
    readonly provider: Provider;
    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});
}

export declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';

export declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {
    [P in K]: {
        $allModels: infer AllModels;
    };
} ? {
    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;
} : {};

declare class AnyNull extends NullTypesEnumValue {
    private readonly _brand_AnyNull;
}

export declare type ApplyOmit<T, OmitConfig> = Compute<{
    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];
}>;

export declare type Args<T, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            operations: {
                [K in F]: {
                    args: any;
                };
            };
        };
    };
} ? T[symbol]['types']['operations'][F]['args'] : any;

export declare type Args_3<T, F extends Operation> = Args<T, F>;

/**
 * Original `quaint::ValueType` enum tag from Prisma's `quaint`.
 * Query arguments marked with this type are sanitized before being sent to the database.
 * Notice while a query argument may be `null`, `ArgType` is guaranteed to be defined.
 */
declare type ArgType = 'Int32' | 'Int64' | 'Float' | 'Double' | 'Text' | 'Enum' | 'EnumArray' | 'Bytes' | 'Boolean' | 'Char' | 'Array' | 'Numeric' | 'Json' | 'Xml' | 'Uuid' | 'DateTime' | 'Date' | 'Time';

/**
 * Attributes is a map from string to attribute values.
 *
 * Note: only the own enumerable keys are counted as valid attribute keys.
 */
declare interface Attributes {
    [attributeKey: string]: AttributeValue | undefined;
}

/**
 * Attribute values may be any non-nullish primitive value except an object.
 *
 * null or undefined attribute values are invalid and will result in undefined behavior.
 */
declare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;

export declare type BaseDMMF = {
    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;
};

declare type BatchArgs = {
    queries: BatchQuery[];
    transaction?: {
        isolationLevel?: IsolationLevel;
    };
};

declare type BatchInternalParams = {
    requests: RequestParams[];
    customDataProxyFetch?: CustomDataProxyFetch;
};

declare type BatchQuery = {
    model: string | undefined;
    operation: string;
    args: JsArgs | RawQueryArgs;
};

declare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;

declare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;

declare type BatchQueryOptionsCbArgs = {
    args: BatchArgs;
    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;
    __internalParams: BatchInternalParams;
};

declare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;

declare type BatchTransactionOptions = {
    isolationLevel?: IsolationLevel;
};

declare interface BinaryTargetsEnvValue {
    fromEnvVar: string | null;
    value: string;
    native?: boolean;
}

export declare type Call<F extends Fn, P> = (F & {
    params: P;
})['returns'];

declare interface CallSite {
    getLocation(): LocationInFile | null;
}

export declare type Cast<A, W> = A extends W ? A : W;

declare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;

export declare type ClientArg = {
    [MethodName in string]: unknown;
};

export declare type ClientArgs = {
    client: ClientArg;
};

export declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;

export declare type ClientOptionDef = undefined | {
    [K in string]: any;
};

export declare type ClientOtherOps = {
    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;
    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;
    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;
    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;
    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;
};

declare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];

declare const ColumnTypeEnum: {
    readonly Int32: 0;
    readonly Int64: 1;
    readonly Float: 2;
    readonly Double: 3;
    readonly Numeric: 4;
    readonly Boolean: 5;
    readonly Character: 6;
    readonly Text: 7;
    readonly Date: 8;
    readonly Time: 9;
    readonly DateTime: 10;
    readonly Json: 11;
    readonly Enum: 12;
    readonly Bytes: 13;
    readonly Set: 14;
    readonly Uuid: 15;
    readonly Int32Array: 64;
    readonly Int64Array: 65;
    readonly FloatArray: 66;
    readonly DoubleArray: 67;
    readonly NumericArray: 68;
    readonly BooleanArray: 69;
    readonly CharacterArray: 70;
    readonly TextArray: 71;
    readonly DateArray: 72;
    readonly TimeArray: 73;
    readonly DateTimeArray: 74;
    readonly JsonArray: 75;
    readonly EnumArray: 76;
    readonly BytesArray: 77;
    readonly UuidArray: 78;
    readonly UnknownNumber: 128;
};

declare type CompactedBatchResponse = {
    type: 'compacted';
    plan: object;
    arguments: Map<string, {}>[];
    nestedSelection: string[];
    keys: string[];
    expectNonEmpty: boolean;
};

declare type CompilerWasmLoadingConfig = {
    /**
     * WASM-bindgen runtime for corresponding module
     */
    getRuntime: () => Promise<{
        __wbg_set_wasm(exports: unknown): void;
        QueryCompiler: QueryCompilerConstructor;
    }>;
    /**
     * Loads the raw wasm module for the wasm compiler engine. This configuration is
     * generated specifically for each type of client, eg. Node.js client and Edge
     * clients will have different implementations.
     * @remarks this is a callback on purpose, we only load the wasm if needed.
     * @remarks only used by ClientEngine
     */
    getQueryCompilerWasmModule: () => Promise<unknown>;
};

export declare type Compute<T> = T extends Function ? T : {
    [K in keyof T]: T[K];
} & unknown;

export declare type ComputeDeep<T> = T extends Function ? T : {
    [K in keyof T]: ComputeDeep<T[K]>;
} & unknown;

declare type ComputedField = {
    name: string;
    needs: string[];
    compute: ResultArgsFieldCompute;
};

declare type ComputedFieldsMap = {
    [fieldName: string]: ComputedField;
};

declare type ConnectionInfo = {
    schemaName?: string;
    maxBindValues?: number;
};

declare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';

declare interface Context {
    /**
     * Get a value from the context.
     *
     * @param key key which identifies a context value
     */
    getValue(key: symbol): unknown;
    /**
     * Create a new context which inherits from this context and has
     * the given key set to the given value.
     *
     * @param key context key for which to set the value
     * @param value value to set for the given key
     */
    setValue(key: symbol, value: unknown): Context;
    /**
     * Return a new context which inherits from this context but does
     * not contain a value for the given key.
     *
     * @param key context key for which to clear a value
     */
    deleteValue(key: symbol): Context;
}

declare type Context_2<T> = T extends {
    [K: symbol]: {
        ctx: infer C;
    };
} ? C & T & {
    /**
     * @deprecated Use `$name` instead.
     */
    name?: string;
    $name?: string;
    $parent?: unknown;
} : T & {
    /**
     * @deprecated Use `$name` instead.
     */
    name?: string;
    $name?: string;
    $parent?: unknown;
};

export declare type Count<O> = {
    [K in keyof O]: Count<number>;
} & {};

export declare function createParam(name: string): Param<unknown, string>;

/**
 * Custom fetch function for `DataProxyEngine`.
 *
 * We can't use the actual type of `globalThis.fetch` because this will result
 * in API Extractor referencing Node.js type definitions in the `.d.ts` bundle
 * for the client runtime. We can only use such types in internal types that
 * don't end up exported anywhere.

 * It's also not possible to write a definition of `fetch` that would accept the
 * actual `fetch` function from different environments such as Node.js and
 * Cloudflare Workers (with their extensions to `RequestInit` and `Response`).
 * `fetch` is used in both covariant and contravariant positions in
 * `CustomDataProxyFetch`, making it invariant, so we need the exact same type.
 * Even if we removed the argument and left `fetch` in covariant position only,
 * then for an extension-supplied function to be assignable to `customDataProxyFetch`,
 * the platform-specific (or custom) `fetch` function needs to be assignable
 * to our `fetch` definition. This, in turn, requires the third-party `Response`
 * to be a subtype of our `Response` (which is not a problem, we could declare
 * a minimal `Response` type that only includes what we use) *and* requires the
 * third-party `RequestInit` to be a supertype of our `RequestInit` (i.e. we
 * have to declare all properties any `RequestInit` implementation in existence
 * could possibly have), which is not possible.
 *
 * Since `@prisma/extension-accelerate` redefines the type of
 * `__internalParams.customDataProxyFetch` to its own type anyway (probably for
 * exactly this reason), our definition is never actually used and is completely
 * ignored, so it doesn't matter, and we can just use `unknown` as the type of
 * `fetch` here.
 */
declare type CustomDataProxyFetch = (fetch: unknown) => unknown;

declare class DataLoader<T = unknown> {
    private options;
    batches: {
        [key: string]: Job[];
    };
    private tickActive;
    constructor(options: DataLoaderOptions<T>);
    request(request: T): Promise<any>;
    private dispatchBatches;
    get [Symbol.toStringTag](): string;
}

declare type DataLoaderOptions<T> = {
    singleLoader: (request: T) => Promise<any>;
    batchLoader: (request: T[]) => Promise<any[]>;
    batchBy: (request: T) => string | undefined;
    batchOrder: (requestA: T, requestB: T) => number;
};

declare type Datamodel = ReadonlyDeep_2<{
    models: Model[];
    enums: DatamodelEnum[];
    types: Model[];
    indexes: Index[];
}>;

declare type DatamodelEnum = ReadonlyDeep_2<{
    name: string;
    values: EnumValue[];
    dbName?: string | null;
    documentation?: string;
}>;

declare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;

declare type Datasource = {
    url?: string;
};

declare type Datasources = {
    [name in string]: Datasource;
};

declare class DbNull extends NullTypesEnumValue {
    private readonly _brand_DbNull;
}

export declare const Debug: typeof debugCreate & {
    enable(namespace: any): void;
    disable(): any;
    enabled(namespace: string): boolean;
    log: (...args: string[]) => void;
    formatters: {};
};

/**
 * Create a new debug instance with the given namespace.
 *
 * @example
 * ```ts
 * import Debug from '@prisma/debug'
 * const debug = Debug('prisma:client')
 * debug('Hello World')
 * ```
 */
declare function debugCreate(namespace: string): ((...args: any[]) => void) & {
    color: string;
    enabled: boolean;
    namespace: string;
    log: (...args: string[]) => void;
    extend: () => void;
};

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
    export type Constructor = typeof Decimal;
    export type Instance = Decimal;
    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    export type Modulo = Rounding | 9;
    export type Value = string | number | Decimal;

    // http://mikemcl.github.io/decimal.js/#constructor-properties
    export interface Config {
        precision?: number;
        rounding?: Rounding;
        toExpNeg?: number;
        toExpPos?: number;
        minE?: number;
        maxE?: number;
        crypto?: boolean;
        modulo?: Modulo;
        defaults?: boolean;
    }
}

export declare class Decimal {
    readonly d: number[];
    readonly e: number;
    readonly s: number;

    constructor(n: Decimal.Value);

    absoluteValue(): Decimal;
    abs(): Decimal;

    ceil(): Decimal;

    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

    comparedTo(n: Decimal.Value): number;
    cmp(n: Decimal.Value): number;

    cosine(): Decimal;
    cos(): Decimal;

    cubeRoot(): Decimal;
    cbrt(): Decimal;

    decimalPlaces(): number;
    dp(): number;

    dividedBy(n: Decimal.Value): Decimal;
    div(n: Decimal.Value): Decimal;

    dividedToIntegerBy(n: Decimal.Value): Decimal;
    divToInt(n: Decimal.Value): Decimal;

    equals(n: Decimal.Value): boolean;
    eq(n: Decimal.Value): boolean;

    floor(): Decimal;

    greaterThan(n: Decimal.Value): boolean;
    gt(n: Decimal.Value): boolean;

    greaterThanOrEqualTo(n: Decimal.Value): boolean;
    gte(n: Decimal.Value): boolean;

    hyperbolicCosine(): Decimal;
    cosh(): Decimal;

    hyperbolicSine(): Decimal;
    sinh(): Decimal;

    hyperbolicTangent(): Decimal;
    tanh(): Decimal;

    inverseCosine(): Decimal;
    acos(): Decimal;

    inverseHyperbolicCosine(): Decimal;
    acosh(): Decimal;

    inverseHyperbolicSine(): Decimal;
    asinh(): Decimal;

    inverseHyperbolicTangent(): Decimal;
    atanh(): Decimal;

    inverseSine(): Decimal;
    asin(): Decimal;

    inverseTangent(): Decimal;
    atan(): Decimal;

    isFinite(): boolean;

    isInteger(): boolean;
    isInt(): boolean;

    isNaN(): boolean;

    isNegative(): boolean;
    isNeg(): boolean;

    isPositive(): boolean;
    isPos(): boolean;

    isZero(): boolean;

    lessThan(n: Decimal.Value): boolean;
    lt(n: Decimal.Value): boolean;

    lessThanOrEqualTo(n: Decimal.Value): boolean;
    lte(n: Decimal.Value): boolean;

    logarithm(n?: Decimal.Value): Decimal;
    log(n?: Decimal.Value): Decimal;

    minus(n: Decimal.Value): Decimal;
    sub(n: Decimal.Value): Decimal;

    modulo(n: Decimal.Value): Decimal;
    mod(n: Decimal.Value): Decimal;

    naturalExponential(): Decimal;
    exp(): Decimal;

    naturalLogarithm(): Decimal;
    ln(): Decimal;

    negated(): Decimal;
    neg(): Decimal;

    plus(n: Decimal.Value): Decimal;
    add(n: Decimal.Value): Decimal;

    precision(includeZeros?: boolean): number;
    sd(includeZeros?: boolean): number;

    round(): Decimal;

    sine() : Decimal;
    sin() : Decimal;

    squareRoot(): Decimal;
    sqrt(): Decimal;

    tangent() : Decimal;
    tan() : Decimal;

    times(n: Decimal.Value): Decimal;
    mul(n: Decimal.Value) : Decimal;

    toBinary(significantDigits?: number): string;
    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

    toDecimalPlaces(decimalPlaces?: number): Decimal;
    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
    toDP(decimalPlaces?: number): Decimal;
    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

    toExponential(decimalPlaces?: number): string;
    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFixed(decimalPlaces?: number): string;
    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

    toFraction(max_denominator?: Decimal.Value): Decimal[];

    toHexadecimal(significantDigits?: number): string;
    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
    toHex(significantDigits?: number): string;
    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

    toJSON(): string;

    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

    toNumber(): number;

    toOctal(significantDigits?: number): string;
    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

    toPower(n: Decimal.Value): Decimal;
    pow(n: Decimal.Value): Decimal;

    toPrecision(significantDigits?: number): string;
    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

    toSignificantDigits(significantDigits?: number): Decimal;
    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
    toSD(significantDigits?: number): Decimal;
    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

    toString(): string;

    truncated(): Decimal;
    trunc(): Decimal;

    valueOf(): string;

    static abs(n: Decimal.Value): Decimal;
    static acos(n: Decimal.Value): Decimal;
    static acosh(n: Decimal.Value): Decimal;
    static add(x: Decimal.Value, y: Decimal.Value): Decimal;
    static asin(n: Decimal.Value): Decimal;
    static asinh(n: Decimal.Value): Decimal;
    static atan(n: Decimal.Value): Decimal;
    static atanh(n: Decimal.Value): Decimal;
    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
    static cbrt(n: Decimal.Value): Decimal;
    static ceil(n: Decimal.Value): Decimal;
    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
    static clone(object?: Decimal.Config): Decimal.Constructor;
    static config(object: Decimal.Config): Decimal.Constructor;
    static cos(n: Decimal.Value): Decimal;
    static cosh(n: Decimal.Value): Decimal;
    static div(x: Decimal.Value, y: Decimal.Value): Decimal;
    static exp(n: Decimal.Value): Decimal;
    static floor(n: Decimal.Value): Decimal;
    static hypot(...n: Decimal.Value[]): Decimal;
    static isDecimal(object: any): object is Decimal;
    static ln(n: Decimal.Value): Decimal;
    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
    static log2(n: Decimal.Value): Decimal;
    static log10(n: Decimal.Value): Decimal;
    static max(...n: Decimal.Value[]): Decimal;
    static min(...n: Decimal.Value[]): Decimal;
    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
    static noConflict(): Decimal.Constructor;   // Browser only
    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
    static random(significantDigits?: number): Decimal;
    static round(n: Decimal.Value): Decimal;
    static set(object: Decimal.Config): Decimal.Constructor;
    static sign(n: Decimal.Value): number;
    static sin(n: Decimal.Value): Decimal;
    static sinh(n: Decimal.Value): Decimal;
    static sqrt(n: Decimal.Value): Decimal;
    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
    static sum(...n: Decimal.Value[]): Decimal;
    static tan(n: Decimal.Value): Decimal;
    static tanh(n: Decimal.Value): Decimal;
    static trunc(n: Decimal.Value): Decimal;

    static readonly default?: Decimal.Constructor;
    static readonly Decimal?: Decimal.Constructor;

    static readonly precision: number;
    static readonly rounding: Decimal.Rounding;
    static readonly toExpNeg: number;
    static readonly toExpPos: number;
    static readonly minE: number;
    static readonly maxE: number;
    static readonly crypto: boolean;
    static readonly modulo: Decimal.Modulo;

    static readonly ROUND_UP: 0;
    static readonly ROUND_DOWN: 1;
    static readonly ROUND_CEIL: 2;
    static readonly ROUND_FLOOR: 3;
    static readonly ROUND_HALF_UP: 4;
    static readonly ROUND_HALF_DOWN: 5;
    static readonly ROUND_HALF_EVEN: 6;
    static readonly ROUND_HALF_CEIL: 7;
    static readonly ROUND_HALF_FLOOR: 8;
    static readonly EUCLID: 9;
}

/**
 * Interface for any Decimal.js-like library
 * Allows us to accept Decimal.js from different
 * versions and some compatible alternatives
 */
export declare interface DecimalJsLike {
    d: number[];
    e: number;
    s: number;
    toFixed(): string;
}

export declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;

export declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {
    omit: infer LocalOmit;
} ? ApplyOmit<UnwrapPayload<{
    default: Payload;
}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{
    default: Payload;
}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;

export declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;

declare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;

declare const denylist: readonly ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];

declare type Deprecation = ReadonlyDeep_2<{
    sinceVersion: string;
    reason: string;
    plannedRemovalVersion?: string;
}>;

declare type DeserializedResponse = Array<Record<string, unknown>>;

export declare function deserializeJsonResponse(result: unknown): unknown;

export declare function deserializeRawResult(response: RawResponse): DeserializedResponse;

export declare type DevTypeMapDef = {
    meta: {
        modelProps: string;
    };
    model: {
        [Model in PropertyKey]: {
            [Operation in PropertyKey]: DevTypeMapFnDef;
        };
    };
    other: {
        [Operation in PropertyKey]: DevTypeMapFnDef;
    };
};

export declare type DevTypeMapFnDef = {
    args: any;
    result: any;
    payload: OperationPayload;
};

export declare namespace DMMF {
    export {
        datamodelEnumToSchemaEnum,
        Document_2 as Document,
        Mappings,
        OtherOperationMappings,
        DatamodelEnum,
        SchemaEnum,
        EnumValue,
        Datamodel,
        uniqueIndex,
        PrimaryKey,
        Model,
        FieldKind,
        FieldNamespace,
        FieldLocation,
        Field,
        FieldDefault,
        FieldDefaultScalar,
        Index,
        IndexType,
        IndexField,
        SortOrder,
        Schema,
        Query,
        QueryOutput,
        TypeRef,
        InputTypeRef,
        SchemaArg,
        OutputType,
        SchemaField,
        OutputTypeRef,
        Deprecation,
        InputType,
        FieldRefType,
        FieldRefAllowType,
        ModelMapping,
        ModelAction
    }
}

declare namespace DMMF_2 {
    export {
        datamodelEnumToSchemaEnum,
        Document_2 as Document,
        Mappings,
        OtherOperationMappings,
        DatamodelEnum,
        SchemaEnum,
        EnumValue,
        Datamodel,
        uniqueIndex,
        PrimaryKey,
        Model,
        FieldKind,
        FieldNamespace,
        FieldLocation,
        Field,
        FieldDefault,
        FieldDefaultScalar,
        Index,
        IndexType,
        IndexField,
        SortOrder,
        Schema,
        Query,
        QueryOutput,
        TypeRef,
        InputTypeRef,
        SchemaArg,
        OutputType,
        SchemaField,
        OutputTypeRef,
        Deprecation,
        InputType,
        FieldRefType,
        FieldRefAllowType,
        ModelMapping,
        ModelAction
    }
}

export declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;

declare type Document_2 = ReadonlyDeep_2<{
    datamodel: Datamodel;
    schema: Schema;
    mappings: Mappings;
}>;

/**
 * A generic driver adapter factory that allows the user to instantiate a
 * driver adapter. The query and result types are specific to the adapter.
 */
declare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {
    /**
     * Instantiate a driver adapter.
     */
    connect(): Promise<Queryable<Query, Result>>;
}

/** Client */
export declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [P in keyof C_]: unknown;
} & {
    [K: symbol]: {
        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {
            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;
        };
    };
};

export declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;
} & {
    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;
} & {
    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;
} & {
    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];
} & {
    [K: symbol]: {
        types: TypeMap['other'];
    };
};

export declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {
        extArgs: ExtArgs;
    }>>;
    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {
        isolationLevel?: TypeMap['meta']['txIsolationLevel'];
    }): Promise<UnwrapTuple<P>>;
    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: TypeMap['meta']['txIsolationLevel'];
    }): Promise<R>;
    $disconnect(): Promise<void>;
    $connect(): Promise<void>;
};

/** Model */
export declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {
    [K in keyof M_]: K extends '$allModels' ? {
        [P in keyof M_[K]]?: unknown;
    } & {
        [K: symbol]: {};
    } : K extends TypeMap['meta']['modelProps'] ? {
        [P in keyof M_[K]]?: unknown;
    } & {
        [K: symbol]: {
            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {
                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;
            } & {
                $name: ModelKey<TypeMap, K>;
            } & {
                /**
                 * @deprecated Use `$name` instead.
                 */
                name: ModelKey<TypeMap, K>;
            };
        };
    } : never;
};

export declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {
    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {
        select: {
            [P in K]: A;
        };
    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;
};

export declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;

export declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;

export declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;

export declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;

export declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {
    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;
} & {
    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;
} & {
    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];
} & {
    [K: symbol]: {
        types: TypeMap['model'][M];
    };
};

/** Query */
export declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {
    [K in keyof Q_]: K extends '$allOperations' ? (args: {
        model?: string;
        operation: string;
        args: any;
        query: (args: any) => PrismaPromise<any>;
    }) => Promise<any> : K extends '$allModels' ? {
        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;
    } : K extends TypeMap['meta']['modelProps'] ? {
        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;
    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;
};

export declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;

export declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {
    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;
    model: _0 extends 0 ? undefined : _1;
    operation: _2;
    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;
} : never : never) & {
    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;
};

export declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];

/** Result */
export declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {
    [K in keyof R_]: {
        [P in keyof R_[K]]?: {
            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;
            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;
        };
    };
};

export declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {
    select: S;
}, {}>;

export declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {
    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;
} & {
    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;
};

/**
 * Placeholder value for "no text".
 */
export declare const empty: Sql;

export declare type EmptyToUnknown<T> = T;

declare interface Engine<InteractiveTransactionPayload = unknown> {
    /** The name of the engine. This is meant to be consumed externally */
    readonly name: string;
    onBeforeExit(callback: () => Promise<void>): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    version(forceRun?: boolean): Promise<string> | string;
    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;
    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;
    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;
    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;
    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;
    metrics(options: MetricsOptionsJson): Promise<Metrics>;
    metrics(options: MetricsOptionsPrometheus): Promise<string>;
    applyPendingMigrations(): Promise<void>;
}

declare interface EngineConfig {
    cwd: string;
    dirname: string;
    enableDebugLogs?: boolean;
    allowTriggerPanic?: boolean;
    prismaPath?: string;
    generator?: GeneratorConfig;
    /**
     * @remarks this field is used internally by Policy, do not rename or remove
     */
    overrideDatasources: Datasources;
    showColors?: boolean;
    logQueries?: boolean;
    logLevel?: 'info' | 'warn';
    env: Record<string, string>;
    flags?: string[];
    clientVersion: string;
    engineVersion: string;
    previewFeatures?: string[];
    engineEndpoint?: string;
    activeProvider?: string;
    logEmitter: LogEmitter;
    transactionOptions: Transaction_2.Options;
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.
     * If set, this is only used in the library engine, and all queries would be performed through it,
     * rather than Prisma's Rust drivers.
     * @remarks only used by LibraryEngine.ts
     */
    adapter?: SqlDriverAdapterFactory;
    /**
     * The contents of the schema encoded into a string
     */
    inlineSchema: string;
    /**
     * The contents of the datasource url saved in a string
     * @remarks only used by DataProxyEngine.ts
     * @remarks this field is used internally by Policy, do not rename or remove
     */
    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];
    /**
     * The string hash that was produced for a given schema
     * @remarks only used by DataProxyEngine.ts
     */
    inlineSchemaHash: string;
    /**
     * The helper for interaction with OTEL tracing
     * @remarks enabling is determined by the client and @prisma/instrumentation package
     */
    tracingHelper: TracingHelper;
    /**
     * Information about whether we have not found a schema.prisma file in the
     * default location, and that we fell back to finding the schema.prisma file
     * in the current working directory. This usually means it has been bundled.
     */
    isBundled?: boolean;
    /**
     * Web Assembly module loading configuration
     */
    engineWasm?: EngineWasmLoadingConfig;
    compilerWasm?: CompilerWasmLoadingConfig;
    /**
     * Allows Accelerate to use runtime utilities from the client. These are
     * necessary for the AccelerateEngine to function correctly.
     */
    accelerateUtils?: {
        resolveDatasourceUrl: typeof resolveDatasourceUrl;
        getBatchRequestPayload: typeof getBatchRequestPayload;
        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;
        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;
        PrismaClientInitializationError: typeof PrismaClientInitializationError;
        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;
        debug: (...args: any[]) => void;
        engineVersion: string;
        clientVersion: string;
    };
}

declare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;

declare type EngineEventType = QueryEventType | LogEventType;

declare type EngineSpan = {
    id: EngineSpanId;
    parentId: string | null;
    name: string;
    startTime: HrTime;
    endTime: HrTime;
    kind: EngineSpanKind;
    attributes?: Record<string, unknown>;
    links?: EngineSpanId[];
};

declare type EngineSpanId = string;

declare type EngineSpanKind = 'client' | 'internal';

declare type EngineWasmLoadingConfig = {
    /**
     * WASM-bindgen runtime for corresponding module
     */
    getRuntime: () => Promise<{
        __wbg_set_wasm(exports: unknown): void;
        QueryEngine: QueryEngineConstructor;
    }>;
    /**
     * Loads the raw wasm module for the wasm query engine. This configuration is
     * generated specifically for each type of client, eg. Node.js client and Edge
     * clients will have different implementations.
     * @remarks this is a callback on purpose, we only load the wasm if needed.
     * @remarks only used by LibraryEngine
     */
    getQueryEngineWasmModule: () => Promise<unknown>;
};

declare type EnumValue = ReadonlyDeep_2<{
    name: string;
    dbName: string | null;
}>;

declare type EnvPaths = {
    rootEnvPath: string | null;
    schemaEnvPath: string | undefined;
};

declare interface EnvValue {
    fromEnvVar: null | string;
    value: null | string;
}

export declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;

declare type Error_2 = {
    kind: 'GenericJs';
    id: number;
} | {
    kind: 'UnsupportedNativeDataType';
    type: string;
} | {
    kind: 'InvalidIsolationLevel';
    level: string;
} | {
    kind: 'postgres';
    code: string;
    severity: string;
    message: string;
    detail: string | undefined;
    column: string | undefined;
    hint: string | undefined;
} | {
    kind: 'mysql';
    code: number;
    message: string;
    state: string;
} | {
    kind: 'sqlite';
    /**
     * Sqlite extended error code: https://www.sqlite.org/rescode.html
     */
    extendedCode: number;
    message: string;
};

declare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;

declare type ErrorCapturingInterface<T> = {
    [K in keyof T]: ErrorCapturingFunction<T[K]>;
};

declare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {
    readonly errorRegistry: ErrorRegistry;
}

declare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';

declare type ErrorRecord = {
    error: unknown;
};

declare interface ErrorRegistry {
    consumeError(id: number): ErrorRecord | undefined;
}

declare interface ErrorWithBatchIndex {
    batchRequestIdx?: number;
}

declare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;

export declare type Exact<A, W> = (A extends unknown ? (W extends A ? {
    [K in keyof A]: Exact<A[K], W[K]>;
} : W) : never) | (A extends Narrowable ? A : never);

/**
 * Defines Exception.
 *
 * string or an object with one of (message or name or code) and optional stack
 */
declare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;

declare interface ExceptionWithCode {
    code: string | number;
    name?: string;
    message?: string;
    stack?: string;
}

declare interface ExceptionWithMessage {
    code?: string | number;
    message: string;
    name?: string;
    stack?: string;
}

declare interface ExceptionWithName {
    code?: string | number;
    message?: string;
    name: string;
    stack?: string;
}

declare type ExtendedEventType = LogLevel | 'beforeExit';

declare type ExtendedSpanOptions = SpanOptions & {
    /** The name of the span */
    name: string;
    internal?: boolean;
    middleware?: boolean;
    /** Whether it propagates context (?=true) */
    active?: boolean;
    /** The context to append the span to */
    context?: Context;
};

/** $extends, defineExtension */
export declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {
    extArgs: ExtArgs;
}>> {
    extArgs: ExtArgs;
    <R_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;
    }, R, M_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;
    }, M, Q_ extends {
        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;
    }, C_ extends {
        [K in string]?: unknown;
    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {
        $extends: {
            extArgs: Args;
        };
    }) | {
        name?: string;
        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;
        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;
        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;
        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;
    }): {
        extends: DynamicClientExtensionThis<Call<TypeMapCb, {
            extArgs: MergedArgs;
        }>, TypeMapCb, MergedArgs>;
        define: (client: any) => {
            $extends: {
                extArgs: Args;
            };
        };
    }[Variant];
}

export declare type ExtensionArgs = Optional<RequiredExtensionArgs>;

declare namespace Extensions {
    export {
        defineExtension,
        getExtensionContext
    }
}
export { Extensions }

declare namespace Extensions_2 {
    export {
        InternalArgs,
        DefaultArgs,
        GetPayloadResultExtensionKeys,
        GetPayloadResultExtensionObject,
        GetPayloadResult,
        GetSelect,
        GetOmit,
        DynamicQueryExtensionArgs,
        DynamicQueryExtensionCb,
        DynamicQueryExtensionCbArgs,
        DynamicQueryExtensionCbArgsArgs,
        DynamicResultExtensionArgs,
        DynamicResultExtensionNeeds,
        DynamicResultExtensionData,
        DynamicModelExtensionArgs,
        DynamicModelExtensionThis,
        DynamicModelExtensionOperationFn,
        DynamicModelExtensionFnResult,
        DynamicModelExtensionFnResultBase,
        DynamicModelExtensionFluentApi,
        DynamicModelExtensionFnResultNull,
        DynamicClientExtensionArgs,
        DynamicClientExtensionThis,
        ClientBuiltInProp,
        DynamicClientExtensionThisBuiltin,
        ExtendsHook,
        MergeExtArgs,
        AllModelsToStringIndex,
        TypeMapDef,
        DevTypeMapDef,
        DevTypeMapFnDef,
        ClientOptionDef,
        ClientOtherOps,
        TypeMapCbDef,
        ModelKey,
        RequiredExtensionArgs as UserArgs
    }
}

export declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {
    omit: {
        [K in ModelName]: infer GlobalOmit;
    };
} ? GlobalOmit : {};

declare type Field = ReadonlyDeep_2<{
    kind: FieldKind;
    name: string;
    isRequired: boolean;
    isList: boolean;
    isUnique: boolean;
    isId: boolean;
    isReadOnly: boolean;
    isGenerated?: boolean;
    isUpdatedAt?: boolean;
    /**
     * Describes the data type in the same the way it is defined in the Prisma schema:
     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName
     */
    type: string;
    /**
     * Native database type, if specified.
     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,
     * `@db.Text` is encoded as `['Text', []]`.
     */
    nativeType?: [string, string[]] | null;
    dbName?: string | null;
    hasDefaultValue: boolean;
    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];
    relationFromFields?: string[];
    relationToFields?: string[];
    relationOnDelete?: string;
    relationOnUpdate?: string;
    relationName?: string;
    documentation?: string;
}>;

declare type FieldDefault = ReadonlyDeep_2<{
    name: string;
    args: Array<string | number>;
}>;

declare type FieldDefaultScalar = string | boolean | number;

declare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';

declare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';

declare type FieldNamespace = 'model' | 'prisma';

/**
 * A reference to a specific field of a specific model
 */
export declare interface FieldRef<Model, FieldType> {
    readonly modelName: Model;
    readonly name: string;
    readonly typeName: FieldType;
    readonly isList: boolean;
}

declare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;

declare type FieldRefType = ReadonlyDeep_2<{
    name: string;
    allowTypes: FieldRefAllowType[];
    fields: SchemaArg[];
}>;

declare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';

export declare interface Fn<Params = unknown, Returns = unknown> {
    params: Params;
    returns: Returns;
}

declare interface GeneratorConfig {
    name: string;
    output: EnvValue | null;
    isCustomOutput?: boolean;
    provider: EnvValue;
    config: {
        /** `output` is a reserved name and will only be available directly at `generator.output` */
        output?: never;
        /** `provider` is a reserved name and will only be available directly at `generator.provider` */
        provider?: never;
        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */
        binaryTargets?: never;
        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */
        previewFeatures?: never;
    } & {
        [key: string]: string | string[] | undefined;
    };
    binaryTargets: BinaryTargetsEnvValue[];
    previewFeatures: string[];
    envPaths?: EnvPaths;
    sourceFilePath: string;
}

export declare type GetAggregateResult<P extends OperationPayload, A> = {
    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {
        [J in keyof A[K] & string]: P['scalars'][J] | null;
    };
};

declare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_3<unknown>): QueryEngineBatchRequest;

export declare type GetBatchResult = {
    count: number;
};

export declare type GetCountResult<A> = A extends {
    select: infer S;
} ? (S extends true ? number : Count<S>) : number;

declare function getExtensionContext<T>(that: T): Context_2<T>;

export declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {
    select: infer S extends object;
} & Record<string, unknown> | {
    include: infer I extends object;
} & Record<string, unknown> ? {
    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {
        scalars: {
            [k in K]: infer O;
        };
    } ? O : K extends '_count' ? Count<P['objects']> : never;
} & (A extends {
    include: any;
} & Record<string, unknown> ? DefaultSelection<P, A & {
    omit: A['omit'];
}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;

export declare type GetGroupByResult<P extends OperationPayload, A> = A extends {
    by: string[];
} ? Array<GetAggregateResult<P, A> & {
    [K in A['by'][number]]: P['scalars'][K];
}> : A extends {
    by: string;
} ? Array<GetAggregateResult<P, A> & {
    [K in A['by']]: P['scalars'][K];
}> : {}[];

export declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {
    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;
};

export declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;

export declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;

export declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {
    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {
        compute: (...args: any) => infer C;
    } ? C : never;
};

export declare function getPrismaClient(config: GetPrismaClientConfig): {
    new (optionsArg?: PrismaClientOptions): {
        _originalClient: any;
        _runtimeDataModel: RuntimeDataModel;
        _requestHandler: RequestHandler;
        _connectionPromise?: Promise<any> | undefined;
        _disconnectionPromise?: Promise<any> | undefined;
        _engineConfig: EngineConfig;
        _accelerateEngineConfig: AccelerateEngineConfig;
        _clientVersion: string;
        _errorFormat: ErrorFormat;
        _tracingHelper: TracingHelper;
        _middlewares: MiddlewareHandler<QueryMiddleware>;
        _previewFeatures: string[];
        _activeProvider: string;
        _globalOmit?: GlobalOmitOptions | undefined;
        _extensions: MergedExtensionsList;
        /**
         * @remarks This is used internally by Policy, do not rename or remove
         */
        _engine: Engine;
        /**
         * A fully constructed/applied Client that references the parent
         * PrismaClient. This is used for Client extensions only.
         */
        _appliedParent: any;
        _createPrismaPromise: PrismaPromiseFactory;
        /**
         * Hook a middleware into the client
         * @param middleware to hook
         */
        $use(middleware: QueryMiddleware): void;
        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;
        $connect(): Promise<void>;
        /**
         * Disconnect from the database
         */
        $disconnect(): Promise<void>;
        /**
         * Executes a raw query and always returns a number
         */
        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;
        /**
         * Executes a raw query provided through a safe tag function
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
        /**
         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
        /**
         * Executes a raw command only for MongoDB
         *
         * @param command
         * @returns
         */
        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;
        /**
         * Executes a raw query and returns selected data
         */
        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;
        /**
         * Executes a raw query provided through a safe tag function
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
        /**
         * Counterpart to $queryRaw, that returns strongly typed results
         * @param typedSql
         */
        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;
        /**
         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections
         * @see https://github.com/prisma/prisma/issues/7142
         *
         * @param query
         * @param values
         * @returns
         */
        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
        /**
         * Execute a batch of requests in a transaction
         * @param requests
         * @param options
         */
        _transactionWithArray({ promises, options, }: {
            promises: Array<PrismaPromise_2<any>>;
            options?: BatchTransactionOptions;
        }): Promise<any>;
        /**
         * Perform a long-running transaction
         * @param callback
         * @param options
         * @returns
         */
        _transactionWithCallback({ callback, options, }: {
            callback: (client: Client) => Promise<unknown>;
            options?: TransactionOptions_2;
        }): Promise<unknown>;
        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;
        /**
         * Execute queries within a transaction
         * @param input a callback or a query list
         * @param options to set timeouts (callback)
         * @returns
         */
        $transaction(input: any, options?: any): Promise<any>;
        /**
         * Runs the middlewares over params before executing a request
         * @param internalParams
         * @returns
         */
        _request(internalParams: InternalRequestParams): Promise<any>;
        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;
        $metrics: MetricsClient;
        /**
         * Shortcut for checking a preview flag
         * @param feature preview flag
         * @returns
         */
        _hasPreviewFlag(feature: string): boolean;
        $applyPendingMigrations(): Promise<void>;
        $extends: typeof $extends;
        readonly [Symbol.toStringTag]: string;
    };
};

/**
 * Config that is stored into the generated client. When the generated client is
 * loaded, this same config is passed to {@link getPrismaClient} which creates a
 * closure with that config around a non-instantiated [[PrismaClient]].
 */
export declare type GetPrismaClientConfig = {
    runtimeDataModel: RuntimeDataModel;
    generator?: GeneratorConfig;
    relativeEnvPaths?: {
        rootEnvPath?: string | null;
        schemaEnvPath?: string | null;
    };
    relativePath: string;
    dirname: string;
    clientVersion: string;
    engineVersion: string;
    datasourceNames: string[];
    activeProvider: ActiveConnectorType;
    /**
     * The contents of the schema encoded into a string
     * @remarks only used for the purpose of data proxy
     */
    inlineSchema: string;
    /**
     * A special env object just for the data proxy edge runtime.
     * Allows bundlers to inject their own env variables (Vercel).
     * Allows platforms to declare global variables as env (Workers).
     * @remarks only used for the purpose of data proxy
     */
    injectableEdgeEnv?: () => LoadedEnv;
    /**
     * The contents of the datasource url saved in a string.
     * This can either be an env var name or connection string.
     * It is needed by the client to connect to the Data Proxy.
     * @remarks only used for the purpose of data proxy
     */
    inlineDatasources: {
        [name in string]: {
            url: EnvValue;
        };
    };
    /**
     * The string hash that was produced for a given schema
     * @remarks only used for the purpose of data proxy
     */
    inlineSchemaHash: string;
    /**
     * A marker to indicate that the client was not generated via `prisma
     * generate` but was generated via `generate --postinstall` script instead.
     * @remarks used to error for Vercel/Netlify for schema caching issues
     */
    postinstall?: boolean;
    /**
     * Information about the CI where the Prisma Client has been generated. The
     * name of the CI environment is stored at generation time because CI
     * information is not always available at runtime. Moreover, the edge client
     * has no notion of environment variables, so this works around that.
     * @remarks used to error for Vercel/Netlify for schema caching issues
     */
    ciName?: string;
    /**
     * Information about whether we have not found a schema.prisma file in the
     * default location, and that we fell back to finding the schema.prisma file
     * in the current working directory. This usually means it has been bundled.
     */
    isBundled?: boolean;
    /**
     * A boolean that is `false` when the client was generated with --no-engine. At
     * runtime, this means the client will be bound to be using the Data Proxy.
     */
    copyEngine?: boolean;
    /**
     * Optional wasm loading configuration
     */
    engineWasm?: EngineWasmLoadingConfig;
    compilerWasm?: CompilerWasmLoadingConfig;
};

export declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {
    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    create: GetFindResult<Payload, Args, GlobalOmitOptions>;
    createMany: GetBatchResult;
    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    update: GetFindResult<Payload, Args, GlobalOmitOptions>;
    updateMany: GetBatchResult;
    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;
    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;
    deleteMany: GetBatchResult;
    aggregate: GetAggregateResult<Payload, Args>;
    count: GetCountResult<Args>;
    groupBy: GetGroupByResult<Payload, Args>;
    $queryRaw: unknown;
    $queryRawTyped: unknown;
    $executeRaw: number;
    $queryRawUnsafe: unknown;
    $executeRawUnsafe: number;
    $runCommandRaw: JsonObject;
    findRaw: JsonObject;
    aggregateRaw: JsonObject;
}[OperationName];

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
    id: RuntimeName;
    prettyName: string;
    isEdge: boolean;
};

export declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {
    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];
};

declare type GlobalOmitOptions = {
    [modelName: string]: {
        [fieldName: string]: boolean;
    };
};

declare type HandleErrorParams = {
    args: JsArgs;
    error: any;
    clientMethod: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    modelName?: string;
    globalOmit?: GlobalOmitOptions;
};

declare type HrTime = [number, number];

/**
 * Defines High-Resolution Time.
 *
 * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 */
declare type HrTime_2 = [number, number];

declare type Index = ReadonlyDeep_2<{
    model: string;
    type: IndexType;
    isDefinedOnField: boolean;
    name?: string;
    dbName?: string;
    algorithm?: string;
    clustered?: boolean;
    fields: IndexField[];
}>;

declare type IndexField = ReadonlyDeep_2<{
    name: string;
    sortOrder?: SortOrder;
    length?: number;
    operatorClass?: string;
}>;

declare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';

/**
 * Matches a JSON array.
 * Unlike \`JsonArray\`, readonly arrays are assignable to this type.
 */
export declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {
}

/**
 * Matches a JSON object.
 * Unlike \`JsonObject\`, this type allows undefined and read-only properties.
 */
export declare type InputJsonObject = {
    readonly [Key in string]?: InputJsonValue | null;
};

/**
 * Matches any valid value that can be used as an input for operations like
 * create and update as the value of a JSON field. Unlike \`JsonValue\`, this
 * type allows read-only arrays and read-only object properties and disallows
 * \`null\` at the top level.
 *
 * \`null\` cannot be used as the value of a JSON field because its meaning
 * would be ambiguous. Use \`Prisma.JsonNull\` to store the JSON null value or
 * \`Prisma.DbNull\` to clear the JSON value and set the field to the database
 * NULL value instead.
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
 */
export declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {
    toJSON(): unknown;
};

declare type InputType = ReadonlyDeep_2<{
    name: string;
    constraints: {
        maxNumFields: number | null;
        minNumFields: number | null;
        fields?: string[];
    };
    meta?: {
        source?: string;
        grouping?: string;
    };
    fields: SchemaArg[];
}>;

declare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;

declare type InteractiveTransactionInfo<Payload = unknown> = {
    /**
     * Transaction ID returned by the query engine.
     */
    id: string;
    /**
     * Arbitrary payload the meaning of which depends on the `Engine` implementation.
     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.
     * In `LibraryEngine` and `BinaryEngine` it is currently not used.
     */
    payload: Payload;
};

declare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;

export declare type InternalArgs<R = {
    [K in string]: {
        [K in string]: unknown;
    };
}, M = {
    [K in string]: {
        [K in string]: unknown;
    };
}, Q = {
    [K in string]: {
        [K in string]: unknown;
    };
}, C = {
    [K in string]: unknown;
}> = {
    result: {
        [K in keyof R]: {
            [P in keyof R[K]]: () => R[K][P];
        };
    };
    model: {
        [K in keyof M]: {
            [P in keyof M[K]]: () => M[K][P];
        };
    };
    query: {
        [K in keyof Q]: {
            [P in keyof Q[K]]: () => Q[K][P];
        };
    };
    client: {
        [K in keyof C]: () => C[K];
    };
};

declare type InternalRequestParams = {
    /**
     * The original client method being called.
     * Even though the rootField / operation can be changed,
     * this method stays as it is, as it's what the user's
     * code looks like
     */
    clientMethod: string;
    /**
     * Name of js model that triggered the request. Might be used
     * for warnings or error messages
     */
    jsModelName?: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    unpacker?: Unpacker;
    otelParentCtx?: Context;
    /** Used to "desugar" a user input into an "expanded" one */
    argsMapper?: (args?: UserArgs_2) => UserArgs_2;
    /** Used to convert args for middleware and back */
    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;
    /** Used for Accelerate client extension via Data Proxy */
    customDataProxyFetch?: CustomDataProxyFetch;
} & Omit<QueryMiddlewareParams, 'runInTransaction'>;

declare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';

declare function isSkip(value: unknown): value is Skip;

export declare function isTypedSql(value: unknown): value is UnknownTypedSql;

export declare type ITXClientDenyList = (typeof denylist)[number];

export declare const itxClientDenyList: readonly (string | symbol)[];

declare interface Job {
    resolve: (data: any) => void;
    reject: (data: any) => void;
    request: any;
}

/**
 * Create a SQL query for a list of values.
 */
export declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;

export declare type JsArgs = {
    select?: Selection_2;
    include?: Selection_2;
    omit?: Omission;
    [argName: string]: JsInputValue;
};

export declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {
    [key: string]: JsInputValue;
};

declare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {
    [key: string]: JsonArgumentValue;
};

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {
}

export declare type JsonBatchQuery = {
    batch: JsonQuery[];
    transaction?: {
        isolationLevel?: IsolationLevel;
    };
};

export declare interface JsonConvertible {
    toJSON(): unknown;
}

declare type JsonFieldSelection = {
    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;
    selection: JsonSelectionSet;
};

declare class JsonNull extends NullTypesEnumValue {
    private readonly _brand_JsonNull;
}

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
 */
export declare type JsonObject = {
    [Key in string]?: JsonValue;
};

export declare type JsonQuery = {
    modelName?: string;
    action: JsonQueryAction;
    query: JsonFieldSelection;
};

declare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';

declare type JsonSelectionSet = {
    $scalars?: boolean;
    $composites?: boolean;
} & {
    [fieldName: string]: boolean | JsonFieldSelection;
};

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;

export declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {
    [key: string]: JsOutputValue;
};

export declare type JsPromise<T> = Promise<T> & {};

declare type KnownErrorParams = {
    code: string;
    clientVersion: string;
    meta?: Record<string, unknown>;
    batchRequestIdx?: number;
};

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 * Few examples of Link usage.
 * 1. Batch Processing: A batch of elements may contain elements associated
 *    with one or more traces/spans. Since there can only be one parent
 *    SpanContext, Link is used to keep reference to SpanContext of all
 *    elements in the batch.
 * 2. Public Endpoint: A SpanContext in incoming client request on a public
 *    endpoint is untrusted from service provider perspective. In such case it
 *    is advisable to start a new trace with appropriate sampling decision.
 *    However, it is desirable to associate incoming SpanContext to new trace
 *    initiated on service provider side so two traces (from Client and from
 *    Service Provider) can be correlated.
 */
declare interface Link {
    /** The {@link SpanContext} of a linked span. */
    context: SpanContext;
    /** A set of {@link SpanAttributes} on the link. */
    attributes?: SpanAttributes;
    /** Count of attributes of the link that were dropped due to collection limits */
    droppedAttributesCount?: number;
}

declare type LoadedEnv = {
    message?: string;
    parsed: {
        [x: string]: string;
    };
} | undefined;

declare type LocationInFile = {
    fileName: string;
    lineNumber: number | null;
    columnNumber: number | null;
};

declare type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
};

/**
 * Typings for the events we emit.
 *
 * @remarks
 * If this is updated, our edge runtime shim needs to be updated as well.
 */
declare type LogEmitter = {
    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;
    emit(event: QueryEventType, payload: QueryEvent): boolean;
    emit(event: LogEventType, payload: LogEvent): boolean;
};

declare type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
};

declare type LogEventType = 'info' | 'warn' | 'error';

declare type LogLevel = 'info' | 'query' | 'warn' | 'error';

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;

export declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;

declare type Mappings = ReadonlyDeep_2<{
    modelOperations: ModelMapping[];
    otherOperations: {
        read: string[];
        write: string[];
    };
}>;

/**
 * Class that holds the list of all extensions, applied to particular instance,
 * as well as resolved versions of the components that need to apply on
 * different levels. Main idea of this class: avoid re-resolving as much of the
 * stuff as possible when new extensions are added while also delaying the
 * resolve until the point it is actually needed. For example, computed fields
 * of the model won't be resolved unless the model is actually queried. Neither
 * adding extensions with `client` component only cause other components to
 * recompute.
 */
declare class MergedExtensionsList {
    private head?;
    private constructor();
    static empty(): MergedExtensionsList;
    static single(extension: ExtensionArgs): MergedExtensionsList;
    isEmpty(): boolean;
    append(extension: ExtensionArgs): MergedExtensionsList;
    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;
    getAllClientExtensions(): ClientArg | undefined;
    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;
    getAllQueryCallbacks(jsModelName: string, operation: string): any;
    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];
}

export declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;

export declare type Metric<T> = {
    key: string;
    value: T;
    labels: Record<string, string>;
    description: string;
};

export declare type MetricHistogram = {
    buckets: MetricHistogramBucket[];
    sum: number;
    count: number;
};

export declare type MetricHistogramBucket = [maxValue: number, count: number];

export declare type Metrics = {
    counters: Metric<number>[];
    gauges: Metric<number>[];
    histograms: Metric<MetricHistogram>[];
};

export declare class MetricsClient {
    private _client;
    constructor(client: Client);
    /**
     * Returns all metrics gathered up to this point in prometheus format.
     * Result of this call can be exposed directly to prometheus scraping endpoint
     *
     * @param options
     * @returns
     */
    prometheus(options?: MetricsOptions): Promise<string>;
    /**
     * Returns all metrics gathered up to this point in prometheus format.
     *
     * @param options
     * @returns
     */
    json(options?: MetricsOptions): Promise<Metrics>;
}

declare type MetricsOptions = {
    /**
     * Labels to add to every metrics in key-value format
     */
    globalLabels?: Record<string, string>;
};

declare type MetricsOptionsCommon = {
    globalLabels?: Record<string, string>;
};

declare type MetricsOptionsJson = {
    format: 'json';
} & MetricsOptionsCommon;

declare type MetricsOptionsPrometheus = {
    format: 'prometheus';
} & MetricsOptionsCommon;

declare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {
    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;
    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;
};

declare class MiddlewareHandler<M extends Function> {
    private _middlewares;
    use(middleware: M): void;
    get(id: number): M | undefined;
    has(id: number): boolean;
    length(): number;
}

declare type Model = ReadonlyDeep_2<{
    name: string;
    dbName: string | null;
    schema: string | null;
    fields: Field[];
    uniqueFields: string[][];
    uniqueIndexes: uniqueIndex[];
    documentation?: string;
    primaryKey: PrimaryKey | null;
    isGenerated?: boolean;
}>;

declare enum ModelAction {
    findUnique = "findUnique",
    findUniqueOrThrow = "findUniqueOrThrow",
    findFirst = "findFirst",
    findFirstOrThrow = "findFirstOrThrow",
    findMany = "findMany",
    create = "create",
    createMany = "createMany",
    createManyAndReturn = "createManyAndReturn",
    update = "update",
    updateMany = "updateMany",
    updateManyAndReturn = "updateManyAndReturn",
    upsert = "upsert",
    delete = "delete",
    deleteMany = "deleteMany",
    groupBy = "groupBy",
    count = "count",// TODO: count does not actually exist in DMMF
    aggregate = "aggregate",
    findRaw = "findRaw",
    aggregateRaw = "aggregateRaw"
}

export declare type ModelArg = {
    [MethodName in string]: unknown;
};

export declare type ModelArgs = {
    model: {
        [ModelName in string]: ModelArg;
    };
};

export declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;

declare type ModelMapping = ReadonlyDeep_2<{
    model: string;
    plural: string;
    findUnique?: string | null;
    findUniqueOrThrow?: string | null;
    findFirst?: string | null;
    findFirstOrThrow?: string | null;
    findMany?: string | null;
    create?: string | null;
    createMany?: string | null;
    createManyAndReturn?: string | null;
    update?: string | null;
    updateMany?: string | null;
    updateManyAndReturn?: string | null;
    upsert?: string | null;
    delete?: string | null;
    deleteMany?: string | null;
    aggregate?: string | null;
    groupBy?: string | null;
    count?: string | null;
    findRaw?: string | null;
    aggregateRaw?: string | null;
}>;

export declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;

export declare type ModelQueryOptionsCbArgs = {
    model: string;
    operation: string;
    args: JsArgs;
    query: (args: JsArgs) => Promise<unknown>;
};

declare type MultiBatchResponse = {
    type: 'multi';
    plans: object[];
};

export declare type NameArgs = {
    name?: string;
};

export declare type Narrow<A> = {
    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;
} | (A extends Narrowable ? A : never);

export declare type Narrowable = string | number | bigint | boolean | [];

export declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;

declare class NullTypesEnumValue extends ObjectEnumValue {
    _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
export declare abstract class ObjectEnumValue {
    constructor(arg?: symbol);
    abstract _getNamespace(): string;
    _getName(): string;
    toString(): string;
}

export declare const objectEnumValues: {
    classes: {
        DbNull: typeof DbNull;
        JsonNull: typeof JsonNull;
        AnyNull: typeof AnyNull;
    };
    instances: {
        DbNull: DbNull;
        JsonNull: JsonNull;
        AnyNull: AnyNull;
    };
};

declare const officialPrismaAdapters: readonly ["@prisma/adapter-planetscale", "@prisma/adapter-neon", "@prisma/adapter-libsql", "@prisma/adapter-d1", "@prisma/adapter-pg", "@prisma/adapter-pg-worker"];

export declare type Omission = Record<string, boolean | Skip>;

declare type Omit_2<T, K extends string | number | symbol> = {
    [P in keyof T as P extends K ? never : P]: T[P];
};
export { Omit_2 as Omit }

export declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;

export declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';

export declare type OperationPayload = {
    name: string;
    scalars: {
        [ScalarName in string]: unknown;
    };
    objects: {
        [ObjectName in string]: unknown;
    };
    composites: {
        [CompositeName in string]: unknown;
    };
};

export declare type Optional<O, K extends keyof any = keyof O> = {
    [P in K & keyof O]?: O[P];
} & {
    [P in Exclude<keyof O, K>]: O[P];
};

export declare type OptionalFlat<T> = {
    [K in keyof T]?: T[K];
};

export declare type OptionalKeys<O> = {
    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;
}[keyof O];

declare type Options = {
    clientVersion: string;
};

export declare type Or<A extends 1 | 0, B extends 1 | 0> = {
    0: {
        0: 0;
        1: 1;
    };
    1: {
        0: 1;
        1: 1;
    };
}[A][B];

declare type OtherOperationMappings = ReadonlyDeep_2<{
    read: string[];
    write: string[];
}>;

declare type OutputType = ReadonlyDeep_2<{
    name: string;
    fields: SchemaField[];
}>;

declare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;

export declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;

export declare type Param<out $Type, $Value extends string> = {
    readonly name: $Value;
};

export declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;

export declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;

export declare type Payload<T, F extends Operation = never> = T extends {
    [K: symbol]: {
        types: {
            payload: any;
        };
    };
} ? T[symbol]['types']['payload'] : any;

export declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {
    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];
};

declare type Pick_2<T, K extends string | number | symbol> = {
    [P in keyof T as P extends K ? P : never]: T[P];
};
export { Pick_2 as Pick }

declare type PrimaryKey = ReadonlyDeep_2<{
    name: string | null;
    fields: string[];
}>;

export declare class PrismaClientInitializationError extends Error {
    clientVersion: string;
    errorCode?: string;
    retryable?: boolean;
    constructor(message: string, clientVersion: string, errorCode?: string);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {
    code: string;
    meta?: Record<string, unknown>;
    clientVersion: string;
    batchRequestIdx?: number;
    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);
    get [Symbol.toStringTag](): string;
}

export declare type PrismaClientOptions = {
    /**
     * Overwrites the primary datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.
     */
    adapter?: SqlDriverAdapterFactory | null;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * The default values for Transaction options
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: Transaction_2.Options;
    /**
     * @example
     * \`\`\`
     * // Defaults to stdout
     * log: ['query', 'info', 'warn']
     *
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     * ]
     * \`\`\`
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>;
    omit?: GlobalOmitOptions;
    /**
     * @internal
     * You probably don't want to use this. \`__internal\` is used by internal tooling.
     */
    __internal?: {
        debug?: boolean;
        engine?: {
            cwd?: string;
            binaryPath?: string;
            endpoint?: string;
            allowTriggerPanic?: boolean;
        };
        /** This can be used for testing purposes */
        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;
    };
};

export declare class PrismaClientRustPanicError extends Error {
    clientVersion: string;
    constructor(message: string, clientVersion: string);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {
    clientVersion: string;
    batchRequestIdx?: number;
    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);
    get [Symbol.toStringTag](): string;
}

export declare class PrismaClientValidationError extends Error {
    name: string;
    clientVersion: string;
    constructor(message: string, { clientVersion }: Options);
    get [Symbol.toStringTag](): string;
}

declare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;

declare type PrismaOperationSpec<TArgs, TAction = string> = {
    args: TArgs;
    action: TAction;
    model: string;
};

export declare interface PrismaPromise<T> extends Promise<T> {
    [Symbol.toStringTag]: 'PrismaPromise';
}

/**
 * Prisma's `Promise` that is backwards-compatible. All additions on top of the
 * original `Promise` are optional so that it can be backwards-compatible.
 * @see [[createPrismaPromise]]
 */
declare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {
    get spec(): TSpec;
    /**
     * Extension of the original `.then` function
     * @param onfulfilled same as regular promises
     * @param onrejected same as regular promises
     * @param transaction transaction options
     */
    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;
    /**
     * Extension of the original `.catch` function
     * @param onrejected same as regular promises
     * @param transaction transaction options
     */
    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;
    /**
     * Extension of the original `.finally` function
     * @param onfinally same as regular promises
     * @param transaction transaction options
     */
    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;
    /**
     * Called when executing a batch of regular tx
     * @param transaction transaction options for batch tx
     */
    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;
}

declare type PrismaPromiseBatchTransaction = {
    kind: 'batch';
    id: number;
    isolationLevel?: IsolationLevel;
    index: number;
    lock: PromiseLike<void>;
};

declare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;

/**
 * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which
 * is essentially a proxy for `Promise`. All the transaction-compatible client
 * methods return one, this allows for pre-preparing queries without executing
 * them until `.then` is called. It's the foundation of Prisma's query batching.
 * @param callback that will be wrapped within our promise implementation
 * @see [[PrismaPromise]]
 * @returns
 */
declare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;

declare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {
    kind: 'itx';
    id: string;
    payload: PayloadType;
};

declare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;

export declare const PrivateResultType: unique symbol;

declare type Provider = 'mysql' | 'postgres' | 'sqlite';

declare namespace Public {
    export {
        validator
    }
}
export { Public }

declare namespace Public_2 {
    export {
        Args,
        Result,
        Payload,
        PrismaPromise,
        Operation,
        Exact
    }
}

declare type Query = ReadonlyDeep_2<{
    name: string;
    args: SchemaArg[];
    output: QueryOutput;
}>;

declare interface Queryable<Query, Result> extends AdapterInfo {
    /**
     * Execute a query and return its result.
     */
    queryRaw(params: Query): Promise<Result>;
    /**
     * Execute a query and return the number of affected rows.
     */
    executeRaw(params: Query): Promise<number>;
}

declare type QueryCompiler = {
    compile(request: string): Promise<string>;
    compileBatch(batchRequest: string): Promise<BatchResponse>;
};

declare interface QueryCompilerConstructor {
    new (options: QueryCompilerOptions): QueryCompiler;
}

declare type QueryCompilerOptions = {
    datamodel: string;
    provider: Provider;
    connectionInfo: ConnectionInfo;
};

declare type QueryEngineBatchGraphQLRequest = {
    batch: QueryEngineRequest[];
    transaction?: boolean;
    isolationLevel?: IsolationLevel;
};

declare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;

declare type QueryEngineConfig = {
    datamodel: string;
    configDir: string;
    logQueries: boolean;
    ignoreEnvVarErrors: boolean;
    datasourceOverrides: Record<string, string>;
    env: Record<string, string | undefined>;
    logLevel: QueryEngineLogLevel;
    engineProtocol: QueryEngineProtocol;
    enableTracing: boolean;
};

declare interface QueryEngineConstructor {
    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;
}

declare type QueryEngineInstance = {
    connect(headers: string, requestId: string): Promise<void>;
    disconnect(headers: string, requestId: string): Promise<void>;
    /**
     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`
     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`
     */
    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;
    sdlSchema?(): Promise<string>;
    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;
    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
    metrics?(options: string): Promise<string>;
    applyPendingMigrations?(): Promise<void>;
    trace(requestId: string): Promise<string | null>;
};

declare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';

declare type QueryEngineProtocol = 'graphql' | 'json';

declare type QueryEngineRequest = {
    query: string;
    variables: Object;
};

declare type QueryEngineResultData<T> = {
    data: T;
};

declare type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
};

declare type QueryEventType = 'query';

declare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';

declare type QueryMiddleware = (params: QueryMiddlewareParams, next: (params: QueryMiddlewareParams) => Promise<unknown>) => Promise<unknown>;

declare type QueryMiddlewareParams = {
    /** The model this is executed on */
    model?: string;
    /** The action that is being handled */
    action: Action;
    /** TODO what is this */
    dataPath: string[];
    /** TODO what is this */
    runInTransaction: boolean;
    args?: UserArgs_2;
};

export declare type QueryOptions = {
    query: {
        [ModelName in string]: {
            [ModelAction in string]: ModelQueryOptionsCb;
        } | QueryOptionsCb;
    };
};

export declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;

export declare type QueryOptionsCbArgs = {
    model?: string;
    operation: string;
    args: JsArgs | RawQueryArgs;
    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;
};

declare type QueryOutput = ReadonlyDeep_2<{
    name: string;
    isRequired: boolean;
    isList: boolean;
}>;

/**
 * Create raw SQL statement.
 */
export declare function raw(value: string): Sql;

export declare type RawParameters = {
    __prismaRawParameters__: true;
    values: string;
};

export declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];

declare type RawResponse = {
    columns: string[];
    types: QueryIntrospectionBuiltinType[];
    rows: unknown[][];
};

declare type RawTaggedValue = {
    $type: 'Raw';
    value: unknown;
};

/**
 * Supported value or SQL instance.
 */
export declare type RawValue = Value | Sql;

export declare type ReadonlyDeep<T> = {
    readonly [K in keyof T]: ReadonlyDeep<T[K]>;
};

declare type ReadonlyDeep_2<O> = {
    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;
};

declare type Record_2<T extends string | number | symbol, U> = {
    [P in T]: U;
};
export { Record_2 as Record }

export declare type RenameAndNestPayloadKeys<P> = {
    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];
};

declare type RequestBatchOptions<InteractiveTransactionPayload> = {
    transaction?: TransactionOptions_3<InteractiveTransactionPayload>;
    traceparent?: string;
    numTry?: number;
    containsWrite: boolean;
    customDataProxyFetch?: CustomDataProxyFetch;
};

declare interface RequestError {
    error: string;
    user_facing_error: {
        is_panic: boolean;
        message: string;
        meta?: Record<string, unknown>;
        error_code?: string;
        batch_request_idx?: number;
    };
}

declare class RequestHandler {
    client: Client;
    dataloader: DataLoader<RequestParams>;
    private logEmitter?;
    constructor(client: Client, logEmitter?: LogEmitter);
    request(params: RequestParams): Promise<any>;
    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;
    /**
     * Handles the error and logs it, logging the error is done synchronously waiting for the event
     * handlers to finish.
     */
    handleAndLogRequestError(params: HandleErrorParams): never;
    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;
    sanitizeMessage(message: any): any;
    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;
    get [Symbol.toStringTag](): string;
}

declare type RequestOptions<InteractiveTransactionPayload> = {
    traceparent?: string;
    numTry?: number;
    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;
    isWrite: boolean;
    customDataProxyFetch?: CustomDataProxyFetch;
};

declare type RequestParams = {
    modelName?: string;
    action: Action;
    protocolQuery: JsonQuery;
    dataPath: string[];
    clientMethod: string;
    callsite?: CallSite;
    transaction?: PrismaPromiseTransaction;
    extensions: MergedExtensionsList;
    args?: any;
    headers?: Record<string, string>;
    unpacker?: Unpacker;
    otelParentCtx?: Context;
    otelChildCtx?: Context;
    globalOmit?: GlobalOmitOptions;
    customDataProxyFetch?: CustomDataProxyFetch;
};

declare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;
export { RequiredExtensionArgs }
export { RequiredExtensionArgs as UserArgs }

export declare type RequiredKeys<O> = {
    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;
}[keyof O];

declare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {
    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];
    overrideDatasources: Datasources;
    env: Record<string, string | undefined>;
    clientVersion: string;
}): string;

export declare type Result<T, A, F extends Operation> = T extends {
    [K: symbol]: {
        types: {
            payload: any;
        };
    };
} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{
    composites: {};
    objects: {};
    scalars: {};
    name: '';
}, {}, F>;

export declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;

declare namespace Result_3 {
    export {
        Count,
        GetFindResult,
        SelectablePayloadFields,
        SelectField,
        DefaultSelection,
        UnwrapPayload,
        ApplyOmit,
        OmitValue,
        GetCountResult,
        Aggregate,
        GetAggregateResult,
        GetBatchResult,
        GetGroupByResult,
        GetResult,
        ExtractGlobalOmit
    }
}

declare type Result_4<T> = {
    map<U>(fn: (value: T) => U): Result_4<U>;
    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;
} & ({
    readonly ok: true;
    readonly value: T;
} | {
    readonly ok: false;
    readonly error: Error_2;
});

export declare type ResultArg = {
    [FieldName in string]: ResultFieldDefinition;
};

export declare type ResultArgs = {
    result: {
        [ModelName in string]: ResultArg;
    };
};

export declare type ResultArgsFieldCompute = (model: any) => unknown;

export declare type ResultFieldDefinition = {
    needs?: {
        [FieldName in string]: boolean;
    };
    compute: ResultArgsFieldCompute;
};

export declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;

export declare type RuntimeDataModel = {
    readonly models: Record<string, RuntimeModel>;
    readonly enums: Record<string, RuntimeEnum>;
    readonly types: Record<string, RuntimeModel>;
};

declare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;

declare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;

declare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';

declare type Schema = ReadonlyDeep_2<{
    rootQueryType?: string;
    rootMutationType?: string;
    inputObjectTypes: {
        model?: InputType[];
        prisma: InputType[];
    };
    outputObjectTypes: {
        model: OutputType[];
        prisma: OutputType[];
    };
    enumTypes: {
        model?: SchemaEnum[];
        prisma: SchemaEnum[];
    };
    fieldRefTypes: {
        prisma?: FieldRefType[];
    };
}>;

declare type SchemaArg = ReadonlyDeep_2<{
    name: string;
    comment?: string;
    isNullable: boolean;
    isRequired: boolean;
    inputTypes: InputTypeRef[];
    deprecation?: Deprecation;
}>;

declare type SchemaEnum = ReadonlyDeep_2<{
    name: string;
    values: string[];
}>;

declare type SchemaField = ReadonlyDeep_2<{
    name: string;
    isNullable?: boolean;
    outputType: OutputTypeRef;
    args: SchemaArg[];
    deprecation?: Deprecation;
    documentation?: string;
}>;

export declare type Select<T, U> = T extends U ? T : never;

export declare type SelectablePayloadFields<K extends PropertyKey, O> = {
    objects: {
        [k in K]: O;
    };
} | {
    composites: {
        [k in K]: O;
    };
};

export declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {
    objects: Record<K, any>;
} ? P['objects'][K] : P extends {
    composites: Record<K, any>;
} ? P['composites'][K] : never;

declare type Selection_2 = Record<string, boolean | Skip | JsArgs>;
export { Selection_2 as Selection }

export declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;

declare type SerializeParams = {
    runtimeDataModel: RuntimeDataModel;
    modelName?: string;
    action: Action;
    args?: JsArgs;
    extensions?: MergedExtensionsList;
    callsite?: CallSite;
    clientMethod: string;
    clientVersion: string;
    errorFormat: ErrorFormat;
    previewFeatures: string[];
    globalOmit?: GlobalOmitOptions;
};

declare class Skip {
    constructor(param?: symbol);
    ifUndefined<T>(value: T | undefined): T | Skip;
}

export declare const skip: Skip;

declare type SortOrder = 'asc' | 'desc';

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 *
 * Spans are created by the {@link Tracer.startSpan} method.
 */
declare interface Span {
    /**
     * Returns the {@link SpanContext} object associated with this Span.
     *
     * Get an immutable, serializable identifier for this span that can be used
     * to create new child spans. Returned SpanContext is usable even after the
     * span ends.
     *
     * @returns the SpanContext object associated with this Span.
     */
    spanContext(): SpanContext;
    /**
     * Sets an attribute to the span.
     *
     * Sets a single Attribute with the key and value passed as arguments.
     *
     * @param key the key for this attribute.
     * @param value the value for this attribute. Setting a value null or
     *              undefined is invalid and will result in undefined behavior.
     */
    setAttribute(key: string, value: SpanAttributeValue): this;
    /**
     * Sets attributes to the span.
     *
     * @param attributes the attributes that will be added.
     *                   null or undefined attribute values
     *                   are invalid and will result in undefined behavior.
     */
    setAttributes(attributes: SpanAttributes): this;
    /**
     * Adds an event to the Span.
     *
     * @param name the name of the event.
     * @param [attributesOrStartTime] the attributes that will be added; these are
     *     associated with this event. Can be also a start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [startTime] start time of the event.
     */
    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;
    /**
     * Adds a single link to the span.
     *
     * Links added after the creation will not affect the sampling decision.
     * It is preferred span links be added at span creation.
     *
     * @param link the link to add.
     */
    addLink(link: Link): this;
    /**
     * Adds multiple links to the span.
     *
     * Links added after the creation will not affect the sampling decision.
     * It is preferred span links be added at span creation.
     *
     * @param links the links to add.
     */
    addLinks(links: Link[]): this;
    /**
     * Sets a status to the span. If used, this will override the default Span
     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value
     * of previous calls to SetStatus on the Span.
     *
     * @param status the SpanStatus to set.
     */
    setStatus(status: SpanStatus): this;
    /**
     * Updates the Span name.
     *
     * This will override the name provided via {@link Tracer.startSpan}.
     *
     * Upon this update, any sampling behavior based on Span name will depend on
     * the implementation.
     *
     * @param name the Span name.
     */
    updateName(name: string): this;
    /**
     * Marks the end of Span execution.
     *
     * Call to End of a Span MUST not have any effects on child spans. Those may
     * still be running and can be ended later.
     *
     * Do not return `this`. The Span generally should not be used after it
     * is ended so chaining is not desired in this context.
     *
     * @param [endTime] the time to set as Span's end time. If not provided,
     *     use the current time as the span's end time.
     */
    end(endTime?: TimeInput): void;
    /**
     * Returns the flag whether this span will be recorded.
     *
     * @returns true if this Span is active and recording information like events
     *     with the `AddEvent` operation and attributes using `setAttributes`.
     */
    isRecording(): boolean;
    /**
     * Sets exception as a span event
     * @param exception the exception the only accepted values are string or Error
     * @param [time] the time to set as Span's event time. If not provided,
     *     use the current time.
     */
    recordException(exception: Exception, time?: TimeInput): void;
}

/**
 * @deprecated please use {@link Attributes}
 */
declare type SpanAttributes = Attributes;

/**
 * @deprecated please use {@link AttributeValue}
 */
declare type SpanAttributeValue = AttributeValue;

declare type SpanCallback<R> = (span?: Span, context?: Context) => R;

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a {@link Baggage}.
 */
declare interface SpanContext {
    /**
     * The ID of the trace that this span belongs to. It is worldwide unique
     * with practically sufficient probability by being made as 16 randomly
     * generated bytes, encoded as a 32 lowercase hex characters corresponding to
     * 128 bits.
     */
    traceId: string;
    /**
     * The ID of the Span. It is globally unique with practically sufficient
     * probability by being made as 8 randomly generated bytes, encoded as a 16
     * lowercase hex characters corresponding to 64 bits.
     */
    spanId: string;
    /**
     * Only true if the SpanContext was propagated from a remote parent.
     */
    isRemote?: boolean;
    /**
     * Trace flags to propagate.
     *
     * It is represented as 1 byte (bitmap). Bit to represent whether trace is
     * sampled or not. When set, the least significant bit documents that the
     * caller may have recorded trace data. A caller who does not record trace
     * data out-of-band leaves this flag unset.
     *
     * see {@link TraceFlags} for valid flag values.
     */
    traceFlags: number;
    /**
     * Tracing-system-specific info to propagate.
     *
     * The tracestate field value is a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
     *
     * Examples:
     *     Single tracing system (generic format):
     *         tracestate: rojo=00f067aa0ba902b7
     *     Multiple tracing systems (with different formatting):
     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
     */
    traceState?: TraceState;
}

declare enum SpanKind {
    /** Default value. Indicates that the span is used internally. */
    INTERNAL = 0,
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SERVER = 1,
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    CLIENT = 2,
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    PRODUCER = 3,
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    CONSUMER = 4
}

/**
 * Options needed for span creation
 */
declare interface SpanOptions {
    /**
     * The SpanKind of a span
     * @default {@link SpanKind.INTERNAL}
     */
    kind?: SpanKind;
    /** A span's attributes */
    attributes?: SpanAttributes;
    /** {@link Link}s span to other spans */
    links?: Link[];
    /** A manually specified start time for the created `Span` object. */
    startTime?: TimeInput;
    /** The new span should be a root span. (Ignore parent from context). */
    root?: boolean;
}

declare interface SpanStatus {
    /** The status code of this message. */
    code: SpanStatusCode;
    /** A developer-facing error message. */
    message?: string;
}

/**
 * An enumeration of status codes.
 */
declare enum SpanStatusCode {
    /**
     * The default status.
     */
    UNSET = 0,
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    OK = 1,
    /**
     * The operation contains an error.
     */
    ERROR = 2
}

/**
 * A SQL instance can be nested within each other to build SQL strings.
 */
export declare class Sql {
    readonly values: Value[];
    readonly strings: string[];
    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);
    get sql(): string;
    get statement(): string;
    get text(): string;
    inspect(): {
        sql: string;
        statement: string;
        text: string;
        values: unknown[];
    };
}

declare interface SqlDriverAdapter extends SqlQueryable {
    /**
     * Execute multiple SQL statements separated by semicolon.
     */
    executeScript(script: string): Promise<void>;
    /**
     * Start new transaction.
     */
    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;
    /**
     * Optional method that returns extra connection info
     */
    getConnectionInfo?(): ConnectionInfo;
    /**
     * Dispose of the connection and release any resources.
     */
    dispose(): Promise<void>;
}

export declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {
    connect(): Promise<SqlDriverAdapter>;
}

declare type SqlQuery = {
    sql: string;
    args: Array<unknown>;
    argTypes: Array<ArgType>;
};

declare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {
}

declare interface SqlResultSet {
    /**
     * List of column types appearing in a database query, in the same order as `columnNames`.
     * They are used within the Query Engine to convert values from JS to Quaint values.
     */
    columnTypes: Array<ColumnType>;
    /**
     * List of column names appearing in a database query, in the same order as `columnTypes`.
     */
    columnNames: Array<string>;
    /**
     * List of rows retrieved from a database query.
     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.
     */
    rows: Array<Array<unknown>>;
    /**
     * The last ID of an `INSERT` statement, if any.
     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.
     */
    lastInsertId?: string;
}

/**
 * Create a SQL object from a template string.
 */
export declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;

/**
 * Defines TimeInput.
 *
 * hrtime, epoch milliseconds, performance.now() or Date
 */
declare type TimeInput = HrTime_2 | number | Date;

export declare type ToTuple<T> = T extends any[] ? T : [T];

declare interface TraceState {
    /**
     * Create a new TraceState which inherits from this TraceState and has the
     * given key set.
     * The new entry will always be added in the front of the list of states.
     *
     * @param key key of the TraceState entry.
     * @param value value of the TraceState entry.
     */
    set(key: string, value: string): TraceState;
    /**
     * Return a new TraceState which inherits from this TraceState but does not
     * contain the given key.
     *
     * @param key the key for the TraceState entry to be removed.
     */
    unset(key: string): TraceState;
    /**
     * Returns the value to which the specified key is mapped, or `undefined` if
     * this map contains no mapping for the key.
     *
     * @param key with which the specified value is to be associated.
     * @returns the value to which the specified key is mapped, or `undefined` if
     *     this map contains no mapping for the key.
     */
    get(key: string): string | undefined;
    /**
     * Serializes the TraceState to a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     *
     * @returns the serialized string.
     */
    serialize(): string;
}

declare interface TracingHelper {
    isEnabled(): boolean;
    getTraceParent(context?: Context): string;
    dispatchEngineSpans(spans: EngineSpan[]): void;
    getActiveContext(): Context | undefined;
    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;
}

declare interface Transaction extends AdapterInfo, SqlQueryable {
    /**
     * Transaction options.
     */
    readonly options: TransactionOptions;
    /**
     * Commit the transaction.
     */
    commit(): Promise<void>;
    /**
     * Roll back the transaction.
     */
    rollback(): Promise<void>;
}

declare namespace Transaction_2 {
    export {
        TransactionOptions_2 as Options,
        InteractiveTransactionInfo,
        TransactionHeaders
    }
}

declare type TransactionHeaders = {
    traceparent?: string;
};

declare type TransactionOptions = {
    usePhantomQuery: boolean;
};

declare type TransactionOptions_2 = {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: IsolationLevel;
};

declare type TransactionOptions_3<InteractiveTransactionPayload> = {
    kind: 'itx';
    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;
} | {
    kind: 'batch';
    options: BatchTransactionOptions;
};

export declare class TypedSql<Values extends readonly unknown[], Result> {
    [PrivateResultType]: Result;
    constructor(sql: string, values: Values);
    get sql(): string;
    get values(): Values;
}

export declare type TypeMapCbDef = Fn<{
    extArgs: InternalArgs;
}, TypeMapDef>;

/** Shared */
export declare type TypeMapDef = Record<any, any>;

declare type TypeRef<AllowedLocations extends FieldLocation> = {
    isList: boolean;
    type: string;
    location: AllowedLocations;
    namespace?: FieldNamespace;
};

declare namespace Types {
    export {
        Result_3 as Result,
        Extensions_2 as Extensions,
        Utils,
        Public_2 as Public,
        isSkip,
        Skip,
        skip,
        UnknownTypedSql,
        OperationPayload as Payload
    }
}
export { Types }

declare type uniqueIndex = ReadonlyDeep_2<{
    name: string;
    fields: string[];
}>;

declare type UnknownErrorParams = {
    clientVersion: string;
    batchRequestIdx?: number;
};

export declare type UnknownTypedSql = TypedSql<unknown[], unknown>;

declare type Unpacker = (data: any) => any;

export declare type UnwrapPayload<P> = {} extends P ? unknown : {
    [K in keyof P]: P[K] extends {
        scalars: infer S;
        composites: infer C;
    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {
        scalars: infer S;
        composites: infer C;
    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;
};

export declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;

export declare type UnwrapTuple<Tuple extends readonly unknown[]> = {
    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;
};

/**
 * Input that flows from the user into the Client.
 */
declare type UserArgs_2 = any;

declare namespace Utils {
    export {
        EmptyToUnknown,
        NeverToUnknown,
        PatchFlat,
        Omit_2 as Omit,
        Pick_2 as Pick,
        ComputeDeep,
        Compute,
        OptionalFlat,
        ReadonlyDeep,
        Narrowable,
        Narrow,
        Exact,
        Cast,
        Record_2 as Record,
        UnwrapPromise,
        UnwrapTuple,
        Path,
        Fn,
        Call,
        RequiredKeys,
        OptionalKeys,
        Optional,
        Return,
        ToTuple,
        RenameAndNestPayloadKeys,
        PayloadToResult,
        Select,
        Equals,
        Or,
        JsPromise
    }
}

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

/**
 * Values supported by SQL engine.
 */
export declare type Value = unknown;

export declare function warnEnvConflicts(envPaths: any): void;

export declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;

export { }

```

## 📄 lib\generated\prisma\runtime\library.js

```js
"use strict";var bu=Object.create;var qt=Object.defineProperty;var Eu=Object.getOwnPropertyDescriptor;var wu=Object.getOwnPropertyNames;var xu=Object.getPrototypeOf,vu=Object.prototype.hasOwnProperty;var Do=(e,r)=>()=>(e&&(r=e(e=0)),r);var ne=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),tr=(e,r)=>{for(var t in r)qt(e,t,{get:r[t],enumerable:!0})},_o=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of wu(r))!vu.call(e,i)&&i!==t&&qt(e,i,{get:()=>r[i],enumerable:!(n=Eu(r,i))||n.enumerable});return e};var k=(e,r,t)=>(t=e!=null?bu(xu(e)):{},_o(r||!e||!e.__esModule?qt(t,"default",{value:e,enumerable:!0}):t,e)),Pu=e=>_o(qt({},"__esModule",{value:!0}),e);var mi=ne((_g,ss)=>{"use strict";ss.exports=(e,r=process.argv)=>{let t=e.startsWith("-")?"":e.length===1?"-":"--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1&&(i===-1||n<i)}});var us=ne((Ng,ls)=>{"use strict";var Mc=require("node:os"),as=require("node:tty"),de=mi(),{env:G}=process,Qe;de("no-color")||de("no-colors")||de("color=false")||de("color=never")?Qe=0:(de("color")||de("colors")||de("color=true")||de("color=always"))&&(Qe=1);"FORCE_COLOR"in G&&(G.FORCE_COLOR==="true"?Qe=1:G.FORCE_COLOR==="false"?Qe=0:Qe=G.FORCE_COLOR.length===0?1:Math.min(parseInt(G.FORCE_COLOR,10),3));function fi(e){return e===0?!1:{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function gi(e,r){if(Qe===0)return 0;if(de("color=16m")||de("color=full")||de("color=truecolor"))return 3;if(de("color=256"))return 2;if(e&&!r&&Qe===void 0)return 0;let t=Qe||0;if(G.TERM==="dumb")return t;if(process.platform==="win32"){let n=Mc.release().split(".");return Number(n[0])>=10&&Number(n[2])>=10586?Number(n[2])>=14931?3:2:1}if("CI"in G)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(n=>n in G)||G.CI_NAME==="codeship"?1:t;if("TEAMCITY_VERSION"in G)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION)?1:0;if(G.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in G){let n=parseInt((G.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(G.TERM_PROGRAM){case"iTerm.app":return n>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(G.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM)||"COLORTERM"in G?1:t}function $c(e){let r=gi(e,e&&e.isTTY);return fi(r)}ls.exports={supportsColor:$c,stdout:fi(gi(!0,as.isatty(1))),stderr:fi(gi(!0,as.isatty(2)))}});var ds=ne((Lg,ps)=>{"use strict";var qc=us(),br=mi();function cs(e){if(/^\d{3,4}$/.test(e)){let t=/(\d{1,2})(\d{2})/.exec(e)||[];return{major:0,minor:parseInt(t[1],10),patch:parseInt(t[2],10)}}let r=(e||"").split(".").map(t=>parseInt(t,10));return{major:r[0],minor:r[1],patch:r[2]}}function hi(e){let{CI:r,FORCE_HYPERLINK:t,NETLIFY:n,TEAMCITY_VERSION:i,TERM_PROGRAM:o,TERM_PROGRAM_VERSION:s,VTE_VERSION:a,TERM:l}=process.env;if(t)return!(t.length>0&&parseInt(t,10)===0);if(br("no-hyperlink")||br("no-hyperlinks")||br("hyperlink=false")||br("hyperlink=never"))return!1;if(br("hyperlink=true")||br("hyperlink=always")||n)return!0;if(!qc.supportsColor(e)||e&&!e.isTTY)return!1;if("WT_SESSION"in process.env)return!0;if(process.platform==="win32"||r||i)return!1;if(o){let u=cs(s||"");switch(o){case"iTerm.app":return u.major===3?u.minor>=1:u.major>3;case"WezTerm":return u.major>=20200620;case"vscode":return u.major>1||u.major===1&&u.minor>=72;case"ghostty":return!0}}if(a){if(a==="0.50.0")return!1;let u=cs(a);return u.major>0||u.minor>=50}switch(l){case"alacritty":return!0}return!1}ps.exports={supportsHyperlink:hi,stdout:hi(process.stdout),stderr:hi(process.stderr)}});var ms=ne((Hg,jc)=>{jc.exports={name:"@prisma/internals",version:"6.6.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.4.7",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-engine-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Ei=ne((zg,Uc)=>{Uc.exports={name:"@prisma/engines-version",version:"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"f676762280b54cd07c770017ed3711ddde35f37a"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var wi=ne(Xt=>{"use strict";Object.defineProperty(Xt,"__esModule",{value:!0});Xt.enginesVersion=void 0;Xt.enginesVersion=Ei().prisma.enginesVersion});var bs=ne((hh,ys)=>{"use strict";ys.exports=e=>{let r=e.match(/^[ \t]*(?=\S)/gm);return r?r.reduce((t,n)=>Math.min(t,n.length),1/0):0}});var Ri=ne((Eh,xs)=>{"use strict";xs.exports=(e,r=1,t)=>{if(t={indent:" ",includeEmptyLines:!1,...t},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof r!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);if(typeof t.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);if(r===0)return e;let n=t.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,t.indent.repeat(r))}});var Ss=ne((vh,Ts)=>{"use strict";Ts.exports=({onlyFirst:e=!1}={})=>{let r=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(r,e?void 0:"g")}});var ki=ne((Ph,Rs)=>{"use strict";var Xc=Ss();Rs.exports=e=>typeof e=="string"?e.replace(Xc(),""):e});var Cs=ne((Ch,ep)=>{ep.exports={name:"dotenv",version:"16.4.7",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard",pretest:"npm run lint && npm run dts-check",test:"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:">=12"},browser:{fs:!1}}});var Os=ne((Ah,Ne)=>{"use strict";var Di=require("node:fs"),_i=require("node:path"),rp=require("node:os"),tp=require("node:crypto"),np=Cs(),Ni=np.version,ip=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function op(e){let r={},t=e.toString();t=t.replace(/\r\n?/mg,`
`);let n;for(;(n=ip.exec(t))!=null;){let i=n[1],o=n[2]||"";o=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&&(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),r[i]=o}return r}function sp(e){let r=ks(e),t=B.configDotenv({path:r});if(!t.parsed){let s=new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);throw s.code="MISSING_DATA",s}let n=Is(e).split(","),i=n.length,o;for(let s=0;s<i;s++)try{let a=n[s].trim(),l=up(t,a);o=B.decrypt(l.ciphertext,l.key);break}catch(a){if(s+1>=i)throw a}return B.parse(o)}function ap(e){console.log(`[dotenv@${Ni}][INFO] ${e}`)}function lp(e){console.log(`[dotenv@${Ni}][WARN] ${e}`)}function tn(e){console.log(`[dotenv@${Ni}][DEBUG] ${e}`)}function Is(e){return e&&e.DOTENV_KEY&&e.DOTENV_KEY.length>0?e.DOTENV_KEY:process.env.DOTENV_KEY&&process.env.DOTENV_KEY.length>0?process.env.DOTENV_KEY:""}function up(e,r){let t;try{t=new URL(r)}catch(a){if(a.code==="ERR_INVALID_URL"){let l=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw l.code="INVALID_DOTENV_KEY",l}throw a}let n=t.password;if(!n){let a=new Error("INVALID_DOTENV_KEY: Missing key part");throw a.code="INVALID_DOTENV_KEY",a}let i=t.searchParams.get("environment");if(!i){let a=new Error("INVALID_DOTENV_KEY: Missing environment part");throw a.code="INVALID_DOTENV_KEY",a}let o=`DOTENV_VAULT_${i.toUpperCase()}`,s=e.parsed[o];if(!s){let a=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);throw a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a}return{ciphertext:s,key:n}}function ks(e){let r=null;if(e&&e.path&&e.path.length>0)if(Array.isArray(e.path))for(let t of e.path)Di.existsSync(t)&&(r=t.endsWith(".vault")?t:`${t}.vault`);else r=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else r=_i.resolve(process.cwd(),".env.vault");return Di.existsSync(r)?r:null}function As(e){return e[0]==="~"?_i.join(rp.homedir(),e.slice(1)):e}function cp(e){ap("Loading env from encrypted .env.vault");let r=B._parseVault(e),t=process.env;return e&&e.processEnv!=null&&(t=e.processEnv),B.populate(t,r,e),{parsed:r}}function pp(e){let r=_i.resolve(process.cwd(),".env"),t="utf8",n=!!(e&&e.debug);e&&e.encoding?t=e.encoding:n&&tn("No encoding is specified. UTF-8 is used by default");let i=[r];if(e&&e.path)if(!Array.isArray(e.path))i=[As(e.path)];else{i=[];for(let l of e.path)i.push(As(l))}let o,s={};for(let l of i)try{let u=B.parse(Di.readFileSync(l,{encoding:t}));B.populate(s,u,e)}catch(u){n&&tn(`Failed to load ${l} ${u.message}`),o=u}let a=process.env;return e&&e.processEnv!=null&&(a=e.processEnv),B.populate(a,s,e),o?{parsed:s,error:o}:{parsed:s}}function dp(e){if(Is(e).length===0)return B.configDotenv(e);let r=ks(e);return r?B._configVault(e):(lp(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`),B.configDotenv(e))}function mp(e,r){let t=Buffer.from(r.slice(-64),"hex"),n=Buffer.from(e,"base64"),i=n.subarray(0,12),o=n.subarray(-16);n=n.subarray(12,-16);try{let s=tp.createDecipheriv("aes-256-gcm",t,i);return s.setAuthTag(o),`${s.update(n)}${s.final()}`}catch(s){let a=s instanceof RangeError,l=s.message==="Invalid key length",u=s.message==="Unsupported state or unable to authenticate data";if(a||l){let c=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw c.code="INVALID_DOTENV_KEY",c}else if(u){let c=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw c.code="DECRYPTION_FAILED",c}else throw s}}function fp(e,r,t={}){let n=!!(t&&t.debug),i=!!(t&&t.override);if(typeof r!="object"){let o=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw o.code="OBJECT_REQUIRED",o}for(let o of Object.keys(r))Object.prototype.hasOwnProperty.call(e,o)?(i===!0&&(e[o]=r[o]),n&&tn(i===!0?`"${o}" is already defined and WAS overwritten`:`"${o}" is already defined and was NOT overwritten`)):e[o]=r[o]}var B={configDotenv:pp,_configVault:cp,_parseVault:sp,config:dp,decrypt:mp,parse:op,populate:fp};Ne.exports.configDotenv=B.configDotenv;Ne.exports._configVault=B._configVault;Ne.exports._parseVault=B._parseVault;Ne.exports.config=B.config;Ne.exports.decrypt=B.decrypt;Ne.exports.parse=B.parse;Ne.exports.populate=B.populate;Ne.exports=B});var Ls=ne((Nh,on)=>{"use strict";on.exports=(e={})=>{let r;if(e.repoUrl)r=e.repoUrl;else if(e.user&&e.repo)r=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let t=new URL(`${r}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"];for(let i of n){let o=e[i];if(o!==void 0){if(i==="labels"||i==="projects"){if(!Array.isArray(o))throw new TypeError(`The \`${i}\` option should be an array`);o=o.join(",")}t.searchParams.set(i,o)}}return t.toString()};on.exports.default=on.exports});var Qi=ne((pb,ia)=>{"use strict";ia.exports=function(){function e(r,t,n,i,o){return r<t||n<t?r>n?n+1:r+1:i===o?t:t+1}return function(r,t){if(r===t)return 0;if(r.length>t.length){var n=r;r=t,t=n}for(var i=r.length,o=t.length;i>0&&r.charCodeAt(i-1)===t.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&r.charCodeAt(s)===t.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,l,u,c,p,d,f,g,h,I,P,S,b,O=[];for(l=0;l<i;l++)O.push(l+1),O.push(r.charCodeAt(s+l));for(var me=O.length-1;a<o-3;)for(I=t.charCodeAt(s+(u=a)),P=t.charCodeAt(s+(c=a+1)),S=t.charCodeAt(s+(p=a+2)),b=t.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l<me;l+=2)g=O[l],h=O[l+1],u=e(g,u,c,I,h),c=e(u,c,p,P,h),p=e(c,p,d,S,h),f=e(p,d,f,b,h),O[l]=f,d=p,p=c,c=u,u=g;for(;a<o;)for(I=t.charCodeAt(s+(u=a)),f=++a,l=0;l<me;l+=2)g=O[l],O[l]=f=e(g,u,f,I,O[l+1]),u=g;return f}}()});var ua=Do(()=>{"use strict"});var ca=Do(()=>{"use strict"});var Vf={};tr(Vf,{DMMF:()=>lt,Debug:()=>N,Decimal:()=>ve,Extensions:()=>ei,MetricsClient:()=>Lr,PrismaClientInitializationError:()=>T,PrismaClientKnownRequestError:()=>z,PrismaClientRustPanicError:()=>le,PrismaClientUnknownRequestError:()=>j,PrismaClientValidationError:()=>Z,Public:()=>ri,Sql:()=>oe,createParam:()=>Ra,defineDmmfProperty:()=>Da,deserializeJsonResponse:()=>Tr,deserializeRawResult:()=>Yn,dmmfToRuntimeDataModel:()=>Zs,empty:()=>La,getPrismaClient:()=>gu,getRuntime:()=>qn,join:()=>Na,makeStrictEnum:()=>hu,makeTypedQueryFactory:()=>_a,objectEnumValues:()=>Sn,raw:()=>eo,serializeJsonQuery:()=>Dn,skip:()=>On,sqltag:()=>ro,warnEnvConflicts:()=>yu,warnOnce:()=>ot});module.exports=Pu(Vf);var ei={};tr(ei,{defineExtension:()=>No,getExtensionContext:()=>Lo});function No(e){return typeof e=="function"?e:r=>r.$extends(e)}function Lo(e){return e}var ri={};tr(ri,{validator:()=>Fo});function Fo(...e){return r=>r}var jt={};tr(jt,{$:()=>Vo,bgBlack:()=>_u,bgBlue:()=>Mu,bgCyan:()=>qu,bgGreen:()=>Lu,bgMagenta:()=>$u,bgRed:()=>Nu,bgWhite:()=>ju,bgYellow:()=>Fu,black:()=>Iu,blue:()=>nr,bold:()=>W,cyan:()=>Oe,dim:()=>Ie,gray:()=>Hr,green:()=>qe,grey:()=>Du,hidden:()=>Cu,inverse:()=>Ru,italic:()=>Su,magenta:()=>ku,red:()=>ce,reset:()=>Tu,strikethrough:()=>Au,underline:()=>Y,white:()=>Ou,yellow:()=>ke});var ti,Mo,$o,qo,jo=!0;typeof process<"u"&&({FORCE_COLOR:ti,NODE_DISABLE_COLORS:Mo,NO_COLOR:$o,TERM:qo}=process.env||{},jo=process.stdout&&process.stdout.isTTY);var Vo={enabled:!Mo&&$o==null&&qo!=="dumb"&&(ti!=null&&ti!=="0"||jo)};function F(e,r){let t=new RegExp(`\\x1b\\[${r}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${r}m`;return function(o){return!Vo.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(t,i+n):o)+i}}var Tu=F(0,0),W=F(1,22),Ie=F(2,22),Su=F(3,23),Y=F(4,24),Ru=F(7,27),Cu=F(8,28),Au=F(9,29),Iu=F(30,39),ce=F(31,39),qe=F(32,39),ke=F(33,39),nr=F(34,39),ku=F(35,39),Oe=F(36,39),Ou=F(37,39),Hr=F(90,39),Du=F(90,39),_u=F(40,49),Nu=F(41,49),Lu=F(42,49),Fu=F(43,49),Mu=F(44,49),$u=F(45,49),qu=F(46,49),ju=F(47,49);var Vu=100,Bo=["green","yellow","blue","magenta","cyan","red"],Kr=[],Uo=Date.now(),Bu=0,ni=typeof process<"u"?process.env:{};globalThis.DEBUG??=ni.DEBUG??"";globalThis.DEBUG_COLORS??=ni.DEBUG_COLORS?ni.DEBUG_COLORS==="true":!0;var Yr={enable(e){typeof e=="string"&&(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},enabled(e){let r=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),t=r.some(i=>i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n=r.some(i=>i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return t&&!n},log:(...e)=>{let[r,t,...n]=e;(console.warn??console.log)(`${r} ${t}`,...n)},formatters:{}};function Uu(e){let r={color:Bo[Bu++%Bo.length],enabled:Yr.enabled(e),namespace:e,log:Yr.log,extend:()=>{}},t=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=r;if(n.length!==0&&Kr.push([o,...n]),Kr.length>Vu&&Kr.shift(),Yr.enabled(o)||i){let l=n.map(c=>typeof c=="string"?c:Gu(c)),u=`+${Date.now()-Uo}ms`;Uo=Date.now(),globalThis.DEBUG_COLORS?a(jt[s](W(o)),...l,jt[s](u)):a(o,...l,u)}};return new Proxy(t,{get:(n,i)=>r[i],set:(n,i,o)=>r[i]=o})}var N=new Proxy(Uu,{get:(e,r)=>Yr[r],set:(e,r,t)=>Yr[r]=t});function Gu(e,r=2){let t=new Set;return JSON.stringify(e,(n,i)=>{if(typeof i=="object"&&i!==null){if(t.has(i))return"[Circular *]";t.add(i)}else if(typeof i=="bigint")return i.toString();return i},r)}function Go(e=7500){let r=Kr.map(([t,...n])=>`${t} ${n.map(i=>typeof i=="string"?i:JSON.stringify(i)).join(" ")}`).join(`
`);return r.length<e?r:r.slice(-e)}function Qo(){Kr.length=0}var gr=N;var Wo=k(require("node:fs"));function ii(){let e=process.env.PRISMA_QUERY_ENGINE_LIBRARY;if(!(e&&Wo.default.existsSync(e))&&process.arch==="ia32")throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}var oi=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var Vt="libquery_engine";function Bt(e,r){let t=r==="url";return e.includes("windows")?t?"query_engine.dll.node":`query_engine-${e}.dll.node`:e.includes("darwin")?t?`${Vt}.dylib.node`:`${Vt}-${e}.dylib.node`:t?`${Vt}.so.node`:`${Vt}-${e}.so.node`}var Yo=k(require("node:child_process")),ci=k(require("node:fs/promises")),Jt=k(require("node:os"));var De=Symbol.for("@ts-pattern/matcher"),Qu=Symbol.for("@ts-pattern/isVariadic"),Gt="@ts-pattern/anonymous-select-key",si=e=>!!(e&&typeof e=="object"),Ut=e=>e&&!!e[De],Ee=(e,r,t)=>{if(Ut(e)){let n=e[De](),{matched:i,selections:o}=n.match(r);return i&&o&&Object.keys(o).forEach(s=>t(s,o[s])),i}if(si(e)){if(!si(r))return!1;if(Array.isArray(e)){if(!Array.isArray(r))return!1;let n=[],i=[],o=[];for(let s of e.keys()){let a=e[s];Ut(a)&&a[Qu]?o.push(a):o.length?i.push(a):n.push(a)}if(o.length){if(o.length>1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(r.length<n.length+i.length)return!1;let s=r.slice(0,n.length),a=i.length===0?[]:r.slice(-i.length),l=r.slice(n.length,i.length===0?1/0:-i.length);return n.every((u,c)=>Ee(u,s[c],t))&&i.every((u,c)=>Ee(u,a[c],t))&&(o.length===0||Ee(o[0],l,t))}return e.length===r.length&&e.every((s,a)=>Ee(s,r[a],t))}return Reflect.ownKeys(e).every(n=>{let i=e[n];return(n in r||Ut(o=i)&&o[De]().matcherType==="optional")&&Ee(i,r[n],t);var o})}return Object.is(r,e)},Ge=e=>{var r,t,n;return si(e)?Ut(e)?(r=(t=(n=e[De]()).getSelectionKeys)==null?void 0:t.call(n))!=null?r:[]:Array.isArray(e)?zr(e,Ge):zr(Object.values(e),Ge):[]},zr=(e,r)=>e.reduce((t,n)=>t.concat(r(n)),[]);function pe(e){return Object.assign(e,{optional:()=>Wu(e),and:r=>q(e,r),or:r=>Ju(e,r),select:r=>r===void 0?Jo(e):Jo(r,e)})}function Wu(e){return pe({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return r===void 0?(Ge(e).forEach(i=>n(i,void 0)),{matched:!0,selections:t}):{matched:Ee(e,r,n),selections:t}},getSelectionKeys:()=>Ge(e),matcherType:"optional"})})}function q(...e){return pe({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return{matched:e.every(i=>Ee(i,r,n)),selections:t}},getSelectionKeys:()=>zr(e,Ge),matcherType:"and"})})}function Ju(...e){return pe({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return zr(e,Ge).forEach(i=>n(i,void 0)),{matched:e.some(i=>Ee(i,r,n)),selections:t}},getSelectionKeys:()=>zr(e,Ge),matcherType:"or"})})}function C(e){return{[De]:()=>({match:r=>({matched:!!e(r)})})}}function Jo(...e){let r=typeof e[0]=="string"?e[0]:void 0,t=e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];return pe({[De]:()=>({match:n=>{let i={[r??Gt]:n};return{matched:t===void 0||Ee(t,n,(o,s)=>{i[o]=s}),selections:i}},getSelectionKeys:()=>[r??Gt].concat(t===void 0?[]:Ge(t))})})}function ye(e){return typeof e=="number"}function je(e){return typeof e=="string"}function Ve(e){return typeof e=="bigint"}var eg=pe(C(function(e){return!0}));var Be=e=>Object.assign(pe(e),{startsWith:r=>{return Be(q(e,(t=r,C(n=>je(n)&&n.startsWith(t)))));var t},endsWith:r=>{return Be(q(e,(t=r,C(n=>je(n)&&n.endsWith(t)))));var t},minLength:r=>Be(q(e,(t=>C(n=>je(n)&&n.length>=t))(r))),length:r=>Be(q(e,(t=>C(n=>je(n)&&n.length===t))(r))),maxLength:r=>Be(q(e,(t=>C(n=>je(n)&&n.length<=t))(r))),includes:r=>{return Be(q(e,(t=r,C(n=>je(n)&&n.includes(t)))));var t},regex:r=>{return Be(q(e,(t=r,C(n=>je(n)&&!!n.match(t)))));var t}}),rg=Be(C(je)),be=e=>Object.assign(pe(e),{between:(r,t)=>be(q(e,((n,i)=>C(o=>ye(o)&&n<=o&&i>=o))(r,t))),lt:r=>be(q(e,(t=>C(n=>ye(n)&&n<t))(r))),gt:r=>be(q(e,(t=>C(n=>ye(n)&&n>t))(r))),lte:r=>be(q(e,(t=>C(n=>ye(n)&&n<=t))(r))),gte:r=>be(q(e,(t=>C(n=>ye(n)&&n>=t))(r))),int:()=>be(q(e,C(r=>ye(r)&&Number.isInteger(r)))),finite:()=>be(q(e,C(r=>ye(r)&&Number.isFinite(r)))),positive:()=>be(q(e,C(r=>ye(r)&&r>0))),negative:()=>be(q(e,C(r=>ye(r)&&r<0)))}),tg=be(C(ye)),Ue=e=>Object.assign(pe(e),{between:(r,t)=>Ue(q(e,((n,i)=>C(o=>Ve(o)&&n<=o&&i>=o))(r,t))),lt:r=>Ue(q(e,(t=>C(n=>Ve(n)&&n<t))(r))),gt:r=>Ue(q(e,(t=>C(n=>Ve(n)&&n>t))(r))),lte:r=>Ue(q(e,(t=>C(n=>Ve(n)&&n<=t))(r))),gte:r=>Ue(q(e,(t=>C(n=>Ve(n)&&n>=t))(r))),positive:()=>Ue(q(e,C(r=>Ve(r)&&r>0))),negative:()=>Ue(q(e,C(r=>Ve(r)&&r<0)))}),ng=Ue(C(Ve)),ig=pe(C(function(e){return typeof e=="boolean"})),og=pe(C(function(e){return typeof e=="symbol"})),sg=pe(C(function(e){return e==null})),ag=pe(C(function(e){return e!=null}));var ai=class extends Error{constructor(r){let t;try{t=JSON.stringify(r)}catch{t=r}super(`Pattern matching error: no pattern matches value ${t}`),this.input=void 0,this.input=r}},li={matched:!1,value:void 0};function hr(e){return new ui(e,li)}var ui=class e{constructor(r,t){this.input=void 0,this.state=void 0,this.input=r,this.state=t}with(...r){if(this.state.matched)return this;let t=r[r.length-1],n=[r[0]],i;r.length===3&&typeof r[1]=="function"?i=r[1]:r.length>2&&n.push(...r.slice(1,r.length-1));let o=!1,s={},a=(u,c)=>{o=!0,s[u]=c},l=!n.some(u=>Ee(u,this.input,a))||i&&!i(this.input)?li:{matched:!0,value:t(o?Gt in s?s[Gt]:s:this.input,this.input)};return new e(this.input,l)}when(r,t){if(this.state.matched)return this;let n=!!r(this.input);return new e(this.input,n?{matched:!0,value:t(this.input,this.input)}:li)}otherwise(r){return this.state.matched?this.state.value:r(this.input)}exhaustive(){if(this.state.matched)return this.state.value;throw new ai(this.input)}run(){return this.exhaustive()}returnType(){return this}};var zo=require("node:util");var Hu={warn:ke("prisma:warn")},Ku={warn:()=>!process.env.PRISMA_DISABLE_WARNINGS};function Qt(e,...r){Ku.warn()&&console.warn(`${Hu.warn} ${e}`,...r)}var Yu=(0,zo.promisify)(Yo.default.exec),ee=gr("prisma:get-platform"),zu=["1.0.x","1.1.x","3.0.x"];async function Zo(){let e=Jt.default.platform(),r=process.arch;if(e==="freebsd"){let s=await Ht("freebsd-version");if(s&&s.trim().length>0){let l=/^(\d+)\.?/.exec(s);if(l)return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:r}}}if(e!=="linux")return{platform:e,arch:r};let t=await Xu(),n=await ac(),i=rc({arch:r,archFromUname:n,familyDistro:t.familyDistro}),{libssl:o}=await tc(i);return{platform:"linux",libssl:o,arch:r,archFromUname:n,...t}}function Zu(e){let r=/^ID="?([^"\n]*)"?$/im,t=/^ID_LIKE="?([^"\n]*)"?$/im,n=r.exec(e),i=n&&n[1]&&n[1].toLowerCase()||"",o=t.exec(e),s=o&&o[1]&&o[1].toLowerCase()||"",a=hr({id:i,idLike:s}).with({id:"alpine"},({id:l})=>({targetDistro:"musl",familyDistro:l,originalDistro:l})).with({id:"raspbian"},({id:l})=>({targetDistro:"arm",familyDistro:"debian",originalDistro:l})).with({id:"nixos"},({id:l})=>({targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).with({id:"debian"},{id:"ubuntu"},({id:l})=>({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).with({id:"rhel"},{id:"centos"},{id:"fedora"},({id:l})=>({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).when(({idLike:l})=>l.includes("debian")||l.includes("ubuntu"),({id:l})=>({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).when(({idLike:l})=>i==="arch"||l.includes("arch"),({id:l})=>({targetDistro:"debian",familyDistro:"arch",originalDistro:l})).when(({idLike:l})=>l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),({id:l})=>({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).otherwise(({id:l})=>({targetDistro:void 0,familyDistro:void 0,originalDistro:l}));return ee(`Found distro info:
${JSON.stringify(a,null,2)}`),a}async function Xu(){let e="/etc/os-release";try{let r=await ci.default.readFile(e,{encoding:"utf-8"});return Zu(r)}catch{return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}}function ec(e){let r=/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);if(r){let t=`${r[1]}.x`;return Xo(t)}}function Ho(e){let r=/libssl\.so\.(\d)(\.\d)?/.exec(e);if(r){let t=`${r[1]}${r[2]??".0"}.x`;return Xo(t)}}function Xo(e){let r=(()=>{if(rs(e))return e;let t=e.split(".");return t[1]="0",t.join(".")})();if(zu.includes(r))return r}function rc(e){return hr(e).with({familyDistro:"musl"},()=>(ee('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])).with({familyDistro:"debian"},({archFromUname:r})=>(ee('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${r}-linux-gnu`,`/lib/${r}-linux-gnu`])).with({familyDistro:"rhel"},()=>(ee('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).otherwise(({familyDistro:r,arch:t,archFromUname:n})=>(ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`),[]))}async function tc(e){let r='grep -v "libssl.so.0"',t=await Ko(e);if(t){ee(`Found libssl.so file using platform-specific paths: ${t}`);let o=Ho(t);if(ee(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"libssl-specific-path"}}ee('Falling back to "ldconfig" and other generic paths');let n=await Ht(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);if(n||(n=await Ko(["/lib64","/usr/lib64","/lib","/usr/lib"])),n){ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);let o=Ho(n);if(ee(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"ldconfig"}}let i=await Ht("openssl version -v");if(i){ee(`Found openssl binary with version: ${i}`);let o=ec(i);if(ee(`The parsed openssl version is: ${o}`),o)return{libssl:o,strategy:"openssl-binary"}}return ee("Couldn't find any version of libssl or OpenSSL in the system"),{}}async function Ko(e){for(let r of e){let t=await nc(r);if(t)return t}}async function nc(e){try{return(await ci.default.readdir(e)).find(t=>t.startsWith("libssl.so.")&&!t.startsWith("libssl.so.0"))}catch(r){if(r.code==="ENOENT")return;throw r}}async function ir(){let{binaryTarget:e}=await es();return e}function ic(e){return e.binaryTarget!==void 0}async function pi(){let{memoized:e,...r}=await es();return r}var Wt={};async function es(){if(ic(Wt))return Promise.resolve({...Wt,memoized:!0});let e=await Zo(),r=oc(e);return Wt={...e,binaryTarget:r},{...Wt,memoized:!1}}function oc(e){let{platform:r,arch:t,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;r==="linux"&&!["x64","arm64"].includes(t)&&Qt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);let l="1.1.x";if(r==="linux"&&i===void 0){let c=hr({familyDistro:s}).with({familyDistro:"debian"},()=>"Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(()=>"Please manually install OpenSSL and try installing Prisma again.");Qt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`)}let u="debian";if(r==="linux"&&o===void 0&&ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),r==="darwin"&&t==="arm64")return"darwin-arm64";if(r==="darwin")return"darwin";if(r==="win32")return"windows";if(r==="freebsd")return o;if(r==="openbsd")return"openbsd";if(r==="netbsd")return"netbsd";if(r==="linux"&&o==="nixos")return"linux-nixos";if(r==="linux"&&t==="arm64")return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;if(r==="linux"&&t==="arm")return`linux-arm-openssl-${i||l}`;if(r==="linux"&&o==="musl"){let c="linux-musl";return!i||rs(i)?c:`${c}-openssl-${i}`}return r==="linux"&&o&&i?`${o}-openssl-${i}`:(r!=="linux"&&Qt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}async function sc(e){try{return await e()}catch{return}}function Ht(e){return sc(async()=>{let r=await Yu(e);return ee(`Command "${e}" successfully returned "${r.stdout}"`),r.stdout})}async function ac(){return typeof Jt.default.machine=="function"?Jt.default.machine():(await Ht("uname -m"))?.trim()}function rs(e){return e.startsWith("1.")}var zt={};tr(zt,{beep:()=>_c,clearScreen:()=>Ic,clearTerminal:()=>kc,cursorBackward:()=>fc,cursorDown:()=>dc,cursorForward:()=>mc,cursorGetPosition:()=>yc,cursorHide:()=>wc,cursorLeft:()=>is,cursorMove:()=>pc,cursorNextLine:()=>bc,cursorPrevLine:()=>Ec,cursorRestorePosition:()=>hc,cursorSavePosition:()=>gc,cursorShow:()=>xc,cursorTo:()=>cc,cursorUp:()=>ns,enterAlternativeScreen:()=>Oc,eraseDown:()=>Sc,eraseEndLine:()=>Pc,eraseLine:()=>os,eraseLines:()=>vc,eraseScreen:()=>di,eraseStartLine:()=>Tc,eraseUp:()=>Rc,exitAlternativeScreen:()=>Dc,iTerm:()=>Fc,image:()=>Lc,link:()=>Nc,scrollDown:()=>Ac,scrollUp:()=>Cc});var Yt=k(require("node:process"),1);var Kt=globalThis.window?.document!==void 0,gg=globalThis.process?.versions?.node!==void 0,hg=globalThis.process?.versions?.bun!==void 0,yg=globalThis.Deno?.version?.deno!==void 0,bg=globalThis.process?.versions?.electron!==void 0,Eg=globalThis.navigator?.userAgent?.includes("jsdom")===!0,wg=typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope,xg=typeof DedicatedWorkerGlobalScope<"u"&&globalThis instanceof DedicatedWorkerGlobalScope,vg=typeof SharedWorkerGlobalScope<"u"&&globalThis instanceof SharedWorkerGlobalScope,Pg=typeof ServiceWorkerGlobalScope<"u"&&globalThis instanceof ServiceWorkerGlobalScope,Zr=globalThis.navigator?.userAgentData?.platform,Tg=Zr==="macOS"||globalThis.navigator?.platform==="MacIntel"||globalThis.navigator?.userAgent?.includes(" Mac ")===!0||globalThis.process?.platform==="darwin",Sg=Zr==="Windows"||globalThis.navigator?.platform==="Win32"||globalThis.process?.platform==="win32",Rg=Zr==="Linux"||globalThis.navigator?.platform?.startsWith("Linux")===!0||globalThis.navigator?.userAgent?.includes(" Linux ")===!0||globalThis.process?.platform==="linux",Cg=Zr==="iOS"||globalThis.navigator?.platform==="MacIntel"&&globalThis.navigator?.maxTouchPoints>1||/iPad|iPhone|iPod/.test(globalThis.navigator?.platform),Ag=Zr==="Android"||globalThis.navigator?.platform==="Android"||globalThis.navigator?.userAgent?.includes(" Android ")===!0||globalThis.process?.platform==="android";var A="\x1B[",et="\x1B]",yr="\x07",Xr=";",ts=!Kt&&Yt.default.env.TERM_PROGRAM==="Apple_Terminal",lc=!Kt&&Yt.default.platform==="win32",uc=Kt?()=>{throw new Error("`process.cwd()` only works in Node.js, not the browser.")}:Yt.default.cwd,cc=(e,r)=>{if(typeof e!="number")throw new TypeError("The `x` argument is required");return typeof r!="number"?A+(e+1)+"G":A+(r+1)+Xr+(e+1)+"H"},pc=(e,r)=>{if(typeof e!="number")throw new TypeError("The `x` argument is required");let t="";return e<0?t+=A+-e+"D":e>0&&(t+=A+e+"C"),r<0?t+=A+-r+"A":r>0&&(t+=A+r+"B"),t},ns=(e=1)=>A+e+"A",dc=(e=1)=>A+e+"B",mc=(e=1)=>A+e+"C",fc=(e=1)=>A+e+"D",is=A+"G",gc=ts?"\x1B7":A+"s",hc=ts?"\x1B8":A+"u",yc=A+"6n",bc=A+"E",Ec=A+"F",wc=A+"?25l",xc=A+"?25h",vc=e=>{let r="";for(let t=0;t<e;t++)r+=os+(t<e-1?ns():"");return e&&(r+=is),r},Pc=A+"K",Tc=A+"1K",os=A+"2K",Sc=A+"J",Rc=A+"1J",di=A+"2J",Cc=A+"S",Ac=A+"T",Ic="\x1Bc",kc=lc?`${di}${A}0f`:`${di}${A}3J${A}H`,Oc=A+"?1049h",Dc=A+"?1049l",_c=yr,Nc=(e,r)=>[et,"8",Xr,Xr,r,yr,e,et,"8",Xr,Xr,yr].join(""),Lc=(e,r={})=>{let t=`${et}1337;File=inline=1`;return r.width&&(t+=`;width=${r.width}`),r.height&&(t+=`;height=${r.height}`),r.preserveAspectRatio===!1&&(t+=";preserveAspectRatio=0"),t+":"+Buffer.from(e).toString("base64")+yr},Fc={setCwd:(e=uc())=>`${et}50;CurrentDir=${e}${yr}`,annotation(e,r={}){let t=`${et}1337;`,n=r.x!==void 0,i=r.y!==void 0;if((n||i)&&!(n&&i&&r.length!==void 0))throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");return e=e.replaceAll("|",""),t+=r.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",r.length>0?t+=(n?[e,r.length,r.x,r.y]:[r.length,e]).join("|"):t+=e,t+yr}};var Zt=k(ds(),1);function or(e,r,{target:t="stdout",...n}={}){return Zt.default[t]?zt.link(e,r):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,r):`${e} (\u200B${r}\u200B)`}or.isSupported=Zt.default.stdout;or.stderr=(e,r,t={})=>or(e,r,{target:"stderr",...t});or.stderr.isSupported=Zt.default.stderr;function yi(e){return or(e,e,{fallback:Y})}var Vc=ms(),bi=Vc.version;var fs="library";function Er(e){let r=Bc();return r||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":fs)}function Bc(){let e=process.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}var Gc=k(wi());var M=k(require("node:path")),Qc=k(wi()),ah=N("prisma:engines");function gs(){return M.default.join(__dirname,"../")}var lh="libquery-engine";M.default.join(__dirname,"../query-engine-darwin");M.default.join(__dirname,"../query-engine-darwin-arm64");M.default.join(__dirname,"../query-engine-debian-openssl-1.0.x");M.default.join(__dirname,"../query-engine-debian-openssl-1.1.x");M.default.join(__dirname,"../query-engine-debian-openssl-3.0.x");M.default.join(__dirname,"../query-engine-linux-static-x64");M.default.join(__dirname,"../query-engine-linux-static-arm64");M.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x");M.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");M.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");M.default.join(__dirname,"../libquery_engine-darwin.dylib.node");M.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");M.default.join(__dirname,"../query_engine-windows.dll.node");var xi=k(require("node:fs")),hs=gr("chmodPlusX");function vi(e){if(process.platform==="win32")return;let r=xi.default.statSync(e),t=r.mode|64|8|1;if(r.mode===t){hs(`Execution permissions of ${e} are fine`);return}let n=t.toString(8).slice(-3);hs(`Have to call chmodPlusX on ${e}`),xi.default.chmodSync(e,n)}function Pi(e){let r=e.e,t=a=>`Prisma cannot find the required \`${a}\` system library in your system`,n=r.message.includes("cannot open shared object file"),i=`Please refer to the documentation about Prisma's system requirements: ${yi("https://pris.ly/d/system-requirements")}`,o=`Unable to require(\`${Ie(e.id)}\`).`,s=hr({message:r.message,code:r.code}).with({code:"ENOENT"},()=>"File does not exist.").when(({message:a})=>n&&a.includes("libz"),()=>`${t("libz")}. Please install it and try again.`).when(({message:a})=>n&&a.includes("libgcc_s"),()=>`${t("libgcc_s")}. Please install it and try again.`).when(({message:a})=>n&&a.includes("libssl"),()=>{let a=e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";return`${t("libssl")}. Please install ${a} and try again.`}).when(({message:a})=>a.includes("GLIBC"),()=>`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({message:a})=>e.platformInfo.platform==="linux"&&a.includes("symbol not found"),()=>`The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(()=>`The Prisma engines do not seem to be compatible with your system. ${i}`);return`${o}
${s}

Details: ${r.message}`}var Es=k(bs(),1);function Ti(e){let r=(0,Es.default)(e);if(r===0)return e;let t=new RegExp(`^[ \\t]{${r}}`,"gm");return e.replace(t,"")}var ws="prisma+postgres",en=`${ws}:`;function Si(e){return e?.startsWith(`${en}//`)??!1}var vs=k(Ri());function Ai(e){return String(new Ci(e))}var Ci=class{constructor(r){this.config=r}toString(){let{config:r}=this,t=r.provider.fromEnvVar?`env("${r.provider.fromEnvVar}")`:r.provider.value,n=JSON.parse(JSON.stringify({provider:t,binaryTargets:Wc(r.binaryTargets)}));return`generator ${r.name} {
${(0,vs.default)(Jc(n),2)}
}`}};function Wc(e){let r;if(e.length>0){let t=e.find(n=>n.fromEnvVar!==null);t?r=`env("${t.fromEnvVar}")`:r=e.map(n=>n.native?"native":n.value)}else r=void 0;return r}function Jc(e){let r=Object.keys(e).reduce((t,n)=>Math.max(t,n.length),0);return Object.entries(e).map(([t,n])=>`${t.padEnd(r)} = ${Hc(n)}`).join(`
`)}function Hc(e){return JSON.parse(JSON.stringify(e,(r,t)=>Array.isArray(t)?`[${t.map(n=>JSON.stringify(n)).join(", ")}]`:JSON.stringify(t)))}var tt={};tr(tt,{error:()=>zc,info:()=>Yc,log:()=>Kc,query:()=>Zc,should:()=>Ps,tags:()=>rt,warn:()=>Ii});var rt={error:ce("prisma:error"),warn:ke("prisma:warn"),info:Oe("prisma:info"),query:nr("prisma:query")},Ps={warn:()=>!process.env.PRISMA_DISABLE_WARNINGS};function Kc(...e){console.log(...e)}function Ii(e,...r){Ps.warn()&&console.warn(`${rt.warn} ${e}`,...r)}function Yc(e,...r){console.info(`${rt.info} ${e}`,...r)}function zc(e,...r){console.error(`${rt.error} ${e}`,...r)}function Zc(e,...r){console.log(`${rt.query} ${e}`,...r)}function rn(e,r){if(!e)throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}function _e(e,r){throw new Error(r)}var nt=k(require("node:path"));function Oi(e){return nt.default.sep===nt.default.posix.sep?e:e.split(nt.default.sep).join(nt.default.posix.sep)}var Fi=k(Os()),nn=k(require("node:fs"));var wr=k(require("node:path"));function Ds(e){let r=e.ignoreProcessEnv?{}:process.env,t=n=>n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o,s){let a=/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);if(!a)return o;let l=a[1],u,c;if(l==="\\")c=a[0],u=c.replace("\\$","$");else{let p=a[2];c=a[0].substring(l.length),u=Object.hasOwnProperty.call(r,p)?r[p]:e.parsed[p]||"",u=t(u)}return o.replace(c,u)},n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(r,n)?r[n]:e.parsed[n];e.parsed[n]=t(i)}for(let n in e.parsed)r[n]=e.parsed[n];return e}var Li=gr("prisma:tryLoadEnv");function it({rootEnvPath:e,schemaEnvPath:r},t={conflictCheck:"none"}){let n=_s(e);t.conflictCheck!=="none"&&gp(n,r,t.conflictCheck);let i=null;return Ns(n?.path,r)||(i=_s(r)),!n&&!i&&Li("No Environment variables loaded"),i?.dotenvResult.error?console.error(ce(W("Schema Env Error: "))+i.dotenvResult.error):{message:[n?.message,i?.message].filter(Boolean).join(`
`),parsed:{...n?.dotenvResult?.parsed,...i?.dotenvResult?.parsed}}}function gp(e,r,t){let n=e?.dotenvResult.parsed,i=!Ns(e?.path,r);if(n&&r&&i&&nn.default.existsSync(r)){let o=Fi.default.parse(nn.default.readFileSync(r)),s=[];for(let a in o)n[a]===o[a]&&s.push(a);if(s.length>0){let a=wr.default.relative(process.cwd(),e.path),l=wr.default.relative(process.cwd(),r);if(t==="error"){let u=`There is a conflict between env var${s.length>1?"s":""} in ${Y(a)} and ${Y(l)}
Conflicting env vars:
${s.map(c=>`  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.
`;throw new Error(u)}else if(t==="warn"){let u=`Conflict for env var${s.length>1?"s":""} ${s.map(c=>W(c)).join(", ")} in ${Y(a)} and ${Y(l)}
Env vars from ${Y(l)} overwrite the ones from ${Y(a)}
      `;console.warn(`${ke("warn(prisma)")} ${u}`)}}}}function _s(e){if(hp(e)){Li(`Environment variables loaded from ${e}`);let r=Fi.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG?!0:void 0});return{dotenvResult:Ds(r),message:Ie(`Environment variables loaded from ${wr.default.relative(process.cwd(),e)}`),path:e}}else Li(`Environment variables not found at ${e}`);return null}function Ns(e,r){return e&&r&&wr.default.resolve(e)===wr.default.resolve(r)}function hp(e){return!!(e&&nn.default.existsSync(e))}function Mi(e,r){return Object.prototype.hasOwnProperty.call(e,r)}function xr(e,r){let t={};for(let n of Object.keys(e))t[n]=r(e[n],n);return t}function $i(e,r){if(e.length===0)return;let t=e[0];for(let n=1;n<e.length;n++)r(t,e[n])<0&&(t=e[n]);return t}function x(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var Fs=new Set,ot=(e,r,...t)=>{Fs.has(e)||(Fs.add(e),Ii(r,...t))};var T=class e extends Error{clientVersion;errorCode;retryable;constructor(r,t,n){super(r),this.name="PrismaClientInitializationError",this.clientVersion=t,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};x(T,"PrismaClientInitializationError");var z=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(r,{code:t,clientVersion:n,meta:i,batchRequestIdx:o}){super(r),this.name="PrismaClientKnownRequestError",this.code=t,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};x(z,"PrismaClientKnownRequestError");var le=class extends Error{clientVersion;constructor(r,t){super(r),this.name="PrismaClientRustPanicError",this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};x(le,"PrismaClientRustPanicError");var j=class extends Error{clientVersion;batchRequestIdx;constructor(r,{clientVersion:t,batchRequestIdx:n}){super(r),this.name="PrismaClientUnknownRequestError",this.clientVersion=t,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};x(j,"PrismaClientUnknownRequestError");var Z=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(r,{clientVersion:t}){super(r),this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};x(Z,"PrismaClientValidationError");var vr=9e15,Ke=1e9,qi="0123456789abcdef",un="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",cn="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",ji={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-vr,maxE:vr,crypto:!1},js,Le,w=!0,dn="[DecimalError] ",He=dn+"Invalid argument: ",Vs=dn+"Precision limit exceeded",Bs=dn+"crypto unavailable",Us="[object Decimal]",X=Math.floor,U=Math.pow,yp=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,bp=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Ep=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Gs=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,fe=1e7,E=7,wp=9007199254740991,xp=un.length-1,Vi=cn.length-1,m={toStringTag:Us};m.absoluteValue=m.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),y(e)};m.ceil=function(){return y(new this.constructor(this),this.e+1,2)};m.clampedTo=m.clamp=function(e,r){var t,n=this,i=n.constructor;if(e=new i(e),r=new i(r),!e.s||!r.s)return new i(NaN);if(e.gt(r))throw Error(He+r);return t=n.cmp(e),t<0?e:n.cmp(r)>0?r:new i(n)};m.comparedTo=m.cmp=function(e){var r,t,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?NaN:l!==u?l:s===a?0:!s^l<0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e>e.e^l<0?1:-1;for(n=s.length,i=a.length,r=0,t=n<i?n:i;r<t;++r)if(s[r]!==a[r])return s[r]>a[r]^l<0?1:-1;return n===i?0:n>i^l<0?1:-1};m.cosine=m.cos=function(){var e,r,t=this,n=t.constructor;return t.d?t.d[0]?(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=vp(n,Ks(n,t)),n.precision=e,n.rounding=r,y(Le==2||Le==3?t.neg():t,e,r,!0)):new n(1):new n(NaN)};m.cubeRoot=m.cbrt=function(){var e,r,t,n,i,o,s,a,l,u,c=this,p=c.constructor;if(!c.isFinite()||c.isZero())return new p(c);for(w=!1,o=c.s*U(c.s*c,1/3),!o||Math.abs(o)==1/0?(t=J(c.d),e=c.e,(o=(e-t.length+1)%3)&&(t+=o==1||o==-2?"0":"00"),o=U(t,1/3),e=X((e+1)/3)-(e%3==(e<0?-1:2)),o==1/0?t="5e"+e:(t=o.toExponential(),t=t.slice(0,t.indexOf("e")+1)+e),n=new p(t),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.plus(c),n=L(u.plus(c).times(a),u.plus(l),s+2,1),J(a.d).slice(0,s)===(t=J(n.d)).slice(0,s))if(t=t.slice(s-3,s+1),t=="9999"||!i&&t=="4999"){if(!i&&(y(a,e+1,0),a.times(a).times(a).eq(c))){n=a;break}s+=4,i=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(y(n,e+1,1),r=!n.times(n).times(n).eq(c));break}return w=!0,y(n,e,p.rounding,r)};m.decimalPlaces=m.dp=function(){var e,r=this.d,t=NaN;if(r){if(e=r.length-1,t=(e-X(this.e/E))*E,e=r[e],e)for(;e%10==0;e/=10)t--;t<0&&(t=0)}return t};m.dividedBy=m.div=function(e){return L(this,new this.constructor(e))};m.dividedToIntegerBy=m.divToInt=function(e){var r=this,t=r.constructor;return y(L(r,new t(e),0,1,1),t.precision,t.rounding)};m.equals=m.eq=function(e){return this.cmp(e)===0};m.floor=function(){return y(new this.constructor(this),this.e+1,3)};m.greaterThan=m.gt=function(e){return this.cmp(e)>0};m.greaterThanOrEqualTo=m.gte=function(e){var r=this.cmp(e);return r==1||r===0};m.hyperbolicCosine=m.cosh=function(){var e,r,t,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;t=s.precision,n=s.rounding,s.precision=t+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i<32?(e=Math.ceil(i/3),r=(1/fn(4,e)).toString()):(e=16,r="2.3283064365386962890625e-10"),o=Pr(s,1,o.times(r),new s(1),!0);for(var l,u=e,c=new s(8);u--;)l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));return y(o,s.precision=t,s.rounding=n,!0)};m.hyperbolicSine=m.sinh=function(){var e,r,t,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(r=o.precision,t=o.rounding,o.precision=r+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n<3)i=Pr(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e>16?16:e|0,i=i.times(1/fn(5,e)),i=Pr(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=r,o.rounding=t,y(i,r,t,!0)};m.hyperbolicTangent=m.tanh=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+7,n.rounding=1,L(t.sinh(),t.cosh(),n.precision=e,n.rounding=r)):new n(t.s)};m.inverseCosine=m.acos=function(){var e=this,r=e.constructor,t=e.abs().cmp(1),n=r.precision,i=r.rounding;return t!==-1?t===0?e.isNeg()?we(r,n,i):new r(0):new r(NaN):e.isZero()?we(r,n+4,i).times(.5):(r.precision=n+6,r.rounding=1,e=new r(1).minus(e).div(e.plus(1)).sqrt().atan(),r.precision=n,r.rounding=i,e.times(2))};m.inverseHyperbolicCosine=m.acosh=function(){var e,r,t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(e=n.precision,r=n.rounding,n.precision=e+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,w=!1,t=t.times(t).minus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln()):new n(t)};m.inverseHyperbolicSine=m.asinh=function(){var e,r,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,w=!1,t=t.times(t).plus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln())};m.inverseHyperbolicTangent=m.atanh=function(){var e,r,t,n,i=this,o=i.constructor;return i.isFinite()?i.e>=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,r=o.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?y(new o(i),e,r,!0):(o.precision=t=n-i.e,i=L(i.plus(1),new o(1).minus(i),t+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=r,i.times(.5))):new o(NaN)};m.inverseSine=m.asin=function(){var e,r,t,n,i=this,o=i.constructor;return i.isZero()?new o(i):(r=i.abs().cmp(1),t=o.precision,n=o.rounding,r!==-1?r===0?(e=we(o,t+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=t+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=t,o.rounding=n,i.times(2)))};m.inverseTangent=m.atan=function(){var e,r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding;if(u.isFinite()){if(u.isZero())return new c(u);if(u.abs().eq(1)&&p+4<=Vi)return s=we(c,p+4,d).times(.25),s.s=u.s,s}else{if(!u.s)return new c(NaN);if(p+4<=Vi)return s=we(c,p+4,d).times(.5),s.s=u.s,s}for(c.precision=a=p+10,c.rounding=1,t=Math.min(28,a/E+2|0),e=t;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(w=!1,r=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[r]!==void 0)for(e=r;s.d[e]===o.d[e]&&e--;);return t&&(s=s.times(2<<t-1)),w=!0,y(s,c.precision=p,c.rounding=d,!0)};m.isFinite=function(){return!!this.d};m.isInteger=m.isInt=function(){return!!this.d&&X(this.e/E)>this.d.length-2};m.isNaN=function(){return!this.s};m.isNegative=m.isNeg=function(){return this.s<0};m.isPositive=m.isPos=function(){return this.s>0};m.isZero=function(){return!!this.d&&this.d[0]===0};m.lessThan=m.lt=function(e){return this.cmp(e)<0};m.lessThanOrEqualTo=m.lte=function(e){return this.cmp(e)<1};m.logarithm=m.log=function(e){var r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding,f=5;if(e==null)e=new c(10),r=!0;else{if(e=new c(e),t=e.d,e.s<0||!t||!t[0]||e.eq(1))return new c(NaN);r=e.eq(10)}if(t=u.d,u.s<0||!t||!t[0]||u.eq(1))return new c(t&&!t[0]?-1/0:u.s!=1?NaN:t?0:1/0);if(r)if(t.length>1)o=!0;else{for(i=t[0];i%10===0;)i/=10;o=i!==1}if(w=!1,a=p+f,s=Je(u,a),n=r?pn(c,a+10):Je(e,a),l=L(s,n,a,1),st(l.d,i=p,d))do if(a+=10,s=Je(u,a),n=r?pn(c,a+10):Je(e,a),l=L(s,n,a,1),!o){+J(l.d).slice(i+1,i+15)+1==1e14&&(l=y(l,p+1,0));break}while(st(l.d,i+=10,d));return w=!0,y(l,p,d)};m.minus=m.sub=function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,g=f.constructor;if(e=new g(e),!f.d||!e.d)return!f.s||!e.s?e=new g(NaN):f.d?e.s=-e.s:e=new g(e.d||f.s!==e.s?f:NaN),e;if(f.s!=e.s)return e.s=-e.s,f.plus(e);if(u=f.d,d=e.d,a=g.precision,l=g.rounding,!u[0]||!d[0]){if(d[0])e.s=-e.s;else if(u[0])e=new g(f);else return new g(l===3?-0:0);return w?y(e,a,l):e}if(t=X(e.e/E),c=X(f.e/E),u=u.slice(),o=c-t,o){for(p=o<0,p?(r=u,o=-o,s=d.length):(r=d,t=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o>n&&(o=n,r.length=1),r.reverse(),n=o;n--;)r.push(0);r.reverse()}else{for(n=u.length,s=d.length,p=n<s,p&&(s=n),n=0;n<s;n++)if(u[n]!=d[n]){p=u[n]<d[n];break}o=0}for(p&&(r=u,u=d,d=r,e.s=-e.s),s=u.length,n=d.length-s;n>0;--n)u[s++]=0;for(n=d.length;n>o;){if(u[--n]<d[n]){for(i=n;i&&u[--i]===0;)u[i]=fe-1;--u[i],u[n]+=fe}u[n]-=d[n]}for(;u[--s]===0;)u.pop();for(;u[0]===0;u.shift())--t;return u[0]?(e.d=u,e.e=mn(u,t),w?y(e,a,l):e):new g(l===3?-0:0)};m.modulo=m.mod=function(e){var r,t=this,n=t.constructor;return e=new n(e),!t.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||t.d&&!t.d[0]?y(new n(t),n.precision,n.rounding):(w=!1,n.modulo==9?(r=L(t,e.abs(),0,3,1),r.s*=e.s):r=L(t,e,0,n.modulo,1),r=r.times(e),w=!0,t.minus(r))};m.naturalExponential=m.exp=function(){return Bi(this)};m.naturalLogarithm=m.ln=function(){return Je(this)};m.negated=m.neg=function(){var e=new this.constructor(this);return e.s=-e.s,y(e)};m.plus=m.add=function(e){var r,t,n,i,o,s,a,l,u,c,p=this,d=p.constructor;if(e=new d(e),!p.d||!e.d)return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;if(p.s!=e.s)return e.s=-e.s,p.minus(e);if(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])return c[0]||(e=new d(p)),w?y(e,a,l):e;if(o=X(p.e/E),n=X(e.e/E),u=u.slice(),i=o-n,i){for(i<0?(t=u,i=-i,s=c.length):(t=c,n=o,s=u.length),o=Math.ceil(a/E),s=o>s?o+1:s+1,i>s&&(i=s,t.length=1),t.reverse();i--;)t.push(0);t.reverse()}for(s=u.length,i=c.length,s-i<0&&(i=s,t=c,c=u,u=t),r=0;i;)r=(u[--i]=u[i]+c[i]+r)/fe|0,u[i]%=fe;for(r&&(u.unshift(r),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=mn(u,n),w?y(e,a,l):e};m.precision=m.sd=function(e){var r,t=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error(He+e);return t.d?(r=Qs(t.d),e&&t.e+1>r&&(r=t.e+1)):r=NaN,r};m.round=function(){var e=this,r=e.constructor;return y(new r(e),e.e+1,r.rounding)};m.sine=m.sin=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Tp(n,Ks(n,t)),n.precision=e,n.rounding=r,y(Le>2?t.neg():t,e,r,!0)):new n(NaN)};m.squareRoot=m.sqrt=function(){var e,r,t,n,i,o,s=this,a=s.d,l=s.e,u=s.s,c=s.constructor;if(u!==1||!a||!a[0])return new c(!u||u<0&&(!a||a[0])?NaN:a?s:1/0);for(w=!1,u=Math.sqrt(+s),u==0||u==1/0?(r=J(a),(r.length+l)%2==0&&(r+="0"),u=Math.sqrt(r),l=X((l+1)/2)-(l<0||l%2),u==1/0?r="5e"+l:(r=u.toExponential(),r=r.slice(0,r.indexOf("e")+1)+l),n=new c(r)):n=new c(u.toString()),t=(l=c.precision)+3;;)if(o=n,n=o.plus(L(s,o,t+2,1)).times(.5),J(o.d).slice(0,t)===(r=J(n.d)).slice(0,t))if(r=r.slice(t-3,t+1),r=="9999"||!i&&r=="4999"){if(!i&&(y(o,l+1,0),o.times(o).eq(s))){n=o;break}t+=4,i=1}else{(!+r||!+r.slice(1)&&r.charAt(0)=="5")&&(y(n,l+1,1),e=!n.times(n).eq(s));break}return w=!0,y(n,l,c.rounding,e)};m.tangent=m.tan=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+10,n.rounding=1,t=t.sin(),t.s=1,t=L(t,new n(1).minus(t.times(t)).sqrt(),e+10,0),n.precision=e,n.rounding=r,y(Le==2||Le==4?t.neg():t,e,r,!0)):new n(NaN)};m.times=m.mul=function(e){var r,t,n,i,o,s,a,l,u,c=this,p=c.constructor,d=c.d,f=(e=new p(e)).d;if(e.s*=c.s,!d||!d[0]||!f||!f[0])return new p(!e.s||d&&!d[0]&&!f||f&&!f[0]&&!d?NaN:!d||!f?e.s/0:e.s*0);for(t=X(c.e/E)+X(e.e/E),l=d.length,u=f.length,l<u&&(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.push(0);for(n=u;--n>=0;){for(r=0,i=l+n;i>n;)a=o[i]+f[n]*d[i-n-1]+r,o[i--]=a%fe|0,r=a/fe|0;o[i]=(o[i]+r)%fe|0}for(;!o[--s];)o.pop();return r?++t:o.shift(),e.d=o,e.e=mn(o,t),w?y(e,p.precision,p.rounding):e};m.toBinary=function(e,r){return Ui(this,2,e,r)};m.toDecimalPlaces=m.toDP=function(e,r){var t=this,n=t.constructor;return t=new n(t),e===void 0?t:(ie(e,0,Ke),r===void 0?r=n.rounding:ie(r,0,8),y(t,e+t.e+1,r))};m.toExponential=function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=xe(n,!0):(ie(e,0,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e+1,r),t=xe(n,!0,e+1)),n.isNeg()&&!n.isZero()?"-"+t:t};m.toFixed=function(e,r){var t,n,i=this,o=i.constructor;return e===void 0?t=xe(i):(ie(e,0,Ke),r===void 0?r=o.rounding:ie(r,0,8),n=y(new o(i),e+i.e+1,r),t=xe(n,!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+t:t};m.toFraction=function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,g=f.d,h=f.constructor;if(!g)return new h(f);if(u=t=new h(1),n=l=new h(0),r=new h(n),o=r.e=Qs(g)-f.e-1,s=o%E,r.d[0]=U(10,s<0?E+s:s),e==null)e=o>0?r:u;else{if(a=new h(e),!a.isInt()||a.lt(u))throw Error(He+a);e=a.gt(r)?o>0?r:u:a}for(w=!1,a=new h(J(g)),c=h.precision,h.precision=o=g.length*E*2;p=L(a,r,0,1,1),i=t.plus(p.times(n)),i.cmp(e)!=1;)t=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=r,r=a.minus(p.times(i)),a=i;return i=L(e.minus(t),n,0,1,1),l=l.plus(i.times(u)),t=t.plus(i.times(n)),l.s=u.s=f.s,d=L(u,n,o,1).minus(f).abs().cmp(L(l,t,o,1).minus(f).abs())<1?[u,n]:[l,t],h.precision=c,w=!0,d};m.toHexadecimal=m.toHex=function(e,r){return Ui(this,16,e,r)};m.toNearest=function(e,r){var t=this,n=t.constructor;if(t=new n(t),e==null){if(!t.d)return t;e=new n(1),r=n.rounding}else{if(e=new n(e),r===void 0?r=n.rounding:ie(r,0,8),!t.d)return e.s?t:e;if(!e.d)return e.s&&(e.s=t.s),e}return e.d[0]?(w=!1,t=L(t,e,0,r,1).times(e),w=!0,y(t)):(e.s=t.s,t=e),t};m.toNumber=function(){return+this};m.toOctal=function(e,r){return Ui(this,8,e,r)};m.toPower=m.pow=function(e){var r,t,n,i,o,s,a=this,l=a.constructor,u=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(U(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return y(a,n,o);if(r=X(e.e/E),r>=e.d.length-1&&(t=u<0?-u:u)<=wp)return i=Ws(l,a,t,n),e.s<0?new l(1).div(i):y(i,n,o);if(s=a.s,s<0){if(r<e.d.length-1)return new l(NaN);if((e.d[r]&1)==0&&(s=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=s,a}return t=U(+a,u),r=t==0||!isFinite(t)?X(u*(Math.log("0."+J(a.d))/Math.LN10+a.e+1)):new l(t+"").e,r>l.maxE+1||r<l.minE-1?new l(r>0?s/0:0):(w=!1,l.rounding=a.s=1,t=Math.min(12,(r+"").length),i=Bi(e.times(Je(a,n+t)),n),i.d&&(i=y(i,n+5,1),st(i.d,n,o)&&(r=n+10,i=y(Bi(e.times(Je(a,r+t)),r),r+5,1),+J(i.d).slice(n+1,n+15)+1==1e14&&(i=y(i,n+1,0)))),i.s=s,w=!0,l.rounding=o,y(i,n,o))};m.toPrecision=function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=xe(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(ie(e,1,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e,r),t=xe(n,e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+t:t};m.toSignificantDigits=m.toSD=function(e,r){var t=this,n=t.constructor;return e===void 0?(e=n.precision,r=n.rounding):(ie(e,1,Ke),r===void 0?r=n.rounding:ie(r,0,8)),y(new n(t),e,r)};m.toString=function(){var e=this,r=e.constructor,t=xe(e,e.e<=r.toExpNeg||e.e>=r.toExpPos);return e.isNeg()&&!e.isZero()?"-"+t:t};m.truncated=m.trunc=function(){return y(new this.constructor(this),this.e+1,1)};m.valueOf=m.toJSON=function(){var e=this,r=e.constructor,t=xe(e,e.e<=r.toExpNeg||e.e>=r.toExpPos);return e.isNeg()?"-"+t:t};function J(e){var r,t,n,i=e.length-1,o="",s=e[0];if(i>0){for(o+=s,r=1;r<i;r++)n=e[r]+"",t=E-n.length,t&&(o+=We(t)),o+=n;s=e[r],n=s+"",t=E-n.length,t&&(o+=We(t))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function ie(e,r,t){if(e!==~~e||e<r||e>t)throw Error(He+e)}function st(e,r,t,n){var i,o,s,a;for(o=e[0];o>=10;o/=10)--r;return--r<0?(r+=E,i=0):(i=Math.ceil((r+1)/E),r%=E),o=U(10,E-r),a=e[i]%o|0,n==null?r<3?(r==0?a=a/100|0:r==1&&(a=a/10|0),s=t<4&&a==99999||t>3&&a==49999||a==5e4||a==0):s=(t<4&&a+1==o||t>3&&a+1==o/2)&&(e[i+1]/o/100|0)==U(10,r-2)-1||(a==o/2||a==0)&&(e[i+1]/o/100|0)==0:r<4?(r==0?a=a/1e3|0:r==1?a=a/100|0:r==2&&(a=a/10|0),s=(n||t<4)&&a==9999||!n&&t>3&&a==4999):s=((n||t<4)&&a+1==o||!n&&t>3&&a+1==o/2)&&(e[i+1]/o/1e3|0)==U(10,r-3)-1,s}function an(e,r,t){for(var n,i=[0],o,s=0,a=e.length;s<a;){for(o=i.length;o--;)i[o]*=r;for(i[0]+=qi.indexOf(e.charAt(s++)),n=0;n<i.length;n++)i[n]>t-1&&(i[n+1]===void 0&&(i[n+1]=0),i[n+1]+=i[n]/t|0,i[n]%=t)}return i.reverse()}function vp(e,r){var t,n,i;if(r.isZero())return r;n=r.d.length,n<32?(t=Math.ceil(n/3),i=(1/fn(4,t)).toString()):(t=16,i="2.3283064365386962890625e-10"),e.precision+=t,r=Pr(e,1,r.times(i),new e(1));for(var o=t;o--;){var s=r.times(r);r=s.times(s).minus(s).times(8).plus(1)}return e.precision-=t,r}var L=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&&n.unshift(a),n}function r(n,i,o,s){var a,l;if(o!=s)l=o>s?1:-1;else for(a=l=0;a<o;a++)if(n[a]!=i[a]){l=n[a]>i[a]?1:-1;break}return l}function t(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]<i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s,a,l){var u,c,p,d,f,g,h,I,P,S,b,O,me,ae,Jr,V,te,Ae,H,fr,$t=n.constructor,Xn=n.s==i.s?1:-1,K=n.d,_=i.d;if(!K||!K[0]||!_||!_[0])return new $t(!n.s||!i.s||(K?_&&K[0]==_[0]:!_)?NaN:K&&K[0]==0||!_?Xn*0:Xn/0);for(l?(f=1,c=n.e-i.e):(l=fe,f=E,c=X(n.e/f)-X(i.e/f)),H=_.length,te=K.length,P=new $t(Xn),S=P.d=[],p=0;_[p]==(K[p]||0);p++);if(_[p]>(K[p]||0)&&c--,o==null?(ae=o=$t.precision,s=$t.rounding):a?ae=o+(n.e-i.e)+1:ae=o,ae<0)S.push(1),g=!0;else{if(ae=ae/f+2|0,p=0,H==1){for(d=0,_=_[0],ae++;(p<te||d)&&ae--;p++)Jr=d*l+(K[p]||0),S[p]=Jr/_|0,d=Jr%_|0;g=d||p<te}else{for(d=l/(_[0]+1)|0,d>1&&(_=e(_,d,l),K=e(K,d,l),H=_.length,te=K.length),V=H,b=K.slice(0,H),O=b.length;O<H;)b[O++]=0;fr=_.slice(),fr.unshift(0),Ae=_[0],_[1]>=l/2&&++Ae;do d=0,u=r(_,b,H,O),u<0?(me=b[0],H!=O&&(me=me*l+(b[1]||0)),d=me/Ae|0,d>1?(d>=l&&(d=l-1),h=e(_,d,l),I=h.length,O=b.length,u=r(h,b,I,O),u==1&&(d--,t(h,H<I?fr:_,I,l))):(d==0&&(u=d=1),h=_.slice()),I=h.length,I<O&&h.unshift(0),t(b,h,O,l),u==-1&&(O=b.length,u=r(_,b,H,O),u<1&&(d++,t(b,H<O?fr:_,O,l))),O=b.length):u===0&&(d++,b=[0]),S[p++]=d,u&&b[0]?b[O++]=K[V]||0:(b=[K[V]],O=1);while((V++<te||b[0]!==void 0)&&ae--);g=b[0]!==void 0}S[0]||S.shift()}if(f==1)P.e=c,js=g;else{for(p=1,d=S[0];d>=10;d/=10)p++;P.e=p+c*f-1,y(P,a?o+P.e+1:o,s,g)}return P}}();function y(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor;e:if(r!=null){if(p=e.d,!p)return e;for(i=1,a=p[0];a>=10;a/=10)i++;if(o=r-i,o<0)o+=E,s=r,c=p[d=0],l=c/U(10,i-s-1)%10|0;else if(d=Math.ceil((o+1)/E),a=p.length,d>=a)if(n){for(;a++<=d;)p.push(0);c=l=0,i=1,o%=E,s=o-E+1}else break e;else{for(c=a=p[d],i=1;a>=10;a/=10)i++;o%=E,s=o-E+i,l=s<0?0:c/U(10,i-s-1)%10|0}if(n=n||r<0||p[d+1]!==void 0||(s<0?c:c%U(10,i-s-1)),u=t<4?(l||n)&&(t==0||t==(e.s<0?3:2)):l>5||l==5&&(t==4||n||t==6&&(o>0?s>0?c/U(10,i-s):0:p[d-1])%10&1||t==(e.s<0?8:7)),r<1||!p[0])return p.length=0,u?(r-=e.e+1,p[0]=U(10,(E-r%E)%E),e.e=-r||0):p[0]=e.e=0,e;if(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=U(10,E-o),p[d]=s>0?(c/U(10,i-s)%U(10,s)|0)*a:0),u)for(;;)if(d==0){for(o=1,s=p[0];s>=10;s/=10)o++;for(s=p[0]+=a,a=1;s>=10;s/=10)a++;o!=a&&(e.e++,p[0]==fe&&(p[0]=1));break}else{if(p[d]+=a,p[d]!=fe)break;p[d--]=0,a=1}for(o=p.length;p[--o]===0;)p.pop()}return w&&(e.e>f.maxE?(e.d=null,e.e=NaN):e.e<f.minE&&(e.e=0,e.d=[0])),e}function xe(e,r,t){if(!e.isFinite())return Hs(e);var n,i=e.e,o=J(e.d),s=o.length;return r?(t&&(n=t-s)>0?o=o.charAt(0)+"."+o.slice(1)+We(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):i<0?(o="0."+We(-i-1)+o,t&&(n=t-s)>0&&(o+=We(n))):i>=s?(o+=We(i+1-s),t&&(n=t-i-1)>0&&(o=o+"."+We(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),t&&(n=t-s)>0&&(i+1===s&&(o+="."),o+=We(n))),o}function mn(e,r){var t=e[0];for(r*=E;t>=10;t/=10)r++;return r}function pn(e,r,t){if(r>xp)throw w=!0,t&&(e.precision=t),Error(Vs);return y(new e(un),r,1,!0)}function we(e,r,t){if(r>Vi)throw Error(Vs);return y(new e(cn),r,t,!0)}function Qs(e){var r=e.length-1,t=r*E+1;if(r=e[r],r){for(;r%10==0;r/=10)t--;for(r=e[0];r>=10;r/=10)t++}return t}function We(e){for(var r="";e--;)r+="0";return r}function Ws(e,r,t,n){var i,o=new e(1),s=Math.ceil(n/E+4);for(w=!1;;){if(t%2&&(o=o.times(r),$s(o.d,s)&&(i=!0)),t=X(t/2),t===0){t=o.d.length-1,i&&o.d[t]===0&&++o.d[t];break}r=r.times(r),$s(r.d,s)}return w=!0,o}function Ms(e){return e.d[e.d.length-1]&1}function Js(e,r,t){for(var n,i,o=new e(r[0]),s=0;++s<r.length;){if(i=new e(r[s]),!i.s){o=i;break}n=o.cmp(i),(n===t||n===0&&o.s===t)&&(o=i)}return o}function Bi(e,r){var t,n,i,o,s,a,l,u=0,c=0,p=0,d=e.constructor,f=d.rounding,g=d.precision;if(!e.d||!e.d[0]||e.e>17)return new d(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(r==null?(w=!1,l=g):l=r,a=new d(.03125);e.e>-2;)e=e.times(a),p+=5;for(n=Math.log(U(2,p))/Math.LN10*2+5|0,l+=n,t=o=s=new d(1),d.precision=l;;){if(o=y(o.times(e),l,1),t=t.times(++c),a=s.plus(L(o,t,l,1)),J(a.d).slice(0,l)===J(s.d).slice(0,l)){for(i=p;i--;)s=y(s.times(s),l,1);if(r==null)if(u<3&&st(s.d,l-n,f,u))d.precision=l+=10,t=o=a=new d(1),c=0,u++;else return y(s,d.precision=g,f,w=!0);else return d.precision=g,s}s=a}}function Je(e,r){var t,n,i,o,s,a,l,u,c,p,d,f=1,g=10,h=e,I=h.d,P=h.constructor,S=P.rounding,b=P.precision;if(h.s<0||!I||!I[0]||!h.e&&I[0]==1&&I.length==1)return new P(I&&!I[0]?-1/0:h.s!=1?NaN:I?0:h);if(r==null?(w=!1,c=b):c=r,P.precision=c+=g,t=J(I),n=t.charAt(0),Math.abs(o=h.e)<15e14){for(;n<7&&n!=1||n==1&&t.charAt(1)>3;)h=h.times(e),t=J(h.d),n=t.charAt(0),f++;o=h.e,n>1?(h=new P("0."+t),o++):h=new P(n+"."+t.slice(1))}else return u=pn(P,c+2,b).times(o+""),h=Je(new P(n+"."+t.slice(1)),c-g).plus(u),P.precision=b,r==null?y(h,b,S,w=!0):h;for(p=h,l=s=h=L(h.minus(1),h.plus(1),c,1),d=y(h.times(h),c,1),i=3;;){if(s=y(s.times(d),c,1),u=l.plus(L(s,new P(i),c,1)),J(u.d).slice(0,c)===J(l.d).slice(0,c))if(l=l.times(2),o!==0&&(l=l.plus(pn(P,c+2,b).times(o+""))),l=L(l,new P(f),c,1),r==null)if(st(l.d,c-g,S,a))P.precision=c+=g,u=s=h=L(p.minus(1),p.plus(1),c,1),d=y(h.times(h),c,1),i=a=1;else return y(l,P.precision=b,S,w=!0);else return P.precision=b,l;l=u,i+=2}}function Hs(e){return String(e.s*e.s/0)}function ln(e,r){var t,n,i;for((t=r.indexOf("."))>-1&&(r=r.replace(".","")),(n=r.search(/e/i))>0?(t<0&&(t=n),t+=+r.slice(n+1),r=r.substring(0,n)):t<0&&(t=r.length),n=0;r.charCodeAt(n)===48;n++);for(i=r.length;r.charCodeAt(i-1)===48;--i);if(r=r.slice(n,i),r){if(i-=n,e.e=t=t-n-1,e.d=[],n=(t+1)%E,t<0&&(n+=E),n<i){for(n&&e.d.push(+r.slice(0,n)),i-=E;n<i;)e.d.push(+r.slice(n,n+=E));r=r.slice(n),n=E-r.length}else n-=i;for(;n--;)r+="0";e.d.push(+r),w&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Pp(e,r){var t,n,i,o,s,a,l,u,c;if(r.indexOf("_")>-1){if(r=r.replace(/(\d)_(?=\d)/g,"$1"),Gs.test(r))return ln(e,r)}else if(r==="Infinity"||r==="NaN")return+r||(e.s=NaN),e.e=NaN,e.d=null,e;if(bp.test(r))t=16,r=r.toLowerCase();else if(yp.test(r))t=2;else if(Ep.test(r))t=8;else throw Error(He+r);for(o=r.search(/p/i),o>0?(l=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),o=r.indexOf("."),s=o>=0,n=e.constructor,s&&(r=r.replace(".",""),a=r.length,o=a-o,i=Ws(n,new n(t),o,o*2)),u=an(r,t,fe),c=u.length-1,o=c;u[o]===0;--o)u.pop();return o<0?new n(e.s*0):(e.e=mn(u,c),e.d=u,w=!1,s&&(e=L(e,i,a*4)),l&&(e=e.times(Math.abs(l)<54?U(2,l):sr.pow(2,l))),w=!0,e)}function Tp(e,r){var t,n=r.d.length;if(n<3)return r.isZero()?r:Pr(e,2,r,r);t=1.4*Math.sqrt(n),t=t>16?16:t|0,r=r.times(1/fn(5,t)),r=Pr(e,2,r,r);for(var i,o=new e(5),s=new e(16),a=new e(20);t--;)i=r.times(r),r=r.times(o.plus(i.times(s.times(i).minus(a))));return r}function Pr(e,r,t,n,i){var o,s,a,l,u=1,c=e.precision,p=Math.ceil(c/E);for(w=!1,l=t.times(t),a=new e(n);;){if(s=L(a.times(l),new e(r++*r++),c,1),a=i?n.plus(s):n.minus(s),n=L(s.times(l),new e(r++*r++),c,1),s=a.plus(n),s.d[p]!==void 0){for(o=p;s.d[o]===a.d[o]&&o--;);if(o==-1)break}o=a,a=n,n=s,s=o,u++}return w=!0,s.d.length=p+1,s}function fn(e,r){for(var t=e;--r;)t*=e;return t}function Ks(e,r){var t,n=r.s<0,i=we(e,e.precision,1),o=i.times(.5);if(r=r.abs(),r.lte(o))return Le=n?4:1,r;if(t=r.divToInt(i),t.isZero())Le=n?3:2;else{if(r=r.minus(t.times(i)),r.lte(o))return Le=Ms(t)?n?2:3:n?4:1,r;Le=Ms(t)?n?1:4:n?3:2}return r.minus(i).abs()}function Ui(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor,g=t!==void 0;if(g?(ie(t,1,Ke),n===void 0?n=f.rounding:ie(n,0,8)):(t=f.precision,n=f.rounding),!e.isFinite())c=Hs(e);else{for(c=xe(e),s=c.indexOf("."),g?(i=2,r==16?t=t*4-3:r==8&&(t=t*3-2)):i=r,s>=0&&(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=an(xe(d),10,i),d.e=d.d.length),p=an(c,10,i),o=l=p.length;p[--l]==0;)p.pop();if(!p[0])c=g?"0p+0":"0";else{if(s<0?o--:(e=new f(e),e.d=p,e.e=o,e=L(e,d,t,n,0,i),p=e.d,o=e.e,u=js),s=p[t],a=i/2,u=u||p[t+1]!==void 0,u=n<4?(s!==void 0||u)&&(n===0||n===(e.s<0?3:2)):s>a||s===a&&(n===4||u||n===6&&p[t-1]&1||n===(e.s<0?8:7)),p.length=t,u)for(;++p[--t]>i-1;)p[t]=0,t||(++o,p.unshift(1));for(l=p.length;!p[l-1];--l);for(s=0,c="";s<l;s++)c+=qi.charAt(p[s]);if(g){if(l>1)if(r==16||r==8){for(s=r==16?4:3,--l;l%s;l++)c+="0";for(p=an(c,i,r),l=p.length;!p[l-1];--l);for(s=1,c="1.";s<l;s++)c+=qi.charAt(p[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)c="0"+c;c="0."+c}else if(++o>l)for(o-=l;o--;)c+="0";else o<l&&(c=c.slice(0,o)+"."+c.slice(o))}c=(r==16?"0x":r==2?"0b":r==8?"0o":"")+c}return e.s<0?"-"+c:c}function $s(e,r){if(e.length>r)return e.length=r,!0}function Sp(e){return new this(e).abs()}function Rp(e){return new this(e).acos()}function Cp(e){return new this(e).acosh()}function Ap(e,r){return new this(e).plus(r)}function Ip(e){return new this(e).asin()}function kp(e){return new this(e).asinh()}function Op(e){return new this(e).atan()}function Dp(e){return new this(e).atanh()}function _p(e,r){e=new this(e),r=new this(r);var t,n=this.precision,i=this.rounding,o=n+4;return!e.s||!r.s?t=new this(NaN):!e.d&&!r.d?(t=we(this,o,1).times(r.s>0?.25:.75),t.s=e.s):!r.d||e.isZero()?(t=r.s<0?we(this,n,i):new this(0),t.s=e.s):!e.d||r.isZero()?(t=we(this,o,1).times(.5),t.s=e.s):r.s<0?(this.precision=o,this.rounding=1,t=this.atan(L(e,r,o,1)),r=we(this,o,1),this.precision=n,this.rounding=i,t=e.s<0?t.minus(r):t.plus(r)):t=this.atan(L(e,r,o,1)),t}function Np(e){return new this(e).cbrt()}function Lp(e){return y(e=new this(e),e.e+1,2)}function Fp(e,r,t){return new this(e).clamp(r,t)}function Mp(e){if(!e||typeof e!="object")throw Error(dn+"Object expected");var r,t,n,i=e.defaults===!0,o=["precision",1,Ke,"rounding",0,8,"toExpNeg",-vr,0,"toExpPos",0,vr,"maxE",0,vr,"minE",-vr,0,"modulo",0,9];for(r=0;r<o.length;r+=3)if(t=o[r],i&&(this[t]=ji[t]),(n=e[t])!==void 0)if(X(n)===n&&n>=o[r+1]&&n<=o[r+2])this[t]=n;else throw Error(He+t+": "+n);if(t="crypto",i&&(this[t]=ji[t]),(n=e[t])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Bs);else this[t]=!1;else throw Error(He+t+": "+n);return this}function $p(e){return new this(e).cos()}function qp(e){return new this(e).cosh()}function Ys(e){var r,t,n;function i(o){var s,a,l,u=this;if(!(u instanceof i))return new i(o);if(u.constructor=i,qs(o)){u.s=o.s,w?!o.d||o.e>i.maxE?(u.e=NaN,u.d=null):o.e<i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){u.s=1/o<0?-1:1,u.e=0,u.d=[0];return}if(o<0?(o=-o,u.s=-1):u.s=1,o===~~o&&o<1e7){for(s=0,a=o;a>=10;a/=10)s++;w?s>i.maxE?(u.e=NaN,u.d=null):s<i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}if(o*0!==0){o||(u.s=NaN),u.e=NaN,u.d=null;return}return ln(u,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),u.s=-1):(a===43&&(o=o.slice(1)),u.s=1),Gs.test(o)?ln(u,o):Pp(u,o);if(l==="bigint")return o<0?(o=-o,u.s=-1):u.s=1,ln(u,o.toString());throw Error(He+o)}if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Mp,i.clone=Ys,i.isDecimal=qs,i.abs=Sp,i.acos=Rp,i.acosh=Cp,i.add=Ap,i.asin=Ip,i.asinh=kp,i.atan=Op,i.atanh=Dp,i.atan2=_p,i.cbrt=Np,i.ceil=Lp,i.clamp=Fp,i.cos=$p,i.cosh=qp,i.div=jp,i.exp=Vp,i.floor=Bp,i.hypot=Up,i.ln=Gp,i.log=Qp,i.log10=Jp,i.log2=Wp,i.max=Hp,i.min=Kp,i.mod=Yp,i.mul=zp,i.pow=Zp,i.random=Xp,i.round=ed,i.sign=rd,i.sin=td,i.sinh=nd,i.sqrt=id,i.sub=od,i.sum=sd,i.tan=ad,i.tanh=ld,i.trunc=ud,e===void 0&&(e={}),e&&e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r<n.length;)e.hasOwnProperty(t=n[r++])||(e[t]=this[t]);return i.config(e),i}function jp(e,r){return new this(e).div(r)}function Vp(e){return new this(e).exp()}function Bp(e){return y(e=new this(e),e.e+1,3)}function Up(){var e,r,t=new this(0);for(w=!1,e=0;e<arguments.length;)if(r=new this(arguments[e++]),r.d)t.d&&(t=t.plus(r.times(r)));else{if(r.s)return w=!0,new this(1/0);t=r}return w=!0,t.sqrt()}function qs(e){return e instanceof sr||e&&e.toStringTag===Us||!1}function Gp(e){return new this(e).ln()}function Qp(e,r){return new this(e).log(r)}function Wp(e){return new this(e).log(2)}function Jp(e){return new this(e).log(10)}function Hp(){return Js(this,arguments,-1)}function Kp(){return Js(this,arguments,1)}function Yp(e,r){return new this(e).mod(r)}function zp(e,r){return new this(e).mul(r)}function Zp(e,r){return new this(e).pow(r)}function Xp(e){var r,t,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:ie(e,1,Ke),n=Math.ceil(e/E),this.crypto)if(crypto.getRandomValues)for(r=crypto.getRandomValues(new Uint32Array(n));o<n;)i=r[o],i>=429e7?r[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(r=crypto.randomBytes(n*=4);o<n;)i=r[o]+(r[o+1]<<8)+(r[o+2]<<16)+((r[o+3]&127)<<24),i>=214e7?crypto.randomBytes(4).copy(r,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(Bs);else for(;o<n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=E,n&&e&&(i=U(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o<0)t=0,a=[0];else{for(t=-1;a[0]===0;t-=E)a.shift();for(n=1,i=a[0];i>=10;i/=10)n++;n<E&&(t-=E-n)}return s.e=t,s.d=a,s}function ed(e){return y(e=new this(e),e.e+1,this.rounding)}function rd(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function td(e){return new this(e).sin()}function nd(e){return new this(e).sinh()}function id(e){return new this(e).sqrt()}function od(e,r){return new this(e).sub(r)}function sd(){var e=0,r=arguments,t=new this(r[e]);for(w=!1;t.s&&++e<r.length;)t=t.plus(r[e]);return w=!0,y(t,this.precision,this.rounding)}function ad(e){return new this(e).tan()}function ld(e){return new this(e).tanh()}function ud(e){return y(e=new this(e),e.e+1,1)}m[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var sr=m.constructor=Ys(ji);un=new sr(un);cn=new sr(cn);var ve=sr;function Tr(e){return e===null?e:Array.isArray(e)?e.map(Tr):typeof e=="object"?cd(e)?pd(e):xr(e,Tr):e}function cd(e){return e!==null&&typeof e=="object"&&typeof e.$type=="string"}function pd({$type:e,value:r}){switch(e){case"BigInt":return BigInt(r);case"Bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"DateTime":return new Date(r);case"Decimal":return new ve(r);case"Json":return JSON.parse(r);default:_e(r,"Unknown tagged value")}}var Pe=class{_map=new Map;get(r){return this._map.get(r)?.value}set(r,t){this._map.set(r,{value:t})}getOrCreate(r,t){let n=this._map.get(r);if(n)return n.value;let i=t();return this.set(r,i),i}};function Ye(e){return e.substring(0,1).toLowerCase()+e.substring(1)}function zs(e,r){let t={};for(let n of e){let i=n[r];t[i]=n}return t}function at(e){let r;return{get(){return r||(r={value:e()}),r.value}}}function Zs(e){return{models:Gi(e.models),enums:Gi(e.enums),types:Gi(e.types)}}function Gi(e){let r={};for(let{name:t,...n}of e)r[t]=n;return r}function Sr(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function gn(e){return e.toString()!=="Invalid Date"}function Rr(e){return sr.isDecimal(e)?!0:e!==null&&typeof e=="object"&&typeof e.s=="number"&&typeof e.e=="number"&&typeof e.toFixed=="function"&&Array.isArray(e.d)}var lt={};tr(lt,{ModelAction:()=>Cr,datamodelEnumToSchemaEnum:()=>dd});function dd(e){return{name:e.name,values:e.values.map(r=>r.name)}}var Cr=(b=>(b.findUnique="findUnique",b.findUniqueOrThrow="findUniqueOrThrow",b.findFirst="findFirst",b.findFirstOrThrow="findFirstOrThrow",b.findMany="findMany",b.create="create",b.createMany="createMany",b.createManyAndReturn="createManyAndReturn",b.update="update",b.updateMany="updateMany",b.updateManyAndReturn="updateManyAndReturn",b.upsert="upsert",b.delete="delete",b.deleteMany="deleteMany",b.groupBy="groupBy",b.count="count",b.aggregate="aggregate",b.findRaw="findRaw",b.aggregateRaw="aggregateRaw",b))(Cr||{});var na=k(Ri());var ta=k(require("node:fs"));var Xs={keyword:Oe,entity:Oe,value:e=>W(nr(e)),punctuation:nr,directive:Oe,function:Oe,variable:e=>W(nr(e)),string:e=>W(qe(e)),boolean:ke,number:Oe,comment:Hr};var md=e=>e,hn={},fd=0,v={manual:hn.Prism&&hn.Prism.manual,disableWorkerMessageHandler:hn.Prism&&hn.Prism.disableWorkerMessageHandler,util:{encode:function(e){if(e instanceof ge){let r=e;return new ge(r.type,v.util.encode(r.content),r.alias)}else return Array.isArray(e)?e.map(v.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++fd}),e.__id},clone:function e(r,t){let n,i,o=v.util.type(r);switch(t=t||{},o){case"Object":if(i=v.util.objId(r),t[i])return t[i];n={},t[i]=n;for(let s in r)r.hasOwnProperty(s)&&(n[s]=e(r[s],t));return n;case"Array":return i=v.util.objId(r),t[i]?t[i]:(n=[],t[i]=n,r.forEach(function(s,a){n[a]=e(s,t)}),n);default:return r}}},languages:{extend:function(e,r){let t=v.util.clone(v.languages[e]);for(let n in r)t[n]=r[n];return t},insertBefore:function(e,r,t,n){n=n||v.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==r)for(let l in t)t.hasOwnProperty(l)&&(o[l]=t[l]);t.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,v.languages.DFS(v.languages,function(a,l){l===s&&a!=e&&(this[a]=o)}),o},DFS:function e(r,t,n,i){i=i||{};let o=v.util.objId;for(let s in r)if(r.hasOwnProperty(s)){t.call(r,s,r[s],n||s);let a=r[s],l=v.util.type(a);l==="Object"&&!i[o(a)]?(i[o(a)]=!0,e(a,t,null,i)):l==="Array"&&!i[o(a)]&&(i[o(a)]=!0,e(a,t,s,i))}}},plugins:{},highlight:function(e,r,t){let n={code:e,grammar:r,language:t};return v.hooks.run("before-tokenize",n),n.tokens=v.tokenize(n.code,n.grammar),v.hooks.run("after-tokenize",n),ge.stringify(v.util.encode(n.tokens),n.language)},matchGrammar:function(e,r,t,n,i,o,s){for(let h in t){if(!t.hasOwnProperty(h)||!t[h])continue;if(h==s)return;let I=t[h];I=v.util.type(I)==="Array"?I:[I];for(let P=0;P<I.length;++P){let S=I[P],b=S.inside,O=!!S.lookbehind,me=!!S.greedy,ae=0,Jr=S.alias;if(me&&!S.pattern.global){let V=S.pattern.toString().match(/[imuy]*$/)[0];S.pattern=RegExp(S.pattern.source,V+"g")}S=S.pattern||S;for(let V=n,te=i;V<r.length;te+=r[V].length,++V){let Ae=r[V];if(r.length>e.length)return;if(Ae instanceof ge)continue;if(me&&V!=r.length-1){S.lastIndex=te;var p=S.exec(e);if(!p)break;var c=p.index+(O?p[1].length:0),d=p.index+p[0].length,a=V,l=te;for(let _=r.length;a<_&&(l<d||!r[a].type&&!r[a-1].greedy);++a)l+=r[a].length,c>=l&&(++V,te=l);if(r[V]instanceof ge)continue;u=a-V,Ae=e.slice(te,l),p.index-=te}else{S.lastIndex=0;var p=S.exec(Ae),u=1}if(!p){if(o)break;continue}O&&(ae=p[1]?p[1].length:0);var c=p.index+ae,p=p[0].slice(ae),d=c+p.length,f=Ae.slice(0,c),g=Ae.slice(d);let H=[V,u];f&&(++V,te+=f.length,H.push(f));let fr=new ge(h,b?v.tokenize(p,b):p,Jr,p,me);if(H.push(fr),g&&H.push(g),Array.prototype.splice.apply(r,H),u!=1&&v.matchGrammar(e,r,t,V,te,!0,h),o)break}}}},tokenize:function(e,r){let t=[e],n=r.rest;if(n){for(let i in n)r[i]=n[i];delete r.rest}return v.matchGrammar(e,t,r,0,0,!1),t},hooks:{all:{},add:function(e,r){let t=v.hooks.all;t[e]=t[e]||[],t[e].push(r)},run:function(e,r){let t=v.hooks.all[e];if(!(!t||!t.length))for(var n=0,i;i=t[n++];)i(r)}},Token:ge};v.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};v.languages.javascript=v.languages.extend("clike",{"class-name":[v.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});v.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;v.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:v.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,inside:v.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,lookbehind:!0,inside:v.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:v.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});v.languages.markup&&v.languages.markup.tag.addInlined("script","javascript");v.languages.js=v.languages.javascript;v.languages.typescript=v.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});v.languages.ts=v.languages.typescript;function ge(e,r,t,n,i){this.type=e,this.content=r,this.alias=t,this.length=(n||"").length|0,this.greedy=!!i}ge.stringify=function(e,r){return typeof e=="string"?e:Array.isArray(e)?e.map(function(t){return ge.stringify(t,r)}).join(""):gd(e.type)(e.content)};function gd(e){return Xs[e]||md}function ea(e){return hd(e,v.languages.javascript)}function hd(e,r){return v.tokenize(e,r).map(n=>ge.stringify(n)).join("")}function ra(e){return Ti(e)}var yn=class e{firstLineNumber;lines;static read(r){let t;try{t=ta.default.readFileSync(r,"utf-8")}catch{return null}return e.fromContent(t)}static fromContent(r){let t=r.split(/\r?\n/);return new e(1,t)}constructor(r,t){this.firstLineNumber=r,this.lines=t}get lastLineNumber(){return this.firstLineNumber+this.lines.length-1}mapLineAt(r,t){if(r<this.firstLineNumber||r>this.lines.length+this.firstLineNumber)return this;let n=r-this.firstLineNumber,i=[...this.lines];return i[n]=t(i[n]),new e(this.firstLineNumber,i)}mapLines(r){return new e(this.firstLineNumber,this.lines.map((t,n)=>r(t,this.firstLineNumber+n)))}lineAt(r){return this.lines[r-this.firstLineNumber]}prependSymbolAt(r,t){return this.mapLines((n,i)=>i===r?`${t} ${n}`:`  ${n}`)}slice(r,t){let n=this.lines.slice(r-1,t).join(`
`);return new e(r,ra(n).split(`
`))}highlight(){let r=ea(this.toString());return new e(this.firstLineNumber,r.split(`
`))}toString(){return this.lines.join(`
`)}};var yd={red:ce,gray:Hr,dim:Ie,bold:W,underline:Y,highlightSource:e=>e.highlight()},bd={red:e=>e,gray:e=>e,dim:e=>e,bold:e=>e,underline:e=>e,highlightSource:e=>e};function Ed({message:e,originalMethod:r,isPanic:t,callArguments:n}){return{functionName:`prisma.${r}()`,message:e,isPanic:t??!1,callArguments:n}}function wd({callsite:e,message:r,originalMethod:t,isPanic:n,callArguments:i},o){let s=Ed({message:r,originalMethod:t,isPanic:n,callArguments:i});if(!e||typeof window<"u"||process.env.NODE_ENV==="production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=yn.read(a.fileName)?.slice(l,a.lineNumber),c=u?.lineAt(a.lineNumber);if(u&&c){let p=vd(c),d=xd(c);if(!d)return s;s.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,g=>g.slice(0,d.openingBraceIndex))),u=o.highlightSource(u);let f=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((g,h)=>o.gray(String(h).padStart(f))+" "+g).mapLines(g=>o.dim(g)).prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let g=p+f+1;g+=2,s.callArguments=(0,na.default)(i,g).slice(g)}}return s}function xd(e){let r=Object.keys(Cr).join("|"),n=new RegExp(String.raw`\.(${r})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}function vd(e){let r=0;for(let t=0;t<e.length;t++){if(e.charAt(t)!==" ")return r;r++}return r}function Pd({functionName:e,location:r,message:t,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=r?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),r&&a.push(s.underline(Td(r))),i){a.push("");let u=[i.toString()];o&&(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(t),a.join(`
`)}function Td(e){let r=[e.fileName];return e.lineNumber&&r.push(String(e.lineNumber)),e.columnNumber&&r.push(String(e.columnNumber)),r.join(":")}function bn(e){let r=e.showColors?yd:bd,t;return t=wd(e,r),Pd(t,r)}var da=k(Qi());function aa(e,r,t){let n=la(e),i=Sd(n),o=Cd(i);o?En(o,r,t):r.addErrorMessage(()=>"Unknown error")}function la(e){return e.errors.flatMap(r=>r.kind==="Union"?la(r):[r])}function Sd(e){let r=new Map,t=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){t.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=r.get(i);o?r.set(i,{...n,argument:{...n.argument,typeNames:Rd(o.argument.typeNames,n.argument.typeNames)}}):r.set(i,n)}return t.push(...r.values()),t}function Rd(e,r){return[...new Set(e.concat(r))]}function Cd(e){return $i(e,(r,t)=>{let n=oa(r),i=oa(t);return n!==i?n-i:sa(r)-sa(t)})}function oa(e){let r=0;return Array.isArray(e.selectionPath)&&(r+=e.selectionPath.length),Array.isArray(e.argumentPath)&&(r+=e.argumentPath.length),r}function sa(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}var ue=class{constructor(r,t){this.name=r;this.value=t}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(r){let{colors:{green:t}}=r.context;r.addMarginSymbol(t(this.isRequired?"+":"?")),r.write(t(this.name)),this.isRequired||r.write(t("?")),r.write(t(": ")),typeof this.value=="string"?r.write(t(this.value)):r.write(this.value)}};ca();var Ar=class{constructor(r=0,t){this.context=t;this.currentIndent=r}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(r){return typeof r=="string"?this.currentLine+=r:r.write(this),this}writeJoined(r,t,n=(i,o)=>o.write(i)){let i=t.length-1;for(let o=0;o<t.length;o++)n(t[o],this),o!==i&&this.write(r);return this}writeLine(r){return this.write(r).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let r=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,r?.(),this}withIndent(r){return this.indent(),r(this),this.unindent(),this}afterNextNewline(r){return this.afterNextNewLineCallback=r,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(r){return this.marginSymbol=r,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let r=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+r.slice(1):r}};ua();var wn=class{constructor(r){this.value=r}write(r){r.write(this.value)}markAsError(){this.value.markAsError()}};var xn=e=>e,vn={bold:xn,red:xn,green:xn,dim:xn,enabled:!1},pa={bold:W,red:ce,green:qe,dim:Ie,enabled:!0},Ir={write(e){e.writeLine(",")}};var Te=class{constructor(r){this.contents=r}isUnderlined=!1;color=r=>r;underline(){return this.isUnderlined=!0,this}setColor(r){return this.color=r,this}write(r){let t=r.getCurrentLineLength();r.write(this.color(this.contents)),this.isUnderlined&&r.afterNextNewline(()=>{r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)))})}};var ze=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var kr=class extends ze{items=[];addItem(r){return this.items.push(new wn(r)),this}getField(r){return this.items[r]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(t=>t.value.getPrintWidth()))+2}write(r){if(this.items.length===0){this.writeEmpty(r);return}this.writeWithItems(r)}writeEmpty(r){let t=new Te("[]");this.hasError&&t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithItems(r){let{colors:t}=r.context;r.writeLine("[").withIndent(()=>r.writeJoined(Ir,this.items).newLine()).write("]"),this.hasError&&r.afterNextNewline(()=>{r.writeLine(t.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var Or=class e extends ze{fields={};suggestions=[];addField(r){this.fields[r.name]=r}addSuggestion(r){this.suggestions.push(r)}getField(r){return this.fields[r]}getDeepField(r){let[t,...n]=r,i=this.getField(t);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof kr&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(r){return r.length===0?this:this.getDeepField(r)?.value}hasField(r){return!!this.getField(r)}removeAllFields(){this.fields={}}removeField(r){delete this.fields[r]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(r){return this.getField(r)?.value}getDeepSubSelectionValue(r){let t=this;for(let n of r){if(!(t instanceof e))return;let i=t.getSubSelectionValue(n);if(!i)return;t=i}return t}getDeepSelectionParent(r){let t=this.getSelectionParent();if(!t)return;let n=t;for(let i of r){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let r=this.getField("select")?.value.asObject();if(r)return{kind:"select",value:r};let t=this.getField("include")?.value.asObject();if(t)return{kind:"include",value:t}}getSubSelectionValue(r){return this.getSelectionParent()?.value.fields[r].value}getPrintWidth(){let r=Object.values(this.fields);return r.length==0?2:Math.max(...r.map(n=>n.getPrintWidth()))+2}write(r){let t=Object.values(this.fields);if(t.length===0&&this.suggestions.length===0){this.writeEmpty(r);return}this.writeWithContents(r,t)}asObject(){return this}writeEmpty(r){let t=new Te("{}");this.hasError&&t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithContents(r,t){r.writeLine("{").withIndent(()=>{r.writeJoined(Ir,[...t,...this.suggestions]).newLine()}),r.write("}"),this.hasError&&r.afterNextNewline(()=>{r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))})}};var Q=class extends ze{constructor(t){super();this.text=t}getPrintWidth(){return this.text.length}write(t){let n=new Te(this.text);this.hasError&&n.underline().setColor(t.context.colors.red),t.write(n)}asObject(){}};var ut=class{fields=[];addField(r,t){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")))}}),this}write(r){let{colors:{green:t}}=r.context;r.writeLine(t("{")).withIndent(()=>{r.writeJoined(Ir,this.fields).newLine()}).write(t("}")).addMarginSymbol(t("+"))}};function En(e,r,t){switch(e.kind){case"MutuallyExclusiveFields":Ad(e,r);break;case"IncludeOnScalar":Id(e,r);break;case"EmptySelection":kd(e,r,t);break;case"UnknownSelectionField":Nd(e,r);break;case"InvalidSelectionValue":Ld(e,r);break;case"UnknownArgument":Fd(e,r);break;case"UnknownInputField":Md(e,r);break;case"RequiredArgumentMissing":$d(e,r);break;case"InvalidArgumentType":qd(e,r);break;case"InvalidArgumentValue":jd(e,r);break;case"ValueTooLarge":Vd(e,r);break;case"SomeFieldsMissing":Bd(e,r);break;case"TooManyFieldsGiven":Ud(e,r);break;case"Union":aa(e,r,t);break;default:throw new Error("not implemented: "+e.kind)}}function Ad(e,r){let t=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();t&&(t.getField(e.firstField)?.markAsError(),t.getField(e.secondField)?.markAsError()),r.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function Id(e,r){let[t,n]=ct(e.selectionPath),i=e.outputType,o=r.arguments.getDeepSelectionParent(t)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new ue(s.name,"true"));r.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${pt(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function kd(e,r,t){let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){Od(e,r,i);return}if(n.hasField("select")){Dd(e,r);return}}if(t?.[Ye(e.outputType.name)]){_d(e,r);return}r.addErrorMessage(()=>`Unknown field at "${e.selectionPath.join(".")} selection"`)}function Od(e,r,t){t.removeAllFields();for(let n of e.outputType.fields)t.addSuggestion(new ue(n.name,"false"));r.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}function Dd(e,r){let t=e.outputType,n=r.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),ga(n,t)),r.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${pt(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`)}function _d(e,r){let t=new ut;for(let i of e.outputType.fields)i.isRelation||t.addField(i.name,"false");let n=new ue("omit",t).makeRequired();if(e.selectionPath.length===0)r.arguments.addSuggestion(n);else{let[i,o]=ct(e.selectionPath),a=r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new Or;l.addSuggestion(n),a.value=l}}r.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function Nd(e,r){let t=ha(e.selectionPath,r);if(t.parentKind!=="unknown"){t.field.markAsError();let n=t.parent;switch(t.parentKind){case"select":ga(n,e.outputType);break;case"include":Gd(n,e.outputType);break;case"omit":Qd(n,e.outputType);break}}r.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${t.fieldName}\``)}`];return t.parentKind!=="unknown"&&i.push(`for ${n.bold(t.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(pt(n)),i.join(" ")})}function Ld(e,r){let t=ha(e.selectionPath,r);t.parentKind!=="unknown"&&t.field.value.markAsError(),r.addErrorMessage(n=>`Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`)}function Fd(e,r){let t=e.argumentPath[0],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&(n.getField(t)?.markAsError(),Wd(n,e.arguments)),r.addErrorMessage(i=>ma(i,t,e.arguments.map(o=>o.name)))}function Md(e,r){let[t,n]=ct(e.argumentPath),i=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(t)?.asObject();o&&ya(o,e.inputType)}r.addErrorMessage(o=>ma(o,n,e.inputType.fields.map(s=>s.name)))}function ma(e,r,t){let n=[`Unknown argument \`${e.red(r)}\`.`],i=Hd(r,t);return i&&n.push(`Did you mean \`${e.green(i)}\`?`),t.length>0&&n.push(pt(e)),n.join(" ")}function $d(e,r){let t;r.addErrorMessage(l=>t?.value instanceof Q&&t.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=ct(e.argumentPath),s=new ut,a=n.getDeepFieldValue(i)?.asObject();if(a)if(t=a.getField(o),t&&a.removeField(o),e.inputTypes.length===1&&e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ue(o,s).makeRequired())}else{let l=e.inputTypes.map(fa).join(" | ");a.addSuggestion(new ue(o,l).makeRequired())}}function fa(e){return e.kind==="list"?`${fa(e.elementType)}[]`:e.name}function qd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=>{let o=Pn("or",e.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}function jd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(t)}\``];if(e.underlyingError&&o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length>0){let s=Pn("or",e.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function Vd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof Q&&(i=s.text)}r.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``),s.join(" ")})}function Bd(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&&ya(i,e.inputType)}r.addErrorMessage(i=>{let o=[`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Pn("or",e.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(pt(i)),o.join(" ")})}function Ud(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}r.addErrorMessage(o=>{let s=[`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&&e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Pn("and",i.map(a=>o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}function ga(e,r){for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ue(t.name,"true"))}function Gd(e,r){for(let t of r.fields)t.isRelation&&!e.hasField(t.name)&&e.addSuggestion(new ue(t.name,"true"))}function Qd(e,r){for(let t of r.fields)!e.hasField(t.name)&&!t.isRelation&&e.addSuggestion(new ue(t.name,"true"))}function Wd(e,r){for(let t of r)e.hasField(t.name)||e.addSuggestion(new ue(t.name,t.typeNames.join(" | ")))}function ha(e,r){let[t,n]=ct(e),i=r.arguments.getDeepSubSelectionValue(t)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&&l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&&l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&&l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function ya(e,r){if(r.kind==="object")for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ue(t.name,t.typeNames.join(" | ")))}function ct(e){let r=[...e],t=r.pop();if(!t)throw new Error("unexpected empty path");return[r,t]}function pt({green:e,enabled:r}){return"Available options are "+(r?`listed in ${e("green")}`:"marked with ?")+"."}function Pn(e,r){if(r.length===1)return r[0];let t=[...r],n=t.pop();return`${t.join(", ")} ${e} ${n}`}var Jd=3;function Hd(e,r){let t=1/0,n;for(let i of r){let o=(0,da.default)(e,i);o>Jd||o<t&&(t=o,n=i)}return n}var dt=class{modelName;name;typeName;isList;isEnum;constructor(r,t,n,i,o){this.modelName=r,this.name=t,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let r=this.isList?"List":"",t=this.isEnum?"Enum":"";return`${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`}};function Dr(e){return e instanceof dt}var Tn=Symbol(),Ji=new WeakMap,Fe=class{constructor(r){r===Tn?Ji.set(this,`Prisma.${this._getName()}`):Ji.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return Ji.get(this)}},mt=class extends Fe{_getNamespace(){return"NullTypes"}},ft=class extends mt{_brand_DbNull};Hi(ft,"DbNull");var gt=class extends mt{_brand_JsonNull};Hi(gt,"JsonNull");var ht=class extends mt{_brand_AnyNull};Hi(ht,"AnyNull");var Sn={classes:{DbNull:ft,JsonNull:gt,AnyNull:ht},instances:{DbNull:new ft(Tn),JsonNull:new gt(Tn),AnyNull:new ht(Tn)}};function Hi(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var ba=": ",Rn=class{constructor(r,t){this.name=r;this.value=t}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+ba.length}write(r){let t=new Te(this.name);this.hasError&&t.underline().setColor(r.context.colors.red),r.write(t).write(ba).write(this.value)}};var Ki=class{arguments;errorMessages=[];constructor(r){this.arguments=r}write(r){r.write(this.arguments)}addErrorMessage(r){this.errorMessages.push(r)}renderAllMessages(r){return this.errorMessages.map(t=>t(r)).join(`
`)}};function _r(e){return new Ki(Ea(e))}function Ea(e){let r=new Or;for(let[t,n]of Object.entries(e)){let i=new Rn(t,wa(n));r.addField(i)}return r}function wa(e){if(typeof e=="string")return new Q(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new Q(String(e));if(typeof e=="bigint")return new Q(`${e}n`);if(e===null)return new Q("null");if(e===void 0)return new Q("undefined");if(Rr(e))return new Q(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return Buffer.isBuffer(e)?new Q(`Buffer.alloc(${e.byteLength})`):new Q(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let r=gn(e)?e.toISOString():"Invalid Date";return new Q(`new Date("${r}")`)}return e instanceof Fe?new Q(`Prisma.${e._getName()}`):Dr(e)?new Q(`prisma.${Ye(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Kd(e):typeof e=="object"?Ea(e):new Q(Object.prototype.toString.call(e))}function Kd(e){let r=new kr;for(let t of e)r.addItem(wa(t));return r}function Cn(e,r){let t=r==="pretty"?pa:vn,n=e.renderAllMessages(t),i=new Ar(0,{colors:t}).write(e).toString();return{message:n,args:i}}function An({args:e,errors:r,errorFormat:t,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=_r(e);for(let p of r)En(p,a,s);let{message:l,args:u}=Cn(a,t),c=bn({message:l,callsite:n,originalMethod:i,showColors:t==="pretty",callArguments:u});throw new Z(c,{clientVersion:o})}function Se(e){return e.replace(/^./,r=>r.toLowerCase())}function va(e,r,t){let n=Se(t);return!r.result||!(r.result.$allModels||r.result[n])?e:Yd({...e,...xa(r.name,e,r.result.$allModels),...xa(r.name,e,r.result[n])})}function Yd(e){let r=new Pe,t=(n,i)=>r.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=>t(o,i)):[n]));return xr(e,n=>({...n,needs:t(n.name,new Set)}))}function xa(e,r,t){return t?xr(t,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:zd(r,o,i)})):{}}function zd(e,r,t){let n=e?.[r]?.compute;return n?i=>t({...i,[r]:n(i)}):t}function Pa(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(e[n.name])for(let i of n.needs)t[i]=!0;return t}function Ta(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(!e[n.name])for(let i of n.needs)delete t[i];return t}var In=class{constructor(r,t){this.extension=r;this.previous=t}computedFieldsCache=new Pe;modelExtensionsCache=new Pe;queryCallbacksCache=new Pe;clientExtensions=at(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=at(()=>{let r=this.previous?.getAllBatchQueryCallbacks()??[],t=this.extension.query?.$__internalBatch;return t?r.concat(t):r});getAllComputedFields(r){return this.computedFieldsCache.getOrCreate(r,()=>va(this.previous?.getAllComputedFields(r),this.extension,r))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(r){return this.modelExtensionsCache.getOrCreate(r,()=>{let t=Se(r);return!this.extension.model||!(this.extension.model[t]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(r):{...this.previous?.getAllModelExtensions(r),...this.extension.model.$allModels,...this.extension.model[t]}})}getAllQueryCallbacks(r,t){return this.queryCallbacksCache.getOrCreate(`${r}:${t}`,()=>{let n=this.previous?.getAllQueryCallbacks(r,t)??[],i=[],o=this.extension.query;return!o||!(o[r]||o.$allModels||o[t]||o.$allOperations)?n:(o[r]!==void 0&&(o[r][t]!==void 0&&i.push(o[r][t]),o[r].$allOperations!==void 0&&i.push(o[r].$allOperations)),r!=="$none"&&o.$allModels!==void 0&&(o.$allModels[t]!==void 0&&i.push(o.$allModels[t]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[t]!==void 0&&i.push(o[t]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},Nr=class e{constructor(r){this.head=r}static empty(){return new e}static single(r){return new e(new In(r))}isEmpty(){return this.head===void 0}append(r){return new e(new In(r,this.head))}getAllComputedFields(r){return this.head?.getAllComputedFields(r)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(r){return this.head?.getAllModelExtensions(r)}getAllQueryCallbacks(r,t){return this.head?.getAllQueryCallbacks(r,t)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};var kn=class{constructor(r){this.name=r}};function Sa(e){return e instanceof kn}function Ra(e){return new kn(e)}var Ca=Symbol(),yt=class{constructor(r){if(r!==Ca)throw new Error("Skip instance can not be constructed directly")}ifUndefined(r){return r===void 0?On:r}},On=new yt(Ca);function Re(e){return e instanceof yt}var Zd={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},Aa="explicitly `undefined` values are not allowed";function Dn({modelName:e,action:r,args:t,runtimeDataModel:n,extensions:i=Nr.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new Yi({runtimeDataModel:n,modelName:e,action:r,rootArgs:t,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:Zd[r],query:bt(t,p)}}function bt({select:e,include:r,...t}={},n){let i=t.omit;return delete t.omit,{arguments:ka(t,n),selection:Xd(e,r,i,n)}}function Xd(e,r,t,n){return e?(r?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):t&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),nm(e,n)):em(n,r,t)}function em(e,r,t){let n={};return e.modelOrType&&!e.isRawAction()&&(n.$composites=!0,n.$scalars=!0),r&&rm(n,r,e),tm(n,t,e),n}function rm(e,r,t){for(let[n,i]of Object.entries(r)){if(Re(i))continue;let o=t.nestSelection(n);if(zi(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=t.findField(n);if(s&&s.kind!=="object"&&t.throwValidationError({kind:"IncludeOnScalar",selectionPath:t.getSelectionPath().concat(n),outputType:t.getOutputTypeDescription()}),s){e[n]=bt(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=bt(i,o)}}function tm(e,r,t){let n=t.getComputedFields(),i={...t.getGlobalOmit(),...r},o=Ta(i,n);for(let[s,a]of Object.entries(o)){if(Re(a))continue;zi(a,t.nestSelection(s));let l=t.findField(s);n?.[s]&&!l||(e[s]=!a)}}function nm(e,r){let t={},n=r.getComputedFields(),i=Pa(e,n);for(let[o,s]of Object.entries(i)){if(Re(s))continue;let a=r.nestSelection(o);zi(s,a);let l=r.findField(o);if(!(n?.[o]&&!l)){if(s===!1||s===void 0||Re(s)){t[o]=!1;continue}if(s===!0){l?.kind==="object"?t[o]=bt({},a):t[o]=!0;continue}t[o]=bt(s,a)}}return t}function Ia(e,r){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(Sr(e)){if(gn(e))return{$type:"DateTime",value:e.toISOString()};r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Sa(e))return{$type:"Param",value:e.name};if(Dr(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return im(e,r);if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:Buffer.from(t,n,i).toString("base64")}}if(om(e))return e.values;if(Rr(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Fe){if(e!==Sn.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(sm(e))return e.toJSON();if(typeof e=="object")return ka(e,r);r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function ka(e,r){if(e.$type)return{$type:"Raw",value:e};let t={};for(let n in e){let i=e[n],o=r.nestArgument(n);Re(i)||(i!==void 0?t[n]=Ia(i,o):r.isPreviewFeatureOn("strictUndefinedChecks")&&r.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:r.getSelectionPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:Aa}))}return t}function im(e,r){let t=[];for(let n=0;n<e.length;n++){let i=r.nestArgument(String(n)),o=e[n];if(o===void 0||Re(o)){let s=o===void 0?"undefined":"Prisma.skip";r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${r.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}t.push(Ia(o,i))}return t}function om(e){return typeof e=="object"&&e!==null&&e.__prismaRawParameters__===!0}function sm(e){return typeof e=="object"&&e!==null&&typeof e.toJSON=="function"}function zi(e,r){e===void 0&&r.isPreviewFeatureOn("strictUndefinedChecks")&&r.throwValidationError({kind:"InvalidSelectionValue",selectionPath:r.getSelectionPath(),underlyingError:Aa})}var Yi=class e{constructor(r){this.params=r;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(r){An({errors:[r],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(r=>({name:r.name,typeName:"boolean",isRelation:r.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(r){return this.params.previewFeatures.includes(r)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(r){return this.modelOrType?.fields.find(t=>t.name===r)}nestSelection(r){let t=this.findField(r),n=t?.kind==="object"?t.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(r)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[Ye(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:_e(this.params.action,"Unknown action")}}nestArgument(r){return new e({...this.params,argumentPath:this.params.argumentPath.concat(r)})}};function Oa(e){if(!e._hasPreviewFlag("metrics"))throw new Z("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var Lr=class{_client;constructor(r){this._client=r}prometheus(r){return Oa(this._client),this._client._engine.metrics({format:"prometheus",...r})}json(r){return Oa(this._client),this._client._engine.metrics({format:"json",...r})}};function Da(e,r){let t=at(()=>am(r));Object.defineProperty(e,"dmmf",{get:()=>t.get()})}function am(e){return{datamodel:{models:Zi(e.models),enums:Zi(e.enums),types:Zi(e.types)}}}function Zi(e){return Object.entries(e).map(([r,t])=>({name:r,...t}))}var Xi=new WeakMap,_n="$$PrismaTypedSql",Et=class{constructor(r,t){Xi.set(this,{sql:r,values:t}),Object.defineProperty(this,_n,{value:_n})}get sql(){return Xi.get(this).sql}get values(){return Xi.get(this).values}};function _a(e){return(...r)=>new Et(e,r)}function Nn(e){return e!=null&&e[_n]===_n}var pu=k(Ei());var du=require("node:async_hooks"),mu=require("node:events"),fu=k(require("node:fs")),Zn=k(require("node:path"));var oe=class e{constructor(r,t){if(r.length-1!==t.length)throw r.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${r.length} strings to have ${r.length-1} values`);let n=t.reduce((s,a)=>s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=r[0];let i=0,o=0;for(;i<t.length;){let s=t[i++],a=r[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l<s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`?${this.strings[t++]}`;return n}get statement(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`:${t}${this.strings[t++]}`;return n}get text(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`$${t}${this.strings[t++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function Na(e,r=",",t="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new oe([t,...Array(e.length-1).fill(r),n],e)}function eo(e){return new oe([e],[])}var La=eo("");function ro(e,...r){return new oe(e,r)}function wt(e){return{getKeys(){return Object.keys(e)},getPropertyValue(r){return e[r]}}}function re(e,r){return{getKeys(){return[e]},getPropertyValue(){return r()}}}function ar(e){let r=new Pe;return{getKeys(){return e.getKeys()},getPropertyValue(t){return r.getOrCreate(t,()=>e.getPropertyValue(t))},getPropertyDescriptor(t){return e.getPropertyDescriptor?.(t)}}}var Ln={enumerable:!0,configurable:!0,writable:!0};function Fn(e){let r=new Set(e);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>Ln,has:(t,n)=>r.has(n),set:(t,n,i)=>r.add(n)&&Reflect.set(t,n,i),ownKeys:()=>[...r]}}var Fa=Symbol.for("nodejs.util.inspect.custom");function he(e,r){let t=lm(r),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=t.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=t.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=Ma(Reflect.ownKeys(o),t),a=Ma(Array.from(t.keys()),t);return[...new Set([...s,...a,...n])]},set(o,s,a){return t.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let l=t.get(s);return l?l.getPropertyDescriptor?{...Ln,...l?.getPropertyDescriptor(s)}:Ln:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[Fa]=function(){let o={...this};return delete o[Fa],o},i}function lm(e){let r=new Map;for(let t of e){let n=t.getKeys();for(let i of n)r.set(i,t)}return r}function Ma(e,r){return e.filter(t=>r.get(t)?.has?.(t)??!0)}function Fr(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}function Mr(e,r){return{batch:e,transaction:r?.kind==="batch"?{isolationLevel:r.options.isolationLevel}:void 0}}function $a(e){if(e===void 0)return"";let r=_r(e);return new Ar(0,{colors:vn}).write(r).toString()}var um="P2037";function $r({error:e,user_facing_error:r},t,n){return r.error_code?new z(cm(r,n),{code:r.error_code,clientVersion:t,meta:r.meta,batchRequestIdx:r.batch_request_idx}):new j(e,{clientVersion:t,batchRequestIdx:r.batch_request_idx})}function cm(e,r){let t=e.message;return(r==="postgresql"||r==="postgres"||r==="mysql")&&e.error_code===um&&(t+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),t}var xt="<unknown>";function qa(e){var r=e.split(`
`);return r.reduce(function(t,n){var i=mm(n)||gm(n)||bm(n)||vm(n)||wm(n);return i&&t.push(i),t},[])}var pm=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,dm=/\((\S*)(?::(\d+))(?::(\d+))\)/;function mm(e){var r=pm.exec(e);if(!r)return null;var t=r[2]&&r[2].indexOf("native")===0,n=r[2]&&r[2].indexOf("eval")===0,i=dm.exec(r[2]);return n&&i!=null&&(r[2]=i[1],r[3]=i[2],r[4]=i[3]),{file:t?null:r[2],methodName:r[1]||xt,arguments:t?[r[2]]:[],lineNumber:r[3]?+r[3]:null,column:r[4]?+r[4]:null}}var fm=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;function gm(e){var r=fm.exec(e);return r?{file:r[2],methodName:r[1]||xt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}var hm=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,ym=/(\S+) line (\d+)(?: > eval line \d+)* > eval/i;function bm(e){var r=hm.exec(e);if(!r)return null;var t=r[3]&&r[3].indexOf(" > eval")>-1,n=ym.exec(r[3]);return t&&n!=null&&(r[3]=n[1],r[4]=n[2],r[5]=null),{file:r[3],methodName:r[1]||xt,arguments:r[2]?r[2].split(","):[],lineNumber:r[4]?+r[4]:null,column:r[5]?+r[5]:null}}var Em=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function wm(e){var r=Em.exec(e);return r?{file:r[3],methodName:r[1]||xt,arguments:[],lineNumber:+r[4],column:r[5]?+r[5]:null}:null}var xm=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;function vm(e){var r=xm.exec(e);return r?{file:r[2],methodName:r[1]||xt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}var to=class{getLocation(){return null}},no=class{_error;constructor(){this._error=new Error}getLocation(){let r=this._error.stack;if(!r)return null;let n=qa(r).find(i=>{if(!i.file)return!1;let o=Oi(i.file);return o!=="<anonymous>"&&!o.includes("@prisma")&&!o.includes("/packages/client/src/runtime/")&&!o.endsWith("/runtime/binary.js")&&!o.endsWith("/runtime/library.js")&&!o.endsWith("/runtime/edge.js")&&!o.endsWith("/runtime/edge-esm.js")&&!o.startsWith("internal/")&&!i.methodName.includes("new ")&&!i.methodName.includes("getCallSite")&&!i.methodName.includes("Proxy.")&&i.methodName.split(".").length<4});return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}};function Ze(e){return e==="minimal"?typeof $EnabledCallSite=="function"&&e!=="minimal"?new $EnabledCallSite:new to:new no}var ja={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function qr(e={}){let r=Tm(e);return Object.entries(r).reduce((n,[i,o])=>(ja[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function Tm(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function Mn(e={}){return r=>(typeof e._count=="boolean"&&(r._count=r._count._all),r)}function Va(e,r){let t=Mn(e);return r({action:"aggregate",unpacker:t,argsMapper:qr})(e)}function Sm(e={}){let{select:r,...t}=e;return typeof r=="object"?qr({...t,_count:r}):qr({...t,_count:{_all:!0}})}function Rm(e={}){return typeof e.select=="object"?r=>Mn(e)(r)._count:r=>Mn(e)(r)._count._all}function Ba(e,r){return r({action:"count",unpacker:Rm(e),argsMapper:Sm})(e)}function Cm(e={}){let r=qr(e);if(Array.isArray(r.by))for(let t of r.by)typeof t=="string"&&(r.select[t]=!0);else typeof r.by=="string"&&(r.select[r.by]=!0);return r}function Am(e={}){return r=>(typeof e?._count=="boolean"&&r.forEach(t=>{t._count=t._count._all}),r)}function Ua(e,r){return r({action:"groupBy",unpacker:Am(e),argsMapper:Cm})(e)}function Ga(e,r,t){if(r==="aggregate")return n=>Va(n,t);if(r==="count")return n=>Ba(n,t);if(r==="groupBy")return n=>Ua(n,t)}function Qa(e,r){let t=r.fields.filter(i=>!i.relationName),n=zs(t,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new dt(e,o,s.type,s.isList,s.kind==="enum")},...Fn(Object.keys(n))})}var Wa=e=>Array.isArray(e)?e:e.split("."),io=(e,r)=>Wa(r).reduce((t,n)=>t&&t[n],e),Ja=(e,r,t)=>Wa(r).reduceRight((n,i,o,s)=>Object.assign({},io(e,s.slice(0,o)),{[i]:n}),t);function Im(e,r){return e===void 0||r===void 0?[]:[...r,"select",e]}function km(e,r,t){return r===void 0?e??{}:Ja(r,t,e||!0)}function oo(e,r,t,n,i,o){let a=e._runtimeDataModel.models[r].fields.reduce((l,u)=>({...l,[u.name]:u}),{});return l=>{let u=Ze(e._errorFormat),c=Im(n,i),p=km(l,o,c),d=t({dataPath:c,callsite:u})(p),f=Om(e,r);return new Proxy(d,{get(g,h){if(!f.includes(h))return g[h];let P=[a[h].type,t,h],S=[c,p];return oo(e,...P,...S)},...Fn([...f,...Object.getOwnPropertyNames(d)])})}}function Om(e,r){return e._runtimeDataModel.models[r].fields.filter(t=>t.kind==="object").map(t=>t.name)}var Dm=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],_m=["aggregate","count","groupBy"];function so(e,r){let t=e._extensions.getAllModelExtensions(r)??{},n=[Nm(e,r),Fm(e,r),wt(t),re("name",()=>r),re("$name",()=>r),re("$parent",()=>e._appliedParent)];return he({},n)}function Nm(e,r){let t=Se(r),n=Object.keys(Cr).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>l=>{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=>{let p={args:l,dataPath:[],action:o,model:r,clientMethod:`${t}.${i}`,jsModelName:t,transaction:c,callsite:u};return e._request({...p,...a})},{action:o,args:l,model:r})};return Dm.includes(o)?oo(e,r,s):Lm(i)?Ga(e,i,s):s({})}}}function Lm(e){return _m.includes(e)}function Fm(e,r){return ar(re("fields",()=>{let t=e._runtimeDataModel.models[r];return Qa(r,t)}))}function Ha(e){return e.replace(/^./,r=>r.toUpperCase())}var ao=Symbol();function vt(e){let r=[Mm(e),$m(e),re(ao,()=>e),re("$parent",()=>e._appliedParent)],t=e._extensions.getAllClientExtensions();return t&&r.push(wt(t)),he(e,r)}function Mm(e){let r=Object.getPrototypeOf(e._originalClient),t=[...new Set(Object.getOwnPropertyNames(r))];return{getKeys(){return t},getPropertyValue(n){return e[n]}}}function $m(e){let r=Object.keys(e._runtimeDataModel.models),t=r.map(Se),n=[...new Set(r.concat(t))];return ar({getKeys(){return n},getPropertyValue(i){let o=Ha(i);if(e._runtimeDataModel.models[o]!==void 0)return so(e,o);if(e._runtimeDataModel.models[i]!==void 0)return so(e,i)},getPropertyDescriptor(i){if(!t.includes(i))return{enumerable:!1}}})}function Ka(e){return e[ao]?e[ao]:e}function Ya(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let t=e.client.__AccelerateEngine;this._originalClient._engine=new t(this._originalClient._accelerateEngineConfig)}let r=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return vt(r)}function za({result:e,modelName:r,select:t,omit:n,extensions:i}){let o=i.getAllComputedFields(r);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(c=>n[c]);u.length>0&&a.push(Fr(u))}else if(t){if(!t[l.name])continue;let u=l.needs.filter(c=>!t[c]);u.length>0&&a.push(Fr(u))}qm(e,l.needs)&&s.push(jm(l,he(e,s)))}return s.length>0||a.length>0?he(e,[...s,...a]):e}function qm(e,r){return r.every(t=>Mi(e,t))}function jm(e,r){return ar(re(e.name,()=>e.compute(r)))}function $n({visitor:e,result:r,args:t,runtimeDataModel:n,modelName:i}){if(Array.isArray(r)){for(let s=0;s<r.length;s++)r[s]=$n({result:r[s],args:t,modelName:i,runtimeDataModel:n,visitor:e});return r}let o=e(r,i,t)??r;return t.include&&Za({includeOrSelect:t.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),t.select&&Za({includeOrSelect:t.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}function Za({includeOrSelect:e,result:r,parentModelName:t,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||r[o]==null||Re(s))continue;let l=n.models[t].fields.find(c=>c.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};r[o]=$n({visitor:i,result:r[o],args:u,modelName:l.type,runtimeDataModel:n})}}function Xa({result:e,modelName:r,args:t,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[r]?e:$n({result:e,args:t??{},modelName:r,runtimeDataModel:i,visitor:(a,l,u)=>{let c=Se(l);return za({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}})}var Vm=["$connect","$disconnect","$on","$transaction","$use","$extends"],el=Vm;function rl(e){if(e instanceof oe)return Bm(e);if(Nn(e))return Um(e);if(Array.isArray(e)){let t=[e[0]];for(let n=1;n<e.length;n++)t[n]=Pt(e[n]);return t}let r={};for(let t in e)r[t]=Pt(e[t]);return r}function Bm(e){return new oe(e.strings,e.values)}function Um(e){return new Et(e.sql,e.values)}function Pt(e){if(typeof e!="object"||e==null||e instanceof Fe||Dr(e))return e;if(Rr(e))return new ve(e.toFixed());if(Sr(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let r=e.length,t;for(t=Array(r);r--;)t[r]=Pt(e[r]);return t}if(typeof e=="object"){let r={};for(let t in e)t==="__proto__"?Object.defineProperty(r,t,{value:Pt(e[t]),configurable:!0,enumerable:!0,writable:!0}):r[t]=Pt(e[t]);return r}_e(e,"Unknown value")}function nl(e,r,t,n=0){return e._createPrismaPromise(i=>{let o=r.customDataProxyFetch;return"transaction"in r&&i!==void 0&&(r.transaction?.kind==="batch"&&r.transaction.lock.then(),r.transaction=i),n===t.length?e._executeRequest(r):t[n]({model:r.model,operation:r.model?r.action:r.clientMethod,args:rl(r.args??{}),__internalParams:r,query:(s,a=r)=>{let l=a.customDataProxyFetch;return a.customDataProxyFetch=al(o,l),a.args=s,nl(e,a,t,n+1)}})})}function il(e,r){let{jsModelName:t,action:n,clientMethod:i}=r,o=t?n:i;if(e._extensions.isEmpty())return e._executeRequest(r);let s=e._extensions.getAllQueryCallbacks(t??"$none",o);return nl(e,r,s)}function ol(e){return r=>{let t={requests:r},n=r[0].extensions.getAllBatchQueryCallbacks();return n.length?sl(t,n,0,e):e(t)}}function sl(e,r,t,n){if(t===r.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return r[t]({args:{queries:e.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=al(i,l),sl(a,r,t+1,n)}})}var tl=e=>e;function al(e=tl,r=tl){return t=>e(r(t))}var ll=N("prisma:client"),ul={Vercel:"vercel","Netlify CI":"netlify"};function cl({postinstall:e,ciName:r,clientVersion:t}){if(ll("checkPlatformCaching:postinstall",e),ll("checkPlatformCaching:ciName",r),e===!0&&r&&r in ul){let n=`Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ul[r]}-build`;throw console.error(n),new T(n,t)}}function pl(e,r){return e?e.datasources?e.datasources:e.datasourceUrl?{[r[0]]:{url:e.datasourceUrl}}:{}:{}}var Gm=()=>globalThis.process?.release?.name==="node",Qm=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,Wm=()=>!!globalThis.Deno,Jm=()=>typeof globalThis.Netlify=="object",Hm=()=>typeof globalThis.EdgeRuntime=="object",Km=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function Ym(){return[[Jm,"netlify"],[Hm,"edge-light"],[Km,"workerd"],[Wm,"deno"],[Qm,"bun"],[Gm,"node"]].flatMap(t=>t[0]()?[t[1]]:[]).at(0)??""}var zm={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function qn(){let e=Ym();return{id:e,prettyName:zm[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}var hl=k(require("node:fs")),Tt=k(require("node:path"));function jn(e){let{runtimeBinaryTarget:r}=e;return`Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Zm(e)}`}function Zm(e){let{generator:r,generatorBinaryTargets:t,runtimeBinaryTarget:n}=e,i={fromEnvVar:null,value:n},o=[...t,i];return Ai({...r,binaryTargets:o})}function Xe(e){let{runtimeBinaryTarget:r}=e;return`Prisma Client could not locate the Query Engine for runtime "${r}".`}function er(e){let{searchedLocations:r}=e;return`The following locations have been searched:
${[...new Set(r)].map(i=>`  ${i}`).join(`
`)}`}function dl(e){let{runtimeBinaryTarget:r}=e;return`${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${jn(e)}

${er(e)}`}function Vn(e){return`We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`}function Bn(e){let{errorStack:r}=e;return r?.match(/\/\.next|\/next@|\/next\//)?`

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}function ml(e){let{queryEngineName:r}=e;return`${Xe(e)}${Bn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${Vn("engine-not-found-bundler-investigation")}

${er(e)}`}function fl(e){let{runtimeBinaryTarget:r,generatorBinaryTargets:t}=e,n=t.find(i=>i.native);return`${Xe(e)}

This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${r}".
${jn(e)}

${er(e)}`}function gl(e){let{queryEngineName:r}=e;return`${Xe(e)}${Bn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${Vn("engine-not-found-tooling-investigation")}

${er(e)}`}var Xm=N("prisma:client:engines:resolveEnginePath"),ef=()=>new RegExp("runtime[\\\\/]library\\.m?js$");async function yl(e,r){let t={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??r.prismaPath;if(t!==void 0)return t;let{enginePath:n,searchedLocations:i}=await rf(e,r);if(Xm("enginePath",n),n!==void 0&&e==="binary"&&vi(n),n!==void 0)return r.prismaPath=n;let o=await ir(),s=r.generator?.binaryTargets??[],a=s.some(d=>d.native),l=!s.some(d=>d.value===o),u=__filename.match(ef())===null,c={searchedLocations:i,generatorBinaryTargets:s,generator:r.generator,runtimeBinaryTarget:o,queryEngineName:bl(e,o),expectedLocation:Tt.default.relative(process.cwd(),r.dirname),errorStack:new Error().stack},p;throw a&&l?p=fl(c):l?p=dl(c):u?p=ml(c):p=gl(c),new T(p,r.clientVersion)}async function rf(engineType,config){let binaryTarget=await ir(),searchedLocations=[],dirname=eval("__dirname"),searchLocations=[config.dirname,Tt.default.resolve(dirname,".."),config.generator?.output?.value??dirname,Tt.default.resolve(dirname,"../../../.prisma/client"),"/tmp/prisma-engines",config.cwd];__filename.includes("resolveEnginePath")&&searchLocations.push(gs());for(let e of searchLocations){let r=bl(engineType,binaryTarget),t=Tt.default.join(e,r);if(searchedLocations.push(e),hl.default.existsSync(t))return{enginePath:t,searchedLocations}}return{enginePath:void 0,searchedLocations}}function bl(e,r){return e==="library"?Bt(r,"fs"):`query-engine-${r}${r==="windows"?".exe":""}`}var lo=k(ki());function El(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,r=>`${r[0]}5`):""}function wl(e){return e.split(`
`).map(r=>r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).join(`
`)}var xl=k(Ls());function vl({title:e,user:r="prisma",repo:t="prisma",template:n="bug_report.yml",body:i}){return(0,xl.default)({user:r,repo:t,template:n,title:e,body:i})}function Pl({version:e,binaryTarget:r,title:t,description:n,engineVersion:i,database:o,query:s}){let a=Go(6e3-(s?.length??0)),l=wl((0,lo.default)(a)),u=n?`# Description
\`\`\`
${n}
\`\`\``:"",c=(0,lo.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s?El(s):""}
\`\`\`
`),p=vl({title:t,body:c});return`${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Y(p)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}function jr({inlineDatasources:e,overrideDatasources:r,env:t,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=r[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=t[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw new T(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new T("error: Missing URL environment variable, value, or override.",n);return i}var Un=class extends Error{clientVersion;cause;constructor(r,t){super(r),this.clientVersion=t.clientVersion,this.cause=t.cause}get[Symbol.toStringTag](){return this.name}};var se=class extends Un{isRetryable;constructor(r,t){super(r,t),this.isRetryable=t.isRetryable??!0}};function R(e,r){return{...e,isRetryable:r}}var Vr=class extends se{name="ForcedRetryError";code="P5001";constructor(r){super("This request must be retried",R(r,!0))}};x(Vr,"ForcedRetryError");var lr=class extends se{name="InvalidDatasourceError";code="P6001";constructor(r,t){super(r,R(t,!1))}};x(lr,"InvalidDatasourceError");var ur=class extends se{name="NotImplementedYetError";code="P5004";constructor(r,t){super(r,R(t,!1))}};x(ur,"NotImplementedYetError");var $=class extends se{response;constructor(r,t){super(r,t),this.response=t.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};var cr=class extends ${name="SchemaMissingError";code="P5005";constructor(r){super("Schema needs to be uploaded",R(r,!0))}};x(cr,"SchemaMissingError");var uo="This request could not be understood by the server",St=class extends ${name="BadRequestError";code="P5000";constructor(r,t,n){super(t||uo,R(r,!1)),n&&(this.code=n)}};x(St,"BadRequestError");var Rt=class extends ${name="HealthcheckTimeoutError";code="P5013";logs;constructor(r,t){super("Engine not started: healthcheck timeout",R(r,!0)),this.logs=t}};x(Rt,"HealthcheckTimeoutError");var Ct=class extends ${name="EngineStartupError";code="P5014";logs;constructor(r,t,n){super(t,R(r,!0)),this.logs=n}};x(Ct,"EngineStartupError");var At=class extends ${name="EngineVersionNotSupportedError";code="P5012";constructor(r){super("Engine version is not supported",R(r,!1))}};x(At,"EngineVersionNotSupportedError");var co="Request timed out",It=class extends ${name="GatewayTimeoutError";code="P5009";constructor(r,t=co){super(t,R(r,!1))}};x(It,"GatewayTimeoutError");var tf="Interactive transaction error",kt=class extends ${name="InteractiveTransactionError";code="P5015";constructor(r,t=tf){super(t,R(r,!1))}};x(kt,"InteractiveTransactionError");var nf="Request parameters are invalid",Ot=class extends ${name="InvalidRequestError";code="P5011";constructor(r,t=nf){super(t,R(r,!1))}};x(Ot,"InvalidRequestError");var po="Requested resource does not exist",Dt=class extends ${name="NotFoundError";code="P5003";constructor(r,t=po){super(t,R(r,!1))}};x(Dt,"NotFoundError");var mo="Unknown server error",Br=class extends ${name="ServerError";code="P5006";logs;constructor(r,t,n){super(t||mo,R(r,!0)),this.logs=n}};x(Br,"ServerError");var fo="Unauthorized, check your connection string",_t=class extends ${name="UnauthorizedError";code="P5007";constructor(r,t=fo){super(t,R(r,!1))}};x(_t,"UnauthorizedError");var go="Usage exceeded, retry again later",Nt=class extends ${name="UsageExceededError";code="P5008";constructor(r,t=go){super(t,R(r,!0))}};x(Nt,"UsageExceededError");async function of(e){let r;try{r=await e.text()}catch{return{type:"EmptyError"}}try{let t=JSON.parse(r);if(typeof t=="string")switch(t){case"InternalDataProxyError":return{type:"DataProxyError",body:t};default:return{type:"UnknownTextError",body:t}}if(typeof t=="object"&&t!==null){if("is_panic"in t&&"message"in t&&"error_code"in t)return{type:"QueryEngineError",body:t};if("EngineNotStarted"in t||"InteractiveTransactionMisrouted"in t||"InvalidRequestError"in t){let n=Object.values(t)[0].reason;return typeof n=="string"&&!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:t}:{type:"DataProxyError",body:t}}}return{type:"UnknownJsonError",body:t}}catch{return r===""?{type:"EmptyError"}:{type:"UnknownTextError",body:r}}}async function Lt(e,r){if(e.ok)return;let t={clientVersion:r,response:e},n=await of(e);if(n.type==="QueryEngineError")throw new z(n.body.message,{code:n.body.error_code,clientVersion:r});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new Br(t,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new cr(t);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new At(t);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new Ct(t,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new T(i,r,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new Rt(t,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new kt(t,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new Ot(t,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new _t(t,Ur(fo,n));if(e.status===404)return new Dt(t,Ur(po,n));if(e.status===429)throw new Nt(t,Ur(go,n));if(e.status===504)throw new It(t,Ur(co,n));if(e.status>=500)throw new Br(t,Ur(mo,n));if(e.status>=400)throw new St(t,Ur(uo,n))}function Ur(e,r){return r.type==="EmptyError"?e:`${e}: ${JSON.stringify(r)}`}function Tl(e){let r=Math.pow(2,e)*50,t=Math.ceil(Math.random()*r)-Math.ceil(r/2),n=r+t;return new Promise(i=>setTimeout(()=>i(n),n))}var Me="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function Sl(e){let r=new TextEncoder().encode(e),t="",n=r.byteLength,i=n%3,o=n-i,s,a,l,u,c;for(let p=0;p<o;p=p+3)c=r[p]<<16|r[p+1]<<8|r[p+2],s=(c&16515072)>>18,a=(c&258048)>>12,l=(c&4032)>>6,u=c&63,t+=Me[s]+Me[a]+Me[l]+Me[u];return i==1?(c=r[o],s=(c&252)>>2,a=(c&3)<<4,t+=Me[s]+Me[a]+"=="):i==2&&(c=r[o]<<8|r[o+1],s=(c&64512)>>10,a=(c&1008)>>4,l=(c&15)<<2,t+=Me[s]+Me[a]+Me[l]+"="),t}function Rl(e){if(!!e.generator?.previewFeatures.some(t=>t.toLowerCase().includes("metrics")))throw new T("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}function sf(e){return e[0]*1e3+e[1]/1e6}function ho(e){return new Date(sf(e))}var Cl={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var Ft=class extends se{name="RequestError";code="P5010";constructor(r,t){super(`Cannot fetch data from service:
${r}`,R(t,!0))}};x(Ft,"RequestError");async function pr(e,r,t=n=>n){let{clientVersion:n,...i}=r,o=t(fetch);try{return await o(e,i)}catch(s){let a=s.message??"Unknown error";throw new Ft(a,{clientVersion:n,cause:s})}}var lf=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,Al=N("prisma:client:dataproxyEngine");async function uf(e,r){let t=Cl["@prisma/engines-version"],n=r.clientVersion??"unknown";if(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&&n!=="0.0.0"&&n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&&lf.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){if(e.startsWith("localhost")||e.startsWith("127.0.0.1"))return"0.0.0";let[s]=t.split("-")??[],[a,l,u]=s.split("."),c=cf(`<=${a}.${l}.${u}`),p=await pr(c,{clientVersion:n});if(!p.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"<empty body>"}`);let d=await p.text();Al("length of body fetched from unpkg.com",d.length);let f;try{f=JSON.parse(d)}catch(g){throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),g}return f.version}throw new ur("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}async function Il(e,r){let t=await uf(e,r);return Al("version",t),t}function cf(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}var kl=3,Gn=N("prisma:client:dataproxyEngine"),yo=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:r,tracingHelper:t,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=r,this.tracingHelper=t,this.logLevel=n,this.logQueries=i,this.engineHash=o}build({traceparent:r,interactiveTransaction:t}={}){let n={Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};this.tracingHelper.isEnabled()&&(n.traceparent=r??this.tracingHelper.getTraceParent()),t&&(n["X-transaction-id"]=t.id);let i=this.buildCaptureSettings();return i.length>0&&(n["X-capture-telemetry"]=i.join(", ")),n}buildCaptureSettings(){let r=[];return this.tracingHelper.isEnabled()&&r.push("tracing"),this.logLevel&&r.push(this.logLevel),this.logQueries&&r.push("query"),r}},Mt=class{name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;constructor(r){Rl(r),this.config=r,this.env={...r.env,...typeof process<"u"?process.env:{}},this.inlineSchema=Sl(r.inlineSchema),this.inlineDatasources=r.inlineDatasources,this.inlineSchemaHash=r.inlineSchemaHash,this.clientVersion=r.clientVersion,this.engineHash=r.engineVersion,this.logEmitter=r.logEmitter,this.tracingHelper=r.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&&await this.startPromise,this.startPromise=(async()=>{let[r,t]=this.extractHostAndApiKey();this.host=r,this.headerBuilder=new yo({apiKey:t,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await Il(r,this.config),Gn("host",this.host)})(),await this.startPromise}async stop(){}propagateResponseExtensions(r){r?.logs?.length&&r.logs.forEach(t=>{switch(t.level){case"debug":case"trace":Gn(t);break;case"error":case"warn":case"info":{this.logEmitter.emit(t.level,{timestamp:ho(t.timestamp),message:t.attributes.message??"",target:t.target});break}case"query":{this.logEmitter.emit("query",{query:t.attributes.query??"",timestamp:ho(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target});break}default:t.level}}),r?.traces?.length&&this.tracingHelper.dispatchEngineSpans(r.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(r){return await this.start(),`https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`}async uploadSchema(){let r={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(r,async()=>{let t=await pr(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});t.ok||Gn("schema response status",t.status);let n=await Lt(t,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(r,{traceparent:t,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:r,traceparent:t,interactiveTransaction:n,customDataProxyFetch:i})}async requestBatch(r,{traceparent:t,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=Mr(r,n);return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:t})).map(l=>(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:r,traceparent:t,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=>{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await pr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t,interactiveTransaction:i}),body:JSON.stringify(r),clientVersion:this.clientVersion},n);a.ok||Gn("graphql response status",a.status),await this.handleError(await Lt(a,this.clientVersion));let l=await a.json();if(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(r,t,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[r]} transaction`,callback:async({logHttpCall:o})=>{if(r==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await pr(a,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await Lt(l,this.clientVersion));let u=await l.json(),{extensions:c}=u;c&&this.propagateResponseExtensions(c);let p=u.id,d=u["data-proxy"].endpoint;return{id:p,payload:{endpoint:d}}}else{let s=`${n.payload.endpoint}/${r}`;o(s);let a=await pr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),clientVersion:this.clientVersion});await this.handleError(await Lt(a,this.clientVersion));let l=await a.json(),{extensions:u}=l;u&&this.propagateResponseExtensions(u);return}}})}extractHostAndApiKey(){let r={clientVersion:this.clientVersion},t=Object.keys(this.inlineDatasources)[0],n=jr({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),i;try{i=new URL(n)}catch{throw new lr(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r)}let{protocol:o,host:s,searchParams:a}=i;if(o!=="prisma:"&&o!==en)throw new lr(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r);let l=a.get("api_key");if(l===null||l.length<1)throw new lr(`Error validating datasource \`${t}\`: the URL must contain a valid API key`,r);return[s,l]}metrics(){throw new ur("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(r){for(let t=0;;t++){let n=i=>{this.logEmitter.emit("info",{message:`Calling ${i} (n=${t})`,timestamp:new Date,target:""})};try{return await r.callback({logHttpCall:n})}catch(i){if(!(i instanceof se)||!i.isRetryable)throw i;if(t>=kl)throw i instanceof Vr?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${t+1}/${kl} failed for ${r.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await Tl(t);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(r){if(r instanceof cr)throw await this.uploadSchema(),new Vr({clientVersion:this.clientVersion,cause:r});if(r)throw r}convertProtocolErrorsToClientError(r){return r.length===1?$r(r[0],this.config.clientVersion,this.config.activeProvider):new j(JSON.stringify(r),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};function bo(e){return e.name==="DriverAdapterError"&&typeof e.cause=="object"}function Qn(e){return{ok:!0,value:e,map(r){return Qn(r(e))},flatMap(r){return r(e)}}}function dr(e){return{ok:!1,error:e,map(){return dr(e)},flatMap(){return dr(e)}}}var Ol=N("driver-adapter-utils"),Eo=class{registeredErrors=[];consumeError(r){return this.registeredErrors[r]}registerNewError(r){let t=0;for(;this.registeredErrors[t]!==void 0;)t++;return this.registeredErrors[t]={error:r},t}};var wo=(e,r=new Eo)=>{let t={adapterName:e.adapterName,errorRegistry:r,queryRaw:$e(r,e.queryRaw.bind(e)),executeRaw:$e(r,e.executeRaw.bind(e)),executeScript:$e(r,e.executeScript.bind(e)),dispose:$e(r,e.dispose.bind(e)),provider:e.provider,startTransaction:async(...n)=>(await $e(r,e.startTransaction.bind(e))(...n)).map(o=>pf(r,o))};return e.getConnectionInfo&&(t.getConnectionInfo=df(r,e.getConnectionInfo.bind(e))),t},pf=(e,r)=>({adapterName:r.adapterName,provider:r.provider,options:r.options,queryRaw:$e(e,r.queryRaw.bind(r)),executeRaw:$e(e,r.executeRaw.bind(r)),commit:$e(e,r.commit.bind(r)),rollback:$e(e,r.rollback.bind(r))});function $e(e,r){return async(...t)=>{try{return Qn(await r(...t))}catch(n){if(Ol("[error@wrapAsync]",n),bo(n))return dr(n.cause);let i=e.registerNewError(n);return dr({kind:"GenericJs",id:i})}}}function df(e,r){return(...t)=>{try{return Qn(r(...t))}catch(n){if(Ol("[error@wrapSync]",n),bo(n))return dr(n.cause);let i=e.registerNewError(n);return dr({kind:"GenericJs",id:i})}}}function Dl(e){if(e?.kind==="itx")return e.options.id}var vo=k(require("node:os")),_l=k(require("node:path"));var xo=Symbol("PrismaLibraryEngineCache");function mf(){let e=globalThis;return e[xo]===void 0&&(e[xo]={}),e[xo]}function ff(e){let r=mf();if(r[e]!==void 0)return r[e];let t=_l.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"&&(i=vo.default.constants.dlopen.RTLD_LAZY|vo.default.constants.dlopen.RTLD_DEEPBIND),process.dlopen(n,t,i),r[e]=n.exports,n.exports}var Nl={async loadLibrary(e){let r=await pi(),t=await yl("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=>ff(t))}catch(n){let i=Pi({e:n,platformInfo:r,id:t});throw new T(i,e.clientVersion)}}};var Po,Ll={async loadLibrary(e){let{clientVersion:r,adapter:t,engineWasm:n}=e;if(t===void 0)throw new T(`The \`adapter\` option for \`PrismaClient\` is required in this context (${qn().prettyName})`,r);if(n===void 0)throw new T("WASM engine was unexpectedly `undefined`",r);Po===void 0&&(Po=(async()=>{let o=await n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new T("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",r);let a={"./query_engine_bg.js":o},l=new WebAssembly.Instance(s,a),u=l.exports.__wbindgen_start;return o.__wbg_set_wasm(l.exports),u(),o.QueryEngine})());let i=await Po;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}};var gf="P2036",Ce=N("prisma:client:libraryEngine");function hf(e){return e.item_type==="query"&&"query"in e}function yf(e){return"level"in e?e.level==="error"&&e.message==="PANIC":!1}var Fl=[...oi,"native"],bf=0xffffffffffffffffn,To=1n;function Ef(){let e=To++;return To>bf&&(To=1n),e}var Gr=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(r,t){this.libraryLoader=t??Nl,r.engineWasm!==void 0&&(this.libraryLoader=t??Ll),this.config=r,this.libraryStarted=!1,this.logQueries=r.logQueries??!1,this.logLevel=r.logLevel??"error",this.logEmitter=r.logEmitter,this.datamodel=r.inlineSchema,this.tracingHelper=r.tracingHelper,r.enableDebugLogs&&(this.logLevel="debug");let n=Object.keys(r.overrideDatasources)[0],i=r.overrideDatasources[n]?.url;n!==void 0&&i!==void 0&&(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(r){return{applyPendingMigrations:r.applyPendingMigrations?.bind(r),commitTransaction:this.withRequestId(r.commitTransaction.bind(r)),connect:this.withRequestId(r.connect.bind(r)),disconnect:this.withRequestId(r.disconnect.bind(r)),metrics:r.metrics?.bind(r),query:this.withRequestId(r.query.bind(r)),rollbackTransaction:this.withRequestId(r.rollbackTransaction.bind(r)),sdlSchema:r.sdlSchema?.bind(r),startTransaction:this.withRequestId(r.startTransaction.bind(r)),trace:r.trace.bind(r)}}withRequestId(r){return async(...t)=>{let n=Ef().toString();try{return await r(...t,n)}finally{if(this.tracingHelper.isEnabled()){let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}}}async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}async transaction(r,t,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(t),s;if(r==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else r==="commit"?s=await this.engine?.commitTransaction(n.id,o):r==="rollback"&&(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(wf(a)){let l=this.getExternalAdapterError(a,i?.errorRegistry);throw l?l.error:new z(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new j(a.message,{clientVersion:this.config.clientVersion});return a}async instantiateLibrary(){if(Ce("internalSetup"),this.libraryInstantiationPromise)return this.libraryInstantiationPromise;ii(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=>this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{if(this.binaryTarget)return this.binaryTarget;let r=await this.tracingHelper.runInChildSpan("detect_platform",()=>ir());if(!Fl.includes(r))throw new T(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(Fl.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return r}}parseEngineResponse(r){if(!r)throw new j("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(r)}catch{throw new j("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let r=new WeakRef(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(wo));let t=await this.adapterPromise;t&&Ce("Using driver adapter: %O",t),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=>{r.deref()?.logger(n)},t))}catch(r){let t=r,n=this.parseInitError(t.message);throw typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}}}logger(r){let t=this.parseEngineResponse(r);t&&(t.level=t?.level.toLowerCase()??"unknown",hf(t)?this.logEmitter.emit("query",{timestamp:new Date,query:t.query,params:t.params,duration:Number(t.duration_ms),target:t.module_path}):yf(t)?this.loggerRustPanic=new le(So(this,`${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`),this.config.clientVersion):this.logEmitter.emit(t.level,{timestamp:new Date,message:t.message,target:t.module_path}))}parseInitError(r){try{return JSON.parse(r)}catch{}return r}parseRequestError(r){try{return JSON.parse(r)}catch{}return r}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}async start(){if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return Ce(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let r=async()=>{Ce("library starting");try{let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(t)),this.libraryStarted=!0,Ce("library started")}catch(t){let n=this.parseInitError(t.message);throw typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",r),this.libraryStartingPromise}async stop(){if(await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Ce("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted)return;let r=async()=>{await new Promise(n=>setTimeout(n,5)),Ce("library stopping");let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(t)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Ce("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",r),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}debugPanic(r){return this.library?.debugPanic(r)}async request(r,{traceparent:t,interactiveTransaction:n}){Ce(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:t}),o=JSON.stringify(r);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:a}}catch(s){if(s instanceof T)throw s;if(s.code==="GenericFailure"&&s.message?.startsWith("PANIC:"))throw new le(So(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new j(`${a.message}
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(r,{transaction:t,traceparent:n}){Ce("requestBatch");let i=Mr(r,t);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),Dl(t));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:l,errors:u}=a;if(Array.isArray(l))return l.map(c=>c.errors&&c.errors.length>0?this.loggerRustPanic??this.buildQueryError(c.errors[0],o?.errorRegistry):{data:c});throw u&&u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}buildQueryError(r,t){if(r.user_facing_error.is_panic)return new le(So(this,r.user_facing_error.message),this.config.clientVersion);let n=this.getExternalAdapterError(r.user_facing_error,t);return n?n.error:$r(r,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(r,t){if(r.error_code===gf&&t){let n=r.meta?.id;rn(typeof n=="number","Malformed external JS error received from the engine");let i=t.consumeError(n);return rn(i,"External error with reported id was not registered"),i}}async metrics(r){await this.start();let t=await this.engine.metrics(JSON.stringify(r));return r.format==="prometheus"?t:this.parseEngineResponse(t)}};function wf(e){return typeof e=="object"&&e!==null&&e.error_code!==void 0}function So(e,r){return Pl({binaryTarget:e.binaryTarget,title:r,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}function Ml({copyEngine:e=!0},r){let t;try{t=jr({inlineDatasources:r.inlineDatasources,overrideDatasources:r.overrideDatasources,env:{...r.env,...process.env},clientVersion:r.clientVersion})}catch{}let n=!!(t?.startsWith("prisma://")||Si(t));e&&n&&ot("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");let i=Er(r.generator),o=n||!e,s=!!r.adapter,a=i==="library",l=i==="binary",u=i==="client";if(o&&s||s&&!1){let c;throw e?t?.startsWith("prisma://")?c=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:c=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:c=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new Z(c.join(`
`),{clientVersion:r.clientVersion})}return o?new Mt(r):a?new Gr(r):new Gr(r)}function Wn({generator:e}){return e?.previewFeatures??[]}var $l=e=>({command:e});var ql=e=>e.strings.reduce((r,t,n)=>`${r}@P${n}${t}`);function Qr(e){try{return jl(e,"fast")}catch{return jl(e,"slow")}}function jl(e,r){return JSON.stringify(e.map(t=>Bl(t,r)))}function Bl(e,r){if(Array.isArray(e))return e.map(t=>Bl(t,r));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(Sr(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(ve.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(xf(e))return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:Buffer.from(t,n,i).toString("base64")}}return typeof e=="object"&&r==="slow"?Ul(e):e}function xf(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&&e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Ul(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Vl);let r={};for(let t of Object.keys(e))r[t]=Vl(e[t]);return r}function Vl(e){return typeof e=="bigint"?e.toString():Ul(e)}var vf=/^(\s*alter\s)/i,Gl=N("prisma:client");function Ro(e,r,t,n){if(!(e!=="postgresql"&&e!=="cockroachdb")&&t.length>0&&vf.exec(r))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var Co=({clientMethod:e,activeProvider:r})=>t=>{let n="",i;if(Nn(t))n=t.sql,i={values:Qr(t.values),__prismaRawParameters__:!0};else if(Array.isArray(t)){let[o,...s]=t;n=o,i={values:Qr(s||[]),__prismaRawParameters__:!0}}else switch(r){case"sqlite":case"mysql":{n=t.sql,i={values:Qr(t.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=t.text,i={values:Qr(t.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=ql(t),i={values:Qr(t.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${r} provider does not support ${e}`)}return i?.values?Gl(`prisma.${e}(${n}, ${i.values})`):Gl(`prisma.${e}(${n})`),{query:n,parameters:i}},Ql={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[r,...t]=e;return new oe(r,t)}},Wl={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};function Ao(e){return function(t,n){let i,o=(s=e)=>{try{return s===void 0||s?.kind==="itx"?i??=Jl(t(s)):Jl(t(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function Jl(e){return typeof e.then=="function"?e:Promise.resolve(e)}var Pf=bi.split(".")[0],Tf={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,r){return r()}},Io=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(r){return this.getGlobalTracingHelper().getTraceParent(r)}dispatchEngineSpans(r){return this.getGlobalTracingHelper().dispatchEngineSpans(r)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(r,t){return this.getGlobalTracingHelper().runInChildSpan(r,t)}getGlobalTracingHelper(){let r=globalThis[`V${Pf}_PRISMA_INSTRUMENTATION`],t=globalThis.PRISMA_INSTRUMENTATION;return r?.helper??t?.helper??Tf}};function Hl(){return new Io}function Kl(e,r=()=>{}){let t,n=new Promise(i=>t=i);return{then(i){return--e===0&&t(r()),i?.(n)}}}function Yl(e){return typeof e=="string"?e:e.reduce((r,t)=>{let n=typeof t=="string"?t:t.level;return n==="query"?r:r&&(t==="info"||r==="info")?"info":n},void 0)}var Jn=class{_middlewares=[];use(r){this._middlewares.push(r)}get(r){return this._middlewares[r]}has(r){return!!this._middlewares[r]}length(){return this._middlewares.length}};var Zl=k(ki());function Hn(e){return typeof e.batchRequestIdx=="number"}function zl(e){if(e.action!=="findUnique"&&e.action!=="findUniqueOrThrow")return;let r=[];return e.modelName&&r.push(e.modelName),e.query.arguments&&r.push(ko(e.query.arguments)),r.push(ko(e.query.selection)),r.join("")}function ko(e){return`(${Object.keys(e).sort().map(t=>{let n=e[t];return typeof n=="object"&&n!==null?`(${t} ${ko(n)})`:t}).join(" ")})`}var Sf={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Oo(e){return Sf[e]}var Kn=class{constructor(r){this.options=r;this.batches={}}batches;tickActive=!1;request(r){let t=this.options.batchBy(r);return t?(this.batches[t]||(this.batches[t]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[t].push({request:r,resolve:n,reject:i})})):this.options.singleLoader(r)}dispatchBatches(){for(let r in this.batches){let t=this.batches[r];delete this.batches[r],t.length===1?this.options.singleLoader(t[0].request).then(n=>{n instanceof Error?t[0].reject(n):t[0].resolve(n)}).catch(n=>{t[0].reject(n)}):(t.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(t.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<t.length;i++)t[i].reject(n);else for(let i=0;i<t.length;i++){let o=n[i];o instanceof Error?t[i].reject(o):t[i].resolve(o)}}).catch(n=>{for(let i=0;i<t.length;i++)t[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};function mr(e,r){if(r===null)return r;switch(e){case"bigint":return BigInt(r);case"bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"decimal":return new ve(r);case"datetime":case"date":return new Date(r);case"time":return new Date(`1970-01-01T${r}Z`);case"bigint-array":return r.map(t=>mr("bigint",t));case"bytes-array":return r.map(t=>mr("bytes",t));case"decimal-array":return r.map(t=>mr("decimal",t));case"datetime-array":return r.map(t=>mr("datetime",t));case"date-array":return r.map(t=>mr("date",t));case"time-array":return r.map(t=>mr("time",t));default:return r}}function Yn(e){let r=[],t=Rf(e);for(let n=0;n<e.rows.length;n++){let i=e.rows[n],o={...t};for(let s=0;s<i.length;s++)o[e.columns[s]]=mr(e.types[s],i[s]);r.push(o)}return r}function Rf(e){let r={};for(let t=0;t<e.columns.length;t++)r[e.columns[t]]=null;return r}var Cf=N("prisma:client:request_handler"),zn=class{client;dataloader;logEmitter;constructor(r,t){this.logEmitter=t,this.client=r,this.dataloader=new Kn({batchLoader:ol(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=>p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=>Oo(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Af(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=>{if(p instanceof Error)return p;try{return this.mapQueryEngineResult(n[d],p)}catch(f){return f}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?Xl(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Oo(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:zl(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(r){try{return await this.dataloader.request(r)}catch(t){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=r;this.handleAndLogRequestError({error:t,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:r.globalOmit})}}mapQueryEngineResult({dataPath:r,unpacker:t},n){let i=n?.data,o=this.unpack(i,r,t);return process.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(r){try{this.handleRequestError(r)}catch(t){throw this.logEmitter&&this.logEmitter.emit("error",{message:t.message,target:r.clientMethod,timestamp:new Date}),t}}handleRequestError({error:r,clientMethod:t,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(Cf(r),If(r,i))throw r;if(r instanceof z&&kf(r)){let u=eu(r.meta);An({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:t,clientVersion:this.client._clientVersion,globalOmit:a})}let l=r.message;if(n&&(l=bn({callsite:n,originalMethod:t,isPanic:r.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),r.code){let u=s?{modelName:s,...r.meta}:r.meta;throw new z(l,{code:r.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:r.batchRequestIdx})}else{if(r.isPanic)throw new le(l,this.client._clientVersion);if(r instanceof j)throw new j(l,{clientVersion:this.client._clientVersion,batchRequestIdx:r.batchRequestIdx});if(r instanceof T)throw new T(l,this.client._clientVersion);if(r instanceof le)throw new le(l,this.client._clientVersion)}throw r.clientVersion=this.client._clientVersion,r}sanitizeMessage(r){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,Zl.default)(r):r}unpack(r,t,n){if(!r||(r.data&&(r=r.data),!r))return r;let i=Object.keys(r)[0],o=Object.values(r)[0],s=t.filter(u=>u!=="select"&&u!=="include"),a=io(o,s),l=i==="queryRaw"?Yn(a):Tr(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function Af(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:Xl(e)};_e(e,"Unknown transaction kind")}}function Xl(e){return{id:e.id,payload:e.payload}}function If(e,r){return Hn(e)&&r?.kind==="batch"&&e.batchRequestIdx!==r.index}function kf(e){return e.code==="P2009"||e.code==="P2012"}function eu(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(eu)};if(Array.isArray(e.selectionPath)){let[,...r]=e.selectionPath;return{...e,selectionPath:r}}return e}var ru="6.6.0";var tu=ru;var au=k(Qi());var D=class extends Error{constructor(r){super(r+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};x(D,"PrismaClientConstructorValidationError");var nu=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],iu=["pretty","colorless","minimal"],ou=["info","query","warn","error"],Df={datasources:(e,{datasourceNames:r})=>{if(e){if(typeof e!="object"||Array.isArray(e))throw new D(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[t,n]of Object.entries(e)){if(!r.includes(t)){let i=Wr(t,r)||` Available datasources: ${r.join(", ")}`;throw new D(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new D(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new D(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new D(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,r)=>{if(!e&&Er(r.generator)==="client")throw new D('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new D('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Wn(r).includes("driverAdapters"))throw new D('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Er(r.generator)==="binary")throw new D('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=>{if(typeof e<"u"&&typeof e!="string")throw new D(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=>{if(e){if(typeof e!="string")throw new D(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!iu.includes(e)){let r=Wr(e,iu);throw new D(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`)}}},log:e=>{if(!e)return;if(!Array.isArray(e))throw new D(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function r(t){if(typeof t=="string"&&!ou.includes(t)){let n=Wr(t,ou);throw new D(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`)}}for(let t of e){r(t);let n={level:r,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=Wr(i,o);throw new D(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(t&&typeof t=="object")for(let[i,o]of Object.entries(t))if(n[i])n[i](o);else throw new D(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=>{if(!e)return;let r=e.maxWait;if(r!=null&&r<=0)throw new D(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let t=e.timeout;if(t!=null&&t<=0)throw new D(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,r)=>{if(typeof e!="object")throw new D('"omit" option is expected to be an object.');if(e===null)throw new D('"omit" option can not be `null`');let t=[];for(let[n,i]of Object.entries(e)){let o=Nf(n,r.runtimeDataModel);if(!o){t.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=>u.name===s);if(!l){t.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){t.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&t.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(t.length>0)throw new D(Lf(e,t))},__internal:e=>{if(!e)return;let r=["debug","engine","configOverride"];if(typeof e!="object")throw new D(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[t]of Object.entries(e))if(!r.includes(t)){let n=Wr(t,r);throw new D(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function lu(e,r){for(let[t,n]of Object.entries(e)){if(!nu.includes(t)){let i=Wr(t,nu);throw new D(`Unknown property ${t} provided to PrismaClient constructor.${i}`)}Df[t](n,r)}if(e.datasourceUrl&&e.datasources)throw new D('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function Wr(e,r){if(r.length===0||typeof e!="string")return"";let t=_f(e,r);return t?` Did you mean "${t}"?`:""}function _f(e,r){if(r.length===0)return null;let t=r.map(i=>({value:i,distance:(0,au.default)(e,i)}));t.sort((i,o)=>i.distance<o.distance?-1:1);let n=t[0];return n.distance<3?n.value:null}function Nf(e,r){return su(r.models,e)??su(r.types,e)}function su(e,r){let t=Object.keys(e).find(n=>Ye(n)===r);if(t)return e[t]}function Lf(e,r){let t=_r(e);for(let o of r)switch(o.kind){case"UnknownModel":t.arguments.getField(o.modelKey)?.markAsError(),t.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":t.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=Cn(t,"colorless");return`Error validating "omit" option:

${i}

${n}`}function uu(e){return e.length===0?Promise.resolve([]):new Promise((r,t)=>{let n=new Array(e.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===e.length&&(o=!0,i?t(i):r(n)))},l=u=>{o||(o=!0,t(u))};for(let u=0;u<e.length;u++)e[u].then(c=>{n[u]=c,a()},c=>{if(!Hn(c)){l(c);return}c.batchRequestIdx===u?l(c):(i||(i=c),a())})})}var rr=N("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var Ff={requestArgsToMiddlewareArgs:e=>e,middlewareArgsToRequestArgs:e=>e},Mf=Symbol.for("prisma.client.transaction.id"),$f={id:0,nextId(){return++this.id}};function gu(e){class r{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new Jn;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=Ao();constructor(n){e=n?.__internal?.configOverride?.(e)??e,cl(e),n&&lu(n,e);let i=new mu.EventEmitter().on("error",()=>{});this._extensions=Nr.empty(),this._previewFeatures=Wn(e),this._clientVersion=e.clientVersion??tu,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Hl();let o=e.relativeEnvPaths&&{rootEnvPath:e.relativeEnvPaths.rootEnvPath&&Zn.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&&Zn.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"?"postgres":e.activeProvider;if(s.provider!==l)throw new T(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new T("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=!s&&o&&it(o,{conflictCheck:"none"})||e.injectableEdgeEnv?.();try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c&&N.enable("prisma:client");let p=Zn.default.resolve(e.dirname,e.relativePath);fu.default.existsSync(p)||(p=e.dirname),rr("dirname",e.dirname),rr("relativePath",e.relativePath),rr("cwd",p);let d=u.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat:process.env.NODE_ENV==="production"?this._errorFormat="minimal":process.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&&Yl(l.log),logQueries:l.log&&!!(typeof l.log=="string"?l.log==="query":l.log.find(f=>typeof f=="string"?f==="query":f.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:pl(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:jr,getBatchRequestPayload:Mr,prismaGraphQLToJSError:$r,PrismaClientUnknownRequestError:j,PrismaClientInitializationError:T,PrismaClientKnownRequestError:z,debug:N("prisma:client:accelerateEngine"),engineVersion:pu.version,clientVersion:e.clientVersion}},rr("clientVersion",e.clientVersion),this._engine=Ml(e,this._engineConfig),this._requestHandler=new zn(this,i),l.log)for(let f of l.log){let g=typeof f=="string"?f:f.emit==="stdout"?f.level:null;g&&this.$on(g,h=>{tt.log(`${tt.tags[g]??""}`,h.message||h.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=vt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Qo()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Co({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=cu(n,i);return Ro(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(Ro(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:$l,callsite:Ze(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Co({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...cu(n,i));throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=$f.nextId(),s=Kl(n.length),a=n.map((l,u)=>{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??l});return uu(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),u}return l}_createItxClient(n){return he(vt(he(Ka(this),[re("_appliedParent",()=>this._appliedParent._createItxClient(n)),re("_createPrismaPromise",()=>Ao(n)),re(Mf,()=>n.id)])),[Fr(el)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Ff,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async u=>{let c=this._middlewares.get(++a);if(c)return this._tracingHelper.runInChildSpan(s.middleware,I=>c(u,P=>(I?.end(),l(P))));let{runInTransaction:p,args:d,...f}=u,g={...n,...f};d&&(g.args=i.middlewareArgsToRequestArgs(d)),n.transaction!==void 0&&p===!1&&delete g.transaction;let h=await il(this,g);return g.model?Xa({result:h,modelName:g.model,args:g.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):h};return this._tracingHelper.runInChildSpan(s.operation,()=>new du.AsyncResource("prisma-client-request").runInAsyncScope(()=>l(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?u(n):n;let g={name:"serialize"},h=this._tracingHelper.runInChildSpan(g,()=>Dn({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return N.enabled("prisma:client")&&(rr("Prisma Client call:"),rr(`prisma.${i}(${$a(n)})`),rr("Generated request:"),rr(JSON.stringify(h,null,2)+`
`)),c?.kind==="batch"&&await c.lock,this._requestHandler.request({protocolQuery:h,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(g){throw g.clientVersion=this._clientVersion,g}}$metrics=new Lr(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=Ya}return r}function cu(e,r){return qf(e)?[new oe(e,r),Ql]:[e,Wl]}function qf(e){return Array.isArray(e)&&Array.isArray(e.raw)}var jf=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function hu(e){return new Proxy(e,{get(r,t){if(t in r)return r[t];if(!jf.has(t))throw new TypeError(`Invalid enum value: ${String(t)}`)}})}function yu(e){it(e,{conflictCheck:"warn"})}0&&(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map

```

## 📄 lib\generated\prisma\runtime\react-native.js

```js
"use strict";var ba=Object.create;var tr=Object.defineProperty;var Ea=Object.getOwnPropertyDescriptor;var xa=Object.getOwnPropertyNames;var Pa=Object.getPrototypeOf,va=Object.prototype.hasOwnProperty;var ge=(e,t)=>()=>(e&&(t=e(e=0)),t);var Ae=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ze=(e,t)=>{for(var r in t)tr(e,r,{get:t[r],enumerable:!0})},ni=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of xa(t))!va.call(e,i)&&i!==r&&tr(e,i,{get:()=>t[i],enumerable:!(n=Ea(t,i))||n.enumerable});return e};var Se=(e,t,r)=>(r=e!=null?ba(Pa(e)):{},ni(t||!e||!e.__esModule?tr(r,"default",{value:e,enumerable:!0}):r,e)),Ta=e=>ni(tr({},"__esModule",{value:!0}),e);var y,c=ge(()=>{"use strict";y={nextTick:(e,...t)=>{setTimeout(()=>{e(...t)},0)},env:{},version:"",cwd:()=>"/",stderr:{},argv:["/bin/node"]}});var x,p=ge(()=>{"use strict";x=globalThis.performance??(()=>{let e=Date.now();return{now:()=>Date.now()-e}})()});var E,d=ge(()=>{"use strict";E=()=>{};E.prototype=E});var b,f=ge(()=>{"use strict";b=class{value;constructor(t){this.value=t}deref(){return this.value}}});var Pi=Ae(rt=>{"use strict";m();c();p();d();f();var li=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ca=li(e=>{"use strict";e.byteLength=l,e.toByteArray=g,e.fromByteArray=R;var t=[],r=[],n=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(o=0,s=i.length;o<s;++o)t[o]=i[o],r[i.charCodeAt(o)]=o;var o,s;r[45]=62,r[95]=63;function a(C){var A=C.length;if(A%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var M=C.indexOf("=");M===-1&&(M=A);var I=M===A?0:4-M%4;return[M,I]}function l(C){var A=a(C),M=A[0],I=A[1];return(M+I)*3/4-I}function u(C,A,M){return(A+M)*3/4-M}function g(C){var A,M=a(C),I=M[0],L=M[1],k=new n(u(C,I,L)),D=0,z=L>0?I-4:I,B;for(B=0;B<z;B+=4)A=r[C.charCodeAt(B)]<<18|r[C.charCodeAt(B+1)]<<12|r[C.charCodeAt(B+2)]<<6|r[C.charCodeAt(B+3)],k[D++]=A>>16&255,k[D++]=A>>8&255,k[D++]=A&255;return L===2&&(A=r[C.charCodeAt(B)]<<2|r[C.charCodeAt(B+1)]>>4,k[D++]=A&255),L===1&&(A=r[C.charCodeAt(B)]<<10|r[C.charCodeAt(B+1)]<<4|r[C.charCodeAt(B+2)]>>2,k[D++]=A>>8&255,k[D++]=A&255),k}function h(C){return t[C>>18&63]+t[C>>12&63]+t[C>>6&63]+t[C&63]}function v(C,A,M){for(var I,L=[],k=A;k<M;k+=3)I=(C[k]<<16&16711680)+(C[k+1]<<8&65280)+(C[k+2]&255),L.push(h(I));return L.join("")}function R(C){for(var A,M=C.length,I=M%3,L=[],k=16383,D=0,z=M-I;D<z;D+=k)L.push(v(C,D,D+k>z?z:D+k));return I===1?(A=C[M-1],L.push(t[A>>2]+t[A<<4&63]+"==")):I===2&&(A=(C[M-2]<<8)+C[M-1],L.push(t[A>>10]+t[A>>4&63]+t[A<<2&63]+"=")),L.join("")}}),Aa=li(e=>{e.read=function(t,r,n,i,o){var s,a,l=o*8-i-1,u=(1<<l)-1,g=u>>1,h=-7,v=n?o-1:0,R=n?-1:1,C=t[r+v];for(v+=R,s=C&(1<<-h)-1,C>>=-h,h+=l;h>0;s=s*256+t[r+v],v+=R,h-=8);for(a=s&(1<<-h)-1,s>>=-h,h+=i;h>0;a=a*256+t[r+v],v+=R,h-=8);if(s===0)s=1-g;else{if(s===u)return a?NaN:(C?-1:1)*(1/0);a=a+Math.pow(2,i),s=s-g}return(C?-1:1)*a*Math.pow(2,s-i)},e.write=function(t,r,n,i,o,s){var a,l,u,g=s*8-o-1,h=(1<<g)-1,v=h>>1,R=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,C=i?0:s-1,A=i?1:-1,M=r<0||r===0&&1/r<0?1:0;for(r=Math.abs(r),isNaN(r)||r===1/0?(l=isNaN(r)?1:0,a=h):(a=Math.floor(Math.log(r)/Math.LN2),r*(u=Math.pow(2,-a))<1&&(a--,u*=2),a+v>=1?r+=R/u:r+=R*Math.pow(2,1-v),r*u>=2&&(a++,u/=2),a+v>=h?(l=0,a=h):a+v>=1?(l=(r*u-1)*Math.pow(2,o),a=a+v):(l=r*Math.pow(2,v-1)*Math.pow(2,o),a=0));o>=8;t[n+C]=l&255,C+=A,l/=256,o-=8);for(a=a<<o|l,g+=o;g>0;t[n+C]=a&255,C+=A,a/=256,g-=8);t[n+C-A]|=M*128}}),Zr=Ca(),et=Aa(),ii=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;rt.Buffer=T;rt.SlowBuffer=Fa;rt.INSPECT_MAX_BYTES=50;var rr=2147483647;rt.kMaxLength=rr;T.TYPED_ARRAY_SUPPORT=Sa();!T.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Sa(){try{let e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),e.foo()===42}catch{return!1}}Object.defineProperty(T.prototype,"parent",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.buffer}});Object.defineProperty(T.prototype,"offset",{enumerable:!0,get:function(){if(T.isBuffer(this))return this.byteOffset}});function Re(e){if(e>rr)throw new RangeError('The value "'+e+'" is invalid for option "size"');let t=new Uint8Array(e);return Object.setPrototypeOf(t,T.prototype),t}function T(e,t,r){if(typeof e=="number"){if(typeof t=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return tn(e)}return ui(e,t,r)}T.poolSize=8192;function ui(e,t,r){if(typeof e=="string")return ka(e,t);if(ArrayBuffer.isView(e))return Oa(e);if(e==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(he(e,ArrayBuffer)||e&&he(e.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(he(e,SharedArrayBuffer)||e&&he(e.buffer,SharedArrayBuffer)))return pi(e,t,r);if(typeof e=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');let n=e.valueOf&&e.valueOf();if(n!=null&&n!==e)return T.from(n,t,r);let i=Ma(e);if(i)return i;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]=="function")return T.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}T.from=function(e,t,r){return ui(e,t,r)};Object.setPrototypeOf(T.prototype,Uint8Array.prototype);Object.setPrototypeOf(T,Uint8Array);function ci(e){if(typeof e!="number")throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function Ra(e,t,r){return ci(e),e<=0?Re(e):t!==void 0?typeof r=="string"?Re(e).fill(t,r):Re(e).fill(t):Re(e)}T.alloc=function(e,t,r){return Ra(e,t,r)};function tn(e){return ci(e),Re(e<0?0:rn(e)|0)}T.allocUnsafe=function(e){return tn(e)};T.allocUnsafeSlow=function(e){return tn(e)};function ka(e,t){if((typeof t!="string"||t==="")&&(t="utf8"),!T.isEncoding(t))throw new TypeError("Unknown encoding: "+t);let r=di(e,t)|0,n=Re(r),i=n.write(e,t);return i!==r&&(n=n.slice(0,i)),n}function Xr(e){let t=e.length<0?0:rn(e.length)|0,r=Re(t);for(let n=0;n<t;n+=1)r[n]=e[n]&255;return r}function Oa(e){if(he(e,Uint8Array)){let t=new Uint8Array(e);return pi(t.buffer,t.byteOffset,t.byteLength)}return Xr(e)}function pi(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return t===void 0&&r===void 0?n=new Uint8Array(e):r===void 0?n=new Uint8Array(e,t):n=new Uint8Array(e,t,r),Object.setPrototypeOf(n,T.prototype),n}function Ma(e){if(T.isBuffer(e)){let t=rn(e.length)|0,r=Re(t);return r.length===0||e.copy(r,0,0,t),r}if(e.length!==void 0)return typeof e.length!="number"||on(e.length)?Re(0):Xr(e);if(e.type==="Buffer"&&Array.isArray(e.data))return Xr(e.data)}function rn(e){if(e>=rr)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+rr.toString(16)+" bytes");return e|0}function Fa(e){return+e!=e&&(e=0),T.alloc(+e)}T.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==T.prototype};T.compare=function(e,t){if(he(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),he(t,Uint8Array)&&(t=T.from(t,t.offset,t.byteLength)),!T.isBuffer(e)||!T.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0};T.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}};T.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(e.length===0)return T.alloc(0);let r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;let n=T.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){let o=e[r];if(he(o,Uint8Array))i+o.length>n.length?(T.isBuffer(o)||(o=T.from(o)),o.copy(n,i)):Uint8Array.prototype.set.call(n,o,i);else if(T.isBuffer(o))o.copy(n,i);else throw new TypeError('"list" argument must be an Array of Buffers');i+=o.length}return n};function di(e,t){if(T.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||he(e,ArrayBuffer))return e.byteLength;if(typeof e!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);let r=e.length,n=arguments.length>2&&arguments[2]===!0;if(!n&&r===0)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return en(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return r*2;case"hex":return r>>>1;case"base64":return xi(e).length;default:if(i)return n?-1:en(e).length;t=(""+t).toLowerCase(),i=!0}}T.byteLength=di;function Ia(e,t,r){let n=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,t>>>=0,r<=t))return"";for(e||(e="utf8");;)switch(e){case"hex":return Va(this,t,r);case"utf8":case"utf-8":return mi(this,t,r);case"ascii":return Ba(this,t,r);case"latin1":case"binary":return Ua(this,t,r);case"base64":return $a(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Qa(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}T.prototype._isBuffer=!0;function Qe(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}T.prototype.swap16=function(){let e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)Qe(this,t,t+1);return this};T.prototype.swap32=function(){let e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)Qe(this,t,t+3),Qe(this,t+1,t+2);return this};T.prototype.swap64=function(){let e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)Qe(this,t,t+7),Qe(this,t+1,t+6),Qe(this,t+2,t+5),Qe(this,t+3,t+4);return this};T.prototype.toString=function(){let e=this.length;return e===0?"":arguments.length===0?mi(this,0,e):Ia.apply(this,arguments)};T.prototype.toLocaleString=T.prototype.toString;T.prototype.equals=function(e){if(!T.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:T.compare(this,e)===0};T.prototype.inspect=function(){let e="",t=rt.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"};ii&&(T.prototype[ii]=T.prototype.inspect);T.prototype.compare=function(e,t,r,n,i){if(he(e,Uint8Array)&&(e=T.from(e,e.offset,e.byteLength)),!T.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(t===void 0&&(t=0),r===void 0&&(r=e?e.length:0),n===void 0&&(n=0),i===void 0&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;let o=i-n,s=r-t,a=Math.min(o,s),l=this.slice(n,i),u=e.slice(t,r);for(let g=0;g<a;++g)if(l[g]!==u[g]){o=l[g],s=u[g];break}return o<s?-1:s<o?1:0};function fi(e,t,r,n,i){if(e.length===0)return-1;if(typeof r=="string"?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,on(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0)if(i)r=0;else return-1;if(typeof t=="string"&&(t=T.from(t,n)),T.isBuffer(t))return t.length===0?-1:oi(e,t,r,n,i);if(typeof t=="number")return t=t&255,typeof Uint8Array.prototype.indexOf=="function"?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):oi(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function oi(e,t,r,n,i){let o=1,s=e.length,a=t.length;if(n!==void 0&&(n=String(n).toLowerCase(),n==="ucs2"||n==="ucs-2"||n==="utf16le"||n==="utf-16le")){if(e.length<2||t.length<2)return-1;o=2,s/=2,a/=2,r/=2}function l(g,h){return o===1?g[h]:g.readUInt16BE(h*o)}let u;if(i){let g=-1;for(u=r;u<s;u++)if(l(e,u)===l(t,g===-1?0:u-g)){if(g===-1&&(g=u),u-g+1===a)return g*o}else g!==-1&&(u-=u-g),g=-1}else for(r+a>s&&(r=s-a),u=r;u>=0;u--){let g=!0;for(let h=0;h<a;h++)if(l(e,u+h)!==l(t,h)){g=!1;break}if(g)return u}return-1}T.prototype.includes=function(e,t,r){return this.indexOf(e,t,r)!==-1};T.prototype.indexOf=function(e,t,r){return fi(this,e,t,r,!0)};T.prototype.lastIndexOf=function(e,t,r){return fi(this,e,t,r,!1)};function _a(e,t,r,n){r=Number(r)||0;let i=e.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;let o=t.length;n>o/2&&(n=o/2);let s;for(s=0;s<n;++s){let a=parseInt(t.substr(s*2,2),16);if(on(a))return s;e[r+s]=a}return s}function La(e,t,r,n){return nr(en(t,e.length-r),e,r,n)}function Na(e,t,r,n){return nr(Ka(t),e,r,n)}function Da(e,t,r,n){return nr(xi(t),e,r,n)}function qa(e,t,r,n){return nr(Ha(t,e.length-r),e,r,n)}T.prototype.write=function(e,t,r,n){if(t===void 0)n="utf8",r=this.length,t=0;else if(r===void 0&&typeof t=="string")n=t,r=this.length,t=0;else if(isFinite(t))t=t>>>0,isFinite(r)?(r=r>>>0,n===void 0&&(n="utf8")):(n=r,r=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let i=this.length-t;if((r===void 0||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return _a(this,e,t,r);case"utf8":case"utf-8":return La(this,e,t,r);case"ascii":case"latin1":case"binary":return Na(this,e,t,r);case"base64":return Da(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return qa(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}};T.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function $a(e,t,r){return t===0&&r===e.length?Zr.fromByteArray(e):Zr.fromByteArray(e.slice(t,r))}function mi(e,t,r){r=Math.min(e.length,r);let n=[],i=t;for(;i<r;){let o=e[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(i+a<=r){let l,u,g,h;switch(a){case 1:o<128&&(s=o);break;case 2:l=e[i+1],(l&192)===128&&(h=(o&31)<<6|l&63,h>127&&(s=h));break;case 3:l=e[i+1],u=e[i+2],(l&192)===128&&(u&192)===128&&(h=(o&15)<<12|(l&63)<<6|u&63,h>2047&&(h<55296||h>57343)&&(s=h));break;case 4:l=e[i+1],u=e[i+2],g=e[i+3],(l&192)===128&&(u&192)===128&&(g&192)===128&&(h=(o&15)<<18|(l&63)<<12|(u&63)<<6|g&63,h>65535&&h<1114112&&(s=h))}}s===null?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),i+=a}return ja(n)}var si=4096;function ja(e){let t=e.length;if(t<=si)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=si));return r}function Ba(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]&127);return n}function Ua(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function Va(e,t,r){let n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let i="";for(let o=t;o<r;++o)i+=za[e[o]];return i}function Qa(e,t,r){let n=e.slice(t,r),i="";for(let o=0;o<n.length-1;o+=2)i+=String.fromCharCode(n[o]+n[o+1]*256);return i}T.prototype.slice=function(e,t){let r=this.length;e=~~e,t=t===void 0?r:~~t,e<0?(e+=r,e<0&&(e=0)):e>r&&(e=r),t<0?(t+=r,t<0&&(t=0)):t>r&&(t=r),t<e&&(t=e);let n=this.subarray(e,t);return Object.setPrototypeOf(n,T.prototype),n};function W(e,t,r){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}T.prototype.readUintLE=T.prototype.readUIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return n};T.prototype.readUintBE=T.prototype.readUIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e+--t],i=1;for(;t>0&&(i*=256);)n+=this[e+--t]*i;return n};T.prototype.readUint8=T.prototype.readUInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]};T.prototype.readUint16LE=T.prototype.readUInt16LE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]|this[e+1]<<8};T.prototype.readUint16BE=T.prototype.readUInt16BE=function(e,t){return e=e>>>0,t||W(e,2,this.length),this[e]<<8|this[e+1]};T.prototype.readUint32LE=T.prototype.readUInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};T.prototype.readUint32BE=T.prototype.readUInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};T.prototype.readBigUInt64LE=Le(function(e){e=e>>>0,tt(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&Tt(e,this.length-8);let n=t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,i=this[++e]+this[++e]*2**8+this[++e]*2**16+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))});T.prototype.readBigUInt64BE=Le(function(e){e=e>>>0,tt(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&Tt(e,this.length-8);let n=t*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],i=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r;return(BigInt(n)<<BigInt(32))+BigInt(i)});T.prototype.readIntLE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n};T.prototype.readIntBE=function(e,t,r){e=e>>>0,t=t>>>0,r||W(e,t,this.length);let n=t,i=1,o=this[e+--n];for(;n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o};T.prototype.readInt8=function(e,t){return e=e>>>0,t||W(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]};T.prototype.readInt16LE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e]|this[e+1]<<8;return r&32768?r|4294901760:r};T.prototype.readInt16BE=function(e,t){e=e>>>0,t||W(e,2,this.length);let r=this[e+1]|this[e]<<8;return r&32768?r|4294901760:r};T.prototype.readInt32LE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};T.prototype.readInt32BE=function(e,t){return e=e>>>0,t||W(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};T.prototype.readBigInt64LE=Le(function(e){e=e>>>0,tt(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&Tt(e,this.length-8);let n=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)});T.prototype.readBigInt64BE=Le(function(e){e=e>>>0,tt(e,"offset");let t=this[e],r=this[e+7];(t===void 0||r===void 0)&&Tt(e,this.length-8);let n=(t<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r)});T.prototype.readFloatLE=function(e,t){return e=e>>>0,t||W(e,4,this.length),et.read(this,e,!0,23,4)};T.prototype.readFloatBE=function(e,t){return e=e>>>0,t||W(e,4,this.length),et.read(this,e,!1,23,4)};T.prototype.readDoubleLE=function(e,t){return e=e>>>0,t||W(e,8,this.length),et.read(this,e,!0,52,8)};T.prototype.readDoubleBE=function(e,t){return e=e>>>0,t||W(e,8,this.length),et.read(this,e,!1,52,8)};function ie(e,t,r,n,i,o){if(!T.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}T.prototype.writeUintLE=T.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;ie(this,e,t,r,s,0)}let i=1,o=0;for(this[t]=e&255;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r};T.prototype.writeUintBE=T.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,r=r>>>0,!n){let s=Math.pow(2,8*r)-1;ie(this,e,t,r,s,0)}let i=r-1,o=1;for(this[t+i]=e&255;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r};T.prototype.writeUint8=T.prototype.writeUInt8=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,1,255,0),this[t]=e&255,t+1};T.prototype.writeUint16LE=T.prototype.writeUInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,2,65535,0),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeUint16BE=T.prototype.writeUInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeUint32LE=T.prototype.writeUInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=e&255,t+4};T.prototype.writeUint32BE=T.prototype.writeUInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};function gi(e,t,r,n,i){Ei(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o,o=o>>8,e[r++]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,s=s>>8,e[r++]=s,r}function hi(e,t,r,n,i){Ei(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r+7]=o,o=o>>8,e[r+6]=o,o=o>>8,e[r+5]=o,o=o>>8,e[r+4]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=s,s=s>>8,e[r+2]=s,s=s>>8,e[r+1]=s,s=s>>8,e[r]=s,r+8}T.prototype.writeBigUInt64LE=Le(function(e,t=0){return gi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeBigUInt64BE=Le(function(e,t=0){return hi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))});T.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);ie(this,e,t,r,a-1,-a)}let i=0,o=1,s=0;for(this[t]=e&255;++i<r&&(o*=256);)e<0&&s===0&&this[t+i-1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t=t>>>0,!n){let a=Math.pow(2,8*r-1);ie(this,e,t,r,a-1,-a)}let i=r-1,o=1,s=0;for(this[t+i]=e&255;--i>=0&&(o*=256);)e<0&&s===0&&this[t+i+1]!==0&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r};T.prototype.writeInt8=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=e&255,t+1};T.prototype.writeInt16LE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,2,32767,-32768),this[t]=e&255,this[t+1]=e>>>8,t+2};T.prototype.writeInt16BE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=e&255,t+2};T.prototype.writeInt32LE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,4,2147483647,-2147483648),this[t]=e&255,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4};T.prototype.writeInt32BE=function(e,t,r){return e=+e,t=t>>>0,r||ie(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=e&255,t+4};T.prototype.writeBigInt64LE=Le(function(e,t=0){return gi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});T.prototype.writeBigInt64BE=Le(function(e,t=0){return hi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function yi(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function wi(e,t,r,n,i){return t=+t,r=r>>>0,i||yi(e,t,r,4,34028234663852886e22,-34028234663852886e22),et.write(e,t,r,n,23,4),r+4}T.prototype.writeFloatLE=function(e,t,r){return wi(this,e,t,!0,r)};T.prototype.writeFloatBE=function(e,t,r){return wi(this,e,t,!1,r)};function bi(e,t,r,n,i){return t=+t,r=r>>>0,i||yi(e,t,r,8,17976931348623157e292,-17976931348623157e292),et.write(e,t,r,n,52,8),r+8}T.prototype.writeDoubleLE=function(e,t,r){return bi(this,e,t,!0,r)};T.prototype.writeDoubleBE=function(e,t,r){return bi(this,e,t,!1,r)};T.prototype.copy=function(e,t,r,n){if(!T.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),!n&&n!==0&&(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r||e.length===0||this.length===0)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);let i=n-r;return this===e&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i};T.prototype.fill=function(e,t,r,n){if(typeof e=="string"){if(typeof t=="string"?(n=t,t=0,r=this.length):typeof r=="string"&&(n=r,r=this.length),n!==void 0&&typeof n!="string")throw new TypeError("encoding must be a string");if(typeof n=="string"&&!T.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(e.length===1){let o=e.charCodeAt(0);(n==="utf8"&&o<128||n==="latin1")&&(e=o)}}else typeof e=="number"?e=e&255:typeof e=="boolean"&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;t=t>>>0,r=r===void 0?this.length:r>>>0,e||(e=0);let i;if(typeof e=="number")for(i=t;i<r;++i)this[i]=e;else{let o=T.isBuffer(e)?e:T.from(e,n),s=o.length;if(s===0)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<r-t;++i)this[i+t]=o[i%s]}return this};var Xe={};function nn(e,t,r){Xe[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(n){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:n,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}nn("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError);nn("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError);nn("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=ai(String(r)):typeof r=="bigint"&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=ai(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n},RangeError);function ai(e){let t="",r=e.length,n=e[0]==="-"?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function Ga(e,t,r){tt(t,"offset"),(e[t]===void 0||e[t+r]===void 0)&&Tt(t,e.length-(r+1))}function Ei(e,t,r,n,i,o){if(e>r||e<t){let s=typeof t=="bigint"?"n":"",a;throw o>3?t===0||t===BigInt(0)?a=`>= 0${s} and < 2${s} ** ${(o+1)*8}${s}`:a=`>= -(2${s} ** ${(o+1)*8-1}${s}) and < 2 ** ${(o+1)*8-1}${s}`:a=`>= ${t}${s} and <= ${r}${s}`,new Xe.ERR_OUT_OF_RANGE("value",a,e)}Ga(n,i,o)}function tt(e,t){if(typeof e!="number")throw new Xe.ERR_INVALID_ARG_TYPE(t,"number",e)}function Tt(e,t,r){throw Math.floor(e)!==e?(tt(e,r),new Xe.ERR_OUT_OF_RANGE(r||"offset","an integer",e)):t<0?new Xe.ERR_BUFFER_OUT_OF_BOUNDS:new Xe.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}var Ja=/[^+/0-9A-Za-z-_]/g;function Wa(e){if(e=e.split("=")[0],e=e.trim().replace(Ja,""),e.length<2)return"";for(;e.length%4!==0;)e=e+"=";return e}function en(e,t){t=t||1/0;let r,n=e.length,i=null,o=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return o}function Ka(e){let t=[];for(let r=0;r<e.length;++r)t.push(e.charCodeAt(r)&255);return t}function Ha(e,t){let r,n,i,o=[];for(let s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function xi(e){return Zr.toByteArray(Wa(e))}function nr(e,t,r,n){let i;for(i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function he(e,t){return e instanceof t||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===t.name}function on(e){return e!==e}var za=function(){let e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){let n=r*16;for(let i=0;i<16;++i)t[n+i]=e[r]+e[i]}return t}();function Le(e){return typeof BigInt>"u"?Ya:e}function Ya(){throw new Error("BigInt not supported")}});var w,m=ge(()=>{"use strict";w=Se(Pi())});function bl(){return!1}function Li(){return{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}function El(){return Li()}function xl(){return[]}function Pl(e){e(null,[])}function vl(){return""}function Tl(){return""}function Cl(){}function Al(){}function Sl(){}function Rl(){}function kl(){}function Ol(){}var Ml,Fl,or,cn=ge(()=>{"use strict";m();c();p();d();f();Ml={},Fl={existsSync:bl,lstatSync:Li,statSync:El,readdirSync:xl,readdir:Pl,readlinkSync:vl,realpathSync:Tl,chmodSync:Cl,renameSync:Al,mkdirSync:Sl,rmdirSync:Rl,rmSync:kl,unlinkSync:Ol,promises:Ml},or=Fl});function Il(...e){return e.join("/")}function _l(...e){return e.join("/")}function Ll(e){let t=Ni(e),r=Di(e),[n,i]=t.split(".");return{root:"/",dir:r,base:t,ext:i,name:n}}function Ni(e){let t=e.split("/");return t[t.length-1]}function Di(e){return e.split("/").slice(0,-1).join("/")}var qi,Nl,Dl,Oe,dn=ge(()=>{"use strict";m();c();p();d();f();qi="/",Nl={sep:qi},Dl={basename:Ni,dirname:Di,join:_l,parse:Ll,posix:Nl,resolve:Il,sep:qi},Oe=Dl});var $i=Ae((Ff,ql)=>{ql.exports={name:"@prisma/internals",version:"6.6.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.4.7",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-engine-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Ui=Ae((Gf,Bi)=>{"use strict";m();c();p();d();f();Bi.exports=e=>{let t=e.match(/^[ \t]*(?=\S)/gm);return t?t.reduce((r,n)=>Math.min(r,n.length),1/0):0}});var Wi=Ae((um,Ji)=>{"use strict";m();c();p();d();f();Ji.exports=(e,t=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof t!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(t===0)return e;let n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,r.indent.repeat(t))}});var zi=Ae((xm,Hi)=>{"use strict";m();c();p();d();f();Hi.exports=({onlyFirst:e=!1}={})=>{let t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(t,e?void 0:"g")}});var yn=Ae((Sm,Yi)=>{"use strict";m();c();p();d();f();var Gl=zi();Yi.exports=e=>typeof e=="string"?e.replace(Gl(),""):e});var Zi=Ae((Zm,ar)=>{"use strict";m();c();p();d();f();ar.exports=(e={})=>{let t;if(e.repoUrl)t=e.repoUrl;else if(e.user&&e.repo)t=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let r=new URL(`${t}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"];for(let i of n){let o=e[i];if(o!==void 0){if(i==="labels"||i==="projects"){if(!Array.isArray(o))throw new TypeError(`The \`${i}\` option should be an array`);o=o.join(",")}r.searchParams.set(i,o)}}return r.toString()};ar.exports.default=ar.exports});var Sn=Ae((xb,Po)=>{"use strict";m();c();p();d();f();Po.exports=function(){function e(t,r,n,i,o){return t<r||n<r?t>n?n+1:t+1:i===o?r:r+1}return function(t,r){if(t===r)return 0;if(t.length>r.length){var n=t;t=r,r=n}for(var i=t.length,o=r.length;i>0&&t.charCodeAt(i-1)===r.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&t.charCodeAt(s)===r.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,l,u,g,h,v,R,C,A,M,I,L,k,D=[];for(l=0;l<i;l++)D.push(l+1),D.push(t.charCodeAt(s+l));for(var z=D.length-1;a<o-3;)for(M=r.charCodeAt(s+(u=a)),I=r.charCodeAt(s+(g=a+1)),L=r.charCodeAt(s+(h=a+2)),k=r.charCodeAt(s+(v=a+3)),R=a+=4,l=0;l<z;l+=2)C=D[l],A=D[l+1],u=e(C,u,g,M,A),g=e(u,g,h,I,A),h=e(g,h,v,L,A),R=e(h,v,R,k,A),D[l]=R,v=h,h=g,g=u,u=C;for(;a<o;)for(M=r.charCodeAt(s+(u=a)),R=++a,l=0;l<z;l+=2)C=D[l],D[l]=R=e(C,u,R,M,D[l+1]),u=C;return R}}()});var So=ge(()=>{"use strict";m();c();p();d();f()});var Ro=ge(()=>{"use strict";m();c();p();d();f()});var Zo=Ae((VP,Dc)=>{Dc.exports={name:"@prisma/engines-version",version:"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"f676762280b54cd07c770017ed3711ddde35f37a"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var Nr,Xo=ge(()=>{"use strict";m();c();p();d();f();Nr=class{events={};on(t,r){return this.events[t]||(this.events[t]=[]),this.events[t].push(r),this}emit(t,...r){return this.events[t]?(this.events[t].forEach(n=>{n(...r)}),!0):!1}}});var rd={};Ze(rd,{DMMF:()=>Dt,Debug:()=>K,Decimal:()=>be,Extensions:()=>sn,MetricsClient:()=>wt,PrismaClientInitializationError:()=>V,PrismaClientKnownRequestError:()=>oe,PrismaClientRustPanicError:()=>ue,PrismaClientUnknownRequestError:()=>G,PrismaClientValidationError:()=>ee,Public:()=>an,Sql:()=>ae,createParam:()=>Qo,defineDmmfProperty:()=>zo,deserializeJsonResponse:()=>at,deserializeRawResult:()=>Hr,dmmfToRuntimeDataModel:()=>yo,empty:()=>ts,getPrismaClient:()=>ha,getRuntime:()=>Fs,join:()=>es,makeStrictEnum:()=>ya,makeTypedQueryFactory:()=>Yo,objectEnumValues:()=>Ar,raw:()=>Nn,serializeJsonQuery:()=>Ir,skip:()=>Fr,sqltag:()=>Dn,warnEnvConflicts:()=>void 0,warnOnce:()=>_t});module.exports=Ta(rd);m();c();p();d();f();var sn={};Ze(sn,{defineExtension:()=>vi,getExtensionContext:()=>Ti});m();c();p();d();f();m();c();p();d();f();function vi(e){return typeof e=="function"?e:t=>t.$extends(e)}m();c();p();d();f();function Ti(e){return e}var an={};Ze(an,{validator:()=>Ci});m();c();p();d();f();m();c();p();d();f();function Ci(...e){return t=>t}m();c();p();d();f();m();c();p();d();f();var ir={};Ze(ir,{$:()=>Oi,bgBlack:()=>al,bgBlue:()=>pl,bgCyan:()=>fl,bgGreen:()=>ul,bgMagenta:()=>dl,bgRed:()=>ll,bgWhite:()=>ml,bgYellow:()=>cl,black:()=>nl,blue:()=>Je,bold:()=>pe,cyan:()=>ke,dim:()=>Ct,gray:()=>kt,green:()=>St,grey:()=>sl,hidden:()=>tl,inverse:()=>el,italic:()=>Xa,magenta:()=>il,red:()=>Ge,reset:()=>Za,strikethrough:()=>rl,underline:()=>At,white:()=>ol,yellow:()=>Rt});m();c();p();d();f();var ln,Ai,Si,Ri,ki=!0;typeof y<"u"&&({FORCE_COLOR:ln,NODE_DISABLE_COLORS:Ai,NO_COLOR:Si,TERM:Ri}=y.env||{},ki=y.stdout&&y.stdout.isTTY);var Oi={enabled:!Ai&&Si==null&&Ri!=="dumb"&&(ln!=null&&ln!=="0"||ki)};function U(e,t){let r=new RegExp(`\\x1b\\[${t}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${t}m`;return function(o){return!Oi.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}}var Za=U(0,0),pe=U(1,22),Ct=U(2,22),Xa=U(3,23),At=U(4,24),el=U(7,27),tl=U(8,28),rl=U(9,29),nl=U(30,39),Ge=U(31,39),St=U(32,39),Rt=U(33,39),Je=U(34,39),il=U(35,39),ke=U(36,39),ol=U(37,39),kt=U(90,39),sl=U(90,39),al=U(40,49),ll=U(41,49),ul=U(42,49),cl=U(43,49),pl=U(44,49),dl=U(45,49),fl=U(46,49),ml=U(47,49);m();c();p();d();f();var gl=100,Mi=["green","yellow","blue","magenta","cyan","red"],Ot=[],Fi=Date.now(),hl=0,un=typeof y<"u"?y.env:{};globalThis.DEBUG??=un.DEBUG??"";globalThis.DEBUG_COLORS??=un.DEBUG_COLORS?un.DEBUG_COLORS==="true":!0;var Mt={enable(e){typeof e=="string"&&(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},enabled(e){let t=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),r=t.some(i=>i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n=t.some(i=>i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return r&&!n},log:(...e)=>{let[t,r,...n]=e;(console.warn??console.log)(`${t} ${r}`,...n)},formatters:{}};function yl(e){let t={color:Mi[hl++%Mi.length],enabled:Mt.enabled(e),namespace:e,log:Mt.log,extend:()=>{}},r=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=t;if(n.length!==0&&Ot.push([o,...n]),Ot.length>gl&&Ot.shift(),Mt.enabled(o)||i){let l=n.map(g=>typeof g=="string"?g:wl(g)),u=`+${Date.now()-Fi}ms`;Fi=Date.now(),globalThis.DEBUG_COLORS?a(ir[s](pe(o)),...l,ir[s](u)):a(o,...l,u)}};return new Proxy(r,{get:(n,i)=>t[i],set:(n,i,o)=>t[i]=o})}var K=new Proxy(yl,{get:(e,t)=>Mt[t],set:(e,t,r)=>Mt[t]=r});function wl(e,t=2){let r=new Set;return JSON.stringify(e,(n,i)=>{if(typeof i=="object"&&i!==null){if(r.has(i))return"[Circular *]";r.add(i)}else if(typeof i=="bigint")return i.toString();return i},t)}function Ii(e=7500){let t=Ot.map(([r,...n])=>`${r} ${n.map(i=>typeof i=="string"?i:JSON.stringify(i)).join(" ")}`).join(`
`);return t.length<e?t:t.slice(-e)}function _i(){Ot.length=0}m();c();p();d();f();m();c();p();d();f();var pn=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];m();c();p();d();f();var $l=$i(),fn=$l.version;m();c();p();d();f();var ji="library";function nt(e){let t=jl();return t||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":ji)}function jl(){let e=y.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}m();c();p();d();f();var Vi=Se(Ui(),1);function mn(e){let t=(0,Vi.default)(e);if(t===0)return e;let r=new RegExp(`^[ \\t]{${t}}`,"gm");return e.replace(r,"")}m();c();p();d();f();var Qi="prisma+postgres",Gi=`${Qi}:`;function gn(e){return e?.startsWith(`${Gi}//`)??!1}var It={};Ze(It,{error:()=>Vl,info:()=>Ul,log:()=>Bl,query:()=>Ql,should:()=>Ki,tags:()=>Ft,warn:()=>hn});m();c();p();d();f();var Ft={error:Ge("prisma:error"),warn:Rt("prisma:warn"),info:ke("prisma:info"),query:Je("prisma:query")},Ki={warn:()=>!y.env.PRISMA_DISABLE_WARNINGS};function Bl(...e){console.log(...e)}function hn(e,...t){Ki.warn()&&console.warn(`${Ft.warn} ${e}`,...t)}function Ul(e,...t){console.info(`${Ft.info} ${e}`,...t)}function Vl(e,...t){console.error(`${Ft.error} ${e}`,...t)}function Ql(e,...t){console.log(`${Ft.query} ${e}`,...t)}m();c();p();d();f();function sr(e,t){if(!e)throw new Error(`${t}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}m();c();p();d();f();function Me(e,t){throw new Error(t)}m();c();p();d();f();dn();function wn(e){return Oe.sep===Oe.posix.sep?e:e.split(Oe.sep).join(Oe.posix.sep)}m();c();p();d();f();function bn(e,t){return Object.prototype.hasOwnProperty.call(e,t)}m();c();p();d();f();function it(e,t){let r={};for(let n of Object.keys(e))r[n]=t(e[n],n);return r}m();c();p();d();f();function En(e,t){if(e.length===0)return;let r=e[0];for(let n=1;n<e.length;n++)t(r,e[n])<0&&(r=e[n]);return r}m();c();p();d();f();function le(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}m();c();p();d();f();var Xi=new Set,_t=(e,t,...r)=>{Xi.has(e)||(Xi.add(e),hn(t,...r))};var V=class e extends Error{clientVersion;errorCode;retryable;constructor(t,r,n){super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};le(V,"PrismaClientInitializationError");m();c();p();d();f();var oe=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};le(oe,"PrismaClientKnownRequestError");m();c();p();d();f();var ue=class extends Error{clientVersion;constructor(t,r){super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};le(ue,"PrismaClientRustPanicError");m();c();p();d();f();var G=class extends Error{clientVersion;batchRequestIdx;constructor(t,{clientVersion:r,batchRequestIdx:n}){super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};le(G,"PrismaClientUnknownRequestError");m();c();p();d();f();var ee=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(t,{clientVersion:r}){super(t),this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};le(ee,"PrismaClientValidationError");m();c();p();d();f();m();c();p();d();f();var ot=9e15,$e=1e9,xn="0123456789abcdef",cr="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",pr="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Pn={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-ot,maxE:ot,crypto:!1},io,Fe,_=!0,fr="[DecimalError] ",qe=fr+"Invalid argument: ",oo=fr+"Precision limit exceeded",so=fr+"crypto unavailable",ao="[object Decimal]",te=Math.floor,J=Math.pow,Jl=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Wl=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Kl=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,lo=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,de=1e7,F=7,Hl=9007199254740991,zl=cr.length-1,vn=pr.length-1,S={toStringTag:ao};S.absoluteValue=S.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),O(e)};S.ceil=function(){return O(new this.constructor(this),this.e+1,2)};S.clampedTo=S.clamp=function(e,t){var r,n=this,i=n.constructor;if(e=new i(e),t=new i(t),!e.s||!t.s)return new i(NaN);if(e.gt(t))throw Error(qe+t);return r=n.cmp(e),r<0?e:n.cmp(t)>0?t:new i(n)};S.comparedTo=S.cmp=function(e){var t,r,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?NaN:l!==u?l:s===a?0:!s^l<0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e>e.e^l<0?1:-1;for(n=s.length,i=a.length,t=0,r=n<i?n:i;t<r;++t)if(s[t]!==a[t])return s[t]>a[t]^l<0?1:-1;return n===i?0:n>i^l<0?1:-1};S.cosine=S.cos=function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+F,n.rounding=1,r=Yl(n,mo(n,r)),n.precision=e,n.rounding=t,O(Fe==2||Fe==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)};S.cubeRoot=S.cbrt=function(){var e,t,r,n,i,o,s,a,l,u,g=this,h=g.constructor;if(!g.isFinite()||g.isZero())return new h(g);for(_=!1,o=g.s*J(g.s*g,1/3),!o||Math.abs(o)==1/0?(r=Y(g.d),e=g.e,(o=(e-r.length+1)%3)&&(r+=o==1||o==-2?"0":"00"),o=J(r,1/3),e=te((e+1)/3)-(e%3==(e<0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new h(r),n.s=g.s):n=new h(o.toString()),s=(e=h.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.plus(g),n=j(u.plus(g).times(a),u.plus(l),s+2,1),Y(a.d).slice(0,s)===(r=Y(n.d)).slice(0,s))if(r=r.slice(s-3,s+1),r=="9999"||!i&&r=="4999"){if(!i&&(O(a,e+1,0),a.times(a).times(a).eq(g))){n=a;break}s+=4,i=1}else{(!+r||!+r.slice(1)&&r.charAt(0)=="5")&&(O(n,e+1,1),t=!n.times(n).times(n).eq(g));break}return _=!0,O(n,e,h.rounding,t)};S.decimalPlaces=S.dp=function(){var e,t=this.d,r=NaN;if(t){if(e=t.length-1,r=(e-te(this.e/F))*F,e=t[e],e)for(;e%10==0;e/=10)r--;r<0&&(r=0)}return r};S.dividedBy=S.div=function(e){return j(this,new this.constructor(e))};S.dividedToIntegerBy=S.divToInt=function(e){var t=this,r=t.constructor;return O(j(t,new r(e),0,1,1),r.precision,r.rounding)};S.equals=S.eq=function(e){return this.cmp(e)===0};S.floor=function(){return O(new this.constructor(this),this.e+1,3)};S.greaterThan=S.gt=function(e){return this.cmp(e)>0};S.greaterThanOrEqualTo=S.gte=function(e){var t=this.cmp(e);return t==1||t===0};S.hyperbolicCosine=S.cosh=function(){var e,t,r,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;r=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i<32?(e=Math.ceil(i/3),t=(1/gr(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=st(s,1,o.times(t),new s(1),!0);for(var l,u=e,g=new s(8);u--;)l=o.times(o),o=a.minus(l.times(g.minus(l.times(g))));return O(o,s.precision=r,s.rounding=n,!0)};S.hyperbolicSine=S.sinh=function(){var e,t,r,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n<3)i=st(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e>16?16:e|0,i=i.times(1/gr(5,e)),i=st(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=t,o.rounding=r,O(i,t,r,!0)};S.hyperbolicTangent=S.tanh=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,j(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)};S.inverseCosine=S.acos=function(){var e=this,t=e.constructor,r=e.abs().cmp(1),n=t.precision,i=t.rounding;return r!==-1?r===0?e.isNeg()?ye(t,n,i):new t(0):new t(NaN):e.isZero()?ye(t,n+4,i).times(.5):(t.precision=n+6,t.rounding=1,e=new t(1).minus(e).div(e.plus(1)).sqrt().atan(),t.precision=n,t.rounding=i,e.times(2))};S.inverseHyperbolicCosine=S.acosh=function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,_=!1,r=r.times(r).minus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)};S.inverseHyperbolicSine=S.asinh=function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,_=!1,r=r.times(r).plus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln())};S.inverseHyperbolicTangent=S.atanh=function(){var e,t,r,n,i=this,o=i.constructor;return i.isFinite()?i.e>=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?O(new o(i),e,t,!0):(o.precision=r=n-i.e,i=j(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)};S.inverseSine=S.asin=function(){var e,t,r,n,i=this,o=i.constructor;return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=ye(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))};S.inverseTangent=S.atan=function(){var e,t,r,n,i,o,s,a,l,u=this,g=u.constructor,h=g.precision,v=g.rounding;if(u.isFinite()){if(u.isZero())return new g(u);if(u.abs().eq(1)&&h+4<=vn)return s=ye(g,h+4,v).times(.25),s.s=u.s,s}else{if(!u.s)return new g(NaN);if(h+4<=vn)return s=ye(g,h+4,v).times(.5),s.s=u.s,s}for(g.precision=a=h+10,g.rounding=1,r=Math.min(28,a/F+2|0),e=r;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(_=!1,t=Math.ceil(a/F),n=1,l=u.times(u),s=new g(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)for(e=t;s.d[e]===o.d[e]&&e--;);return r&&(s=s.times(2<<r-1)),_=!0,O(s,g.precision=h,g.rounding=v,!0)};S.isFinite=function(){return!!this.d};S.isInteger=S.isInt=function(){return!!this.d&&te(this.e/F)>this.d.length-2};S.isNaN=function(){return!this.s};S.isNegative=S.isNeg=function(){return this.s<0};S.isPositive=S.isPos=function(){return this.s>0};S.isZero=function(){return!!this.d&&this.d[0]===0};S.lessThan=S.lt=function(e){return this.cmp(e)<0};S.lessThanOrEqualTo=S.lte=function(e){return this.cmp(e)<1};S.logarithm=S.log=function(e){var t,r,n,i,o,s,a,l,u=this,g=u.constructor,h=g.precision,v=g.rounding,R=5;if(e==null)e=new g(10),t=!0;else{if(e=new g(e),r=e.d,e.s<0||!r||!r[0]||e.eq(1))return new g(NaN);t=e.eq(10)}if(r=u.d,u.s<0||!r||!r[0]||u.eq(1))return new g(r&&!r[0]?-1/0:u.s!=1?NaN:r?0:1/0);if(t)if(r.length>1)o=!0;else{for(i=r[0];i%10===0;)i/=10;o=i!==1}if(_=!1,a=h+R,s=De(u,a),n=t?dr(g,a+10):De(e,a),l=j(s,n,a,1),Lt(l.d,i=h,v))do if(a+=10,s=De(u,a),n=t?dr(g,a+10):De(e,a),l=j(s,n,a,1),!o){+Y(l.d).slice(i+1,i+15)+1==1e14&&(l=O(l,h+1,0));break}while(Lt(l.d,i+=10,v));return _=!0,O(l,h,v)};S.minus=S.sub=function(e){var t,r,n,i,o,s,a,l,u,g,h,v,R=this,C=R.constructor;if(e=new C(e),!R.d||!e.d)return!R.s||!e.s?e=new C(NaN):R.d?e.s=-e.s:e=new C(e.d||R.s!==e.s?R:NaN),e;if(R.s!=e.s)return e.s=-e.s,R.plus(e);if(u=R.d,v=e.d,a=C.precision,l=C.rounding,!u[0]||!v[0]){if(v[0])e.s=-e.s;else if(u[0])e=new C(R);else return new C(l===3?-0:0);return _?O(e,a,l):e}if(r=te(e.e/F),g=te(R.e/F),u=u.slice(),o=g-r,o){for(h=o<0,h?(t=u,o=-o,s=v.length):(t=v,r=g,s=u.length),n=Math.max(Math.ceil(a/F),s)+2,o>n&&(o=n,t.length=1),t.reverse(),n=o;n--;)t.push(0);t.reverse()}else{for(n=u.length,s=v.length,h=n<s,h&&(s=n),n=0;n<s;n++)if(u[n]!=v[n]){h=u[n]<v[n];break}o=0}for(h&&(t=u,u=v,v=t,e.s=-e.s),s=u.length,n=v.length-s;n>0;--n)u[s++]=0;for(n=v.length;n>o;){if(u[--n]<v[n]){for(i=n;i&&u[--i]===0;)u[i]=de-1;--u[i],u[n]+=de}u[n]-=v[n]}for(;u[--s]===0;)u.pop();for(;u[0]===0;u.shift())--r;return u[0]?(e.d=u,e.e=mr(u,r),_?O(e,a,l):e):new C(l===3?-0:0)};S.modulo=S.mod=function(e){var t,r=this,n=r.constructor;return e=new n(e),!r.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||r.d&&!r.d[0]?O(new n(r),n.precision,n.rounding):(_=!1,n.modulo==9?(t=j(r,e.abs(),0,3,1),t.s*=e.s):t=j(r,e,0,n.modulo,1),t=t.times(e),_=!0,r.minus(t))};S.naturalExponential=S.exp=function(){return Tn(this)};S.naturalLogarithm=S.ln=function(){return De(this)};S.negated=S.neg=function(){var e=new this.constructor(this);return e.s=-e.s,O(e)};S.plus=S.add=function(e){var t,r,n,i,o,s,a,l,u,g,h=this,v=h.constructor;if(e=new v(e),!h.d||!e.d)return!h.s||!e.s?e=new v(NaN):h.d||(e=new v(e.d||h.s===e.s?h:NaN)),e;if(h.s!=e.s)return e.s=-e.s,h.minus(e);if(u=h.d,g=e.d,a=v.precision,l=v.rounding,!u[0]||!g[0])return g[0]||(e=new v(h)),_?O(e,a,l):e;if(o=te(h.e/F),n=te(e.e/F),u=u.slice(),i=o-n,i){for(i<0?(r=u,i=-i,s=g.length):(r=g,n=o,s=u.length),o=Math.ceil(a/F),s=o>s?o+1:s+1,i>s&&(i=s,r.length=1),r.reverse();i--;)r.push(0);r.reverse()}for(s=u.length,i=g.length,s-i<0&&(i=s,r=g,g=u,u=r),t=0;i;)t=(u[--i]=u[i]+g[i]+t)/de|0,u[i]%=de;for(t&&(u.unshift(t),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=mr(u,n),_?O(e,a,l):e};S.precision=S.sd=function(e){var t,r=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error(qe+e);return r.d?(t=uo(r.d),e&&r.e+1>t&&(t=r.e+1)):t=NaN,t};S.round=function(){var e=this,t=e.constructor;return O(new t(e),e.e+1,t.rounding)};S.sine=S.sin=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+F,n.rounding=1,r=Xl(n,mo(n,r)),n.precision=e,n.rounding=t,O(Fe>2?r.neg():r,e,t,!0)):new n(NaN)};S.squareRoot=S.sqrt=function(){var e,t,r,n,i,o,s=this,a=s.d,l=s.e,u=s.s,g=s.constructor;if(u!==1||!a||!a[0])return new g(!u||u<0&&(!a||a[0])?NaN:a?s:1/0);for(_=!1,u=Math.sqrt(+s),u==0||u==1/0?(t=Y(a),(t.length+l)%2==0&&(t+="0"),u=Math.sqrt(t),l=te((l+1)/2)-(l<0||l%2),u==1/0?t="5e"+l:(t=u.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new g(t)):n=new g(u.toString()),r=(l=g.precision)+3;;)if(o=n,n=o.plus(j(s,o,r+2,1)).times(.5),Y(o.d).slice(0,r)===(t=Y(n.d)).slice(0,r))if(t=t.slice(r-3,r+1),t=="9999"||!i&&t=="4999"){if(!i&&(O(o,l+1,0),o.times(o).eq(s))){n=o;break}r+=4,i=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(O(n,l+1,1),e=!n.times(n).eq(s));break}return _=!0,O(n,l,g.rounding,e)};S.tangent=S.tan=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=j(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,O(Fe==2||Fe==4?r.neg():r,e,t,!0)):new n(NaN)};S.times=S.mul=function(e){var t,r,n,i,o,s,a,l,u,g=this,h=g.constructor,v=g.d,R=(e=new h(e)).d;if(e.s*=g.s,!v||!v[0]||!R||!R[0])return new h(!e.s||v&&!v[0]&&!R||R&&!R[0]&&!v?NaN:!v||!R?e.s/0:e.s*0);for(r=te(g.e/F)+te(e.e/F),l=v.length,u=R.length,l<u&&(o=v,v=R,R=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.push(0);for(n=u;--n>=0;){for(t=0,i=l+n;i>n;)a=o[i]+R[n]*v[i-n-1]+t,o[i--]=a%de|0,t=a/de|0;o[i]=(o[i]+t)%de|0}for(;!o[--s];)o.pop();return t?++r:o.shift(),e.d=o,e.e=mr(o,r),_?O(e,h.precision,h.rounding):e};S.toBinary=function(e,t){return Cn(this,2,e,t)};S.toDecimalPlaces=S.toDP=function(e,t){var r=this,n=r.constructor;return r=new n(r),e===void 0?r:(se(e,0,$e),t===void 0?t=n.rounding:se(t,0,8),O(r,e+r.e+1,t))};S.toExponential=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=we(n,!0):(se(e,0,$e),t===void 0?t=i.rounding:se(t,0,8),n=O(new i(n),e+1,t),r=we(n,!0,e+1)),n.isNeg()&&!n.isZero()?"-"+r:r};S.toFixed=function(e,t){var r,n,i=this,o=i.constructor;return e===void 0?r=we(i):(se(e,0,$e),t===void 0?t=o.rounding:se(t,0,8),n=O(new o(i),e+i.e+1,t),r=we(n,!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+r:r};S.toFraction=function(e){var t,r,n,i,o,s,a,l,u,g,h,v,R=this,C=R.d,A=R.constructor;if(!C)return new A(R);if(u=r=new A(1),n=l=new A(0),t=new A(n),o=t.e=uo(C)-R.e-1,s=o%F,t.d[0]=J(10,s<0?F+s:s),e==null)e=o>0?t:u;else{if(a=new A(e),!a.isInt()||a.lt(u))throw Error(qe+a);e=a.gt(t)?o>0?t:u:a}for(_=!1,a=new A(Y(C)),g=A.precision,A.precision=o=C.length*F*2;h=j(a,t,0,1,1),i=r.plus(h.times(n)),i.cmp(e)!=1;)r=n,n=i,i=u,u=l.plus(h.times(i)),l=i,i=t,t=a.minus(h.times(i)),a=i;return i=j(e.minus(r),n,0,1,1),l=l.plus(i.times(u)),r=r.plus(i.times(n)),l.s=u.s=R.s,v=j(u,n,o,1).minus(R).abs().cmp(j(l,r,o,1).minus(R).abs())<1?[u,n]:[l,r],A.precision=g,_=!0,v};S.toHexadecimal=S.toHex=function(e,t){return Cn(this,16,e,t)};S.toNearest=function(e,t){var r=this,n=r.constructor;if(r=new n(r),e==null){if(!r.d)return r;e=new n(1),t=n.rounding}else{if(e=new n(e),t===void 0?t=n.rounding:se(t,0,8),!r.d)return e.s?r:e;if(!e.d)return e.s&&(e.s=r.s),e}return e.d[0]?(_=!1,r=j(r,e,0,t,1).times(e),_=!0,O(r)):(e.s=r.s,r=e),r};S.toNumber=function(){return+this};S.toOctal=function(e,t){return Cn(this,8,e,t)};S.toPower=S.pow=function(e){var t,r,n,i,o,s,a=this,l=a.constructor,u=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(J(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return O(a,n,o);if(t=te(e.e/F),t>=e.d.length-1&&(r=u<0?-u:u)<=Hl)return i=co(l,a,r,n),e.s<0?new l(1).div(i):O(i,n,o);if(s=a.s,s<0){if(t<e.d.length-1)return new l(NaN);if((e.d[t]&1)==0&&(s=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=s,a}return r=J(+a,u),t=r==0||!isFinite(r)?te(u*(Math.log("0."+Y(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t>l.maxE+1||t<l.minE-1?new l(t>0?s/0:0):(_=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=Tn(e.times(De(a,n+r)),n),i.d&&(i=O(i,n+5,1),Lt(i.d,n,o)&&(t=n+10,i=O(Tn(e.times(De(a,t+r)),t),t+5,1),+Y(i.d).slice(n+1,n+15)+1==1e14&&(i=O(i,n+1,0)))),i.s=s,_=!0,l.rounding=o,O(i,n,o))};S.toPrecision=function(e,t){var r,n=this,i=n.constructor;return e===void 0?r=we(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(se(e,1,$e),t===void 0?t=i.rounding:se(t,0,8),n=O(new i(n),e,t),r=we(n,e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+r:r};S.toSignificantDigits=S.toSD=function(e,t){var r=this,n=r.constructor;return e===void 0?(e=n.precision,t=n.rounding):(se(e,1,$e),t===void 0?t=n.rounding:se(t,0,8)),O(new n(r),e,t)};S.toString=function(){var e=this,t=e.constructor,r=we(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+r:r};S.truncated=S.trunc=function(){return O(new this.constructor(this),this.e+1,1)};S.valueOf=S.toJSON=function(){var e=this,t=e.constructor,r=we(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+r:r};function Y(e){var t,r,n,i=e.length-1,o="",s=e[0];if(i>0){for(o+=s,t=1;t<i;t++)n=e[t]+"",r=F-n.length,r&&(o+=Ne(r)),o+=n;s=e[t],n=s+"",r=F-n.length,r&&(o+=Ne(r))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function se(e,t,r){if(e!==~~e||e<t||e>r)throw Error(qe+e)}function Lt(e,t,r,n){var i,o,s,a;for(o=e[0];o>=10;o/=10)--t;return--t<0?(t+=F,i=0):(i=Math.ceil((t+1)/F),t%=F),o=J(10,F-t),a=e[i]%o|0,n==null?t<3?(t==0?a=a/100|0:t==1&&(a=a/10|0),s=r<4&&a==99999||r>3&&a==49999||a==5e4||a==0):s=(r<4&&a+1==o||r>3&&a+1==o/2)&&(e[i+1]/o/100|0)==J(10,t-2)-1||(a==o/2||a==0)&&(e[i+1]/o/100|0)==0:t<4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&&(a=a/10|0),s=(n||r<4)&&a==9999||!n&&r>3&&a==4999):s=((n||r<4)&&a+1==o||!n&&r>3&&a+1==o/2)&&(e[i+1]/o/1e3|0)==J(10,t-3)-1,s}function lr(e,t,r){for(var n,i=[0],o,s=0,a=e.length;s<a;){for(o=i.length;o--;)i[o]*=t;for(i[0]+=xn.indexOf(e.charAt(s++)),n=0;n<i.length;n++)i[n]>r-1&&(i[n+1]===void 0&&(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}return i.reverse()}function Yl(e,t){var r,n,i;if(t.isZero())return t;n=t.d.length,n<32?(r=Math.ceil(n/3),i=(1/gr(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=st(e,1,t.times(i),new e(1));for(var o=r;o--;){var s=t.times(t);t=s.times(s).minus(s).times(8).plus(1)}return e.precision-=r,t}var j=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&&n.unshift(a),n}function t(n,i,o,s){var a,l;if(o!=s)l=o>s?1:-1;else for(a=l=0;a<o;a++)if(n[a]!=i[a]){l=n[a]>i[a]?1:-1;break}return l}function r(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]<i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s,a,l){var u,g,h,v,R,C,A,M,I,L,k,D,z,B,vt,Q,ne,Ce,Z,Ye,er=n.constructor,Yr=n.s==i.s?1:-1,X=n.d,$=i.d;if(!X||!X[0]||!$||!$[0])return new er(!n.s||!i.s||(X?$&&X[0]==$[0]:!$)?NaN:X&&X[0]==0||!$?Yr*0:Yr/0);for(l?(R=1,g=n.e-i.e):(l=de,R=F,g=te(n.e/R)-te(i.e/R)),Z=$.length,ne=X.length,I=new er(Yr),L=I.d=[],h=0;$[h]==(X[h]||0);h++);if($[h]>(X[h]||0)&&g--,o==null?(B=o=er.precision,s=er.rounding):a?B=o+(n.e-i.e)+1:B=o,B<0)L.push(1),C=!0;else{if(B=B/R+2|0,h=0,Z==1){for(v=0,$=$[0],B++;(h<ne||v)&&B--;h++)vt=v*l+(X[h]||0),L[h]=vt/$|0,v=vt%$|0;C=v||h<ne}else{for(v=l/($[0]+1)|0,v>1&&($=e($,v,l),X=e(X,v,l),Z=$.length,ne=X.length),Q=Z,k=X.slice(0,Z),D=k.length;D<Z;)k[D++]=0;Ye=$.slice(),Ye.unshift(0),Ce=$[0],$[1]>=l/2&&++Ce;do v=0,u=t($,k,Z,D),u<0?(z=k[0],Z!=D&&(z=z*l+(k[1]||0)),v=z/Ce|0,v>1?(v>=l&&(v=l-1),A=e($,v,l),M=A.length,D=k.length,u=t(A,k,M,D),u==1&&(v--,r(A,Z<M?Ye:$,M,l))):(v==0&&(u=v=1),A=$.slice()),M=A.length,M<D&&A.unshift(0),r(k,A,D,l),u==-1&&(D=k.length,u=t($,k,Z,D),u<1&&(v++,r(k,Z<D?Ye:$,D,l))),D=k.length):u===0&&(v++,k=[0]),L[h++]=v,u&&k[0]?k[D++]=X[Q]||0:(k=[X[Q]],D=1);while((Q++<ne||k[0]!==void 0)&&B--);C=k[0]!==void 0}L[0]||L.shift()}if(R==1)I.e=g,io=C;else{for(h=1,v=L[0];v>=10;v/=10)h++;I.e=h+g*R-1,O(I,a?o+I.e+1:o,s,C)}return I}}();function O(e,t,r,n){var i,o,s,a,l,u,g,h,v,R=e.constructor;e:if(t!=null){if(h=e.d,!h)return e;for(i=1,a=h[0];a>=10;a/=10)i++;if(o=t-i,o<0)o+=F,s=t,g=h[v=0],l=g/J(10,i-s-1)%10|0;else if(v=Math.ceil((o+1)/F),a=h.length,v>=a)if(n){for(;a++<=v;)h.push(0);g=l=0,i=1,o%=F,s=o-F+1}else break e;else{for(g=a=h[v],i=1;a>=10;a/=10)i++;o%=F,s=o-F+i,l=s<0?0:g/J(10,i-s-1)%10|0}if(n=n||t<0||h[v+1]!==void 0||(s<0?g:g%J(10,i-s-1)),u=r<4?(l||n)&&(r==0||r==(e.s<0?3:2)):l>5||l==5&&(r==4||n||r==6&&(o>0?s>0?g/J(10,i-s):0:h[v-1])%10&1||r==(e.s<0?8:7)),t<1||!h[0])return h.length=0,u?(t-=e.e+1,h[0]=J(10,(F-t%F)%F),e.e=-t||0):h[0]=e.e=0,e;if(o==0?(h.length=v,a=1,v--):(h.length=v+1,a=J(10,F-o),h[v]=s>0?(g/J(10,i-s)%J(10,s)|0)*a:0),u)for(;;)if(v==0){for(o=1,s=h[0];s>=10;s/=10)o++;for(s=h[0]+=a,a=1;s>=10;s/=10)a++;o!=a&&(e.e++,h[0]==de&&(h[0]=1));break}else{if(h[v]+=a,h[v]!=de)break;h[v--]=0,a=1}for(o=h.length;h[--o]===0;)h.pop()}return _&&(e.e>R.maxE?(e.d=null,e.e=NaN):e.e<R.minE&&(e.e=0,e.d=[0])),e}function we(e,t,r){if(!e.isFinite())return fo(e);var n,i=e.e,o=Y(e.d),s=o.length;return t?(r&&(n=r-s)>0?o=o.charAt(0)+"."+o.slice(1)+Ne(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):i<0?(o="0."+Ne(-i-1)+o,r&&(n=r-s)>0&&(o+=Ne(n))):i>=s?(o+=Ne(i+1-s),r&&(n=r-i-1)>0&&(o=o+"."+Ne(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),r&&(n=r-s)>0&&(i+1===s&&(o+="."),o+=Ne(n))),o}function mr(e,t){var r=e[0];for(t*=F;r>=10;r/=10)t++;return t}function dr(e,t,r){if(t>zl)throw _=!0,r&&(e.precision=r),Error(oo);return O(new e(cr),t,1,!0)}function ye(e,t,r){if(t>vn)throw Error(oo);return O(new e(pr),t,r,!0)}function uo(e){var t=e.length-1,r=t*F+1;if(t=e[t],t){for(;t%10==0;t/=10)r--;for(t=e[0];t>=10;t/=10)r++}return r}function Ne(e){for(var t="";e--;)t+="0";return t}function co(e,t,r,n){var i,o=new e(1),s=Math.ceil(n/F+4);for(_=!1;;){if(r%2&&(o=o.times(t),ro(o.d,s)&&(i=!0)),r=te(r/2),r===0){r=o.d.length-1,i&&o.d[r]===0&&++o.d[r];break}t=t.times(t),ro(t.d,s)}return _=!0,o}function to(e){return e.d[e.d.length-1]&1}function po(e,t,r){for(var n,i,o=new e(t[0]),s=0;++s<t.length;){if(i=new e(t[s]),!i.s){o=i;break}n=o.cmp(i),(n===r||n===0&&o.s===r)&&(o=i)}return o}function Tn(e,t){var r,n,i,o,s,a,l,u=0,g=0,h=0,v=e.constructor,R=v.rounding,C=v.precision;if(!e.d||!e.d[0]||e.e>17)return new v(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(t==null?(_=!1,l=C):l=t,a=new v(.03125);e.e>-2;)e=e.times(a),h+=5;for(n=Math.log(J(2,h))/Math.LN10*2+5|0,l+=n,r=o=s=new v(1),v.precision=l;;){if(o=O(o.times(e),l,1),r=r.times(++g),a=s.plus(j(o,r,l,1)),Y(a.d).slice(0,l)===Y(s.d).slice(0,l)){for(i=h;i--;)s=O(s.times(s),l,1);if(t==null)if(u<3&&Lt(s.d,l-n,R,u))v.precision=l+=10,r=o=a=new v(1),g=0,u++;else return O(s,v.precision=C,R,_=!0);else return v.precision=C,s}s=a}}function De(e,t){var r,n,i,o,s,a,l,u,g,h,v,R=1,C=10,A=e,M=A.d,I=A.constructor,L=I.rounding,k=I.precision;if(A.s<0||!M||!M[0]||!A.e&&M[0]==1&&M.length==1)return new I(M&&!M[0]?-1/0:A.s!=1?NaN:M?0:A);if(t==null?(_=!1,g=k):g=t,I.precision=g+=C,r=Y(M),n=r.charAt(0),Math.abs(o=A.e)<15e14){for(;n<7&&n!=1||n==1&&r.charAt(1)>3;)A=A.times(e),r=Y(A.d),n=r.charAt(0),R++;o=A.e,n>1?(A=new I("0."+r),o++):A=new I(n+"."+r.slice(1))}else return u=dr(I,g+2,k).times(o+""),A=De(new I(n+"."+r.slice(1)),g-C).plus(u),I.precision=k,t==null?O(A,k,L,_=!0):A;for(h=A,l=s=A=j(A.minus(1),A.plus(1),g,1),v=O(A.times(A),g,1),i=3;;){if(s=O(s.times(v),g,1),u=l.plus(j(s,new I(i),g,1)),Y(u.d).slice(0,g)===Y(l.d).slice(0,g))if(l=l.times(2),o!==0&&(l=l.plus(dr(I,g+2,k).times(o+""))),l=j(l,new I(R),g,1),t==null)if(Lt(l.d,g-C,L,a))I.precision=g+=C,u=s=A=j(h.minus(1),h.plus(1),g,1),v=O(A.times(A),g,1),i=a=1;else return O(l,I.precision=k,L,_=!0);else return I.precision=k,l;l=u,i+=2}}function fo(e){return String(e.s*e.s/0)}function ur(e,t){var r,n,i;for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(n=t.search(/e/i))>0?(r<0&&(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r<0&&(r=t.length),n=0;t.charCodeAt(n)===48;n++);for(i=t.length;t.charCodeAt(i-1)===48;--i);if(t=t.slice(n,i),t){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%F,r<0&&(n+=F),n<i){for(n&&e.d.push(+t.slice(0,n)),i-=F;n<i;)e.d.push(+t.slice(n,n+=F));t=t.slice(n),n=F-t.length}else n-=i;for(;n--;)t+="0";e.d.push(+t),_&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Zl(e,t){var r,n,i,o,s,a,l,u,g;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),lo.test(t))return ur(e,t)}else if(t==="Infinity"||t==="NaN")return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(Wl.test(t))r=16,t=t.toLowerCase();else if(Jl.test(t))r=2;else if(Kl.test(t))r=8;else throw Error(qe+t);for(o=t.search(/p/i),o>0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o>=0,n=e.constructor,s&&(t=t.replace(".",""),a=t.length,o=a-o,i=co(n,new n(r),o,o*2)),u=lr(t,r,de),g=u.length-1,o=g;u[o]===0;--o)u.pop();return o<0?new n(e.s*0):(e.e=mr(u,g),e.d=u,_=!1,s&&(e=j(e,i,a*4)),l&&(e=e.times(Math.abs(l)<54?J(2,l):We.pow(2,l))),_=!0,e)}function Xl(e,t){var r,n=t.d.length;if(n<3)return t.isZero()?t:st(e,2,t,t);r=1.4*Math.sqrt(n),r=r>16?16:r|0,t=t.times(1/gr(5,r)),t=st(e,2,t,t);for(var i,o=new e(5),s=new e(16),a=new e(20);r--;)i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));return t}function st(e,t,r,n,i){var o,s,a,l,u=1,g=e.precision,h=Math.ceil(g/F);for(_=!1,l=r.times(r),a=new e(n);;){if(s=j(a.times(l),new e(t++*t++),g,1),a=i?n.plus(s):n.minus(s),n=j(s.times(l),new e(t++*t++),g,1),s=a.plus(n),s.d[h]!==void 0){for(o=h;s.d[o]===a.d[o]&&o--;);if(o==-1)break}o=a,a=n,n=s,s=o,u++}return _=!0,s.d.length=h+1,s}function gr(e,t){for(var r=e;--t;)r*=e;return r}function mo(e,t){var r,n=t.s<0,i=ye(e,e.precision,1),o=i.times(.5);if(t=t.abs(),t.lte(o))return Fe=n?4:1,t;if(r=t.divToInt(i),r.isZero())Fe=n?3:2;else{if(t=t.minus(r.times(i)),t.lte(o))return Fe=to(r)?n?2:3:n?4:1,t;Fe=to(r)?n?1:4:n?3:2}return t.minus(i).abs()}function Cn(e,t,r,n){var i,o,s,a,l,u,g,h,v,R=e.constructor,C=r!==void 0;if(C?(se(r,1,$e),n===void 0?n=R.rounding:se(n,0,8)):(r=R.precision,n=R.rounding),!e.isFinite())g=fo(e);else{for(g=we(e),s=g.indexOf("."),C?(i=2,t==16?r=r*4-3:t==8&&(r=r*3-2)):i=t,s>=0&&(g=g.replace(".",""),v=new R(1),v.e=g.length-s,v.d=lr(we(v),10,i),v.e=v.d.length),h=lr(g,10,i),o=l=h.length;h[--l]==0;)h.pop();if(!h[0])g=C?"0p+0":"0";else{if(s<0?o--:(e=new R(e),e.d=h,e.e=o,e=j(e,v,r,n,0,i),h=e.d,o=e.e,u=io),s=h[r],a=i/2,u=u||h[r+1]!==void 0,u=n<4?(s!==void 0||u)&&(n===0||n===(e.s<0?3:2)):s>a||s===a&&(n===4||u||n===6&&h[r-1]&1||n===(e.s<0?8:7)),h.length=r,u)for(;++h[--r]>i-1;)h[r]=0,r||(++o,h.unshift(1));for(l=h.length;!h[l-1];--l);for(s=0,g="";s<l;s++)g+=xn.charAt(h[s]);if(C){if(l>1)if(t==16||t==8){for(s=t==16?4:3,--l;l%s;l++)g+="0";for(h=lr(g,i,t),l=h.length;!h[l-1];--l);for(s=1,g="1.";s<l;s++)g+=xn.charAt(h[s])}else g=g.charAt(0)+"."+g.slice(1);g=g+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)g="0"+g;g="0."+g}else if(++o>l)for(o-=l;o--;)g+="0";else o<l&&(g=g.slice(0,o)+"."+g.slice(o))}g=(t==16?"0x":t==2?"0b":t==8?"0o":"")+g}return e.s<0?"-"+g:g}function ro(e,t){if(e.length>t)return e.length=t,!0}function eu(e){return new this(e).abs()}function tu(e){return new this(e).acos()}function ru(e){return new this(e).acosh()}function nu(e,t){return new this(e).plus(t)}function iu(e){return new this(e).asin()}function ou(e){return new this(e).asinh()}function su(e){return new this(e).atan()}function au(e){return new this(e).atanh()}function lu(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,o=n+4;return!e.s||!t.s?r=new this(NaN):!e.d&&!t.d?(r=ye(this,o,1).times(t.s>0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s<0?ye(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=ye(this,o,1).times(.5),r.s=e.s):t.s<0?(this.precision=o,this.rounding=1,r=this.atan(j(e,t,o,1)),t=ye(this,o,1),this.precision=n,this.rounding=i,r=e.s<0?r.minus(t):r.plus(t)):r=this.atan(j(e,t,o,1)),r}function uu(e){return new this(e).cbrt()}function cu(e){return O(e=new this(e),e.e+1,2)}function pu(e,t,r){return new this(e).clamp(t,r)}function du(e){if(!e||typeof e!="object")throw Error(fr+"Object expected");var t,r,n,i=e.defaults===!0,o=["precision",1,$e,"rounding",0,8,"toExpNeg",-ot,0,"toExpPos",0,ot,"maxE",0,ot,"minE",-ot,0,"modulo",0,9];for(t=0;t<o.length;t+=3)if(r=o[t],i&&(this[r]=Pn[r]),(n=e[r])!==void 0)if(te(n)===n&&n>=o[t+1]&&n<=o[t+2])this[r]=n;else throw Error(qe+r+": "+n);if(r="crypto",i&&(this[r]=Pn[r]),(n=e[r])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[r]=!0;else throw Error(so);else this[r]=!1;else throw Error(qe+r+": "+n);return this}function fu(e){return new this(e).cos()}function mu(e){return new this(e).cosh()}function go(e){var t,r,n;function i(o){var s,a,l,u=this;if(!(u instanceof i))return new i(o);if(u.constructor=i,no(o)){u.s=o.s,_?!o.d||o.e>i.maxE?(u.e=NaN,u.d=null):o.e<i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){u.s=1/o<0?-1:1,u.e=0,u.d=[0];return}if(o<0?(o=-o,u.s=-1):u.s=1,o===~~o&&o<1e7){for(s=0,a=o;a>=10;a/=10)s++;_?s>i.maxE?(u.e=NaN,u.d=null):s<i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}if(o*0!==0){o||(u.s=NaN),u.e=NaN,u.d=null;return}return ur(u,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),u.s=-1):(a===43&&(o=o.slice(1)),u.s=1),lo.test(o)?ur(u,o):Zl(u,o);if(l==="bigint")return o<0?(o=-o,u.s=-1):u.s=1,ur(u,o.toString());throw Error(qe+o)}if(i.prototype=S,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=du,i.clone=go,i.isDecimal=no,i.abs=eu,i.acos=tu,i.acosh=ru,i.add=nu,i.asin=iu,i.asinh=ou,i.atan=su,i.atanh=au,i.atan2=lu,i.cbrt=uu,i.ceil=cu,i.clamp=pu,i.cos=fu,i.cosh=mu,i.div=gu,i.exp=hu,i.floor=yu,i.hypot=wu,i.ln=bu,i.log=Eu,i.log10=Pu,i.log2=xu,i.max=vu,i.min=Tu,i.mod=Cu,i.mul=Au,i.pow=Su,i.random=Ru,i.round=ku,i.sign=Ou,i.sin=Mu,i.sinh=Fu,i.sqrt=Iu,i.sub=_u,i.sum=Lu,i.tan=Nu,i.tanh=Du,i.trunc=qu,e===void 0&&(e={}),e&&e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t<n.length;)e.hasOwnProperty(r=n[t++])||(e[r]=this[r]);return i.config(e),i}function gu(e,t){return new this(e).div(t)}function hu(e){return new this(e).exp()}function yu(e){return O(e=new this(e),e.e+1,3)}function wu(){var e,t,r=new this(0);for(_=!1,e=0;e<arguments.length;)if(t=new this(arguments[e++]),t.d)r.d&&(r=r.plus(t.times(t)));else{if(t.s)return _=!0,new this(1/0);r=t}return _=!0,r.sqrt()}function no(e){return e instanceof We||e&&e.toStringTag===ao||!1}function bu(e){return new this(e).ln()}function Eu(e,t){return new this(e).log(t)}function xu(e){return new this(e).log(2)}function Pu(e){return new this(e).log(10)}function vu(){return po(this,arguments,-1)}function Tu(){return po(this,arguments,1)}function Cu(e,t){return new this(e).mod(t)}function Au(e,t){return new this(e).mul(t)}function Su(e,t){return new this(e).pow(t)}function Ru(e){var t,r,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:se(e,1,$e),n=Math.ceil(e/F),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));o<n;)i=t[o],i>=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(t=crypto.randomBytes(n*=4);o<n;)i=t[o]+(t[o+1]<<8)+(t[o+2]<<16)+((t[o+3]&127)<<24),i>=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(so);else for(;o<n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=F,n&&e&&(i=J(10,F-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o<0)r=0,a=[0];else{for(r=-1;a[0]===0;r-=F)a.shift();for(n=1,i=a[0];i>=10;i/=10)n++;n<F&&(r-=F-n)}return s.e=r,s.d=a,s}function ku(e){return O(e=new this(e),e.e+1,this.rounding)}function Ou(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function Mu(e){return new this(e).sin()}function Fu(e){return new this(e).sinh()}function Iu(e){return new this(e).sqrt()}function _u(e,t){return new this(e).sub(t)}function Lu(){var e=0,t=arguments,r=new this(t[e]);for(_=!1;r.s&&++e<t.length;)r=r.plus(t[e]);return _=!0,O(r,this.precision,this.rounding)}function Nu(e){return new this(e).tan()}function Du(e){return new this(e).tanh()}function qu(e){return O(e=new this(e),e.e+1,1)}S[Symbol.for("nodejs.util.inspect.custom")]=S.toString;S[Symbol.toStringTag]="Decimal";var We=S.constructor=go(Pn);cr=new We(cr);pr=new We(pr);var be=We;function at(e){return e===null?e:Array.isArray(e)?e.map(at):typeof e=="object"?$u(e)?ju(e):it(e,at):e}function $u(e){return e!==null&&typeof e=="object"&&typeof e.$type=="string"}function ju({$type:e,value:t}){switch(e){case"BigInt":return BigInt(t);case"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"DateTime":return new Date(t);case"Decimal":return new be(t);case"Json":return JSON.parse(t);default:Me(t,"Unknown tagged value")}}m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();var Ee=class{_map=new Map;get(t){return this._map.get(t)?.value}set(t,r){this._map.set(t,{value:r})}getOrCreate(t,r){let n=this._map.get(t);if(n)return n.value;let i=r();return this.set(t,i),i}};m();c();p();d();f();function je(e){return e.substring(0,1).toLowerCase()+e.substring(1)}m();c();p();d();f();function ho(e,t){let r={};for(let n of e){let i=n[t];r[i]=n}return r}m();c();p();d();f();function Nt(e){let t;return{get(){return t||(t={value:e()}),t.value}}}m();c();p();d();f();function yo(e){return{models:An(e.models),enums:An(e.enums),types:An(e.types)}}function An(e){let t={};for(let{name:r,...n}of e)t[r]=n;return t}m();c();p();d();f();function lt(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function hr(e){return e.toString()!=="Invalid Date"}m();c();p();d();f();function ut(e){return We.isDecimal(e)?!0:e!==null&&typeof e=="object"&&typeof e.s=="number"&&typeof e.e=="number"&&typeof e.toFixed=="function"&&Array.isArray(e.d)}m();c();p();d();f();m();c();p();d();f();var Dt={};Ze(Dt,{ModelAction:()=>ct,datamodelEnumToSchemaEnum:()=>Bu});m();c();p();d();f();m();c();p();d();f();function Bu(e){return{name:e.name,values:e.values.map(t=>t.name)}}m();c();p();d();f();var ct=(k=>(k.findUnique="findUnique",k.findUniqueOrThrow="findUniqueOrThrow",k.findFirst="findFirst",k.findFirstOrThrow="findFirstOrThrow",k.findMany="findMany",k.create="create",k.createMany="createMany",k.createManyAndReturn="createManyAndReturn",k.update="update",k.updateMany="updateMany",k.updateManyAndReturn="updateManyAndReturn",k.upsert="upsert",k.delete="delete",k.deleteMany="deleteMany",k.groupBy="groupBy",k.count="count",k.aggregate="aggregate",k.findRaw="findRaw",k.aggregateRaw="aggregateRaw",k))(ct||{});var xo=Se(Wi());m();c();p();d();f();cn();m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();var wo={keyword:ke,entity:ke,value:e=>pe(Je(e)),punctuation:Je,directive:ke,function:ke,variable:e=>pe(Je(e)),string:e=>pe(St(e)),boolean:Rt,number:ke,comment:kt};var Uu=e=>e,yr={},Vu=0,N={manual:yr.Prism&&yr.Prism.manual,disableWorkerMessageHandler:yr.Prism&&yr.Prism.disableWorkerMessageHandler,util:{encode:function(e){if(e instanceof fe){let t=e;return new fe(t.type,N.util.encode(t.content),t.alias)}else return Array.isArray(e)?e.map(N.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++Vu}),e.__id},clone:function e(t,r){let n,i,o=N.util.type(t);switch(r=r||{},o){case"Object":if(i=N.util.objId(t),r[i])return r[i];n={},r[i]=n;for(let s in t)t.hasOwnProperty(s)&&(n[s]=e(t[s],r));return n;case"Array":return i=N.util.objId(t),r[i]?r[i]:(n=[],r[i]=n,t.forEach(function(s,a){n[a]=e(s,r)}),n);default:return t}}},languages:{extend:function(e,t){let r=N.util.clone(N.languages[e]);for(let n in t)r[n]=t[n];return r},insertBefore:function(e,t,r,n){n=n||N.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==t)for(let l in r)r.hasOwnProperty(l)&&(o[l]=r[l]);r.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,N.languages.DFS(N.languages,function(a,l){l===s&&a!=e&&(this[a]=o)}),o},DFS:function e(t,r,n,i){i=i||{};let o=N.util.objId;for(let s in t)if(t.hasOwnProperty(s)){r.call(t,s,t[s],n||s);let a=t[s],l=N.util.type(a);l==="Object"&&!i[o(a)]?(i[o(a)]=!0,e(a,r,null,i)):l==="Array"&&!i[o(a)]&&(i[o(a)]=!0,e(a,r,s,i))}}},plugins:{},highlight:function(e,t,r){let n={code:e,grammar:t,language:r};return N.hooks.run("before-tokenize",n),n.tokens=N.tokenize(n.code,n.grammar),N.hooks.run("after-tokenize",n),fe.stringify(N.util.encode(n.tokens),n.language)},matchGrammar:function(e,t,r,n,i,o,s){for(let A in r){if(!r.hasOwnProperty(A)||!r[A])continue;if(A==s)return;let M=r[A];M=N.util.type(M)==="Array"?M:[M];for(let I=0;I<M.length;++I){let L=M[I],k=L.inside,D=!!L.lookbehind,z=!!L.greedy,B=0,vt=L.alias;if(z&&!L.pattern.global){let Q=L.pattern.toString().match(/[imuy]*$/)[0];L.pattern=RegExp(L.pattern.source,Q+"g")}L=L.pattern||L;for(let Q=n,ne=i;Q<t.length;ne+=t[Q].length,++Q){let Ce=t[Q];if(t.length>e.length)return;if(Ce instanceof fe)continue;if(z&&Q!=t.length-1){L.lastIndex=ne;var h=L.exec(e);if(!h)break;var g=h.index+(D?h[1].length:0),v=h.index+h[0].length,a=Q,l=ne;for(let $=t.length;a<$&&(l<v||!t[a].type&&!t[a-1].greedy);++a)l+=t[a].length,g>=l&&(++Q,ne=l);if(t[Q]instanceof fe)continue;u=a-Q,Ce=e.slice(ne,l),h.index-=ne}else{L.lastIndex=0;var h=L.exec(Ce),u=1}if(!h){if(o)break;continue}D&&(B=h[1]?h[1].length:0);var g=h.index+B,h=h[0].slice(B),v=g+h.length,R=Ce.slice(0,g),C=Ce.slice(v);let Z=[Q,u];R&&(++Q,ne+=R.length,Z.push(R));let Ye=new fe(A,k?N.tokenize(h,k):h,vt,h,z);if(Z.push(Ye),C&&Z.push(C),Array.prototype.splice.apply(t,Z),u!=1&&N.matchGrammar(e,t,r,Q,ne,!0,A),o)break}}}},tokenize:function(e,t){let r=[e],n=t.rest;if(n){for(let i in n)t[i]=n[i];delete t.rest}return N.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){let r=N.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){let r=N.hooks.all[e];if(!(!r||!r.length))for(var n=0,i;i=r[n++];)i(t)}},Token:fe};N.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};N.languages.javascript=N.languages.extend("clike",{"class-name":[N.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});N.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;N.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:N.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,inside:N.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,lookbehind:!0,inside:N.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:N.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});N.languages.markup&&N.languages.markup.tag.addInlined("script","javascript");N.languages.js=N.languages.javascript;N.languages.typescript=N.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});N.languages.ts=N.languages.typescript;function fe(e,t,r,n,i){this.type=e,this.content=t,this.alias=r,this.length=(n||"").length|0,this.greedy=!!i}fe.stringify=function(e,t){return typeof e=="string"?e:Array.isArray(e)?e.map(function(r){return fe.stringify(r,t)}).join(""):Qu(e.type)(e.content)};function Qu(e){return wo[e]||Uu}function bo(e){return Gu(e,N.languages.javascript)}function Gu(e,t){return N.tokenize(e,t).map(n=>fe.stringify(n)).join("")}m();c();p();d();f();function Eo(e){return mn(e)}var wr=class e{firstLineNumber;lines;static read(t){let r;try{r=or.readFileSync(t,"utf-8")}catch{return null}return e.fromContent(r)}static fromContent(t){let r=t.split(/\r?\n/);return new e(1,r)}constructor(t,r){this.firstLineNumber=t,this.lines=r}get lastLineNumber(){return this.firstLineNumber+this.lines.length-1}mapLineAt(t,r){if(t<this.firstLineNumber||t>this.lines.length+this.firstLineNumber)return this;let n=t-this.firstLineNumber,i=[...this.lines];return i[n]=r(i[n]),new e(this.firstLineNumber,i)}mapLines(t){return new e(this.firstLineNumber,this.lines.map((r,n)=>t(r,this.firstLineNumber+n)))}lineAt(t){return this.lines[t-this.firstLineNumber]}prependSymbolAt(t,r){return this.mapLines((n,i)=>i===t?`${r} ${n}`:`  ${n}`)}slice(t,r){let n=this.lines.slice(t-1,r).join(`
`);return new e(t,Eo(n).split(`
`))}highlight(){let t=bo(this.toString());return new e(this.firstLineNumber,t.split(`
`))}toString(){return this.lines.join(`
`)}};var Ju={red:Ge,gray:kt,dim:Ct,bold:pe,underline:At,highlightSource:e=>e.highlight()},Wu={red:e=>e,gray:e=>e,dim:e=>e,bold:e=>e,underline:e=>e,highlightSource:e=>e};function Ku({message:e,originalMethod:t,isPanic:r,callArguments:n}){return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}function Hu({callsite:e,message:t,originalMethod:r,isPanic:n,callArguments:i},o){let s=Ku({message:t,originalMethod:r,isPanic:n,callArguments:i});if(!e||typeof window<"u"||y.env.NODE_ENV==="production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=wr.read(a.fileName)?.slice(l,a.lineNumber),g=u?.lineAt(a.lineNumber);if(u&&g){let h=Yu(g),v=zu(g);if(!v)return s;s.functionName=`${v.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,C=>C.slice(0,v.openingBraceIndex))),u=o.highlightSource(u);let R=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((C,A)=>o.gray(String(A).padStart(R))+" "+C).mapLines(C=>o.dim(C)).prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let C=h+R+1;C+=2,s.callArguments=(0,xo.default)(i,C).slice(C)}}return s}function zu(e){let t=Object.keys(ct).join("|"),n=new RegExp(String.raw`\.(${t})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}function Yu(e){let t=0;for(let r=0;r<e.length;r++){if(e.charAt(r)!==" ")return t;t++}return t}function Zu({functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=t?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&&a.push(s.underline(Xu(t))),i){a.push("");let u=[i.toString()];o&&(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(r),a.join(`
`)}function Xu(e){let t=[e.fileName];return e.lineNumber&&t.push(String(e.lineNumber)),e.columnNumber&&t.push(String(e.columnNumber)),t.join(":")}function br(e){let t=e.showColors?Ju:Wu,r;return r=Hu(e,t),Zu(r,t)}m();c();p();d();f();var Oo=Se(Sn());m();c();p();d();f();function Co(e,t,r){let n=Ao(e),i=ec(n),o=rc(i);o?Er(o,t,r):t.addErrorMessage(()=>"Unknown error")}function Ao(e){return e.errors.flatMap(t=>t.kind==="Union"?Ao(t):[t])}function ec(e){let t=new Map,r=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){r.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=t.get(i);o?t.set(i,{...n,argument:{...n.argument,typeNames:tc(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}return r.push(...t.values()),r}function tc(e,t){return[...new Set(e.concat(t))]}function rc(e){return En(e,(t,r)=>{let n=vo(t),i=vo(r);return n!==i?n-i:To(t)-To(r)})}function vo(e){let t=0;return Array.isArray(e.selectionPath)&&(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&&(t+=e.argumentPath.length),t}function To(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}m();c();p();d();f();var ce=class{constructor(t,r){this.name=t;this.value=r}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(t){let{colors:{green:r}}=t.context;t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}};m();c();p();d();f();m();c();p();d();f();Ro();m();c();p();d();f();var pt=class{constructor(t=0,r){this.context=r;this.currentIndent=t}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(t){return typeof t=="string"?this.currentLine+=t:t.write(this),this}writeJoined(t,r,n=(i,o)=>o.write(i)){let i=r.length-1;for(let o=0;o<r.length;o++)n(r[o],this),o!==i&&this.write(t);return this}writeLine(t){return this.write(t).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let t=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,t?.(),this}withIndent(t){return this.indent(),t(this),this.unindent(),this}afterNextNewline(t){return this.afterNextNewLineCallback=t,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(t){return this.marginSymbol=t,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let t=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+t.slice(1):t}};So();m();c();p();d();f();m();c();p();d();f();var xr=class{constructor(t){this.value=t}write(t){t.write(this.value)}markAsError(){this.value.markAsError()}};m();c();p();d();f();var Pr=e=>e,vr={bold:Pr,red:Pr,green:Pr,dim:Pr,enabled:!1},ko={bold:pe,red:Ge,green:St,dim:Ct,enabled:!0},dt={write(e){e.writeLine(",")}};m();c();p();d();f();var xe=class{constructor(t){this.contents=t}isUnderlined=!1;color=t=>t;underline(){return this.isUnderlined=!0,this}setColor(t){return this.color=t,this}write(t){let r=t.getCurrentLineLength();t.write(this.color(this.contents)),this.isUnderlined&&t.afterNextNewline(()=>{t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))})}};m();c();p();d();f();var Be=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var ft=class extends Be{items=[];addItem(t){return this.items.push(new xr(t)),this}getField(t){return this.items[t]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(r=>r.value.getPrintWidth()))+2}write(t){if(this.items.length===0){this.writeEmpty(t);return}this.writeWithItems(t)}writeEmpty(t){let r=new xe("[]");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithItems(t){let{colors:r}=t.context;t.writeLine("[").withIndent(()=>t.writeJoined(dt,this.items).newLine()).write("]"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(r.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var mt=class e extends Be{fields={};suggestions=[];addField(t){this.fields[t.name]=t}addSuggestion(t){this.suggestions.push(t)}getField(t){return this.fields[t]}getDeepField(t){let[r,...n]=t,i=this.getField(r);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof ft&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(t){return t.length===0?this:this.getDeepField(t)?.value}hasField(t){return!!this.getField(t)}removeAllFields(){this.fields={}}removeField(t){delete this.fields[t]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(t){return this.getField(t)?.value}getDeepSubSelectionValue(t){let r=this;for(let n of t){if(!(r instanceof e))return;let i=r.getSubSelectionValue(n);if(!i)return;r=i}return r}getDeepSelectionParent(t){let r=this.getSelectionParent();if(!r)return;let n=r;for(let i of t){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let t=this.getField("select")?.value.asObject();if(t)return{kind:"select",value:t};let r=this.getField("include")?.value.asObject();if(r)return{kind:"include",value:r}}getSubSelectionValue(t){return this.getSelectionParent()?.value.fields[t].value}getPrintWidth(){let t=Object.values(this.fields);return t.length==0?2:Math.max(...t.map(n=>n.getPrintWidth()))+2}write(t){let r=Object.values(this.fields);if(r.length===0&&this.suggestions.length===0){this.writeEmpty(t);return}this.writeWithContents(t,r)}asObject(){return this}writeEmpty(t){let r=new xe("{}");this.hasError&&r.setColor(t.context.colors.red).underline(),t.write(r)}writeWithContents(t,r){t.writeLine("{").withIndent(()=>{t.writeJoined(dt,[...r,...this.suggestions]).newLine()}),t.write("}"),this.hasError&&t.afterNextNewline(()=>{t.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())))})}};m();c();p();d();f();var H=class extends Be{constructor(r){super();this.text=r}getPrintWidth(){return this.text.length}write(r){let n=new xe(this.text);this.hasError&&n.underline().setColor(r.context.colors.red),r.write(n)}asObject(){}};m();c();p();d();f();var qt=class{fields=[];addField(t,r){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}}),this}write(t){let{colors:{green:r}}=t.context;t.writeLine(r("{")).withIndent(()=>{t.writeJoined(dt,this.fields).newLine()}).write(r("}")).addMarginSymbol(r("+"))}};function Er(e,t,r){switch(e.kind){case"MutuallyExclusiveFields":nc(e,t);break;case"IncludeOnScalar":ic(e,t);break;case"EmptySelection":oc(e,t,r);break;case"UnknownSelectionField":uc(e,t);break;case"InvalidSelectionValue":cc(e,t);break;case"UnknownArgument":pc(e,t);break;case"UnknownInputField":dc(e,t);break;case"RequiredArgumentMissing":fc(e,t);break;case"InvalidArgumentType":mc(e,t);break;case"InvalidArgumentValue":gc(e,t);break;case"ValueTooLarge":hc(e,t);break;case"SomeFieldsMissing":yc(e,t);break;case"TooManyFieldsGiven":wc(e,t);break;case"Union":Co(e,t,r);break;default:throw new Error("not implemented: "+e.kind)}}function nc(e,t){let r=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();r&&(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function ic(e,t){let[r,n]=$t(e.selectionPath),i=e.outputType,o=t.arguments.getDeepSelectionParent(r)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new ce(s.name,"true"));t.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${jt(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function oc(e,t,r){let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){sc(e,t,i);return}if(n.hasField("select")){ac(e,t);return}}if(r?.[je(e.outputType.name)]){lc(e,t);return}t.addErrorMessage(()=>`Unknown field at "${e.selectionPath.join(".")} selection"`)}function sc(e,t,r){r.removeAllFields();for(let n of e.outputType.fields)r.addSuggestion(new ce(n.name,"false"));t.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}function ac(e,t){let r=e.outputType,n=t.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),Io(n,r)),t.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${jt(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)}function lc(e,t){let r=new qt;for(let i of e.outputType.fields)i.isRelation||r.addField(i.name,"false");let n=new ce("omit",r).makeRequired();if(e.selectionPath.length===0)t.arguments.addSuggestion(n);else{let[i,o]=$t(e.selectionPath),a=t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new mt;l.addSuggestion(n),a.value=l}}t.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function uc(e,t){let r=_o(e.selectionPath,t);if(r.parentKind!=="unknown"){r.field.markAsError();let n=r.parent;switch(r.parentKind){case"select":Io(n,e.outputType);break;case"include":bc(n,e.outputType);break;case"omit":Ec(n,e.outputType);break}}t.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];return r.parentKind!=="unknown"&&i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(jt(n)),i.join(" ")})}function cc(e,t){let r=_o(e.selectionPath,t);r.parentKind!=="unknown"&&r.field.value.markAsError(),t.addErrorMessage(n=>`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)}function pc(e,t){let r=e.argumentPath[0],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&(n.getField(r)?.markAsError(),xc(n,e.arguments)),t.addErrorMessage(i=>Mo(i,r,e.arguments.map(o=>o.name)))}function dc(e,t){let[r,n]=$t(e.argumentPath),i=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(r)?.asObject();o&&Lo(o,e.inputType)}t.addErrorMessage(o=>Mo(o,n,e.inputType.fields.map(s=>s.name)))}function Mo(e,t,r){let n=[`Unknown argument \`${e.red(t)}\`.`],i=vc(t,r);return i&&n.push(`Did you mean \`${e.green(i)}\`?`),r.length>0&&n.push(jt(e)),n.join(" ")}function fc(e,t){let r;t.addErrorMessage(l=>r?.value instanceof H&&r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=$t(e.argumentPath),s=new qt,a=n.getDeepFieldValue(i)?.asObject();if(a)if(r=a.getField(o),r&&a.removeField(o),e.inputTypes.length===1&&e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ce(o,s).makeRequired())}else{let l=e.inputTypes.map(Fo).join(" | ");a.addSuggestion(new ce(o,l).makeRequired())}}function Fo(e){return e.kind==="list"?`${Fo(e.elementType)}[]`:e.name}function mc(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=Tr("or",e.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}function gc(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(r)}\``];if(e.underlyingError&&o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length>0){let s=Tr("or",e.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function hc(e,t){let r=e.argument.name,n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof H&&(i=s.text)}t.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")})}function yc(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&&Lo(i,e.inputType)}t.addErrorMessage(i=>{let o=[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Tr("or",e.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(jt(i)),o.join(" ")})}function wc(e,t){let r=e.argumentPath[e.argumentPath.length-1],n=t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}t.addErrorMessage(o=>{let s=[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&&e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Tr("and",i.map(a=>o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}function Io(e,t){for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ce(r.name,"true"))}function bc(e,t){for(let r of t.fields)r.isRelation&&!e.hasField(r.name)&&e.addSuggestion(new ce(r.name,"true"))}function Ec(e,t){for(let r of t.fields)!e.hasField(r.name)&&!r.isRelation&&e.addSuggestion(new ce(r.name,"true"))}function xc(e,t){for(let r of t)e.hasField(r.name)||e.addSuggestion(new ce(r.name,r.typeNames.join(" | ")))}function _o(e,t){let[r,n]=$t(e),i=t.arguments.getDeepSubSelectionValue(r)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&&l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&&l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&&l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function Lo(e,t){if(t.kind==="object")for(let r of t.fields)e.hasField(r.name)||e.addSuggestion(new ce(r.name,r.typeNames.join(" | ")))}function $t(e){let t=[...e],r=t.pop();if(!r)throw new Error("unexpected empty path");return[t,r]}function jt({green:e,enabled:t}){return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}function Tr(e,t){if(t.length===1)return t[0];let r=[...t],n=r.pop();return`${r.join(", ")} ${e} ${n}`}var Pc=3;function vc(e,t){let r=1/0,n;for(let i of t){let o=(0,Oo.default)(e,i);o>Pc||o<r&&(r=o,n=i)}return n}m();c();p();d();f();m();c();p();d();f();var Bt=class{modelName;name;typeName;isList;isEnum;constructor(t,r,n,i,o){this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let t=this.isList?"List":"",r=this.isEnum?"Enum":"";return`${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`}};function gt(e){return e instanceof Bt}m();c();p();d();f();var Cr=Symbol(),kn=new WeakMap,Ie=class{constructor(t){t===Cr?kn.set(this,`Prisma.${this._getName()}`):kn.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return kn.get(this)}},Ut=class extends Ie{_getNamespace(){return"NullTypes"}},Vt=class extends Ut{_brand_DbNull};On(Vt,"DbNull");var Qt=class extends Ut{_brand_JsonNull};On(Qt,"JsonNull");var Gt=class extends Ut{_brand_AnyNull};On(Gt,"AnyNull");var Ar={classes:{DbNull:Vt,JsonNull:Qt,AnyNull:Gt},instances:{DbNull:new Vt(Cr),JsonNull:new Qt(Cr),AnyNull:new Gt(Cr)}};function On(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}m();c();p();d();f();var No=": ",Sr=class{constructor(t,r){this.name=t;this.value=r}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+No.length}write(t){let r=new xe(this.name);this.hasError&&r.underline().setColor(t.context.colors.red),t.write(r).write(No).write(this.value)}};var Mn=class{arguments;errorMessages=[];constructor(t){this.arguments=t}write(t){t.write(this.arguments)}addErrorMessage(t){this.errorMessages.push(t)}renderAllMessages(t){return this.errorMessages.map(r=>r(t)).join(`
`)}};function ht(e){return new Mn(Do(e))}function Do(e){let t=new mt;for(let[r,n]of Object.entries(e)){let i=new Sr(r,qo(n));t.addField(i)}return t}function qo(e){if(typeof e=="string")return new H(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new H(String(e));if(typeof e=="bigint")return new H(`${e}n`);if(e===null)return new H("null");if(e===void 0)return new H("undefined");if(ut(e))return new H(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return w.Buffer.isBuffer(e)?new H(`Buffer.alloc(${e.byteLength})`):new H(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let t=hr(e)?e.toISOString():"Invalid Date";return new H(`new Date("${t}")`)}return e instanceof Ie?new H(`Prisma.${e._getName()}`):gt(e)?new H(`prisma.${je(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Tc(e):typeof e=="object"?Do(e):new H(Object.prototype.toString.call(e))}function Tc(e){let t=new ft;for(let r of e)t.addItem(qo(r));return t}function Rr(e,t){let r=t==="pretty"?ko:vr,n=e.renderAllMessages(r),i=new pt(0,{colors:r}).write(e).toString();return{message:n,args:i}}function kr({args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=ht(e);for(let h of t)Er(h,a,s);let{message:l,args:u}=Rr(a,r),g=br({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:u});throw new ee(g,{clientVersion:o})}m();c();p();d();f();m();c();p();d();f();function Pe(e){return e.replace(/^./,t=>t.toLowerCase())}m();c();p();d();f();function jo(e,t,r){let n=Pe(r);return!t.result||!(t.result.$allModels||t.result[n])?e:Cc({...e,...$o(t.name,e,t.result.$allModels),...$o(t.name,e,t.result[n])})}function Cc(e){let t=new Ee,r=(n,i)=>t.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=>r(o,i)):[n]));return it(e,n=>({...n,needs:r(n.name,new Set)}))}function $o(e,t,r){return r?it(r,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:Ac(t,o,i)})):{}}function Ac(e,t,r){let n=e?.[t]?.compute;return n?i=>r({...i,[t]:n(i)}):r}function Bo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(e[n.name])for(let i of n.needs)r[i]=!0;return r}function Uo(e,t){if(!t)return e;let r={...e};for(let n of Object.values(t))if(!e[n.name])for(let i of n.needs)delete r[i];return r}var Or=class{constructor(t,r){this.extension=t;this.previous=r}computedFieldsCache=new Ee;modelExtensionsCache=new Ee;queryCallbacksCache=new Ee;clientExtensions=Nt(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=Nt(()=>{let t=this.previous?.getAllBatchQueryCallbacks()??[],r=this.extension.query?.$__internalBatch;return r?t.concat(r):t});getAllComputedFields(t){return this.computedFieldsCache.getOrCreate(t,()=>jo(this.previous?.getAllComputedFields(t),this.extension,t))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(t){return this.modelExtensionsCache.getOrCreate(t,()=>{let r=Pe(t);return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}})}getAllQueryCallbacks(t,r){return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,()=>{let n=this.previous?.getAllQueryCallbacks(t,r)??[],i=[],o=this.extension.query;return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&&(o[t][r]!==void 0&&i.push(o[t][r]),o[t].$allOperations!==void 0&&i.push(o[t].$allOperations)),t!=="$none"&&o.$allModels!==void 0&&(o.$allModels[r]!==void 0&&i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[r]!==void 0&&i.push(o[r]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},yt=class e{constructor(t){this.head=t}static empty(){return new e}static single(t){return new e(new Or(t))}isEmpty(){return this.head===void 0}append(t){return new e(new Or(t,this.head))}getAllComputedFields(t){return this.head?.getAllComputedFields(t)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(t){return this.head?.getAllModelExtensions(t)}getAllQueryCallbacks(t,r){return this.head?.getAllQueryCallbacks(t,r)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};m();c();p();d();f();var Mr=class{constructor(t){this.name=t}};function Vo(e){return e instanceof Mr}function Qo(e){return new Mr(e)}m();c();p();d();f();m();c();p();d();f();var Go=Symbol(),Jt=class{constructor(t){if(t!==Go)throw new Error("Skip instance can not be constructed directly")}ifUndefined(t){return t===void 0?Fr:t}},Fr=new Jt(Go);function ve(e){return e instanceof Jt}var Sc={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},Jo="explicitly `undefined` values are not allowed";function Ir({modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=yt.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:g}){let h=new Fn({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:g});return{modelName:e,action:Sc[t],query:Wt(r,h)}}function Wt({select:e,include:t,...r}={},n){let i=r.omit;return delete r.omit,{arguments:Ko(r,n),selection:Rc(e,t,i,n)}}function Rc(e,t,r,n){return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),Fc(e,n)):kc(n,t,r)}function kc(e,t,r){let n={};return e.modelOrType&&!e.isRawAction()&&(n.$composites=!0,n.$scalars=!0),t&&Oc(n,t,e),Mc(n,r,e),n}function Oc(e,t,r){for(let[n,i]of Object.entries(t)){if(ve(i))continue;let o=r.nestSelection(n);if(In(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=r.findField(n);if(s&&s.kind!=="object"&&r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){e[n]=Wt(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=Wt(i,o)}}function Mc(e,t,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...t},o=Uo(i,n);for(let[s,a]of Object.entries(o)){if(ve(a))continue;In(a,r.nestSelection(s));let l=r.findField(s);n?.[s]&&!l||(e[s]=!a)}}function Fc(e,t){let r={},n=t.getComputedFields(),i=Bo(e,n);for(let[o,s]of Object.entries(i)){if(ve(s))continue;let a=t.nestSelection(o);In(s,a);let l=t.findField(o);if(!(n?.[o]&&!l)){if(s===!1||s===void 0||ve(s)){r[o]=!1;continue}if(s===!0){l?.kind==="object"?r[o]=Wt({},a):r[o]=!0;continue}r[o]=Wt(s,a)}}return r}function Wo(e,t){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(lt(e)){if(hr(e))return{$type:"DateTime",value:e.toISOString()};t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Vo(e))return{$type:"Param",value:e.name};if(gt(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return Ic(e,t);if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:w.Buffer.from(r,n,i).toString("base64")}}if(_c(e))return e.values;if(ut(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Ie){if(e!==Ar.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(Lc(e))return e.toJSON();if(typeof e=="object")return Ko(e,t);t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function Ko(e,t){if(e.$type)return{$type:"Raw",value:e};let r={};for(let n in e){let i=e[n],o=t.nestArgument(n);ve(i)||(i!==void 0?r[n]=Wo(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:Jo}))}return r}function Ic(e,t){let r=[];for(let n=0;n<e.length;n++){let i=t.nestArgument(String(n)),o=e[n];if(o===void 0||ve(o)){let s=o===void 0?"undefined":"Prisma.skip";t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}r.push(Wo(o,i))}return r}function _c(e){return typeof e=="object"&&e!==null&&e.__prismaRawParameters__===!0}function Lc(e){return typeof e=="object"&&e!==null&&typeof e.toJSON=="function"}function In(e,t){e===void 0&&t.isPreviewFeatureOn("strictUndefinedChecks")&&t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:Jo})}var Fn=class e{constructor(t){this.params=t;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(t){kr({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(t=>({name:t.name,typeName:"boolean",isRelation:t.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(t){return this.params.previewFeatures.includes(t)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(t){return this.modelOrType?.fields.find(r=>r.name===t)}nestSelection(t){let r=this.findField(t),n=r?.kind==="object"?r.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[je(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:Me(this.params.action,"Unknown action")}}nestArgument(t){return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}};m();c();p();d();f();function Ho(e){if(!e._hasPreviewFlag("metrics"))throw new ee("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var wt=class{_client;constructor(t){this._client=t}prometheus(t){return Ho(this._client),this._client._engine.metrics({format:"prometheus",...t})}json(t){return Ho(this._client),this._client._engine.metrics({format:"json",...t})}};m();c();p();d();f();function zo(e,t){let r=Nt(()=>Nc(t));Object.defineProperty(e,"dmmf",{get:()=>r.get()})}function Nc(e){return{datamodel:{models:_n(e.models),enums:_n(e.enums),types:_n(e.types)}}}function _n(e){return Object.entries(e).map(([t,r])=>({name:t,...r}))}m();c();p();d();f();var Ln=new WeakMap,_r="$$PrismaTypedSql",Kt=class{constructor(t,r){Ln.set(this,{sql:t,values:r}),Object.defineProperty(this,_r,{value:_r})}get sql(){return Ln.get(this).sql}get values(){return Ln.get(this).values}};function Yo(e){return(...t)=>new Kt(e,t)}function Lr(e){return e!=null&&e[_r]===_r}m();c();p();d();f();var ga=Se(Zo());m();c();p();d();f();Xo();cn();dn();m();c();p();d();f();var ae=class e{constructor(t,r){if(t.length-1!==r.length)throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);let n=r.reduce((s,a)=>s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];let i=0,o=0;for(;i<r.length;){let s=r[i++],a=t[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l<s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`?${this.strings[r++]}`;return n}get statement(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`:${r}${this.strings[r++]}`;return n}get text(){let t=this.strings.length,r=1,n=this.strings[0];for(;r<t;)n+=`$${r}${this.strings[r++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function es(e,t=",",r="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new ae([r,...Array(e.length-1).fill(t),n],e)}function Nn(e){return new ae([e],[])}var ts=Nn("");function Dn(e,...t){return new ae(e,t)}m();c();p();d();f();m();c();p();d();f();function Ht(e){return{getKeys(){return Object.keys(e)},getPropertyValue(t){return e[t]}}}m();c();p();d();f();function re(e,t){return{getKeys(){return[e]},getPropertyValue(){return t()}}}m();c();p();d();f();function Ke(e){let t=new Ee;return{getKeys(){return e.getKeys()},getPropertyValue(r){return t.getOrCreate(r,()=>e.getPropertyValue(r))},getPropertyDescriptor(r){return e.getPropertyDescriptor?.(r)}}}m();c();p();d();f();m();c();p();d();f();var Dr={enumerable:!0,configurable:!0,writable:!0};function qr(e){let t=new Set(e);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>Dr,has:(r,n)=>t.has(n),set:(r,n,i)=>t.add(n)&&Reflect.set(r,n,i),ownKeys:()=>[...t]}}var rs=Symbol.for("nodejs.util.inspect.custom");function me(e,t){let r=qc(t),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=r.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=r.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=ns(Reflect.ownKeys(o),r),a=ns(Array.from(r.keys()),r);return[...new Set([...s,...a,...n])]},set(o,s,a){return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let l=r.get(s);return l?l.getPropertyDescriptor?{...Dr,...l?.getPropertyDescriptor(s)}:Dr:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[rs]=function(){let o={...this};return delete o[rs],o},i}function qc(e){let t=new Map;for(let r of e){let n=r.getKeys();for(let i of n)t.set(i,r)}return t}function ns(e,t){return e.filter(r=>t.get(r)?.has?.(r)??!0)}m();c();p();d();f();function bt(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}m();c();p();d();f();function $r(e,t){return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}m();c();p();d();f();function is(e){if(e===void 0)return"";let t=ht(e);return new pt(0,{colors:vr}).write(t).toString()}m();c();p();d();f();var $c="P2037";function jr({error:e,user_facing_error:t},r,n){return t.error_code?new oe(jc(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new G(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}function jc(e,t){let r=e.message;return(t==="postgresql"||t==="postgres"||t==="mysql")&&e.error_code===$c&&(r+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();var zt="<unknown>";function os(e){var t=e.split(`
`);return t.reduce(function(r,n){var i=Vc(n)||Gc(n)||Kc(n)||Zc(n)||zc(n);return i&&r.push(i),r},[])}var Bc=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,Uc=/\((\S*)(?::(\d+))(?::(\d+))\)/;function Vc(e){var t=Bc.exec(e);if(!t)return null;var r=t[2]&&t[2].indexOf("native")===0,n=t[2]&&t[2].indexOf("eval")===0,i=Uc.exec(t[2]);return n&&i!=null&&(t[2]=i[1],t[3]=i[2],t[4]=i[3]),{file:r?null:t[2],methodName:t[1]||zt,arguments:r?[t[2]]:[],lineNumber:t[3]?+t[3]:null,column:t[4]?+t[4]:null}}var Qc=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;function Gc(e){var t=Qc.exec(e);return t?{file:t[2],methodName:t[1]||zt,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}var Jc=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,Wc=/(\S+) line (\d+)(?: > eval line \d+)* > eval/i;function Kc(e){var t=Jc.exec(e);if(!t)return null;var r=t[3]&&t[3].indexOf(" > eval")>-1,n=Wc.exec(t[3]);return r&&n!=null&&(t[3]=n[1],t[4]=n[2],t[5]=null),{file:t[3],methodName:t[1]||zt,arguments:t[2]?t[2].split(","):[],lineNumber:t[4]?+t[4]:null,column:t[5]?+t[5]:null}}var Hc=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function zc(e){var t=Hc.exec(e);return t?{file:t[3],methodName:t[1]||zt,arguments:[],lineNumber:+t[4],column:t[5]?+t[5]:null}:null}var Yc=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;function Zc(e){var t=Yc.exec(e);return t?{file:t[2],methodName:t[1]||zt,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}var qn=class{getLocation(){return null}},$n=class{_error;constructor(){this._error=new Error}getLocation(){let t=this._error.stack;if(!t)return null;let n=os(t).find(i=>{if(!i.file)return!1;let o=wn(i.file);return o!=="<anonymous>"&&!o.includes("@prisma")&&!o.includes("/packages/client/src/runtime/")&&!o.endsWith("/runtime/binary.js")&&!o.endsWith("/runtime/library.js")&&!o.endsWith("/runtime/edge.js")&&!o.endsWith("/runtime/edge-esm.js")&&!o.startsWith("internal/")&&!i.methodName.includes("new ")&&!i.methodName.includes("getCallSite")&&!i.methodName.includes("Proxy.")&&i.methodName.split(".").length<4});return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}};function Ue(e){return e==="minimal"?typeof $EnabledCallSite=="function"&&e!=="minimal"?new $EnabledCallSite:new qn:new $n}m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();var ss={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function Et(e={}){let t=ep(e);return Object.entries(t).reduce((n,[i,o])=>(ss[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function ep(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function Br(e={}){return t=>(typeof e._count=="boolean"&&(t._count=t._count._all),t)}function as(e,t){let r=Br(e);return t({action:"aggregate",unpacker:r,argsMapper:Et})(e)}m();c();p();d();f();function tp(e={}){let{select:t,...r}=e;return typeof t=="object"?Et({...r,_count:t}):Et({...r,_count:{_all:!0}})}function rp(e={}){return typeof e.select=="object"?t=>Br(e)(t)._count:t=>Br(e)(t)._count._all}function ls(e,t){return t({action:"count",unpacker:rp(e),argsMapper:tp})(e)}m();c();p();d();f();function np(e={}){let t=Et(e);if(Array.isArray(t.by))for(let r of t.by)typeof r=="string"&&(t.select[r]=!0);else typeof t.by=="string"&&(t.select[t.by]=!0);return t}function ip(e={}){return t=>(typeof e?._count=="boolean"&&t.forEach(r=>{r._count=r._count._all}),t)}function us(e,t){return t({action:"groupBy",unpacker:ip(e),argsMapper:np})(e)}function cs(e,t,r){if(t==="aggregate")return n=>as(n,r);if(t==="count")return n=>ls(n,r);if(t==="groupBy")return n=>us(n,r)}m();c();p();d();f();function ps(e,t){let r=t.fields.filter(i=>!i.relationName),n=ho(r,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new Bt(e,o,s.type,s.isList,s.kind==="enum")},...qr(Object.keys(n))})}m();c();p();d();f();m();c();p();d();f();var ds=e=>Array.isArray(e)?e:e.split("."),jn=(e,t)=>ds(t).reduce((r,n)=>r&&r[n],e),fs=(e,t,r)=>ds(t).reduceRight((n,i,o,s)=>Object.assign({},jn(e,s.slice(0,o)),{[i]:n}),r);function op(e,t){return e===void 0||t===void 0?[]:[...t,"select",e]}function sp(e,t,r){return t===void 0?e??{}:fs(t,r,e||!0)}function Bn(e,t,r,n,i,o){let a=e._runtimeDataModel.models[t].fields.reduce((l,u)=>({...l,[u.name]:u}),{});return l=>{let u=Ue(e._errorFormat),g=op(n,i),h=sp(l,o,g),v=r({dataPath:g,callsite:u})(h),R=ap(e,t);return new Proxy(v,{get(C,A){if(!R.includes(A))return C[A];let I=[a[A].type,r,A],L=[g,h];return Bn(e,...I,...L)},...qr([...R,...Object.getOwnPropertyNames(v)])})}}function ap(e,t){return e._runtimeDataModel.models[t].fields.filter(r=>r.kind==="object").map(r=>r.name)}var lp=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],up=["aggregate","count","groupBy"];function Un(e,t){let r=e._extensions.getAllModelExtensions(t)??{},n=[cp(e,t),dp(e,t),Ht(r),re("name",()=>t),re("$name",()=>t),re("$parent",()=>e._appliedParent)];return me({},n)}function cp(e,t){let r=Pe(t),n=Object.keys(ct).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>l=>{let u=Ue(e._errorFormat);return e._createPrismaPromise(g=>{let h={args:l,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:g,callsite:u};return e._request({...h,...a})},{action:o,args:l,model:t})};return lp.includes(o)?Bn(e,t,s):pp(i)?cs(e,i,s):s({})}}}function pp(e){return up.includes(e)}function dp(e,t){return Ke(re("fields",()=>{let r=e._runtimeDataModel.models[t];return ps(t,r)}))}m();c();p();d();f();function ms(e){return e.replace(/^./,t=>t.toUpperCase())}var Vn=Symbol();function Yt(e){let t=[fp(e),mp(e),re(Vn,()=>e),re("$parent",()=>e._appliedParent)],r=e._extensions.getAllClientExtensions();return r&&t.push(Ht(r)),me(e,t)}function fp(e){let t=Object.getPrototypeOf(e._originalClient),r=[...new Set(Object.getOwnPropertyNames(t))];return{getKeys(){return r},getPropertyValue(n){return e[n]}}}function mp(e){let t=Object.keys(e._runtimeDataModel.models),r=t.map(Pe),n=[...new Set(t.concat(r))];return Ke({getKeys(){return n},getPropertyValue(i){let o=ms(i);if(e._runtimeDataModel.models[o]!==void 0)return Un(e,o);if(e._runtimeDataModel.models[i]!==void 0)return Un(e,i)},getPropertyDescriptor(i){if(!r.includes(i))return{enumerable:!1}}})}function gs(e){return e[Vn]?e[Vn]:e}function hs(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let r=e.client.__AccelerateEngine;this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}let t=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return Yt(t)}m();c();p();d();f();m();c();p();d();f();function ys({result:e,modelName:t,select:r,omit:n,extensions:i}){let o=i.getAllComputedFields(t);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(g=>n[g]);u.length>0&&a.push(bt(u))}else if(r){if(!r[l.name])continue;let u=l.needs.filter(g=>!r[g]);u.length>0&&a.push(bt(u))}gp(e,l.needs)&&s.push(hp(l,me(e,s)))}return s.length>0||a.length>0?me(e,[...s,...a]):e}function gp(e,t){return t.every(r=>bn(e,r))}function hp(e,t){return Ke(re(e.name,()=>e.compute(t)))}m();c();p();d();f();function Ur({visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){if(Array.isArray(t)){for(let s=0;s<t.length;s++)t[s]=Ur({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});return t}let o=e(t,i,r)??t;return r.include&&ws({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&&ws({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}function ws({includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||t[o]==null||ve(s))continue;let l=n.models[r].fields.find(g=>g.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};t[o]=Ur({visitor:i,result:t[o],args:u,modelName:l.type,runtimeDataModel:n})}}function bs({result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:Ur({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:(a,l,u)=>{let g=Pe(l);return ys({result:a,modelName:g,select:u.select,omit:u.select?void 0:{...o?.[g],...u.omit},extensions:n})}})}m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();var yp=["$connect","$disconnect","$on","$transaction","$use","$extends"],Es=yp;function xs(e){if(e instanceof ae)return wp(e);if(Lr(e))return bp(e);if(Array.isArray(e)){let r=[e[0]];for(let n=1;n<e.length;n++)r[n]=Zt(e[n]);return r}let t={};for(let r in e)t[r]=Zt(e[r]);return t}function wp(e){return new ae(e.strings,e.values)}function bp(e){return new Kt(e.sql,e.values)}function Zt(e){if(typeof e!="object"||e==null||e instanceof Ie||gt(e))return e;if(ut(e))return new be(e.toFixed());if(lt(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let t=e.length,r;for(r=Array(t);t--;)r[t]=Zt(e[t]);return r}if(typeof e=="object"){let t={};for(let r in e)r==="__proto__"?Object.defineProperty(t,r,{value:Zt(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=Zt(e[r]);return t}Me(e,"Unknown value")}function vs(e,t,r,n=0){return e._createPrismaPromise(i=>{let o=t.customDataProxyFetch;return"transaction"in t&&i!==void 0&&(t.transaction?.kind==="batch"&&t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:xs(t.args??{}),__internalParams:t,query:(s,a=t)=>{let l=a.customDataProxyFetch;return a.customDataProxyFetch=Ss(o,l),a.args=s,vs(e,a,r,n+1)}})})}function Ts(e,t){let{jsModelName:r,action:n,clientMethod:i}=t,o=r?n:i;if(e._extensions.isEmpty())return e._executeRequest(t);let s=e._extensions.getAllQueryCallbacks(r??"$none",o);return vs(e,t,s)}function Cs(e){return t=>{let r={requests:t},n=t[0].extensions.getAllBatchQueryCallbacks();return n.length?As(r,n,0,e):e(r)}}function As(e,t,r,n){if(r===t.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return t[r]({args:{queries:e.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=Ss(i,l),As(a,t,r+1,n)}})}var Ps=e=>e;function Ss(e=Ps,t=Ps){return r=>e(t(r))}m();c();p();d();f();var Rs=K("prisma:client"),ks={Vercel:"vercel","Netlify CI":"netlify"};function Os({postinstall:e,ciName:t,clientVersion:r}){if(Rs("checkPlatformCaching:postinstall",e),Rs("checkPlatformCaching:ciName",t),e===!0&&t&&t in ks){let n=`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ks[t]}-build`;throw console.error(n),new V(n,r)}}m();c();p();d();f();function Ms(e,t){return e?e.datasources?e.datasources:e.datasourceUrl?{[t[0]]:{url:e.datasourceUrl}}:{}:{}}m();c();p();d();f();m();c();p();d();f();var Ep=()=>globalThis.process?.release?.name==="node",xp=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,Pp=()=>!!globalThis.Deno,vp=()=>typeof globalThis.Netlify=="object",Tp=()=>typeof globalThis.EdgeRuntime=="object",Cp=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function Ap(){return[[vp,"netlify"],[Tp,"edge-light"],[Cp,"workerd"],[Pp,"deno"],[xp,"bun"],[Ep,"node"]].flatMap(r=>r[0]()?[r[1]]:[]).at(0)??""}var Sp={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function Fs(){let e=Ap();return{id:e,prettyName:Sp[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}m();c();p();d();f();m();c();p();d();f();var Qn=Se(yn());m();c();p();d();f();function Is(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,t=>`${t[0]}5`):""}m();c();p();d();f();function _s(e){return e.split(`
`).map(t=>t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).join(`
`)}m();c();p();d();f();var Ls=Se(Zi());function Ns({title:e,user:t="prisma",repo:r="prisma",template:n="bug_report.yml",body:i}){return(0,Ls.default)({user:t,repo:r,template:n,title:e,body:i})}function Ds({version:e,binaryTarget:t,title:r,description:n,engineVersion:i,database:o,query:s}){let a=Ii(6e3-(s?.length??0)),l=_s((0,Qn.default)(a)),u=n?`# Description
\`\`\`
${n}
\`\`\``:"",g=(0,Qn.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${y.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s?Is(s):""}
\`\`\`
`),h=Ns({title:r,body:g});return`${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${At(h)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}m();c();p();d();f();function Vr({inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=t[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw new V(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new V("error: Missing URL environment variable, value, or override.",n);return i}m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();m();c();p();d();f();function Gn(e){return e.name==="DriverAdapterError"&&typeof e.cause=="object"}m();c();p();d();f();function Qr(e){return{ok:!0,value:e,map(t){return Qr(t(e))},flatMap(t){return t(e)}}}function He(e){return{ok:!1,error:e,map(){return He(e)},flatMap(){return He(e)}}}var qs=K("driver-adapter-utils"),Jn=class{registeredErrors=[];consumeError(t){return this.registeredErrors[t]}registerNewError(t){let r=0;for(;this.registeredErrors[r]!==void 0;)r++;return this.registeredErrors[r]={error:t},r}};var Wn=(e,t=new Jn)=>{let r={adapterName:e.adapterName,errorRegistry:t,queryRaw:_e(t,e.queryRaw.bind(e)),executeRaw:_e(t,e.executeRaw.bind(e)),executeScript:_e(t,e.executeScript.bind(e)),dispose:_e(t,e.dispose.bind(e)),provider:e.provider,startTransaction:async(...n)=>(await _e(t,e.startTransaction.bind(e))(...n)).map(o=>Rp(t,o))};return e.getConnectionInfo&&(r.getConnectionInfo=kp(t,e.getConnectionInfo.bind(e))),r},Rp=(e,t)=>({adapterName:t.adapterName,provider:t.provider,options:t.options,queryRaw:_e(e,t.queryRaw.bind(t)),executeRaw:_e(e,t.executeRaw.bind(t)),commit:_e(e,t.commit.bind(t)),rollback:_e(e,t.rollback.bind(t))});function _e(e,t){return async(...r)=>{try{return Qr(await t(...r))}catch(n){if(qs("[error@wrapAsync]",n),Gn(n))return He(n.cause);let i=e.registerNewError(n);return He({kind:"GenericJs",id:i})}}}function kp(e,t){return(...r)=>{try{return Qr(t(...r))}catch(n){if(qs("[error@wrapSync]",n),Gn(n))return He(n.cause);let i=e.registerNewError(n);return He({kind:"GenericJs",id:i})}}}m();c();p();d();f();function $s(e){if(e?.kind==="itx")return e.options.id}m();c();p();d();f();var Kn=class{engineObject;constructor(t,r,n){this.engineObject=__PrismaProxy.create({datamodel:t.datamodel,env:y.env,ignoreEnvVarErrors:!0,datasourceOverrides:t.datasourceOverrides??{},logLevel:t.logLevel,logQueries:t.logQueries??!1,logCallback:r,enableTracing:t.enableTracing})}async connect(t,r){return __PrismaProxy.connect(this.engineObject,t,r)}async disconnect(t,r){return __PrismaProxy.disconnect(this.engineObject,t,r)}query(t,r,n,i){return __PrismaProxy.execute(this.engineObject,t,r,n,i)}compile(){throw new Error("not implemented")}sdlSchema(){return Promise.resolve("{}")}dmmf(t){return Promise.resolve("{}")}async startTransaction(t,r,n){return __PrismaProxy.startTransaction(this.engineObject,t,r,n)}async commitTransaction(t,r,n){return __PrismaProxy.commitTransaction(this.engineObject,t,r,n)}async rollbackTransaction(t,r,n){return __PrismaProxy.rollbackTransaction(this.engineObject,t,r,n)}metrics(t){return Promise.resolve("{}")}async applyPendingMigrations(){return __PrismaProxy.applyPendingMigrations(this.engineObject)}trace(t){return __PrismaProxy.trace(this.engineObject,t)}},js={async loadLibrary(e){if(!__PrismaProxy)throw new V("__PrismaProxy not detected make sure React Native bindings are installed",e.clientVersion);return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:Kn}}};var Op="P2036",Te=K("prisma:client:libraryEngine");function Mp(e){return e.item_type==="query"&&"query"in e}function Fp(e){return"level"in e?e.level==="error"&&e.message==="PANIC":!1}var z2=[...pn,"native"],Ip=0xffffffffffffffffn,Hn=1n;function _p(){let e=Hn++;return Hn>Ip&&(Hn=1n),e}var Xt=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(t,r){this.libraryLoader=js,this.config=t,this.libraryStarted=!1,this.logQueries=t.logQueries??!1,this.logLevel=t.logLevel??"error",this.logEmitter=t.logEmitter,this.datamodel=t.inlineSchema,this.tracingHelper=t.tracingHelper,t.enableDebugLogs&&(this.logLevel="debug");let n=Object.keys(t.overrideDatasources)[0],i=t.overrideDatasources[n]?.url;n!==void 0&&i!==void 0&&(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(t){return{applyPendingMigrations:t.applyPendingMigrations?.bind(t),commitTransaction:this.withRequestId(t.commitTransaction.bind(t)),connect:this.withRequestId(t.connect.bind(t)),disconnect:this.withRequestId(t.disconnect.bind(t)),metrics:t.metrics?.bind(t),query:this.withRequestId(t.query.bind(t)),rollbackTransaction:this.withRequestId(t.rollbackTransaction.bind(t)),sdlSchema:t.sdlSchema?.bind(t),startTransaction:this.withRequestId(t.startTransaction.bind(t)),trace:t.trace.bind(t)}}withRequestId(t){return async(...r)=>{let n=_p().toString();try{return await t(...r,n)}finally{if(this.tracingHelper.isEnabled()){let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}}}async applyPendingMigrations(){await this.start(),await this.engine?.applyPendingMigrations()}async transaction(t,r,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(r),s;if(t==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else t==="commit"?s=await this.engine?.commitTransaction(n.id,o):t==="rollback"&&(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(Lp(a)){let l=this.getExternalAdapterError(a,i?.errorRegistry);throw l?l.error:new oe(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new G(a.message,{clientVersion:this.config.clientVersion});return a}async instantiateLibrary(){if(Te("internalSetup"),this.libraryInstantiationPromise)return this.libraryInstantiationPromise;this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=>this.loadEngine()),this.version()}async getCurrentBinaryTarget(){}parseEngineResponse(t){if(!t)throw new G("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(t)}catch{throw new G("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let t=new b(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(Wn));let r=await this.adapterPromise;r&&Te("Using driver adapter: %O",r),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:y.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=>{t.deref()?.logger(n)},r))}catch(t){let r=t,n=this.parseInitError(r.message);throw typeof n=="string"?r:new V(n.message,this.config.clientVersion,n.error_code)}}}logger(t){let r=this.parseEngineResponse(t);r&&(r.level=r?.level.toLowerCase()??"unknown",Mp(r)?this.logEmitter.emit("query",{timestamp:new Date,query:r.query,params:r.params,duration:Number(r.duration_ms),target:r.module_path}):Fp(r)?this.loggerRustPanic=new ue(zn(this,`${r.message}: ${r.reason} in ${r.file}:${r.line}:${r.column}`),this.config.clientVersion):this.logEmitter.emit(r.level,{timestamp:new Date,message:r.message,target:r.module_path}))}parseInitError(t){try{return JSON.parse(t)}catch{}return t}parseRequestError(t){try{return JSON.parse(t)}catch{}return t}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}async start(){if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return Te(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let t=async()=>{Te("library starting");try{let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(r)),this.libraryStarted=!0,Te("library started")}catch(r){let n=this.parseInitError(r.message);throw typeof n=="string"?r:new V(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",t),this.libraryStartingPromise}async stop(){if(await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Te("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted)return;let t=async()=>{await new Promise(n=>setTimeout(n,5)),Te("library stopping");let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(r)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Te("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",t),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}debugPanic(t){return this.library?.debugPanic(t)}async request(t,{traceparent:r,interactiveTransaction:n}){Te(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:r}),o=JSON.stringify(t);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new G(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:a}}catch(s){if(s instanceof V)throw s;if(s.code==="GenericFailure"&&s.message?.startsWith("PANIC:"))throw new ue(zn(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new G(`${a.message}
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(t,{transaction:r,traceparent:n}){Te("requestBatch");let i=$r(t,r);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),$s(r));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new G(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:l,errors:u}=a;if(Array.isArray(l))return l.map(g=>g.errors&&g.errors.length>0?this.loggerRustPanic??this.buildQueryError(g.errors[0],o?.errorRegistry):{data:g});throw u&&u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}buildQueryError(t,r){if(t.user_facing_error.is_panic)return new ue(zn(this,t.user_facing_error.message),this.config.clientVersion);let n=this.getExternalAdapterError(t.user_facing_error,r);return n?n.error:jr(t,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(t,r){if(t.error_code===Op&&r){let n=t.meta?.id;sr(typeof n=="number","Malformed external JS error received from the engine");let i=r.consumeError(n);return sr(i,"External error with reported id was not registered"),i}}async metrics(t){await this.start();let r=await this.engine.metrics(JSON.stringify(t));return t.format==="prometheus"?r:this.parseEngineResponse(r)}};function Lp(e){return typeof e=="object"&&e!==null&&e.error_code!==void 0}function zn(e,t){return Ds({binaryTarget:e.binaryTarget,title:t,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}function Bs({copyEngine:e=!0},t){let r;try{r=Vr({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...y.env},clientVersion:t.clientVersion})}catch{}let n=!!(r?.startsWith("prisma://")||gn(r));e&&n&&_t("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");let i=nt(t.generator),o=n||!e,s=!!t.adapter,a=i==="library",l=i==="binary",u=i==="client";if(o&&s||s&&!1){let g;throw e?r?.startsWith("prisma://")?g=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:g=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:g=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new ee(g.join(`
`),{clientVersion:t.clientVersion})}return new Xt(t)}m();c();p();d();f();function Gr({generator:e}){return e?.previewFeatures??[]}m();c();p();d();f();var Us=e=>({command:e});m();c();p();d();f();m();c();p();d();f();var Vs=e=>e.strings.reduce((t,r,n)=>`${t}@P${n}${r}`);m();c();p();d();f();function xt(e){try{return Qs(e,"fast")}catch{return Qs(e,"slow")}}function Qs(e,t){return JSON.stringify(e.map(r=>Js(r,t)))}function Js(e,t){if(Array.isArray(e))return e.map(r=>Js(r,t));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(lt(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(be.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(w.Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(Np(e))return{prisma__type:"bytes",prisma__value:w.Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:w.Buffer.from(r,n,i).toString("base64")}}return typeof e=="object"&&t==="slow"?Ws(e):e}function Np(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&&e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Ws(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Gs);let t={};for(let r of Object.keys(e))t[r]=Gs(e[r]);return t}function Gs(e){return typeof e=="bigint"?e.toString():Ws(e)}var Dp=/^(\s*alter\s)/i,Ks=K("prisma:client");function Yn(e,t,r,n){if(!(e!=="postgresql"&&e!=="cockroachdb")&&r.length>0&&Dp.exec(t))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var Zn=({clientMethod:e,activeProvider:t})=>r=>{let n="",i;if(Lr(r))n=r.sql,i={values:xt(r.values),__prismaRawParameters__:!0};else if(Array.isArray(r)){let[o,...s]=r;n=o,i={values:xt(s||[]),__prismaRawParameters__:!0}}else switch(t){case"sqlite":case"mysql":{n=r.sql,i={values:xt(r.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=r.text,i={values:xt(r.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=Vs(r),i={values:xt(r.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${t} provider does not support ${e}`)}return i?.values?Ks(`prisma.${e}(${n}, ${i.values})`):Ks(`prisma.${e}(${n})`),{query:n,parameters:i}},Hs={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[t,...r]=e;return new ae(t,r)}},zs={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};m();c();p();d();f();function Xn(e){return function(r,n){let i,o=(s=e)=>{try{return s===void 0||s?.kind==="itx"?i??=Ys(r(s)):Ys(r(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function Ys(e){return typeof e.then=="function"?e:Promise.resolve(e)}m();c();p();d();f();var qp=fn.split(".")[0],$p={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,t){return t()}},ei=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(t){return this.getGlobalTracingHelper().getTraceParent(t)}dispatchEngineSpans(t){return this.getGlobalTracingHelper().dispatchEngineSpans(t)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(t,r){return this.getGlobalTracingHelper().runInChildSpan(t,r)}getGlobalTracingHelper(){let t=globalThis[`V${qp}_PRISMA_INSTRUMENTATION`],r=globalThis.PRISMA_INSTRUMENTATION;return t?.helper??r?.helper??$p}};function Zs(){return new ei}m();c();p();d();f();function Xs(e,t=()=>{}){let r,n=new Promise(i=>r=i);return{then(i){return--e===0&&r(t()),i?.(n)}}}m();c();p();d();f();function ea(e){return typeof e=="string"?e:e.reduce((t,r)=>{let n=typeof r=="string"?r:r.level;return n==="query"?t:t&&(r==="info"||t==="info")?"info":n},void 0)}m();c();p();d();f();var Jr=class{_middlewares=[];use(t){this._middlewares.push(t)}get(t){return this._middlewares[t]}has(t){return!!this._middlewares[t]}length(){return this._middlewares.length}};m();c();p();d();f();var ra=Se(yn());m();c();p();d();f();function Wr(e){return typeof e.batchRequestIdx=="number"}m();c();p();d();f();function ta(e){if(e.action!=="findUnique"&&e.action!=="findUniqueOrThrow")return;let t=[];return e.modelName&&t.push(e.modelName),e.query.arguments&&t.push(ti(e.query.arguments)),t.push(ti(e.query.selection)),t.join("")}function ti(e){return`(${Object.keys(e).sort().map(r=>{let n=e[r];return typeof n=="object"&&n!==null?`(${r} ${ti(n)})`:r}).join(" ")})`}m();c();p();d();f();var jp={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function ri(e){return jp[e]}m();c();p();d();f();var Kr=class{constructor(t){this.options=t;this.batches={}}batches;tickActive=!1;request(t){let r=this.options.batchBy(t);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,y.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[r].push({request:t,resolve:n,reject:i})})):this.options.singleLoader(t)}dispatchBatches(){for(let t in this.batches){let r=this.batches[t];delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(n=>{n instanceof Error?r[0].reject(n):r[0].resolve(n)}).catch(n=>{r[0].reject(n)}):(r.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(r.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<r.length;i++)r[i].reject(n);else for(let i=0;i<r.length;i++){let o=n[i];o instanceof Error?r[i].reject(o):r[i].resolve(o)}}).catch(n=>{for(let i=0;i<r.length;i++)r[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};m();c();p();d();f();function ze(e,t){if(t===null)return t;switch(e){case"bigint":return BigInt(t);case"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=w.Buffer.from(t,"base64");return new Uint8Array(r,n,i)}case"decimal":return new be(t);case"datetime":case"date":return new Date(t);case"time":return new Date(`1970-01-01T${t}Z`);case"bigint-array":return t.map(r=>ze("bigint",r));case"bytes-array":return t.map(r=>ze("bytes",r));case"decimal-array":return t.map(r=>ze("decimal",r));case"datetime-array":return t.map(r=>ze("datetime",r));case"date-array":return t.map(r=>ze("date",r));case"time-array":return t.map(r=>ze("time",r));default:return t}}function Hr(e){let t=[],r=Bp(e);for(let n=0;n<e.rows.length;n++){let i=e.rows[n],o={...r};for(let s=0;s<i.length;s++)o[e.columns[s]]=ze(e.types[s],i[s]);t.push(o)}return t}function Bp(e){let t={};for(let r=0;r<e.columns.length;r++)t[e.columns[r]]=null;return t}var Up=K("prisma:client:request_handler"),zr=class{client;dataloader;logEmitter;constructor(t,r){this.logEmitter=r,this.client=t,this.dataloader=new Kr({batchLoader:Cs(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(h=>h.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(h=>ri(h.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Vp(o),containsWrite:u,customDataProxyFetch:i})).map((h,v)=>{if(h instanceof Error)return h;try{return this.mapQueryEngineResult(n[v],h)}catch(R){return R}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?na(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:ri(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:ta(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(t){try{return await this.dataloader.request(t)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=t;this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}}mapQueryEngineResult({dataPath:t,unpacker:r},n){let i=n?.data,o=this.unpack(i,t,r);return y.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(t){try{this.handleRequestError(t)}catch(r){throw this.logEmitter&&this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}}handleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(Up(t),Qp(t,i))throw t;if(t instanceof oe&&Gp(t)){let u=ia(t.meta);kr({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}let l=t.message;if(n&&(l=br({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let u=s?{modelName:s,...t.meta}:t.meta;throw new oe(l,{code:t.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:t.batchRequestIdx})}else{if(t.isPanic)throw new ue(l,this.client._clientVersion);if(t instanceof G)throw new G(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});if(t instanceof V)throw new V(l,this.client._clientVersion);if(t instanceof ue)throw new ue(l,this.client._clientVersion)}throw t.clientVersion=this.client._clientVersion,t}sanitizeMessage(t){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,ra.default)(t):t}unpack(t,r,n){if(!t||(t.data&&(t=t.data),!t))return t;let i=Object.keys(t)[0],o=Object.values(t)[0],s=r.filter(u=>u!=="select"&&u!=="include"),a=jn(o,s),l=i==="queryRaw"?Hr(a):at(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function Vp(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:na(e)};Me(e,"Unknown transaction kind")}}function na(e){return{id:e.id,payload:e.payload}}function Qp(e,t){return Wr(e)&&t?.kind==="batch"&&e.batchRequestIdx!==t.index}function Gp(e){return e.code==="P2009"||e.code==="P2012"}function ia(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(ia)};if(Array.isArray(e.selectionPath)){let[,...t]=e.selectionPath;return{...e,selectionPath:t}}return e}m();c();p();d();f();var oa="6.6.0";var sa=oa;m();c();p();d();f();var pa=Se(Sn());m();c();p();d();f();var q=class extends Error{constructor(t){super(t+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};le(q,"PrismaClientConstructorValidationError");var aa=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],la=["pretty","colorless","minimal"],ua=["info","query","warn","error"],Wp={datasources:(e,{datasourceNames:t})=>{if(e){if(typeof e!="object"||Array.isArray(e))throw new q(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[r,n]of Object.entries(e)){if(!t.includes(r)){let i=Pt(r,t)||` Available datasources: ${t.join(", ")}`;throw new q(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new q(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,t)=>{if(!e&&nt(t.generator)==="client")throw new q('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Gr(t).includes("driverAdapters"))throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(nt(t.generator)==="binary")throw new q('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=>{if(typeof e<"u"&&typeof e!="string")throw new q(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=>{if(e){if(typeof e!="string")throw new q(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!la.includes(e)){let t=Pt(e,la);throw new q(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}}},log:e=>{if(!e)return;if(!Array.isArray(e))throw new q(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function t(r){if(typeof r=="string"&&!ua.includes(r)){let n=Pt(r,ua);throw new q(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}}for(let r of e){t(r);let n={level:t,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=Pt(i,o);throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(r&&typeof r=="object")for(let[i,o]of Object.entries(r))if(n[i])n[i](o);else throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=>{if(!e)return;let t=e.maxWait;if(t!=null&&t<=0)throw new q(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let r=e.timeout;if(r!=null&&r<=0)throw new q(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,t)=>{if(typeof e!="object")throw new q('"omit" option is expected to be an object.');if(e===null)throw new q('"omit" option can not be `null`');let r=[];for(let[n,i]of Object.entries(e)){let o=Hp(n,t.runtimeDataModel);if(!o){r.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=>u.name===s);if(!l){r.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(r.length>0)throw new q(zp(e,r))},__internal:e=>{if(!e)return;let t=["debug","engine","configOverride"];if(typeof e!="object")throw new q(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[r]of Object.entries(e))if(!t.includes(r)){let n=Pt(r,t);throw new q(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function da(e,t){for(let[r,n]of Object.entries(e)){if(!aa.includes(r)){let i=Pt(r,aa);throw new q(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}Wp[r](n,t)}if(e.datasourceUrl&&e.datasources)throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function Pt(e,t){if(t.length===0||typeof e!="string")return"";let r=Kp(e,t);return r?` Did you mean "${r}"?`:""}function Kp(e,t){if(t.length===0)return null;let r=t.map(i=>({value:i,distance:(0,pa.default)(e,i)}));r.sort((i,o)=>i.distance<o.distance?-1:1);let n=r[0];return n.distance<3?n.value:null}function Hp(e,t){return ca(t.models,e)??ca(t.types,e)}function ca(e,t){let r=Object.keys(e).find(n=>je(n)===t);if(r)return e[r]}function zp(e,t){let r=ht(e);for(let o of t)switch(o.kind){case"UnknownModel":r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=Rr(r,"colorless");return`Error validating "omit" option:

${i}

${n}`}m();c();p();d();f();function fa(e){return e.length===0?Promise.resolve([]):new Promise((t,r)=>{let n=new Array(e.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===e.length&&(o=!0,i?r(i):t(n)))},l=u=>{o||(o=!0,r(u))};for(let u=0;u<e.length;u++)e[u].then(g=>{n[u]=g,a()},g=>{if(!Wr(g)){l(g);return}g.batchRequestIdx===u?l(g):(i||(i=g),a())})})}var Ve=K("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var Yp={requestArgsToMiddlewareArgs:e=>e,middlewareArgsToRequestArgs:e=>e},Zp=Symbol.for("prisma.client.transaction.id"),Xp={id:0,nextId(){return++this.id}};function ha(e){class t{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new Jr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=Xn();constructor(n){e=n?.__internal?.configOverride?.(e)??e,Os(e),n&&da(n,e);let i=new Nr().on("error",()=>{});this._extensions=yt.empty(),this._previewFeatures=Gr(e),this._clientVersion=e.clientVersion??sa,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Zs();let o=e.relativeEnvPaths&&{rootEnvPath:e.relativeEnvPaths.rootEnvPath&&Oe.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&&Oe.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"?"postgres":e.activeProvider;if(s.provider!==l)throw new V(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new V("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=e.injectableEdgeEnv?.();try{let l=n??{},u=l.__internal??{},g=u.debug===!0;g&&K.enable("prisma:client");let h=Oe.resolve(e.dirname,e.relativePath);or.existsSync(h)||(h=e.dirname),Ve("dirname",e.dirname),Ve("relativePath",e.relativePath),Ve("cwd",h);let v=u.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat:y.env.NODE_ENV==="production"?this._errorFormat="minimal":y.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:h,dirname:e.dirname,enableDebugLogs:g,allowTriggerPanic:v.allowTriggerPanic,prismaPath:v.binaryPath??void 0,engineEndpoint:v.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&&ea(l.log),logQueries:l.log&&!!(typeof l.log=="string"?l.log==="query":l.log.find(R=>typeof R=="string"?R==="query":R.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Ms(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:Vr,getBatchRequestPayload:$r,prismaGraphQLToJSError:jr,PrismaClientUnknownRequestError:G,PrismaClientInitializationError:V,PrismaClientKnownRequestError:oe,debug:K("prisma:client:accelerateEngine"),engineVersion:ga.version,clientVersion:e.clientVersion}},Ve("clientVersion",e.clientVersion),this._engine=Bs(e,this._engineConfig),this._requestHandler=new zr(this,i),l.log)for(let R of l.log){let C=typeof R=="string"?R:R.emit==="stdout"?R.level:null;C&&this.$on(C,A=>{It.log(`${It.tags[C]??""}`,A.message||A.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=Yt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{_i()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Zn({clientMethod:i,activeProvider:a}),callsite:Ue(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=ma(n,i);return Yn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new ee("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(Yn(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new ee(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:Us,callsite:Ue(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Zn({clientMethod:i,activeProvider:a}),callsite:Ue(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...ma(n,i));throw new ee("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new ee("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=Xp.nextId(),s=Xs(n.length),a=n.map((l,u)=>{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let g=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,h={kind:"batch",id:o,index:u,isolationLevel:g,lock:s};return l.requestTransaction?.(h)??l});return fa(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),u}return l}_createItxClient(n){return me(Yt(me(gs(this),[re("_appliedParent",()=>this._appliedParent._createItxClient(n)),re("_createPrismaPromise",()=>Xn(n)),re(Zp,()=>n.id)])),[bt(Es)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Yp,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async u=>{let g=this._middlewares.get(++a);if(g)return this._tracingHelper.runInChildSpan(s.middleware,M=>g(u,I=>(M?.end(),l(I))));let{runInTransaction:h,args:v,...R}=u,C={...n,...R};v&&(C.args=i.middlewareArgsToRequestArgs(v)),n.transaction!==void 0&&h===!1&&delete C.transaction;let A=await Ts(this,C);return C.model?bs({result:A,modelName:C.model,args:C.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):A};return this._tracingHelper.runInChildSpan(s.operation,()=>l(o))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:g,unpacker:h,otelParentCtx:v,customDataProxyFetch:R}){try{n=u?u(n):n;let C={name:"serialize"},A=this._tracingHelper.runInChildSpan(C,()=>Ir({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return K.enabled("prisma:client")&&(Ve("Prisma Client call:"),Ve(`prisma.${i}(${is(n)})`),Ve("Generated request:"),Ve(JSON.stringify(A,null,2)+`
`)),g?.kind==="batch"&&await g.lock,this._requestHandler.request({protocolQuery:A,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:g,unpacker:h,otelParentCtx:v,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:R})}catch(C){throw C.clientVersion=this._clientVersion,C}}$metrics=new wt(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=hs}return t}function ma(e,t){return ed(e)?[new ae(e,t),Hs]:[e,zs]}function ed(e){return Array.isArray(e)&&Array.isArray(e.raw)}m();c();p();d();f();var td=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function ya(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(!td.has(r))throw new TypeError(`Invalid enum value: ${String(r)}`)}})}m();c();p();d();f();0&&(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});
//# sourceMappingURL=react-native.js.map

```

## 📄 lib\generated\prisma\runtime\wasm.js

```js
"use strict";var Yo=Object.create;var Ot=Object.defineProperty;var Xo=Object.getOwnPropertyDescriptor;var Zo=Object.getOwnPropertyNames;var es=Object.getPrototypeOf,ts=Object.prototype.hasOwnProperty;var ne=(t,e)=>()=>(t&&(e=t(t=0)),e);var Le=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),rt=(t,e)=>{for(var r in e)Ot(t,r,{get:e[r],enumerable:!0})},cn=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Zo(e))!ts.call(t,i)&&i!==r&&Ot(t,i,{get:()=>e[i],enumerable:!(n=Xo(e,i))||n.enumerable});return t};var nt=(t,e,r)=>(r=t!=null?Yo(es(t)):{},cn(e||!t||!t.__esModule?Ot(r,"default",{value:t,enumerable:!0}):r,t)),rs=t=>cn(Ot({},"__esModule",{value:!0}),t);function Er(t,e){if(e=e.toLowerCase(),e==="utf8"||e==="utf-8")return new y(ss.encode(t));if(e==="base64"||e==="base64url")return t=t.replace(/-/g,"+").replace(/_/g,"/"),t=t.replace(/[^A-Za-z0-9+/]/g,""),new y([...atob(t)].map(r=>r.charCodeAt(0)));if(e==="binary"||e==="ascii"||e==="latin1"||e==="latin-1")return new y([...t].map(r=>r.charCodeAt(0)));if(e==="ucs2"||e==="ucs-2"||e==="utf16le"||e==="utf-16le"){let r=new y(t.length*2),n=new DataView(r.buffer);for(let i=0;i<t.length;i++)n.setUint16(i*2,t.charCodeAt(i),!0);return r}if(e==="hex"){let r=new y(t.length/2);for(let n=0,i=0;i<t.length;i+=2,n++)r[n]=parseInt(t.slice(i,i+2),16);return r}pn(`encoding "${e}"`)}function ns(t){let r=Object.getOwnPropertyNames(DataView.prototype).filter(a=>a.startsWith("get")||a.startsWith("set")),n=r.map(a=>a.replace("get","read").replace("set","write")),i=(a,f)=>function(h=0){return B(h,"offset"),Y(h,"offset"),V(h,"offset",this.length-1),new DataView(this.buffer)[r[a]](h,f)},o=(a,f)=>function(h,T=0){let C=r[a].match(/set(\w+\d+)/)[1].toLowerCase(),k=os[C];return B(T,"offset"),Y(T,"offset"),V(T,"offset",this.length-1),is(h,"value",k[0],k[1]),new DataView(this.buffer)[r[a]](T,h,f),T+parseInt(r[a].match(/\d+/)[0])/8},s=a=>{a.forEach(f=>{f.includes("Uint")&&(t[f.replace("Uint","UInt")]=t[f]),f.includes("Float64")&&(t[f.replace("Float64","Double")]=t[f]),f.includes("Float32")&&(t[f.replace("Float32","Float")]=t[f])})};n.forEach((a,f)=>{a.startsWith("read")&&(t[a]=i(f,!1),t[a+"LE"]=i(f,!0),t[a+"BE"]=i(f,!1)),a.startsWith("write")&&(t[a]=o(f,!1),t[a+"LE"]=o(f,!0),t[a+"BE"]=o(f,!1)),s([a,a+"LE",a+"BE"])})}function pn(t){throw new Error(`Buffer polyfill does not implement "${t}"`)}function Mt(t,e){if(!(t instanceof Uint8Array))throw new TypeError(`The "${e}" argument must be an instance of Buffer or Uint8Array`)}function V(t,e,r=us+1){if(t<0||t>r){let n=new RangeError(`The value of "${e}" is out of range. It must be >= 0 && <= ${r}. Received ${t}`);throw n.code="ERR_OUT_OF_RANGE",n}}function B(t,e){if(typeof t!="number"){let r=new TypeError(`The "${e}" argument must be of type number. Received type ${typeof t}.`);throw r.code="ERR_INVALID_ARG_TYPE",r}}function Y(t,e){if(!Number.isInteger(t)||Number.isNaN(t)){let r=new RangeError(`The value of "${e}" is out of range. It must be an integer. Received ${t}`);throw r.code="ERR_OUT_OF_RANGE",r}}function is(t,e,r,n){if(t<r||t>n){let i=new RangeError(`The value of "${e}" is out of range. It must be >= ${r} and <= ${n}. Received ${t}`);throw i.code="ERR_OUT_OF_RANGE",i}}function mn(t,e){if(typeof t!="string"){let r=new TypeError(`The "${e}" argument must be of type string. Received type ${typeof t}`);throw r.code="ERR_INVALID_ARG_TYPE",r}}function cs(t,e="utf8"){return y.from(t,e)}var y,os,ss,as,ls,us,b,xr,u=ne(()=>{"use strict";y=class t extends Uint8Array{_isBuffer=!0;get offset(){return this.byteOffset}static alloc(e,r=0,n="utf8"){return mn(n,"encoding"),t.allocUnsafe(e).fill(r,n)}static allocUnsafe(e){return t.from(e)}static allocUnsafeSlow(e){return t.from(e)}static isBuffer(e){return e&&!!e._isBuffer}static byteLength(e,r="utf8"){if(typeof e=="string")return Er(e,r).byteLength;if(e&&e.byteLength)return e.byteLength;let n=new TypeError('The "string" argument must be of type string or an instance of Buffer or ArrayBuffer.');throw n.code="ERR_INVALID_ARG_TYPE",n}static isEncoding(e){return ls.includes(e)}static compare(e,r){Mt(e,"buff1"),Mt(r,"buff2");for(let n=0;n<e.length;n++){if(e[n]<r[n])return-1;if(e[n]>r[n])return 1}return e.length===r.length?0:e.length>r.length?1:-1}static from(e,r="utf8"){if(e&&typeof e=="object"&&e.type==="Buffer")return new t(e.data);if(typeof e=="number")return new t(new Uint8Array(e));if(typeof e=="string")return Er(e,r);if(ArrayBuffer.isView(e)){let{byteOffset:n,byteLength:i,buffer:o}=e;return"map"in e&&typeof e.map=="function"?new t(e.map(s=>s%256),n,i):new t(o,n,i)}if(e&&typeof e=="object"&&("length"in e||"byteLength"in e||"buffer"in e))return new t(e);throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}static concat(e,r){if(e.length===0)return t.alloc(0);let n=[].concat(...e.map(o=>[...o])),i=t.alloc(r!==void 0?r:n.length);return i.set(r!==void 0?n.slice(0,r):n),i}slice(e=0,r=this.length){return this.subarray(e,r)}subarray(e=0,r=this.length){return Object.setPrototypeOf(super.subarray(e,r),t.prototype)}reverse(){return super.reverse(),this}readIntBE(e,r){B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");let n=new DataView(this.buffer,e,r),i=0;for(let o=0;o<r;o++)i=i*256+n.getUint8(o);return n.getUint8(0)&128&&(i-=Math.pow(256,r)),i}readIntLE(e,r){B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");let n=new DataView(this.buffer,e,r),i=0;for(let o=0;o<r;o++)i+=n.getUint8(o)*Math.pow(256,o);return n.getUint8(r-1)&128&&(i-=Math.pow(256,r)),i}readUIntBE(e,r){B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");let n=new DataView(this.buffer,e,r),i=0;for(let o=0;o<r;o++)i=i*256+n.getUint8(o);return i}readUintBE(e,r){return this.readUIntBE(e,r)}readUIntLE(e,r){B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");let n=new DataView(this.buffer,e,r),i=0;for(let o=0;o<r;o++)i+=n.getUint8(o)*Math.pow(256,o);return i}readUintLE(e,r){return this.readUIntLE(e,r)}writeIntBE(e,r,n){return e=e<0?e+Math.pow(256,n):e,this.writeUIntBE(e,r,n)}writeIntLE(e,r,n){return e=e<0?e+Math.pow(256,n):e,this.writeUIntLE(e,r,n)}writeUIntBE(e,r,n){B(r,"offset"),Y(r,"offset"),V(r,"offset",this.length-1),B(n,"byteLength"),Y(n,"byteLength");let i=new DataView(this.buffer,r,n);for(let o=n-1;o>=0;o--)i.setUint8(o,e&255),e=e/256;return r+n}writeUintBE(e,r,n){return this.writeUIntBE(e,r,n)}writeUIntLE(e,r,n){B(r,"offset"),Y(r,"offset"),V(r,"offset",this.length-1),B(n,"byteLength"),Y(n,"byteLength");let i=new DataView(this.buffer,r,n);for(let o=0;o<n;o++)i.setUint8(o,e&255),e=e/256;return r+n}writeUintLE(e,r,n){return this.writeUIntLE(e,r,n)}toJSON(){return{type:"Buffer",data:Array.from(this)}}swap16(){let e=new DataView(this.buffer,this.byteOffset,this.byteLength);for(let r=0;r<this.length;r+=2)e.setUint16(r,e.getUint16(r,!0),!1);return this}swap32(){let e=new DataView(this.buffer,this.byteOffset,this.byteLength);for(let r=0;r<this.length;r+=4)e.setUint32(r,e.getUint32(r,!0),!1);return this}swap64(){let e=new DataView(this.buffer,this.byteOffset,this.byteLength);for(let r=0;r<this.length;r+=8)e.setBigUint64(r,e.getBigUint64(r,!0),!1);return this}compare(e,r=0,n=e.length,i=0,o=this.length){return Mt(e,"target"),B(r,"targetStart"),B(n,"targetEnd"),B(i,"sourceStart"),B(o,"sourceEnd"),V(r,"targetStart"),V(n,"targetEnd",e.length),V(i,"sourceStart"),V(o,"sourceEnd",this.length),t.compare(this.slice(i,o),e.slice(r,n))}equals(e){return Mt(e,"otherBuffer"),this.length===e.length&&this.every((r,n)=>r===e[n])}copy(e,r=0,n=0,i=this.length){V(r,"targetStart"),V(n,"sourceStart",this.length),V(i,"sourceEnd"),r>>>=0,n>>>=0,i>>>=0;let o=0;for(;n<i&&!(this[n]===void 0||e[r]===void 0);)e[r]=this[n],o++,n++,r++;return o}write(e,r,n,i="utf8"){let o=typeof r=="string"?0:r??0,s=typeof n=="string"?this.length-o:n??this.length-o;return i=typeof r=="string"?r:typeof n=="string"?n:i,B(o,"offset"),B(s,"length"),V(o,"offset",this.length),V(s,"length",this.length),(i==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")&&(s=s-s%2),Er(e,i).copy(this,o,0,s)}fill(e=0,r=0,n=this.length,i="utf-8"){let o=typeof r=="string"?0:r,s=typeof n=="string"?this.length:n;if(i=typeof r=="string"?r:typeof n=="string"?n:i,e=t.from(typeof e=="number"?[e]:e??[],i),mn(i,"encoding"),V(o,"offset",this.length),V(s,"end",this.length),e.length!==0)for(let a=o;a<s;a+=e.length)super.set(e.slice(0,e.length+a>=this.length?this.length-a:e.length),a);return this}includes(e,r=null,n="utf-8"){return this.indexOf(e,r,n)!==-1}lastIndexOf(e,r=null,n="utf-8"){return this.indexOf(e,r,n,!0)}indexOf(e,r=null,n="utf-8",i=!1){let o=i?this.findLastIndex.bind(this):this.findIndex.bind(this);n=typeof r=="string"?r:n;let s=t.from(typeof e=="number"?[e]:e,n),a=typeof r=="string"?0:r;return a=typeof r=="number"?a:null,a=Number.isNaN(a)?null:a,a??=i?this.length:0,a=a<0?this.length+a:a,s.length===0&&i===!1?a>=this.length?this.length:a:s.length===0&&i===!0?(a>=this.length?this.length:a)||this.length:o((f,h)=>(i?h<=a:h>=a)&&this[h]===s[0]&&s.every((C,k)=>this[h+k]===C))}toString(e="utf8",r=0,n=this.length){if(r=r<0?0:r,e=e.toString().toLowerCase(),n<=0)return"";if(e==="utf8"||e==="utf-8")return as.decode(this.slice(r,n));if(e==="base64"||e==="base64url"){let i=btoa(this.reduce((o,s)=>o+xr(s),""));return e==="base64url"?i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""):i}if(e==="binary"||e==="ascii"||e==="latin1"||e==="latin-1")return this.slice(r,n).reduce((i,o)=>i+xr(o&(e==="ascii"?127:255)),"");if(e==="ucs2"||e==="ucs-2"||e==="utf16le"||e==="utf-16le"){let i=new DataView(this.buffer.slice(r,n));return Array.from({length:i.byteLength/2},(o,s)=>s*2+1<i.byteLength?xr(i.getUint16(s*2,!0)):"").join("")}if(e==="hex")return this.slice(r,n).reduce((i,o)=>i+o.toString(16).padStart(2,"0"),"");pn(`encoding "${e}"`)}toLocaleString(){return this.toString()}inspect(){return`<Buffer ${this.toString("hex").match(/.{1,2}/g).join(" ")}>`}};os={int8:[-128,127],int16:[-32768,32767],int32:[-2147483648,2147483647],uint8:[0,255],uint16:[0,65535],uint32:[0,4294967295],float32:[-1/0,1/0],float64:[-1/0,1/0],bigint64:[-0x8000000000000000n,0x7fffffffffffffffn],biguint64:[0n,0xffffffffffffffffn]},ss=new TextEncoder,as=new TextDecoder,ls=["utf8","utf-8","hex","base64","ascii","binary","base64url","ucs2","ucs-2","utf16le","utf-16le","latin1","latin-1"],us=4294967295;ns(y.prototype);b=new Proxy(cs,{construct(t,[e,r]){return y.from(e,r)},get(t,e){return y[e]}}),xr=String.fromCodePoint});var g,c=ne(()=>{"use strict";g={nextTick:(t,...e)=>{setTimeout(()=>{t(...e)},0)},env:{},version:"",cwd:()=>"/",stderr:{},argv:["/bin/node"]}});var x,m=ne(()=>{"use strict";x=globalThis.performance??(()=>{let t=Date.now();return{now:()=>Date.now()-t}})()});var E,p=ne(()=>{"use strict";E=()=>{};E.prototype=E});var w,d=ne(()=>{"use strict";w=class{value;constructor(e){this.value=e}deref(){return this.value}}});function yn(t,e){var r,n,i,o,s,a,f,h,T=t.constructor,C=T.precision;if(!t.s||!e.s)return e.s||(e=new T(t)),q?D(e,C):e;if(f=t.d,h=e.d,s=t.e,i=e.e,f=f.slice(),o=s-i,o){for(o<0?(n=f,o=-o,a=h.length):(n=h,i=s,a=f.length),s=Math.ceil(C/N),a=s>a?s+1:a+1,o>a&&(o=a,n.length=1),n.reverse();o--;)n.push(0);n.reverse()}for(a=f.length,o=h.length,a-o<0&&(o=a,n=h,h=f,f=n),r=0;o;)r=(f[--o]=f[o]+h[o]+r)/Q|0,f[o]%=Q;for(r&&(f.unshift(r),++i),a=f.length;f[--a]==0;)f.pop();return e.d=f,e.e=i,q?D(e,C):e}function ce(t,e,r){if(t!==~~t||t<e||t>r)throw Error(Oe+t)}function ue(t){var e,r,n,i=t.length-1,o="",s=t[0];if(i>0){for(o+=s,e=1;e<i;e++)n=t[e]+"",r=N-n.length,r&&(o+=Pe(r)),o+=n;s=t[e],n=s+"",r=N-n.length,r&&(o+=Pe(r))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function hn(t,e){var r,n,i,o,s,a,f=0,h=0,T=t.constructor,C=T.precision;if($(t)>16)throw Error(vr+$(t));if(!t.s)return new T(ee);for(e==null?(q=!1,a=C):a=e,s=new T(.03125);t.abs().gte(.1);)t=t.times(s),h+=5;for(n=Math.log(ke(2,h))/Math.LN10*2+5|0,a+=n,r=i=o=new T(ee),T.precision=a;;){if(i=D(i.times(t),a),r=r.times(++f),s=o.plus(he(i,r,a)),ue(s.d).slice(0,a)===ue(o.d).slice(0,a)){for(;h--;)o=D(o.times(o),a);return T.precision=C,e==null?(q=!0,D(o,C)):o}o=s}}function $(t){for(var e=t.e*N,r=t.d[0];r>=10;r/=10)e++;return e}function Pr(t,e,r){if(e>t.LN10.sd())throw q=!0,r&&(t.precision=r),Error(ie+"LN10 precision limit exceeded");return D(new t(t.LN10),e)}function Pe(t){for(var e="";t--;)e+="0";return e}function it(t,e){var r,n,i,o,s,a,f,h,T,C=1,k=10,A=t,O=A.d,S=A.constructor,M=S.precision;if(A.s<1)throw Error(ie+(A.s?"NaN":"-Infinity"));if(A.eq(ee))return new S(0);if(e==null?(q=!1,h=M):h=e,A.eq(10))return e==null&&(q=!0),Pr(S,h);if(h+=k,S.precision=h,r=ue(O),n=r.charAt(0),o=$(A),Math.abs(o)<15e14){for(;n<7&&n!=1||n==1&&r.charAt(1)>3;)A=A.times(t),r=ue(A.d),n=r.charAt(0),C++;o=$(A),n>1?(A=new S("0."+r),o++):A=new S(n+"."+r.slice(1))}else return f=Pr(S,h+2,M).times(o+""),A=it(new S(n+"."+r.slice(1)),h-k).plus(f),S.precision=M,e==null?(q=!0,D(A,M)):A;for(a=s=A=he(A.minus(ee),A.plus(ee),h),T=D(A.times(A),h),i=3;;){if(s=D(s.times(T),h),f=a.plus(he(s,new S(i),h)),ue(f.d).slice(0,h)===ue(a.d).slice(0,h))return a=a.times(2),o!==0&&(a=a.plus(Pr(S,h+2,M).times(o+""))),a=he(a,new S(C),h),S.precision=M,e==null?(q=!0,D(a,M)):a;a=f,i+=2}}function dn(t,e){var r,n,i;for((r=e.indexOf("."))>-1&&(e=e.replace(".","")),(n=e.search(/e/i))>0?(r<0&&(r=n),r+=+e.slice(n+1),e=e.substring(0,n)):r<0&&(r=e.length),n=0;e.charCodeAt(n)===48;)++n;for(i=e.length;e.charCodeAt(i-1)===48;)--i;if(e=e.slice(n,i),e){if(i-=n,r=r-n-1,t.e=Ne(r/N),t.d=[],n=(r+1)%N,r<0&&(n+=N),n<i){for(n&&t.d.push(+e.slice(0,n)),i-=N;n<i;)t.d.push(+e.slice(n,n+=N));e=e.slice(n),n=N-e.length}else n-=i;for(;n--;)e+="0";if(t.d.push(+e),q&&(t.e>It||t.e<-It))throw Error(vr+r)}else t.s=0,t.e=0,t.d=[0];return t}function D(t,e,r){var n,i,o,s,a,f,h,T,C=t.d;for(s=1,o=C[0];o>=10;o/=10)s++;if(n=e-s,n<0)n+=N,i=e,h=C[T=0];else{if(T=Math.ceil((n+1)/N),o=C.length,T>=o)return t;for(h=o=C[T],s=1;o>=10;o/=10)s++;n%=N,i=n-N+s}if(r!==void 0&&(o=ke(10,s-i-1),a=h/o%10|0,f=e<0||C[T+1]!==void 0||h%o,f=r<4?(a||f)&&(r==0||r==(t.s<0?3:2)):a>5||a==5&&(r==4||f||r==6&&(n>0?i>0?h/ke(10,s-i):0:C[T-1])%10&1||r==(t.s<0?8:7))),e<1||!C[0])return f?(o=$(t),C.length=1,e=e-o-1,C[0]=ke(10,(N-e%N)%N),t.e=Ne(-e/N)||0):(C.length=1,C[0]=t.e=t.s=0),t;if(n==0?(C.length=T,o=1,T--):(C.length=T+1,o=ke(10,N-n),C[T]=i>0?(h/ke(10,s-i)%ke(10,i)|0)*o:0),f)for(;;)if(T==0){(C[0]+=o)==Q&&(C[0]=1,++t.e);break}else{if(C[T]+=o,C[T]!=Q)break;C[T--]=0,o=1}for(n=C.length;C[--n]===0;)C.pop();if(q&&(t.e>It||t.e<-It))throw Error(vr+$(t));return t}function bn(t,e){var r,n,i,o,s,a,f,h,T,C,k=t.constructor,A=k.precision;if(!t.s||!e.s)return e.s?e.s=-e.s:e=new k(t),q?D(e,A):e;if(f=t.d,C=e.d,n=e.e,h=t.e,f=f.slice(),s=h-n,s){for(T=s<0,T?(r=f,s=-s,a=C.length):(r=C,n=h,a=f.length),i=Math.max(Math.ceil(A/N),a)+2,s>i&&(s=i,r.length=1),r.reverse(),i=s;i--;)r.push(0);r.reverse()}else{for(i=f.length,a=C.length,T=i<a,T&&(a=i),i=0;i<a;i++)if(f[i]!=C[i]){T=f[i]<C[i];break}s=0}for(T&&(r=f,f=C,C=r,e.s=-e.s),a=f.length,i=C.length-a;i>0;--i)f[a++]=0;for(i=C.length;i>s;){if(f[--i]<C[i]){for(o=i;o&&f[--o]===0;)f[o]=Q-1;--f[o],f[i]+=Q}f[i]-=C[i]}for(;f[--a]===0;)f.pop();for(;f[0]===0;f.shift())--n;return f[0]?(e.d=f,e.e=n,q?D(e,A):e):new k(0)}function Me(t,e,r){var n,i=$(t),o=ue(t.d),s=o.length;return e?(r&&(n=r-s)>0?o=o.charAt(0)+"."+o.slice(1)+Pe(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(i<0?"e":"e+")+i):i<0?(o="0."+Pe(-i-1)+o,r&&(n=r-s)>0&&(o+=Pe(n))):i>=s?(o+=Pe(i+1-s),r&&(n=r-i-1)>0&&(o=o+"."+Pe(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),r&&(n=r-s)>0&&(i+1===s&&(o+="."),o+=Pe(n))),t.s<0?"-"+o:o}function fn(t,e){if(t.length>e)return t.length=e,!0}function wn(t){var e,r,n;function i(o){var s=this;if(!(s instanceof i))return new i(o);if(s.constructor=i,o instanceof i){s.s=o.s,s.e=o.e,s.d=(o=o.d)?o.slice():o;return}if(typeof o=="number"){if(o*0!==0)throw Error(Oe+o);if(o>0)s.s=1;else if(o<0)o=-o,s.s=-1;else{s.s=0,s.e=0,s.d=[0];return}if(o===~~o&&o<1e7){s.e=0,s.d=[o];return}return dn(s,o.toString())}else if(typeof o!="string")throw Error(Oe+o);if(o.charCodeAt(0)===45?(o=o.slice(1),s.s=-1):s.s=1,ps.test(o))dn(s,o);else throw Error(Oe+o)}if(i.prototype=R,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.clone=wn,i.config=i.set=ds,t===void 0&&(t={}),t)for(n=["precision","rounding","toExpNeg","toExpPos","LN10"],e=0;e<n.length;)t.hasOwnProperty(r=n[e++])||(t[r]=this[r]);return i.config(t),i}function ds(t){if(!t||typeof t!="object")throw Error(ie+"Object expected");var e,r,n,i=["precision",1,Fe,"rounding",0,8,"toExpNeg",-1/0,0,"toExpPos",0,1/0];for(e=0;e<i.length;e+=3)if((n=t[r=i[e]])!==void 0)if(Ne(n)===n&&n>=i[e+1]&&n<=i[e+2])this[r]=n;else throw Error(Oe+r+": "+n);if((n=t[r="LN10"])!==void 0)if(n==Math.LN10)this[r]=new this(n);else throw Error(Oe+r+": "+n);return this}var Fe,ms,Tr,q,ie,Oe,vr,Ne,ke,ps,ee,Q,N,gn,It,R,he,Tr,_t,En=ne(()=>{"use strict";u();c();m();p();d();l();Fe=1e9,ms={precision:20,rounding:4,toExpNeg:-7,toExpPos:21,LN10:"2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"},q=!0,ie="[DecimalError] ",Oe=ie+"Invalid argument: ",vr=ie+"Exponent out of range: ",Ne=Math.floor,ke=Math.pow,ps=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,Q=1e7,N=7,gn=9007199254740991,It=Ne(gn/N),R={};R.absoluteValue=R.abs=function(){var t=new this.constructor(this);return t.s&&(t.s=1),t};R.comparedTo=R.cmp=function(t){var e,r,n,i,o=this;if(t=new o.constructor(t),o.s!==t.s)return o.s||-t.s;if(o.e!==t.e)return o.e>t.e^o.s<0?1:-1;for(n=o.d.length,i=t.d.length,e=0,r=n<i?n:i;e<r;++e)if(o.d[e]!==t.d[e])return o.d[e]>t.d[e]^o.s<0?1:-1;return n===i?0:n>i^o.s<0?1:-1};R.decimalPlaces=R.dp=function(){var t=this,e=t.d.length-1,r=(e-t.e)*N;if(e=t.d[e],e)for(;e%10==0;e/=10)r--;return r<0?0:r};R.dividedBy=R.div=function(t){return he(this,new this.constructor(t))};R.dividedToIntegerBy=R.idiv=function(t){var e=this,r=e.constructor;return D(he(e,new r(t),0,1),r.precision)};R.equals=R.eq=function(t){return!this.cmp(t)};R.exponent=function(){return $(this)};R.greaterThan=R.gt=function(t){return this.cmp(t)>0};R.greaterThanOrEqualTo=R.gte=function(t){return this.cmp(t)>=0};R.isInteger=R.isint=function(){return this.e>this.d.length-2};R.isNegative=R.isneg=function(){return this.s<0};R.isPositive=R.ispos=function(){return this.s>0};R.isZero=function(){return this.s===0};R.lessThan=R.lt=function(t){return this.cmp(t)<0};R.lessThanOrEqualTo=R.lte=function(t){return this.cmp(t)<1};R.logarithm=R.log=function(t){var e,r=this,n=r.constructor,i=n.precision,o=i+5;if(t===void 0)t=new n(10);else if(t=new n(t),t.s<1||t.eq(ee))throw Error(ie+"NaN");if(r.s<1)throw Error(ie+(r.s?"NaN":"-Infinity"));return r.eq(ee)?new n(0):(q=!1,e=he(it(r,o),it(t,o),o),q=!0,D(e,i))};R.minus=R.sub=function(t){var e=this;return t=new e.constructor(t),e.s==t.s?bn(e,t):yn(e,(t.s=-t.s,t))};R.modulo=R.mod=function(t){var e,r=this,n=r.constructor,i=n.precision;if(t=new n(t),!t.s)throw Error(ie+"NaN");return r.s?(q=!1,e=he(r,t,0,1).times(t),q=!0,r.minus(e)):D(new n(r),i)};R.naturalExponential=R.exp=function(){return hn(this)};R.naturalLogarithm=R.ln=function(){return it(this)};R.negated=R.neg=function(){var t=new this.constructor(this);return t.s=-t.s||0,t};R.plus=R.add=function(t){var e=this;return t=new e.constructor(t),e.s==t.s?yn(e,t):bn(e,(t.s=-t.s,t))};R.precision=R.sd=function(t){var e,r,n,i=this;if(t!==void 0&&t!==!!t&&t!==1&&t!==0)throw Error(Oe+t);if(e=$(i)+1,n=i.d.length-1,r=n*N+1,n=i.d[n],n){for(;n%10==0;n/=10)r--;for(n=i.d[0];n>=10;n/=10)r++}return t&&e>r?e:r};R.squareRoot=R.sqrt=function(){var t,e,r,n,i,o,s,a=this,f=a.constructor;if(a.s<1){if(!a.s)return new f(0);throw Error(ie+"NaN")}for(t=$(a),q=!1,i=Math.sqrt(+a),i==0||i==1/0?(e=ue(a.d),(e.length+t)%2==0&&(e+="0"),i=Math.sqrt(e),t=Ne((t+1)/2)-(t<0||t%2),i==1/0?e="5e"+t:(e=i.toExponential(),e=e.slice(0,e.indexOf("e")+1)+t),n=new f(e)):n=new f(i.toString()),r=f.precision,i=s=r+3;;)if(o=n,n=o.plus(he(a,o,s+2)).times(.5),ue(o.d).slice(0,s)===(e=ue(n.d)).slice(0,s)){if(e=e.slice(s-3,s+1),i==s&&e=="4999"){if(D(o,r+1,0),o.times(o).eq(a)){n=o;break}}else if(e!="9999")break;s+=4}return q=!0,D(n,r)};R.times=R.mul=function(t){var e,r,n,i,o,s,a,f,h,T=this,C=T.constructor,k=T.d,A=(t=new C(t)).d;if(!T.s||!t.s)return new C(0);for(t.s*=T.s,r=T.e+t.e,f=k.length,h=A.length,f<h&&(o=k,k=A,A=o,s=f,f=h,h=s),o=[],s=f+h,n=s;n--;)o.push(0);for(n=h;--n>=0;){for(e=0,i=f+n;i>n;)a=o[i]+A[n]*k[i-n-1]+e,o[i--]=a%Q|0,e=a/Q|0;o[i]=(o[i]+e)%Q|0}for(;!o[--s];)o.pop();return e?++r:o.shift(),t.d=o,t.e=r,q?D(t,C.precision):t};R.toDecimalPlaces=R.todp=function(t,e){var r=this,n=r.constructor;return r=new n(r),t===void 0?r:(ce(t,0,Fe),e===void 0?e=n.rounding:ce(e,0,8),D(r,t+$(r)+1,e))};R.toExponential=function(t,e){var r,n=this,i=n.constructor;return t===void 0?r=Me(n,!0):(ce(t,0,Fe),e===void 0?e=i.rounding:ce(e,0,8),n=D(new i(n),t+1,e),r=Me(n,!0,t+1)),r};R.toFixed=function(t,e){var r,n,i=this,o=i.constructor;return t===void 0?Me(i):(ce(t,0,Fe),e===void 0?e=o.rounding:ce(e,0,8),n=D(new o(i),t+$(i)+1,e),r=Me(n.abs(),!1,t+$(n)+1),i.isneg()&&!i.isZero()?"-"+r:r)};R.toInteger=R.toint=function(){var t=this,e=t.constructor;return D(new e(t),$(t)+1,e.rounding)};R.toNumber=function(){return+this};R.toPower=R.pow=function(t){var e,r,n,i,o,s,a=this,f=a.constructor,h=12,T=+(t=new f(t));if(!t.s)return new f(ee);if(a=new f(a),!a.s){if(t.s<1)throw Error(ie+"Infinity");return a}if(a.eq(ee))return a;if(n=f.precision,t.eq(ee))return D(a,n);if(e=t.e,r=t.d.length-1,s=e>=r,o=a.s,s){if((r=T<0?-T:T)<=gn){for(i=new f(ee),e=Math.ceil(n/N+4),q=!1;r%2&&(i=i.times(a),fn(i.d,e)),r=Ne(r/2),r!==0;)a=a.times(a),fn(a.d,e);return q=!0,t.s<0?new f(ee).div(i):D(i,n)}}else if(o<0)throw Error(ie+"NaN");return o=o<0&&t.d[Math.max(e,r)]&1?-1:1,a.s=1,q=!1,i=t.times(it(a,n+h)),q=!0,i=hn(i),i.s=o,i};R.toPrecision=function(t,e){var r,n,i=this,o=i.constructor;return t===void 0?(r=$(i),n=Me(i,r<=o.toExpNeg||r>=o.toExpPos)):(ce(t,1,Fe),e===void 0?e=o.rounding:ce(e,0,8),i=D(new o(i),t,e),r=$(i),n=Me(i,t<=r||r<=o.toExpNeg,t)),n};R.toSignificantDigits=R.tosd=function(t,e){var r=this,n=r.constructor;return t===void 0?(t=n.precision,e=n.rounding):(ce(t,1,Fe),e===void 0?e=n.rounding:ce(e,0,8)),D(new n(r),t,e)};R.toString=R.valueOf=R.val=R.toJSON=R[Symbol.for("nodejs.util.inspect.custom")]=function(){var t=this,e=$(t),r=t.constructor;return Me(t,e<=r.toExpNeg||e>=r.toExpPos)};he=function(){function t(n,i){var o,s=0,a=n.length;for(n=n.slice();a--;)o=n[a]*i+s,n[a]=o%Q|0,s=o/Q|0;return s&&n.unshift(s),n}function e(n,i,o,s){var a,f;if(o!=s)f=o>s?1:-1;else for(a=f=0;a<o;a++)if(n[a]!=i[a]){f=n[a]>i[a]?1:-1;break}return f}function r(n,i,o){for(var s=0;o--;)n[o]-=s,s=n[o]<i[o]?1:0,n[o]=s*Q+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s){var a,f,h,T,C,k,A,O,S,M,oe,H,L,z,Se,wr,se,St,kt=n.constructor,zo=n.s==i.s?1:-1,le=n.d,U=i.d;if(!n.s)return new kt(n);if(!i.s)throw Error(ie+"Division by zero");for(f=n.e-i.e,se=U.length,Se=le.length,A=new kt(zo),O=A.d=[],h=0;U[h]==(le[h]||0);)++h;if(U[h]>(le[h]||0)&&--f,o==null?H=o=kt.precision:s?H=o+($(n)-$(i))+1:H=o,H<0)return new kt(0);if(H=H/N+2|0,h=0,se==1)for(T=0,U=U[0],H++;(h<Se||T)&&H--;h++)L=T*Q+(le[h]||0),O[h]=L/U|0,T=L%U|0;else{for(T=Q/(U[0]+1)|0,T>1&&(U=t(U,T),le=t(le,T),se=U.length,Se=le.length),z=se,S=le.slice(0,se),M=S.length;M<se;)S[M++]=0;St=U.slice(),St.unshift(0),wr=U[0],U[1]>=Q/2&&++wr;do T=0,a=e(U,S,se,M),a<0?(oe=S[0],se!=M&&(oe=oe*Q+(S[1]||0)),T=oe/wr|0,T>1?(T>=Q&&(T=Q-1),C=t(U,T),k=C.length,M=S.length,a=e(C,S,k,M),a==1&&(T--,r(C,se<k?St:U,k))):(T==0&&(a=T=1),C=U.slice()),k=C.length,k<M&&C.unshift(0),r(S,C,M),a==-1&&(M=S.length,a=e(U,S,se,M),a<1&&(T++,r(S,se<M?St:U,M))),M=S.length):a===0&&(T++,S=[0]),O[h++]=T,a&&S[0]?S[M++]=le[z]||0:(S=[le[z]],M=1);while((z++<Se||S[0]!==void 0)&&H--)}return O[0]||O.shift(),A.e=f,D(A,s?o+$(A)+1:o)}}();Tr=wn(ms);ee=new Tr(1);_t=Tr});var v,me,l=ne(()=>{"use strict";En();v=class extends _t{static isDecimal(e){return e instanceof _t}static random(e=20){{let n=globalThis.crypto.getRandomValues(new Uint8Array(e)).reduce((i,o)=>i+o,"");return new _t(`0.${n.slice(0,e)}`)}}},me=v});function ws(){return!1}function Nn(){return{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}function Es(){return Nn()}function xs(){return[]}function Ps(t){t(null,[])}function vs(){return""}function Ts(){return""}function Cs(){}function Rs(){}function As(){}function Ss(){}function ks(){}function Os(){}var Ms,Is,qn,Un=ne(()=>{"use strict";u();c();m();p();d();l();Ms={},Is={existsSync:ws,lstatSync:Nn,statSync:Es,readdirSync:xs,readdir:Ps,readlinkSync:vs,realpathSync:Ts,chmodSync:Cs,renameSync:Rs,mkdirSync:As,rmdirSync:Ss,rmSync:ks,unlinkSync:Os,promises:Ms},qn=Is});function _s(...t){return t.join("/")}function Ds(...t){return t.join("/")}function Ls(t){let e=Bn(t),r=$n(t),[n,i]=e.split(".");return{root:"/",dir:r,base:e,ext:i,name:n}}function Bn(t){let e=t.split("/");return e[e.length-1]}function $n(t){return t.split("/").slice(0,-1).join("/")}var Vn,Fs,Ns,Nt,jn=ne(()=>{"use strict";u();c();m();p();d();l();Vn="/",Fs={sep:Vn},Ns={basename:Bn,dirname:$n,join:Ds,parse:Ls,posix:Fs,resolve:_s,sep:Vn},Nt=Ns});var Qn=Le((Zc,qs)=>{qs.exports={name:"@prisma/internals",version:"6.6.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.4.7",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-engine-wasm":"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var Hn=Le((xm,Kn)=>{"use strict";u();c();m();p();d();l();Kn.exports=(t,e=1,r)=>{if(r={indent:" ",includeEmptyLines:!1,...r},typeof t!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof t}\``);if(typeof e!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof e}\``);if(typeof r.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);if(e===0)return t;let n=r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return t.replace(n,r.indent.repeat(e))}});var Xn=Le((Lm,Yn)=>{"use strict";u();c();m();p();d();l();Yn.exports=({onlyFirst:t=!1}={})=>{let e=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(e,t?void 0:"g")}});var ei=Le((Vm,Zn)=>{"use strict";u();c();m();p();d();l();var Js=Xn();Zn.exports=t=>typeof t=="string"?t.replace(Js(),""):t});var Fr=Le((oy,oi)=>{"use strict";u();c();m();p();d();l();oi.exports=function(){function t(e,r,n,i,o){return e<r||n<r?e>n?n+1:e+1:i===o?r:r+1}return function(e,r){if(e===r)return 0;if(e.length>r.length){var n=e;e=r,r=n}for(var i=e.length,o=r.length;i>0&&e.charCodeAt(i-1)===r.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&e.charCodeAt(s)===r.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,f,h,T,C,k,A,O,S,M,oe,H,L,z=[];for(f=0;f<i;f++)z.push(f+1),z.push(e.charCodeAt(s+f));for(var Se=z.length-1;a<o-3;)for(M=r.charCodeAt(s+(h=a)),oe=r.charCodeAt(s+(T=a+1)),H=r.charCodeAt(s+(C=a+2)),L=r.charCodeAt(s+(k=a+3)),A=a+=4,f=0;f<Se;f+=2)O=z[f],S=z[f+1],h=t(O,h,T,M,S),T=t(h,T,C,oe,S),C=t(T,C,k,H,S),A=t(C,k,A,L,S),z[f]=A,k=C,C=T,T=h,h=O;for(;a<o;)for(M=r.charCodeAt(s+(h=a)),A=++a,f=0;f<Se;f+=2)O=z[f],z[f]=A=t(O,h,A,M,z[f+1]),h=O;return A}}()});var ci=ne(()=>{"use strict";u();c();m();p();d();l()});var mi=ne(()=>{"use strict";u();c();m();p();d();l()});var Li=Le((iP,qa)=>{qa.exports={name:"@prisma/engines-version",version:"6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"f676762280b54cd07c770017ed3711ddde35f37a"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var nr,Fi=ne(()=>{"use strict";u();c();m();p();d();l();nr=class{events={};on(e,r){return this.events[e]||(this.events[e]=[]),this.events[e].push(r),this}emit(e,...r){return this.events[e]?(this.events[e].forEach(n=>{n(...r)}),!0):!1}}});var Jl={};rt(Jl,{DMMF:()=>mt,Debug:()=>J,Decimal:()=>me,Extensions:()=>Cr,MetricsClient:()=>Ye,PrismaClientInitializationError:()=>I,PrismaClientKnownRequestError:()=>X,PrismaClientRustPanicError:()=>we,PrismaClientUnknownRequestError:()=>j,PrismaClientValidationError:()=>W,Public:()=>Rr,Sql:()=>Z,createParam:()=>Ai,defineDmmfProperty:()=>_i,deserializeJsonResponse:()=>$e,deserializeRawResult:()=>hr,dmmfToRuntimeDataModel:()=>ii,empty:()=>qi,getPrismaClient:()=>Wo,getRuntime:()=>Re,join:()=>Ni,makeStrictEnum:()=>Ko,makeTypedQueryFactory:()=>Di,objectEnumValues:()=>Wt,raw:()=>Jr,serializeJsonQuery:()=>er,skip:()=>Zt,sqltag:()=>Gr,warnEnvConflicts:()=>void 0,warnOnce:()=>lt});module.exports=rs(Jl);u();c();m();p();d();l();var Cr={};rt(Cr,{defineExtension:()=>xn,getExtensionContext:()=>Pn});u();c();m();p();d();l();u();c();m();p();d();l();function xn(t){return typeof t=="function"?t:e=>e.$extends(t)}u();c();m();p();d();l();function Pn(t){return t}var Rr={};rt(Rr,{validator:()=>vn});u();c();m();p();d();l();u();c();m();p();d();l();function vn(...t){return e=>e}u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();var Ar,Tn,Cn,Rn,An=!0;typeof g<"u"&&({FORCE_COLOR:Ar,NODE_DISABLE_COLORS:Tn,NO_COLOR:Cn,TERM:Rn}=g.env||{},An=g.stdout&&g.stdout.isTTY);var fs={enabled:!Tn&&Cn==null&&Rn!=="dumb"&&(Ar!=null&&Ar!=="0"||An)};function F(t,e){let r=new RegExp(`\\x1b\\[${e}m`,"g"),n=`\x1B[${t}m`,i=`\x1B[${e}m`;return function(o){return!fs.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}}var ju=F(0,0),Dt=F(1,22),Lt=F(2,22),Qu=F(3,23),Sn=F(4,24),Ju=F(7,27),Gu=F(8,28),Wu=F(9,29),Ku=F(30,39),qe=F(31,39),kn=F(32,39),On=F(33,39),Mn=F(34,39),Hu=F(35,39),In=F(36,39),zu=F(37,39),_n=F(90,39),Yu=F(90,39),Xu=F(40,49),Zu=F(41,49),ec=F(42,49),tc=F(43,49),rc=F(44,49),nc=F(45,49),ic=F(46,49),oc=F(47,49);u();c();m();p();d();l();var gs=100,Dn=["green","yellow","blue","magenta","cyan","red"],Ft=[],Ln=Date.now(),ys=0,Sr=typeof g<"u"?g.env:{};globalThis.DEBUG??=Sr.DEBUG??"";globalThis.DEBUG_COLORS??=Sr.DEBUG_COLORS?Sr.DEBUG_COLORS==="true":!0;var ot={enable(t){typeof t=="string"&&(globalThis.DEBUG=t)},disable(){let t=globalThis.DEBUG;return globalThis.DEBUG="",t},enabled(t){let e=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),r=e.some(i=>i===""||i[0]==="-"?!1:t.match(RegExp(i.split("*").join(".*")+"$"))),n=e.some(i=>i===""||i[0]!=="-"?!1:t.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return r&&!n},log:(...t)=>{let[e,r,...n]=t;(console.warn??console.log)(`${e} ${r}`,...n)},formatters:{}};function hs(t){let e={color:Dn[ys++%Dn.length],enabled:ot.enabled(t),namespace:t,log:ot.log,extend:()=>{}},r=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=e;if(n.length!==0&&Ft.push([o,...n]),Ft.length>gs&&Ft.shift(),ot.enabled(o)||i){let f=n.map(T=>typeof T=="string"?T:bs(T)),h=`+${Date.now()-Ln}ms`;Ln=Date.now(),a(o,...f,h)}};return new Proxy(r,{get:(n,i)=>e[i],set:(n,i,o)=>e[i]=o})}var J=new Proxy(hs,{get:(t,e)=>ot[e],set:(t,e,r)=>ot[e]=r});function bs(t,e=2){let r=new Set;return JSON.stringify(t,(n,i)=>{if(typeof i=="object"&&i!==null){if(r.has(i))return"[Circular *]";r.add(i)}else if(typeof i=="bigint")return i.toString();return i},e)}function Fn(){Ft.length=0}u();c();m();p();d();l();u();c();m();p();d();l();var kr=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];u();c();m();p();d();l();var Us=Qn(),Or=Us.version;u();c();m();p();d();l();var Jn="library";function Ue(t){let e=Bs();return e||(t?.config.engineType==="library"?"library":t?.config.engineType==="binary"?"binary":t?.config.engineType==="client"?"client":Jn)}function Bs(){let t=g.env.PRISMA_CLIENT_ENGINE_TYPE;return t==="library"?"library":t==="binary"?"binary":t==="client"?"client":void 0}u();c();m();p();d();l();var Gn="prisma+postgres",Wn=`${Gn}:`;function Mr(t){return t?.startsWith(`${Wn}//`)??!1}var at={};rt(at,{error:()=>js,info:()=>Vs,log:()=>$s,query:()=>Qs,should:()=>zn,tags:()=>st,warn:()=>Ir});u();c();m();p();d();l();var st={error:qe("prisma:error"),warn:On("prisma:warn"),info:In("prisma:info"),query:Mn("prisma:query")},zn={warn:()=>!g.env.PRISMA_DISABLE_WARNINGS};function $s(...t){console.log(...t)}function Ir(t,...e){zn.warn()&&console.warn(`${st.warn} ${t}`,...e)}function Vs(t,...e){console.info(`${st.info} ${t}`,...e)}function js(t,...e){console.error(`${st.error} ${t}`,...e)}function Qs(t,...e){console.log(`${st.query} ${t}`,...e)}u();c();m();p();d();l();function qt(t,e){if(!t)throw new Error(`${e}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}u();c();m();p();d();l();function be(t,e){throw new Error(e)}u();c();m();p();d();l();function _r(t,e){return Object.prototype.hasOwnProperty.call(t,e)}u();c();m();p();d();l();function Be(t,e){let r={};for(let n of Object.keys(t))r[n]=e(t[n],n);return r}u();c();m();p();d();l();function Dr(t,e){if(t.length===0)return;let r=t[0];for(let n=1;n<t.length;n++)e(r,t[n])<0&&(r=t[n]);return r}u();c();m();p();d();l();function te(t,e){Object.defineProperty(t,"name",{value:e,configurable:!0})}u();c();m();p();d();l();var ti=new Set,lt=(t,e,...r)=>{ti.has(t)||(ti.add(t),Ir(e,...r))};var I=class t extends Error{clientVersion;errorCode;retryable;constructor(e,r,n){super(e),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(t)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};te(I,"PrismaClientInitializationError");u();c();m();p();d();l();var X=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(e,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){super(e),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};te(X,"PrismaClientKnownRequestError");u();c();m();p();d();l();var we=class extends Error{clientVersion;constructor(e,r){super(e),this.name="PrismaClientRustPanicError",this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};te(we,"PrismaClientRustPanicError");u();c();m();p();d();l();var j=class extends Error{clientVersion;batchRequestIdx;constructor(e,{clientVersion:r,batchRequestIdx:n}){super(e),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};te(j,"PrismaClientUnknownRequestError");u();c();m();p();d();l();var W=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(e,{clientVersion:r}){super(e),this.clientVersion=r}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};te(W,"PrismaClientValidationError");u();c();m();p();d();l();l();function $e(t){return t===null?t:Array.isArray(t)?t.map($e):typeof t=="object"?Gs(t)?Ws(t):Be(t,$e):t}function Gs(t){return t!==null&&typeof t=="object"&&typeof t.$type=="string"}function Ws({$type:t,value:e}){switch(t){case"BigInt":return BigInt(e);case"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=b.from(e,"base64");return new Uint8Array(r,n,i)}case"DateTime":return new Date(e);case"Decimal":return new me(e);case"Json":return JSON.parse(e);default:be(e,"Unknown tagged value")}}u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();var pe=class{_map=new Map;get(e){return this._map.get(e)?.value}set(e,r){this._map.set(e,{value:r})}getOrCreate(e,r){let n=this._map.get(e);if(n)return n.value;let i=r();return this.set(e,i),i}};u();c();m();p();d();l();function ve(t){return t.substring(0,1).toLowerCase()+t.substring(1)}u();c();m();p();d();l();function ni(t,e){let r={};for(let n of t){let i=n[e];r[i]=n}return r}u();c();m();p();d();l();function ut(t){let e;return{get(){return e||(e={value:t()}),e.value}}}u();c();m();p();d();l();function ii(t){return{models:Lr(t.models),enums:Lr(t.enums),types:Lr(t.types)}}function Lr(t){let e={};for(let{name:r,...n}of t)e[r]=n;return e}u();c();m();p();d();l();function Ve(t){return t instanceof Date||Object.prototype.toString.call(t)==="[object Date]"}function Ut(t){return t.toString()!=="Invalid Date"}u();c();m();p();d();l();l();function je(t){return v.isDecimal(t)?!0:t!==null&&typeof t=="object"&&typeof t.s=="number"&&typeof t.e=="number"&&typeof t.toFixed=="function"&&Array.isArray(t.d)}u();c();m();p();d();l();u();c();m();p();d();l();var mt={};rt(mt,{ModelAction:()=>ct,datamodelEnumToSchemaEnum:()=>Ks});u();c();m();p();d();l();u();c();m();p();d();l();function Ks(t){return{name:t.name,values:t.values.map(e=>e.name)}}u();c();m();p();d();l();var ct=(L=>(L.findUnique="findUnique",L.findUniqueOrThrow="findUniqueOrThrow",L.findFirst="findFirst",L.findFirstOrThrow="findFirstOrThrow",L.findMany="findMany",L.create="create",L.createMany="createMany",L.createManyAndReturn="createManyAndReturn",L.update="update",L.updateMany="updateMany",L.updateManyAndReturn="updateManyAndReturn",L.upsert="upsert",L.delete="delete",L.deleteMany="deleteMany",L.groupBy="groupBy",L.count="count",L.aggregate="aggregate",L.findRaw="findRaw",L.aggregateRaw="aggregateRaw",L))(ct||{});var Hs=nt(Hn());var zs={red:qe,gray:_n,dim:Lt,bold:Dt,underline:Sn,highlightSource:t=>t.highlight()},Ys={red:t=>t,gray:t=>t,dim:t=>t,bold:t=>t,underline:t=>t,highlightSource:t=>t};function Xs({message:t,originalMethod:e,isPanic:r,callArguments:n}){return{functionName:`prisma.${e}()`,message:t,isPanic:r??!1,callArguments:n}}function Zs({functionName:t,location:e,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],f=e?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${t}\``)} invocation${f}`))):a.push(s.red(`Invalid ${s.bold(`\`${t}\``)} invocation${f}`)),e&&a.push(s.underline(ea(e))),i){a.push("");let h=[i.toString()];o&&(h.push(o),h.push(s.dim(")"))),a.push(h.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(r),a.join(`
`)}function ea(t){let e=[t.fileName];return t.lineNumber&&e.push(String(t.lineNumber)),t.columnNumber&&e.push(String(t.columnNumber)),e.join(":")}function Bt(t){let e=t.showColors?zs:Ys,r;return typeof $getTemplateParameters<"u"?r=$getTemplateParameters(t,e):r=Xs(t),Zs(r,e)}u();c();m();p();d();l();var di=nt(Fr());u();c();m();p();d();l();function li(t,e,r){let n=ui(t),i=ta(n),o=na(i);o?$t(o,e,r):e.addErrorMessage(()=>"Unknown error")}function ui(t){return t.errors.flatMap(e=>e.kind==="Union"?ui(e):[e])}function ta(t){let e=new Map,r=[];for(let n of t){if(n.kind!=="InvalidArgumentType"){r.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=e.get(i);o?e.set(i,{...n,argument:{...n.argument,typeNames:ra(o.argument.typeNames,n.argument.typeNames)}}):e.set(i,n)}return r.push(...e.values()),r}function ra(t,e){return[...new Set(t.concat(e))]}function na(t){return Dr(t,(e,r)=>{let n=si(e),i=si(r);return n!==i?n-i:ai(e)-ai(r)})}function si(t){let e=0;return Array.isArray(t.selectionPath)&&(e+=t.selectionPath.length),Array.isArray(t.argumentPath)&&(e+=t.argumentPath.length),e}function ai(t){switch(t.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}u();c();m();p();d();l();var re=class{constructor(e,r){this.name=e;this.value=r}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(e){let{colors:{green:r}}=e.context;e.addMarginSymbol(r(this.isRequired?"+":"?")),e.write(r(this.name)),this.isRequired||e.write(r("?")),e.write(r(": ")),typeof this.value=="string"?e.write(r(this.value)):e.write(this.value)}};u();c();m();p();d();l();u();c();m();p();d();l();mi();u();c();m();p();d();l();var Qe=class{constructor(e=0,r){this.context=r;this.currentIndent=e}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(e){return typeof e=="string"?this.currentLine+=e:e.write(this),this}writeJoined(e,r,n=(i,o)=>o.write(i)){let i=r.length-1;for(let o=0;o<r.length;o++)n(r[o],this),o!==i&&this.write(e);return this}writeLine(e){return this.write(e).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let e=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,e?.(),this}withIndent(e){return this.indent(),e(this),this.unindent(),this}afterNextNewline(e){return this.afterNextNewLineCallback=e,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(e){return this.marginSymbol=e,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let e=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+e.slice(1):e}};ci();u();c();m();p();d();l();u();c();m();p();d();l();var Vt=class{constructor(e){this.value=e}write(e){e.write(this.value)}markAsError(){this.value.markAsError()}};u();c();m();p();d();l();var jt=t=>t,Qt={bold:jt,red:jt,green:jt,dim:jt,enabled:!1},pi={bold:Dt,red:qe,green:kn,dim:Lt,enabled:!0},Je={write(t){t.writeLine(",")}};u();c();m();p();d();l();var de=class{constructor(e){this.contents=e}isUnderlined=!1;color=e=>e;underline(){return this.isUnderlined=!0,this}setColor(e){return this.color=e,this}write(e){let r=e.getCurrentLineLength();e.write(this.color(this.contents)),this.isUnderlined&&e.afterNextNewline(()=>{e.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))})}};u();c();m();p();d();l();var Te=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var Ge=class extends Te{items=[];addItem(e){return this.items.push(new Vt(e)),this}getField(e){return this.items[e]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(r=>r.value.getPrintWidth()))+2}write(e){if(this.items.length===0){this.writeEmpty(e);return}this.writeWithItems(e)}writeEmpty(e){let r=new de("[]");this.hasError&&r.setColor(e.context.colors.red).underline(),e.write(r)}writeWithItems(e){let{colors:r}=e.context;e.writeLine("[").withIndent(()=>e.writeJoined(Je,this.items).newLine()).write("]"),this.hasError&&e.afterNextNewline(()=>{e.writeLine(r.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var We=class t extends Te{fields={};suggestions=[];addField(e){this.fields[e.name]=e}addSuggestion(e){this.suggestions.push(e)}getField(e){return this.fields[e]}getDeepField(e){let[r,...n]=e,i=this.getField(r);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof t?a=o.value.getField(s):o.value instanceof Ge&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(e){return e.length===0?this:this.getDeepField(e)?.value}hasField(e){return!!this.getField(e)}removeAllFields(){this.fields={}}removeField(e){delete this.fields[e]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(e){return this.getField(e)?.value}getDeepSubSelectionValue(e){let r=this;for(let n of e){if(!(r instanceof t))return;let i=r.getSubSelectionValue(n);if(!i)return;r=i}return r}getDeepSelectionParent(e){let r=this.getSelectionParent();if(!r)return;let n=r;for(let i of e){let o=n.value.getFieldValue(i);if(!o||!(o instanceof t))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let e=this.getField("select")?.value.asObject();if(e)return{kind:"select",value:e};let r=this.getField("include")?.value.asObject();if(r)return{kind:"include",value:r}}getSubSelectionValue(e){return this.getSelectionParent()?.value.fields[e].value}getPrintWidth(){let e=Object.values(this.fields);return e.length==0?2:Math.max(...e.map(n=>n.getPrintWidth()))+2}write(e){let r=Object.values(this.fields);if(r.length===0&&this.suggestions.length===0){this.writeEmpty(e);return}this.writeWithContents(e,r)}asObject(){return this}writeEmpty(e){let r=new de("{}");this.hasError&&r.setColor(e.context.colors.red).underline(),e.write(r)}writeWithContents(e,r){e.writeLine("{").withIndent(()=>{e.writeJoined(Je,[...r,...this.suggestions]).newLine()}),e.write("}"),this.hasError&&e.afterNextNewline(()=>{e.writeLine(e.context.colors.red("~".repeat(this.getPrintWidth())))})}};u();c();m();p();d();l();var G=class extends Te{constructor(r){super();this.text=r}getPrintWidth(){return this.text.length}write(r){let n=new de(this.text);this.hasError&&n.underline().setColor(r.context.colors.red),r.write(n)}asObject(){}};u();c();m();p();d();l();var pt=class{fields=[];addField(e,r){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${e}: ${r}`))).addMarginSymbol(i(o("+")))}}),this}write(e){let{colors:{green:r}}=e.context;e.writeLine(r("{")).withIndent(()=>{e.writeJoined(Je,this.fields).newLine()}).write(r("}")).addMarginSymbol(r("+"))}};function $t(t,e,r){switch(t.kind){case"MutuallyExclusiveFields":ia(t,e);break;case"IncludeOnScalar":oa(t,e);break;case"EmptySelection":sa(t,e,r);break;case"UnknownSelectionField":ca(t,e);break;case"InvalidSelectionValue":ma(t,e);break;case"UnknownArgument":pa(t,e);break;case"UnknownInputField":da(t,e);break;case"RequiredArgumentMissing":fa(t,e);break;case"InvalidArgumentType":ga(t,e);break;case"InvalidArgumentValue":ya(t,e);break;case"ValueTooLarge":ha(t,e);break;case"SomeFieldsMissing":ba(t,e);break;case"TooManyFieldsGiven":wa(t,e);break;case"Union":li(t,e,r);break;default:throw new Error("not implemented: "+t.kind)}}function ia(t,e){let r=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();r&&(r.getField(t.firstField)?.markAsError(),r.getField(t.secondField)?.markAsError()),e.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${t.firstField}\``)} or ${n.green(`\`${t.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function oa(t,e){let[r,n]=dt(t.selectionPath),i=t.outputType,o=e.arguments.getDeepSelectionParent(r)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new re(s.name,"true"));e.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${ft(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function sa(t,e,r){let n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){aa(t,e,i);return}if(n.hasField("select")){la(t,e);return}}if(r?.[ve(t.outputType.name)]){ua(t,e);return}e.addErrorMessage(()=>`Unknown field at "${t.selectionPath.join(".")} selection"`)}function aa(t,e,r){r.removeAllFields();for(let n of t.outputType.fields)r.addSuggestion(new re(n.name,"false"));e.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(t.outputType.name)}. At least one field must be included in the result`)}function la(t,e){let r=t.outputType,n=e.arguments.getDeepSelectionParent(t.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),yi(n,r)),e.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${ft(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)}function ua(t,e){let r=new pt;for(let i of t.outputType.fields)i.isRelation||r.addField(i.name,"false");let n=new re("omit",r).makeRequired();if(t.selectionPath.length===0)e.arguments.addSuggestion(n);else{let[i,o]=dt(t.selectionPath),a=e.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let f=a?.value.asObject()??new We;f.addSuggestion(n),a.value=f}}e.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(t.outputType.name)}. At least one field must be included in the result`)}function ca(t,e){let r=hi(t.selectionPath,e);if(r.parentKind!=="unknown"){r.field.markAsError();let n=r.parent;switch(r.parentKind){case"select":yi(n,t.outputType);break;case"include":Ea(n,t.outputType);break;case"omit":xa(n,t.outputType);break}}e.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];return r.parentKind!=="unknown"&&i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${t.outputType.name}\``)}.`),i.push(ft(n)),i.join(" ")})}function ma(t,e){let r=hi(t.selectionPath,e);r.parentKind!=="unknown"&&r.field.value.markAsError(),e.addErrorMessage(n=>`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${t.underlyingError}`)}function pa(t,e){let r=t.argumentPath[0],n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();n&&(n.getField(r)?.markAsError(),Pa(n,t.arguments)),e.addErrorMessage(i=>fi(i,r,t.arguments.map(o=>o.name)))}function da(t,e){let[r,n]=dt(t.argumentPath),i=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();if(i){i.getDeepField(t.argumentPath)?.markAsError();let o=i.getDeepFieldValue(r)?.asObject();o&&bi(o,t.inputType)}e.addErrorMessage(o=>fi(o,n,t.inputType.fields.map(s=>s.name)))}function fi(t,e,r){let n=[`Unknown argument \`${t.red(e)}\`.`],i=Ta(e,r);return i&&n.push(`Did you mean \`${t.green(i)}\`?`),r.length>0&&n.push(ft(t)),n.join(" ")}function fa(t,e){let r;e.addErrorMessage(f=>r?.value instanceof G&&r.value.text==="null"?`Argument \`${f.green(o)}\` must not be ${f.red("null")}.`:`Argument \`${f.green(o)}\` is missing.`);let n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();if(!n)return;let[i,o]=dt(t.argumentPath),s=new pt,a=n.getDeepFieldValue(i)?.asObject();if(a)if(r=a.getField(o),r&&a.removeField(o),t.inputTypes.length===1&&t.inputTypes[0].kind==="object"){for(let f of t.inputTypes[0].fields)s.addField(f.name,f.typeNames.join(" | "));a.addSuggestion(new re(o,s).makeRequired())}else{let f=t.inputTypes.map(gi).join(" | ");a.addSuggestion(new re(o,f).makeRequired())}}function gi(t){return t.kind==="list"?`${gi(t.elementType)}[]`:t.name}function ga(t,e){let r=t.argument.name,n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();n&&n.getDeepFieldValue(t.argumentPath)?.markAsError(),e.addErrorMessage(i=>{let o=Jt("or",t.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(t.inferredType)}.`})}function ya(t,e){let r=t.argument.name,n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();n&&n.getDeepFieldValue(t.argumentPath)?.markAsError(),e.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(r)}\``];if(t.underlyingError&&o.push(`: ${t.underlyingError}`),o.push("."),t.argument.typeNames.length>0){let s=Jt("or",t.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function ha(t,e){let r=t.argument.name,n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(t.argumentPath)?.value;s?.markAsError(),s instanceof G&&(i=s.text)}e.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")})}function ba(t,e){let r=t.argumentPath[t.argumentPath.length-1],n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(t.argumentPath)?.asObject();i&&bi(i,t.inputType)}e.addErrorMessage(i=>{let o=[`Argument \`${i.bold(r)}\` of type ${i.bold(t.inputType.name)} needs`];return t.constraints.minFieldCount===1?t.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Jt("or",t.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${t.constraints.minFieldCount}`)} arguments.`),o.push(ft(i)),o.join(" ")})}function wa(t,e){let r=t.argumentPath[t.argumentPath.length-1],n=e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(t.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}e.addErrorMessage(o=>{let s=[`Argument \`${o.bold(r)}\` of type ${o.bold(t.inputType.name)} needs`];return t.constraints.minFieldCount===1&&t.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):t.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${t.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Jt("and",i.map(a=>o.red(a)))}. Please choose`),t.constraints.maxFieldCount===1?s.push("one."):s.push(`${t.constraints.maxFieldCount}.`),s.join(" ")})}function yi(t,e){for(let r of e.fields)t.hasField(r.name)||t.addSuggestion(new re(r.name,"true"))}function Ea(t,e){for(let r of e.fields)r.isRelation&&!t.hasField(r.name)&&t.addSuggestion(new re(r.name,"true"))}function xa(t,e){for(let r of e.fields)!t.hasField(r.name)&&!r.isRelation&&t.addSuggestion(new re(r.name,"true"))}function Pa(t,e){for(let r of e)t.hasField(r.name)||t.addSuggestion(new re(r.name,r.typeNames.join(" | ")))}function hi(t,e){let[r,n]=dt(t),i=e.arguments.getDeepSubSelectionValue(r)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),f=o?.getField(n);return o&&f?{parentKind:"select",parent:o,field:f,fieldName:n}:(f=s?.getField(n),s&&f?{parentKind:"include",field:f,parent:s,fieldName:n}:(f=a?.getField(n),a&&f?{parentKind:"omit",field:f,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function bi(t,e){if(e.kind==="object")for(let r of e.fields)t.hasField(r.name)||t.addSuggestion(new re(r.name,r.typeNames.join(" | ")))}function dt(t){let e=[...t],r=e.pop();if(!r)throw new Error("unexpected empty path");return[e,r]}function ft({green:t,enabled:e}){return"Available options are "+(e?`listed in ${t("green")}`:"marked with ?")+"."}function Jt(t,e){if(e.length===1)return e[0];let r=[...e],n=r.pop();return`${r.join(", ")} ${t} ${n}`}var va=3;function Ta(t,e){let r=1/0,n;for(let i of e){let o=(0,di.default)(t,i);o>va||o<r&&(r=o,n=i)}return n}u();c();m();p();d();l();u();c();m();p();d();l();var gt=class{modelName;name;typeName;isList;isEnum;constructor(e,r,n,i,o){this.modelName=e,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let e=this.isList?"List":"",r=this.isEnum?"Enum":"";return`${e}${r}${this.typeName}FieldRefInput<${this.modelName}>`}};function Ke(t){return t instanceof gt}u();c();m();p();d();l();var Gt=Symbol(),qr=new WeakMap,Ee=class{constructor(e){e===Gt?qr.set(this,`Prisma.${this._getName()}`):qr.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return qr.get(this)}},yt=class extends Ee{_getNamespace(){return"NullTypes"}},ht=class extends yt{_brand_DbNull};Ur(ht,"DbNull");var bt=class extends yt{_brand_JsonNull};Ur(bt,"JsonNull");var wt=class extends yt{_brand_AnyNull};Ur(wt,"AnyNull");var Wt={classes:{DbNull:ht,JsonNull:bt,AnyNull:wt},instances:{DbNull:new ht(Gt),JsonNull:new bt(Gt),AnyNull:new wt(Gt)}};function Ur(t,e){Object.defineProperty(t,"name",{value:e,configurable:!0})}u();c();m();p();d();l();var wi=": ",Kt=class{constructor(e,r){this.name=e;this.value=r}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+wi.length}write(e){let r=new de(this.name);this.hasError&&r.underline().setColor(e.context.colors.red),e.write(r).write(wi).write(this.value)}};var Br=class{arguments;errorMessages=[];constructor(e){this.arguments=e}write(e){e.write(this.arguments)}addErrorMessage(e){this.errorMessages.push(e)}renderAllMessages(e){return this.errorMessages.map(r=>r(e)).join(`
`)}};function He(t){return new Br(Ei(t))}function Ei(t){let e=new We;for(let[r,n]of Object.entries(t)){let i=new Kt(r,xi(n));e.addField(i)}return e}function xi(t){if(typeof t=="string")return new G(JSON.stringify(t));if(typeof t=="number"||typeof t=="boolean")return new G(String(t));if(typeof t=="bigint")return new G(`${t}n`);if(t===null)return new G("null");if(t===void 0)return new G("undefined");if(je(t))return new G(`new Prisma.Decimal("${t.toFixed()}")`);if(t instanceof Uint8Array)return b.isBuffer(t)?new G(`Buffer.alloc(${t.byteLength})`):new G(`new Uint8Array(${t.byteLength})`);if(t instanceof Date){let e=Ut(t)?t.toISOString():"Invalid Date";return new G(`new Date("${e}")`)}return t instanceof Ee?new G(`Prisma.${t._getName()}`):Ke(t)?new G(`prisma.${ve(t.modelName)}.$fields.${t.name}`):Array.isArray(t)?Ca(t):typeof t=="object"?Ei(t):new G(Object.prototype.toString.call(t))}function Ca(t){let e=new Ge;for(let r of t)e.addItem(xi(r));return e}function Ht(t,e){let r=e==="pretty"?pi:Qt,n=t.renderAllMessages(r),i=new Qe(0,{colors:r}).write(t).toString();return{message:n,args:i}}function zt({args:t,errors:e,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=He(t);for(let C of e)$t(C,a,s);let{message:f,args:h}=Ht(a,r),T=Bt({message:f,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:h});throw new W(T,{clientVersion:o})}u();c();m();p();d();l();u();c();m();p();d();l();function fe(t){return t.replace(/^./,e=>e.toLowerCase())}u();c();m();p();d();l();function vi(t,e,r){let n=fe(r);return!e.result||!(e.result.$allModels||e.result[n])?t:Ra({...t,...Pi(e.name,t,e.result.$allModels),...Pi(e.name,t,e.result[n])})}function Ra(t){let e=new pe,r=(n,i)=>e.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),t[n]?t[n].needs.flatMap(o=>r(o,i)):[n]));return Be(t,n=>({...n,needs:r(n.name,new Set)}))}function Pi(t,e,r){return r?Be(r,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:Aa(e,o,i)})):{}}function Aa(t,e,r){let n=t?.[e]?.compute;return n?i=>r({...i,[e]:n(i)}):r}function Ti(t,e){if(!e)return t;let r={...t};for(let n of Object.values(e))if(t[n.name])for(let i of n.needs)r[i]=!0;return r}function Ci(t,e){if(!e)return t;let r={...t};for(let n of Object.values(e))if(!t[n.name])for(let i of n.needs)delete r[i];return r}var Yt=class{constructor(e,r){this.extension=e;this.previous=r}computedFieldsCache=new pe;modelExtensionsCache=new pe;queryCallbacksCache=new pe;clientExtensions=ut(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=ut(()=>{let e=this.previous?.getAllBatchQueryCallbacks()??[],r=this.extension.query?.$__internalBatch;return r?e.concat(r):e});getAllComputedFields(e){return this.computedFieldsCache.getOrCreate(e,()=>vi(this.previous?.getAllComputedFields(e),this.extension,e))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(e){return this.modelExtensionsCache.getOrCreate(e,()=>{let r=fe(e);return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(e):{...this.previous?.getAllModelExtensions(e),...this.extension.model.$allModels,...this.extension.model[r]}})}getAllQueryCallbacks(e,r){return this.queryCallbacksCache.getOrCreate(`${e}:${r}`,()=>{let n=this.previous?.getAllQueryCallbacks(e,r)??[],i=[],o=this.extension.query;return!o||!(o[e]||o.$allModels||o[r]||o.$allOperations)?n:(o[e]!==void 0&&(o[e][r]!==void 0&&i.push(o[e][r]),o[e].$allOperations!==void 0&&i.push(o[e].$allOperations)),e!=="$none"&&o.$allModels!==void 0&&(o.$allModels[r]!==void 0&&i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[r]!==void 0&&i.push(o[r]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},ze=class t{constructor(e){this.head=e}static empty(){return new t}static single(e){return new t(new Yt(e))}isEmpty(){return this.head===void 0}append(e){return new t(new Yt(e,this.head))}getAllComputedFields(e){return this.head?.getAllComputedFields(e)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(e){return this.head?.getAllModelExtensions(e)}getAllQueryCallbacks(e,r){return this.head?.getAllQueryCallbacks(e,r)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};u();c();m();p();d();l();var Xt=class{constructor(e){this.name=e}};function Ri(t){return t instanceof Xt}function Ai(t){return new Xt(t)}u();c();m();p();d();l();u();c();m();p();d();l();var Si=Symbol(),Et=class{constructor(e){if(e!==Si)throw new Error("Skip instance can not be constructed directly")}ifUndefined(e){return e===void 0?Zt:e}},Zt=new Et(Si);function ge(t){return t instanceof Et}var Sa={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},ki="explicitly `undefined` values are not allowed";function er({modelName:t,action:e,args:r,runtimeDataModel:n,extensions:i=ze.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:f,previewFeatures:h,globalOmit:T}){let C=new $r({runtimeDataModel:n,modelName:t,action:e,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:f,previewFeatures:h,globalOmit:T});return{modelName:t,action:Sa[e],query:xt(r,C)}}function xt({select:t,include:e,...r}={},n){let i=r.omit;return delete r.omit,{arguments:Mi(r,n),selection:ka(t,e,i,n)}}function ka(t,e,r,n){return t?(e?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),_a(t,n)):Oa(n,e,r)}function Oa(t,e,r){let n={};return t.modelOrType&&!t.isRawAction()&&(n.$composites=!0,n.$scalars=!0),e&&Ma(n,e,t),Ia(n,r,t),n}function Ma(t,e,r){for(let[n,i]of Object.entries(e)){if(ge(i))continue;let o=r.nestSelection(n);if(Vr(i,o),i===!1||i===void 0){t[n]=!1;continue}let s=r.findField(n);if(s&&s.kind!=="object"&&r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){t[n]=xt(i===!0?{}:i,o);continue}if(i===!0){t[n]=!0;continue}t[n]=xt(i,o)}}function Ia(t,e,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...e},o=Ci(i,n);for(let[s,a]of Object.entries(o)){if(ge(a))continue;Vr(a,r.nestSelection(s));let f=r.findField(s);n?.[s]&&!f||(t[s]=!a)}}function _a(t,e){let r={},n=e.getComputedFields(),i=Ti(t,n);for(let[o,s]of Object.entries(i)){if(ge(s))continue;let a=e.nestSelection(o);Vr(s,a);let f=e.findField(o);if(!(n?.[o]&&!f)){if(s===!1||s===void 0||ge(s)){r[o]=!1;continue}if(s===!0){f?.kind==="object"?r[o]=xt({},a):r[o]=!0;continue}r[o]=xt(s,a)}}return r}function Oi(t,e){if(t===null)return null;if(typeof t=="string"||typeof t=="number"||typeof t=="boolean")return t;if(typeof t=="bigint")return{$type:"BigInt",value:String(t)};if(Ve(t)){if(Ut(t))return{$type:"DateTime",value:t.toISOString()};e.throwValidationError({kind:"InvalidArgumentValue",selectionPath:e.getSelectionPath(),argumentPath:e.getArgumentPath(),argument:{name:e.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Ri(t))return{$type:"Param",value:t.name};if(Ke(t))return{$type:"FieldRef",value:{_ref:t.name,_container:t.modelName}};if(Array.isArray(t))return Da(t,e);if(ArrayBuffer.isView(t)){let{buffer:r,byteOffset:n,byteLength:i}=t;return{$type:"Bytes",value:b.from(r,n,i).toString("base64")}}if(La(t))return t.values;if(je(t))return{$type:"Decimal",value:t.toFixed()};if(t instanceof Ee){if(t!==Wt.instances[t._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:t._getName()}}if(Fa(t))return t.toJSON();if(typeof t=="object")return Mi(t,e);e.throwValidationError({kind:"InvalidArgumentValue",selectionPath:e.getSelectionPath(),argumentPath:e.getArgumentPath(),argument:{name:e.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(t)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function Mi(t,e){if(t.$type)return{$type:"Raw",value:t};let r={};for(let n in t){let i=t[n],o=e.nestArgument(n);ge(i)||(i!==void 0?r[n]=Oi(i,o):e.isPreviewFeatureOn("strictUndefinedChecks")&&e.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:e.getSelectionPath(),argument:{name:e.getArgumentName(),typeNames:[]},underlyingError:ki}))}return r}function Da(t,e){let r=[];for(let n=0;n<t.length;n++){let i=e.nestArgument(String(n)),o=t[n];if(o===void 0||ge(o)){let s=o===void 0?"undefined":"Prisma.skip";e.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${e.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}r.push(Oi(o,i))}return r}function La(t){return typeof t=="object"&&t!==null&&t.__prismaRawParameters__===!0}function Fa(t){return typeof t=="object"&&t!==null&&typeof t.toJSON=="function"}function Vr(t,e){t===void 0&&e.isPreviewFeatureOn("strictUndefinedChecks")&&e.throwValidationError({kind:"InvalidSelectionValue",selectionPath:e.getSelectionPath(),underlyingError:ki})}var $r=class t{constructor(e){this.params=e;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(e){zt({errors:[e],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(e=>({name:e.name,typeName:"boolean",isRelation:e.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(e){return this.params.previewFeatures.includes(e)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(e){return this.modelOrType?.fields.find(r=>r.name===e)}nestSelection(e){let r=this.findField(e),n=r?.kind==="object"?r.type:void 0;return new t({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(e)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[ve(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:be(this.params.action,"Unknown action")}}nestArgument(e){return new t({...this.params,argumentPath:this.params.argumentPath.concat(e)})}};u();c();m();p();d();l();function Ii(t){if(!t._hasPreviewFlag("metrics"))throw new W("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:t._clientVersion})}var Ye=class{_client;constructor(e){this._client=e}prometheus(e){return Ii(this._client),this._client._engine.metrics({format:"prometheus",...e})}json(e){return Ii(this._client),this._client._engine.metrics({format:"json",...e})}};u();c();m();p();d();l();function _i(t,e){let r=ut(()=>Na(e));Object.defineProperty(t,"dmmf",{get:()=>r.get()})}function Na(t){throw new Error("Prisma.dmmf is not available when running in edge runtimes.")}function jr(t){return Object.entries(t).map(([e,r])=>({name:e,...r}))}u();c();m();p();d();l();var Qr=new WeakMap,tr="$$PrismaTypedSql",Pt=class{constructor(e,r){Qr.set(this,{sql:e,values:r}),Object.defineProperty(this,tr,{value:tr})}get sql(){return Qr.get(this).sql}get values(){return Qr.get(this).values}};function Di(t){return(...e)=>new Pt(t,e)}function rr(t){return t!=null&&t[tr]===tr}u();c();m();p();d();l();var Go=nt(Li());u();c();m();p();d();l();Fi();Un();jn();u();c();m();p();d();l();var Z=class t{constructor(e,r){if(e.length-1!==r.length)throw e.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${e.length} strings to have ${e.length-1} values`);let n=r.reduce((s,a)=>s+(a instanceof t?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=e[0];let i=0,o=0;for(;i<r.length;){let s=r[i++],a=e[i];if(s instanceof t){this.strings[o]+=s.strings[0];let f=0;for(;f<s.values.length;)this.values[o++]=s.values[f++],this.strings[o]=s.strings[f];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let e=this.strings.length,r=1,n=this.strings[0];for(;r<e;)n+=`?${this.strings[r++]}`;return n}get statement(){let e=this.strings.length,r=1,n=this.strings[0];for(;r<e;)n+=`:${r}${this.strings[r++]}`;return n}get text(){let e=this.strings.length,r=1,n=this.strings[0];for(;r<e;)n+=`$${r}${this.strings[r++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function Ni(t,e=",",r="",n=""){if(t.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new Z([r,...Array(t.length-1).fill(e),n],t)}function Jr(t){return new Z([t],[])}var qi=Jr("");function Gr(t,...e){return new Z(t,e)}u();c();m();p();d();l();u();c();m();p();d();l();function vt(t){return{getKeys(){return Object.keys(t)},getPropertyValue(e){return t[e]}}}u();c();m();p();d();l();function K(t,e){return{getKeys(){return[t]},getPropertyValue(){return e()}}}u();c();m();p();d();l();function Ie(t){let e=new pe;return{getKeys(){return t.getKeys()},getPropertyValue(r){return e.getOrCreate(r,()=>t.getPropertyValue(r))},getPropertyDescriptor(r){return t.getPropertyDescriptor?.(r)}}}u();c();m();p();d();l();u();c();m();p();d();l();var ir={enumerable:!0,configurable:!0,writable:!0};function or(t){let e=new Set(t);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>ir,has:(r,n)=>e.has(n),set:(r,n,i)=>e.add(n)&&Reflect.set(r,n,i),ownKeys:()=>[...e]}}var Ui=Symbol.for("nodejs.util.inspect.custom");function ae(t,e){let r=Ua(e),n=new Set,i=new Proxy(t,{get(o,s){if(n.has(s))return o[s];let a=r.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=r.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=Bi(Reflect.ownKeys(o),r),a=Bi(Array.from(r.keys()),r);return[...new Set([...s,...a,...n])]},set(o,s,a){return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let f=r.get(s);return f?f.getPropertyDescriptor?{...ir,...f?.getPropertyDescriptor(s)}:ir:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[Ui]=function(){let o={...this};return delete o[Ui],o},i}function Ua(t){let e=new Map;for(let r of t){let n=r.getKeys();for(let i of n)e.set(i,r)}return e}function Bi(t,e){return t.filter(r=>e.get(r)?.has?.(r)??!0)}u();c();m();p();d();l();function Xe(t){return{getKeys(){return t},has(){return!1},getPropertyValue(){}}}u();c();m();p();d();l();function sr(t,e){return{batch:t,transaction:e?.kind==="batch"?{isolationLevel:e.options.isolationLevel}:void 0}}u();c();m();p();d();l();function $i(t){if(t===void 0)return"";let e=He(t);return new Qe(0,{colors:Qt}).write(e).toString()}u();c();m();p();d();l();var Ba="P2037";function ar({error:t,user_facing_error:e},r,n){return e.error_code?new X($a(e,n),{code:e.error_code,clientVersion:r,meta:e.meta,batchRequestIdx:e.batch_request_idx}):new j(t,{clientVersion:r,batchRequestIdx:e.batch_request_idx})}function $a(t,e){let r=t.message;return(e==="postgresql"||e==="postgres"||e==="mysql")&&t.error_code===Ba&&(r+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();var Wr=class{getLocation(){return null}};function Ce(t){return typeof $EnabledCallSite=="function"&&t!=="minimal"?new $EnabledCallSite:new Wr}u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();var Vi={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function Ze(t={}){let e=ja(t);return Object.entries(e).reduce((n,[i,o])=>(Vi[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function ja(t={}){return typeof t._count=="boolean"?{...t,_count:{_all:t._count}}:t}function lr(t={}){return e=>(typeof t._count=="boolean"&&(e._count=e._count._all),e)}function ji(t,e){let r=lr(t);return e({action:"aggregate",unpacker:r,argsMapper:Ze})(t)}u();c();m();p();d();l();function Qa(t={}){let{select:e,...r}=t;return typeof e=="object"?Ze({...r,_count:e}):Ze({...r,_count:{_all:!0}})}function Ja(t={}){return typeof t.select=="object"?e=>lr(t)(e)._count:e=>lr(t)(e)._count._all}function Qi(t,e){return e({action:"count",unpacker:Ja(t),argsMapper:Qa})(t)}u();c();m();p();d();l();function Ga(t={}){let e=Ze(t);if(Array.isArray(e.by))for(let r of e.by)typeof r=="string"&&(e.select[r]=!0);else typeof e.by=="string"&&(e.select[e.by]=!0);return e}function Wa(t={}){return e=>(typeof t?._count=="boolean"&&e.forEach(r=>{r._count=r._count._all}),e)}function Ji(t,e){return e({action:"groupBy",unpacker:Wa(t),argsMapper:Ga})(t)}function Gi(t,e,r){if(e==="aggregate")return n=>ji(n,r);if(e==="count")return n=>Qi(n,r);if(e==="groupBy")return n=>Ji(n,r)}u();c();m();p();d();l();function Wi(t,e){let r=e.fields.filter(i=>!i.relationName),n=ni(r,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new gt(t,o,s.type,s.isList,s.kind==="enum")},...or(Object.keys(n))})}u();c();m();p();d();l();u();c();m();p();d();l();var Ki=t=>Array.isArray(t)?t:t.split("."),Kr=(t,e)=>Ki(e).reduce((r,n)=>r&&r[n],t),Hi=(t,e,r)=>Ki(e).reduceRight((n,i,o,s)=>Object.assign({},Kr(t,s.slice(0,o)),{[i]:n}),r);function Ka(t,e){return t===void 0||e===void 0?[]:[...e,"select",t]}function Ha(t,e,r){return e===void 0?t??{}:Hi(e,r,t||!0)}function Hr(t,e,r,n,i,o){let a=t._runtimeDataModel.models[e].fields.reduce((f,h)=>({...f,[h.name]:h}),{});return f=>{let h=Ce(t._errorFormat),T=Ka(n,i),C=Ha(f,o,T),k=r({dataPath:T,callsite:h})(C),A=za(t,e);return new Proxy(k,{get(O,S){if(!A.includes(S))return O[S];let oe=[a[S].type,r,S],H=[T,C];return Hr(t,...oe,...H)},...or([...A,...Object.getOwnPropertyNames(k)])})}}function za(t,e){return t._runtimeDataModel.models[e].fields.filter(r=>r.kind==="object").map(r=>r.name)}var Ya=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],Xa=["aggregate","count","groupBy"];function zr(t,e){let r=t._extensions.getAllModelExtensions(e)??{},n=[Za(t,e),tl(t,e),vt(r),K("name",()=>e),K("$name",()=>e),K("$parent",()=>t._appliedParent)];return ae({},n)}function Za(t,e){let r=fe(e),n=Object.keys(ct).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>f=>{let h=Ce(t._errorFormat);return t._createPrismaPromise(T=>{let C={args:f,dataPath:[],action:o,model:e,clientMethod:`${r}.${i}`,jsModelName:r,transaction:T,callsite:h};return t._request({...C,...a})},{action:o,args:f,model:e})};return Ya.includes(o)?Hr(t,e,s):el(i)?Gi(t,i,s):s({})}}}function el(t){return Xa.includes(t)}function tl(t,e){return Ie(K("fields",()=>{let r=t._runtimeDataModel.models[e];return Wi(e,r)}))}u();c();m();p();d();l();function zi(t){return t.replace(/^./,e=>e.toUpperCase())}var Yr=Symbol();function Tt(t){let e=[rl(t),nl(t),K(Yr,()=>t),K("$parent",()=>t._appliedParent)],r=t._extensions.getAllClientExtensions();return r&&e.push(vt(r)),ae(t,e)}function rl(t){let e=Object.getPrototypeOf(t._originalClient),r=[...new Set(Object.getOwnPropertyNames(e))];return{getKeys(){return r},getPropertyValue(n){return t[n]}}}function nl(t){let e=Object.keys(t._runtimeDataModel.models),r=e.map(fe),n=[...new Set(e.concat(r))];return Ie({getKeys(){return n},getPropertyValue(i){let o=zi(i);if(t._runtimeDataModel.models[o]!==void 0)return zr(t,o);if(t._runtimeDataModel.models[i]!==void 0)return zr(t,i)},getPropertyDescriptor(i){if(!r.includes(i))return{enumerable:!1}}})}function Yi(t){return t[Yr]?t[Yr]:t}function Xi(t){if(typeof t=="function")return t(this);if(t.client?.__AccelerateEngine){let r=t.client.__AccelerateEngine;this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}let e=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(t)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return Tt(e)}u();c();m();p();d();l();u();c();m();p();d();l();function Zi({result:t,modelName:e,select:r,omit:n,extensions:i}){let o=i.getAllComputedFields(e);if(!o)return t;let s=[],a=[];for(let f of Object.values(o)){if(n){if(n[f.name])continue;let h=f.needs.filter(T=>n[T]);h.length>0&&a.push(Xe(h))}else if(r){if(!r[f.name])continue;let h=f.needs.filter(T=>!r[T]);h.length>0&&a.push(Xe(h))}il(t,f.needs)&&s.push(ol(f,ae(t,s)))}return s.length>0||a.length>0?ae(t,[...s,...a]):t}function il(t,e){return e.every(r=>_r(t,r))}function ol(t,e){return Ie(K(t.name,()=>t.compute(e)))}u();c();m();p();d();l();function ur({visitor:t,result:e,args:r,runtimeDataModel:n,modelName:i}){if(Array.isArray(e)){for(let s=0;s<e.length;s++)e[s]=ur({result:e[s],args:r,modelName:i,runtimeDataModel:n,visitor:t});return e}let o=t(e,i,r)??e;return r.include&&eo({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:t}),r.select&&eo({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:t}),o}function eo({includeOrSelect:t,result:e,parentModelName:r,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(t)){if(!s||e[o]==null||ge(s))continue;let f=n.models[r].fields.find(T=>T.name===o);if(!f||f.kind!=="object"||!f.relationName)continue;let h=typeof s=="object"?s:{};e[o]=ur({visitor:i,result:e[o],args:h,modelName:f.type,runtimeDataModel:n})}}function to({result:t,modelName:e,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||t==null||typeof t!="object"||!i.models[e]?t:ur({result:t,args:r??{},modelName:e,runtimeDataModel:i,visitor:(a,f,h)=>{let T=fe(f);return Zi({result:a,modelName:T,select:h.select,omit:h.select?void 0:{...o?.[T],...h.omit},extensions:n})}})}u();c();m();p();d();l();u();c();m();p();d();l();l();u();c();m();p();d();l();var sl=["$connect","$disconnect","$on","$transaction","$use","$extends"],ro=sl;function no(t){if(t instanceof Z)return al(t);if(rr(t))return ll(t);if(Array.isArray(t)){let r=[t[0]];for(let n=1;n<t.length;n++)r[n]=Ct(t[n]);return r}let e={};for(let r in t)e[r]=Ct(t[r]);return e}function al(t){return new Z(t.strings,t.values)}function ll(t){return new Pt(t.sql,t.values)}function Ct(t){if(typeof t!="object"||t==null||t instanceof Ee||Ke(t))return t;if(je(t))return new me(t.toFixed());if(Ve(t))return new Date(+t);if(ArrayBuffer.isView(t))return t.slice(0);if(Array.isArray(t)){let e=t.length,r;for(r=Array(e);e--;)r[e]=Ct(t[e]);return r}if(typeof t=="object"){let e={};for(let r in t)r==="__proto__"?Object.defineProperty(e,r,{value:Ct(t[r]),configurable:!0,enumerable:!0,writable:!0}):e[r]=Ct(t[r]);return e}be(t,"Unknown value")}function oo(t,e,r,n=0){return t._createPrismaPromise(i=>{let o=e.customDataProxyFetch;return"transaction"in e&&i!==void 0&&(e.transaction?.kind==="batch"&&e.transaction.lock.then(),e.transaction=i),n===r.length?t._executeRequest(e):r[n]({model:e.model,operation:e.model?e.action:e.clientMethod,args:no(e.args??{}),__internalParams:e,query:(s,a=e)=>{let f=a.customDataProxyFetch;return a.customDataProxyFetch=uo(o,f),a.args=s,oo(t,a,r,n+1)}})})}function so(t,e){let{jsModelName:r,action:n,clientMethod:i}=e,o=r?n:i;if(t._extensions.isEmpty())return t._executeRequest(e);let s=t._extensions.getAllQueryCallbacks(r??"$none",o);return oo(t,e,s)}function ao(t){return e=>{let r={requests:e},n=e[0].extensions.getAllBatchQueryCallbacks();return n.length?lo(r,n,0,t):t(r)}}function lo(t,e,r,n){if(r===e.length)return n(t);let i=t.customDataProxyFetch,o=t.requests[0].transaction;return e[r]({args:{queries:t.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:t,query(s,a=t){let f=a.customDataProxyFetch;return a.customDataProxyFetch=uo(i,f),lo(a,e,r+1,n)}})}var io=t=>t;function uo(t=io,e=io){return r=>t(e(r))}u();c();m();p();d();l();var co=J("prisma:client"),mo={Vercel:"vercel","Netlify CI":"netlify"};function po({postinstall:t,ciName:e,clientVersion:r}){if(co("checkPlatformCaching:postinstall",t),co("checkPlatformCaching:ciName",e),t===!0&&e&&e in mo){let n=`Prisma has detected that this project was built on ${e}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${mo[e]}-build`;throw console.error(n),new I(n,r)}}u();c();m();p();d();l();function fo(t,e){return t?t.datasources?t.datasources:t.datasourceUrl?{[e[0]]:{url:t.datasourceUrl}}:{}:{}}u();c();m();p();d();l();u();c();m();p();d();l();var ul=()=>globalThis.process?.release?.name==="node",cl=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,ml=()=>!!globalThis.Deno,pl=()=>typeof globalThis.Netlify=="object",dl=()=>typeof globalThis.EdgeRuntime=="object",fl=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function gl(){return[[pl,"netlify"],[dl,"edge-light"],[fl,"workerd"],[ml,"deno"],[cl,"bun"],[ul,"node"]].flatMap(r=>r[0]()?[r[1]]:[]).at(0)??""}var yl={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function Re(){let t=gl();return{id:t,prettyName:yl[t]||t,isEdge:["workerd","deno","netlify","edge-light"].includes(t)}}u();c();m();p();d();l();u();c();m();p();d();l();function cr({inlineDatasources:t,overrideDatasources:e,env:r,clientVersion:n}){let i,o=Object.keys(t)[0],s=t[o]?.url,a=e[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw Re().id==="workerd"?new I(`error: Environment variable not found: ${s.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new I(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new I("error: Missing URL environment variable, value, or override.",n);return i}u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();u();c();m();p();d();l();function Xr(t){return t.name==="DriverAdapterError"&&typeof t.cause=="object"}u();c();m();p();d();l();function mr(t){return{ok:!0,value:t,map(e){return mr(e(t))},flatMap(e){return e(t)}}}function _e(t){return{ok:!1,error:t,map(){return _e(t)},flatMap(){return _e(t)}}}var go=J("driver-adapter-utils"),Zr=class{registeredErrors=[];consumeError(e){return this.registeredErrors[e]}registerNewError(e){let r=0;for(;this.registeredErrors[r]!==void 0;)r++;return this.registeredErrors[r]={error:e},r}};var en=(t,e=new Zr)=>{let r={adapterName:t.adapterName,errorRegistry:e,queryRaw:xe(e,t.queryRaw.bind(t)),executeRaw:xe(e,t.executeRaw.bind(t)),executeScript:xe(e,t.executeScript.bind(t)),dispose:xe(e,t.dispose.bind(t)),provider:t.provider,startTransaction:async(...n)=>(await xe(e,t.startTransaction.bind(t))(...n)).map(o=>hl(e,o))};return t.getConnectionInfo&&(r.getConnectionInfo=bl(e,t.getConnectionInfo.bind(t))),r},hl=(t,e)=>({adapterName:e.adapterName,provider:e.provider,options:e.options,queryRaw:xe(t,e.queryRaw.bind(e)),executeRaw:xe(t,e.executeRaw.bind(e)),commit:xe(t,e.commit.bind(e)),rollback:xe(t,e.rollback.bind(e))});function xe(t,e){return async(...r)=>{try{return mr(await e(...r))}catch(n){if(go("[error@wrapAsync]",n),Xr(n))return _e(n.cause);let i=t.registerNewError(n);return _e({kind:"GenericJs",id:i})}}}function bl(t,e){return(...r)=>{try{return mr(e(...r))}catch(n){if(go("[error@wrapSync]",n),Xr(n))return _e(n.cause);let i=t.registerNewError(n);return _e({kind:"GenericJs",id:i})}}}u();c();m();p();d();l();function yo(t){if(t?.kind==="itx")return t.options.id}u();c();m();p();d();l();var tn,ho={async loadLibrary(t){let{clientVersion:e,adapter:r,engineWasm:n}=t;if(r===void 0)throw new I(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Re().prettyName})`,e);if(n===void 0)throw new I("WASM engine was unexpectedly `undefined`",e);tn===void 0&&(tn=(async()=>{let o=await n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new I("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",e);let a={"./query_engine_bg.js":o},f=new WebAssembly.Instance(s,a),h=f.exports.__wbindgen_start;return o.__wbg_set_wasm(f.exports),h(),o.QueryEngine})());let i=await tn;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}};var wl="P2036",ye=J("prisma:client:libraryEngine");function El(t){return t.item_type==="query"&&"query"in t}function xl(t){return"level"in t?t.level==="error"&&t.message==="PANIC":!1}var SS=[...kr,"native"],Pl=0xffffffffffffffffn,rn=1n;function vl(){let t=rn++;return rn>Pl&&(rn=1n),t}var Rt=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(e,r){this.libraryLoader=r??ho,this.config=e,this.libraryStarted=!1,this.logQueries=e.logQueries??!1,this.logLevel=e.logLevel??"error",this.logEmitter=e.logEmitter,this.datamodel=e.inlineSchema,this.tracingHelper=e.tracingHelper,e.enableDebugLogs&&(this.logLevel="debug");let n=Object.keys(e.overrideDatasources)[0],i=e.overrideDatasources[n]?.url;n!==void 0&&i!==void 0&&(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(e){return{applyPendingMigrations:e.applyPendingMigrations?.bind(e),commitTransaction:this.withRequestId(e.commitTransaction.bind(e)),connect:this.withRequestId(e.connect.bind(e)),disconnect:this.withRequestId(e.disconnect.bind(e)),metrics:e.metrics?.bind(e),query:this.withRequestId(e.query.bind(e)),rollbackTransaction:this.withRequestId(e.rollbackTransaction.bind(e)),sdlSchema:e.sdlSchema?.bind(e),startTransaction:this.withRequestId(e.startTransaction.bind(e)),trace:e.trace.bind(e)}}withRequestId(e){return async(...r)=>{let n=vl().toString();try{return await e(...r,n)}finally{if(this.tracingHelper.isEnabled()){let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}}}async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}async transaction(e,r,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(r),s;if(e==="start"){let f=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(f,o)}else e==="commit"?s=await this.engine?.commitTransaction(n.id,o):e==="rollback"&&(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(Tl(a)){let f=this.getExternalAdapterError(a,i?.errorRegistry);throw f?f.error:new X(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new j(a.message,{clientVersion:this.config.clientVersion});return a}async instantiateLibrary(){if(ye("internalSetup"),this.libraryInstantiationPromise)return this.libraryInstantiationPromise;this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=>this.loadEngine()),this.version()}async getCurrentBinaryTarget(){}parseEngineResponse(e){if(!e)throw new j("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(e)}catch{throw new j("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let e=new w(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(en));let r=await this.adapterPromise;r&&ye("Using driver adapter: %O",r),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:g.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=>{e.deref()?.logger(n)},r))}catch(e){let r=e,n=this.parseInitError(r.message);throw typeof n=="string"?r:new I(n.message,this.config.clientVersion,n.error_code)}}}logger(e){let r=this.parseEngineResponse(e);r&&(r.level=r?.level.toLowerCase()??"unknown",El(r)?this.logEmitter.emit("query",{timestamp:new Date,query:r.query,params:r.params,duration:Number(r.duration_ms),target:r.module_path}):(xl(r),this.logEmitter.emit(r.level,{timestamp:new Date,message:r.message,target:r.module_path})))}parseInitError(e){try{return JSON.parse(e)}catch{}return e}parseRequestError(e){try{return JSON.parse(e)}catch{}return e}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}async start(){if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return ye(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let e=async()=>{ye("library starting");try{let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(r)),this.libraryStarted=!0,ye("library started")}catch(r){let n=this.parseInitError(r.message);throw typeof n=="string"?r:new I(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",e),this.libraryStartingPromise}async stop(){if(await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return ye("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted)return;let e=async()=>{await new Promise(n=>setTimeout(n,5)),ye("library stopping");let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(r)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,ye("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",e),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}debugPanic(e){return this.library?.debugPanic(e)}async request(e,{traceparent:r,interactiveTransaction:n}){ye(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:r}),o=JSON.stringify(e);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:a}}catch(s){if(s instanceof I)throw s;s.code==="GenericFailure"&&s.message?.startsWith("PANIC:");let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new j(`${a.message}
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(e,{transaction:r,traceparent:n}){ye("requestBatch");let i=sr(e,r);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),yo(r));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:f,errors:h}=a;if(Array.isArray(f))return f.map(T=>T.errors&&T.errors.length>0?this.loggerRustPanic??this.buildQueryError(T.errors[0],o?.errorRegistry):{data:T});throw h&&h.length===1?new Error(h[0].error):new Error(JSON.stringify(a))}buildQueryError(e,r){e.user_facing_error.is_panic;let n=this.getExternalAdapterError(e.user_facing_error,r);return n?n.error:ar(e,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(e,r){if(e.error_code===wl&&r){let n=e.meta?.id;qt(typeof n=="number","Malformed external JS error received from the engine");let i=r.consumeError(n);return qt(i,"External error with reported id was not registered"),i}}async metrics(e){await this.start();let r=await this.engine.metrics(JSON.stringify(e));return e.format==="prometheus"?r:this.parseEngineResponse(r)}};function Tl(t){return typeof t=="object"&&t!==null&&t.error_code!==void 0}u();c();m();p();d();l();var At="Accelerate has not been setup correctly. Make sure your client is using `.$extends(withAccelerate())`. See https://pris.ly/d/accelerate-getting-started",pr=class{constructor(e){this.config=e;this.resolveDatasourceUrl=this.config.accelerateUtils?.resolveDatasourceUrl,this.getBatchRequestPayload=this.config.accelerateUtils?.getBatchRequestPayload,this.prismaGraphQLToJSError=this.config.accelerateUtils?.prismaGraphQLToJSError,this.PrismaClientUnknownRequestError=this.config.accelerateUtils?.PrismaClientUnknownRequestError,this.PrismaClientInitializationError=this.config.accelerateUtils?.PrismaClientInitializationError,this.PrismaClientKnownRequestError=this.config.accelerateUtils?.PrismaClientKnownRequestError,this.debug=this.config.accelerateUtils?.debug,this.engineVersion=this.config.accelerateUtils?.engineVersion,this.clientVersion=this.config.accelerateUtils?.clientVersion}name="AccelerateEngine";resolveDatasourceUrl;getBatchRequestPayload;prismaGraphQLToJSError;PrismaClientUnknownRequestError;PrismaClientInitializationError;PrismaClientKnownRequestError;debug;engineVersion;clientVersion;onBeforeExit(e){}async start(){}async stop(){}version(e){return"unknown"}transaction(e,r,n){throw new I(At,this.config.clientVersion)}metrics(e){throw new I(At,this.config.clientVersion)}request(e,r){throw new I(At,this.config.clientVersion)}requestBatch(e,r){throw new I(At,this.config.clientVersion)}applyPendingMigrations(){throw new I(At,this.config.clientVersion)}};function bo({copyEngine:t=!0},e){let r;try{r=cr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,env:{...e.env,...g.env},clientVersion:e.clientVersion})}catch{}let n=!!(r?.startsWith("prisma://")||Mr(r));t&&n&&lt("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");let i=Ue(e.generator),o=n||!t,s=!!e.adapter,a=i==="library",f=i==="binary",h=i==="client";if(o&&s||s&&!1){let T;throw t?r?.startsWith("prisma://")?T=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:T=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:T=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new W(T.join(`
`),{clientVersion:e.clientVersion})}if(s)return new Rt(e);if(o)return new pr(e);{let T=[`PrismaClient failed to initialize because it wasn't configured to run in this environment (${Re().prettyName}).`,"In order to run Prisma Client in an edge runtime, you will need to configure one of the following options:","- Enable Driver Adapters: https://pris.ly/d/driver-adapters","- Enable Accelerate: https://pris.ly/d/accelerate"];throw new W(T.join(`
`),{clientVersion:e.clientVersion})}return"wasm"}u();c();m();p();d();l();function dr({generator:t}){return t?.previewFeatures??[]}u();c();m();p();d();l();var wo=t=>({command:t});u();c();m();p();d();l();u();c();m();p();d();l();var Eo=t=>t.strings.reduce((e,r,n)=>`${e}@P${n}${r}`);u();c();m();p();d();l();l();function et(t){try{return xo(t,"fast")}catch{return xo(t,"slow")}}function xo(t,e){return JSON.stringify(t.map(r=>vo(r,e)))}function vo(t,e){if(Array.isArray(t))return t.map(r=>vo(r,e));if(typeof t=="bigint")return{prisma__type:"bigint",prisma__value:t.toString()};if(Ve(t))return{prisma__type:"date",prisma__value:t.toJSON()};if(me.isDecimal(t))return{prisma__type:"decimal",prisma__value:t.toJSON()};if(b.isBuffer(t))return{prisma__type:"bytes",prisma__value:t.toString("base64")};if(Cl(t))return{prisma__type:"bytes",prisma__value:b.from(t).toString("base64")};if(ArrayBuffer.isView(t)){let{buffer:r,byteOffset:n,byteLength:i}=t;return{prisma__type:"bytes",prisma__value:b.from(r,n,i).toString("base64")}}return typeof t=="object"&&e==="slow"?To(t):t}function Cl(t){return t instanceof ArrayBuffer||t instanceof SharedArrayBuffer?!0:typeof t=="object"&&t!==null?t[Symbol.toStringTag]==="ArrayBuffer"||t[Symbol.toStringTag]==="SharedArrayBuffer":!1}function To(t){if(typeof t!="object"||t===null)return t;if(typeof t.toJSON=="function")return t.toJSON();if(Array.isArray(t))return t.map(Po);let e={};for(let r of Object.keys(t))e[r]=Po(t[r]);return e}function Po(t){return typeof t=="bigint"?t.toString():To(t)}var Rl=/^(\s*alter\s)/i,Co=J("prisma:client");function nn(t,e,r,n){if(!(t!=="postgresql"&&t!=="cockroachdb")&&r.length>0&&Rl.exec(e))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var on=({clientMethod:t,activeProvider:e})=>r=>{let n="",i;if(rr(r))n=r.sql,i={values:et(r.values),__prismaRawParameters__:!0};else if(Array.isArray(r)){let[o,...s]=r;n=o,i={values:et(s||[]),__prismaRawParameters__:!0}}else switch(e){case"sqlite":case"mysql":{n=r.sql,i={values:et(r.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=r.text,i={values:et(r.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=Eo(r),i={values:et(r.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${e} provider does not support ${t}`)}return i?.values?Co(`prisma.${t}(${n}, ${i.values})`):Co(`prisma.${t}(${n})`),{query:n,parameters:i}},Ro={requestArgsToMiddlewareArgs(t){return[t.strings,...t.values]},middlewareArgsToRequestArgs(t){let[e,...r]=t;return new Z(e,r)}},Ao={requestArgsToMiddlewareArgs(t){return[t]},middlewareArgsToRequestArgs(t){return t[0]}};u();c();m();p();d();l();function sn(t){return function(r,n){let i,o=(s=t)=>{try{return s===void 0||s?.kind==="itx"?i??=So(r(s)):So(r(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function So(t){return typeof t.then=="function"?t:Promise.resolve(t)}u();c();m();p();d();l();var Al=Or.split(".")[0],Sl={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(t,e){return e()}},an=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(e){return this.getGlobalTracingHelper().getTraceParent(e)}dispatchEngineSpans(e){return this.getGlobalTracingHelper().dispatchEngineSpans(e)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(e,r){return this.getGlobalTracingHelper().runInChildSpan(e,r)}getGlobalTracingHelper(){let e=globalThis[`V${Al}_PRISMA_INSTRUMENTATION`],r=globalThis.PRISMA_INSTRUMENTATION;return e?.helper??r?.helper??Sl}};function ko(){return new an}u();c();m();p();d();l();function Oo(t,e=()=>{}){let r,n=new Promise(i=>r=i);return{then(i){return--t===0&&r(e()),i?.(n)}}}u();c();m();p();d();l();function Mo(t){return typeof t=="string"?t:t.reduce((e,r)=>{let n=typeof r=="string"?r:r.level;return n==="query"?e:e&&(r==="info"||e==="info")?"info":n},void 0)}u();c();m();p();d();l();var fr=class{_middlewares=[];use(e){this._middlewares.push(e)}get(e){return this._middlewares[e]}has(e){return!!this._middlewares[e]}length(){return this._middlewares.length}};u();c();m();p();d();l();var _o=nt(ei());u();c();m();p();d();l();function gr(t){return typeof t.batchRequestIdx=="number"}u();c();m();p();d();l();function Io(t){if(t.action!=="findUnique"&&t.action!=="findUniqueOrThrow")return;let e=[];return t.modelName&&e.push(t.modelName),t.query.arguments&&e.push(ln(t.query.arguments)),e.push(ln(t.query.selection)),e.join("")}function ln(t){return`(${Object.keys(t).sort().map(r=>{let n=t[r];return typeof n=="object"&&n!==null?`(${r} ${ln(n)})`:r}).join(" ")})`}u();c();m();p();d();l();var kl={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function un(t){return kl[t]}u();c();m();p();d();l();var yr=class{constructor(e){this.options=e;this.batches={}}batches;tickActive=!1;request(e){let r=this.options.batchBy(e);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,g.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[r].push({request:e,resolve:n,reject:i})})):this.options.singleLoader(e)}dispatchBatches(){for(let e in this.batches){let r=this.batches[e];delete this.batches[e],r.length===1?this.options.singleLoader(r[0].request).then(n=>{n instanceof Error?r[0].reject(n):r[0].resolve(n)}).catch(n=>{r[0].reject(n)}):(r.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(r.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<r.length;i++)r[i].reject(n);else for(let i=0;i<r.length;i++){let o=n[i];o instanceof Error?r[i].reject(o):r[i].resolve(o)}}).catch(n=>{for(let i=0;i<r.length;i++)r[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};u();c();m();p();d();l();l();function De(t,e){if(e===null)return e;switch(t){case"bigint":return BigInt(e);case"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=b.from(e,"base64");return new Uint8Array(r,n,i)}case"decimal":return new me(e);case"datetime":case"date":return new Date(e);case"time":return new Date(`1970-01-01T${e}Z`);case"bigint-array":return e.map(r=>De("bigint",r));case"bytes-array":return e.map(r=>De("bytes",r));case"decimal-array":return e.map(r=>De("decimal",r));case"datetime-array":return e.map(r=>De("datetime",r));case"date-array":return e.map(r=>De("date",r));case"time-array":return e.map(r=>De("time",r));default:return e}}function hr(t){let e=[],r=Ol(t);for(let n=0;n<t.rows.length;n++){let i=t.rows[n],o={...r};for(let s=0;s<i.length;s++)o[t.columns[s]]=De(t.types[s],i[s]);e.push(o)}return e}function Ol(t){let e={};for(let r=0;r<t.columns.length;r++)e[t.columns[r]]=null;return e}var Ml=J("prisma:client:request_handler"),br=class{client;dataloader;logEmitter;constructor(e,r){this.logEmitter=r,this.client=e,this.dataloader=new yr({batchLoader:ao(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(C=>C.protocolQuery),f=this.client._tracingHelper.getTraceParent(s),h=n.some(C=>un(C.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:f,transaction:Il(o),containsWrite:h,customDataProxyFetch:i})).map((C,k)=>{if(C instanceof Error)return C;try{return this.mapQueryEngineResult(n[k],C)}catch(A){return A}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?Do(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:un(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:Io(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(e){try{return await this.dataloader.request(e)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=e;this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:e.globalOmit})}}mapQueryEngineResult({dataPath:e,unpacker:r},n){let i=n?.data,o=this.unpack(i,e,r);return g.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(e){try{this.handleRequestError(e)}catch(r){throw this.logEmitter&&this.logEmitter.emit("error",{message:r.message,target:e.clientMethod,timestamp:new Date}),r}}handleRequestError({error:e,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(Ml(e),_l(e,i))throw e;if(e instanceof X&&Dl(e)){let h=Lo(e.meta);zt({args:o,errors:[h],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}let f=e.message;if(n&&(f=Bt({callsite:n,originalMethod:r,isPanic:e.isPanic,showColors:this.client._errorFormat==="pretty",message:f})),f=this.sanitizeMessage(f),e.code){let h=s?{modelName:s,...e.meta}:e.meta;throw new X(f,{code:e.code,clientVersion:this.client._clientVersion,meta:h,batchRequestIdx:e.batchRequestIdx})}else{if(e.isPanic)throw new we(f,this.client._clientVersion);if(e instanceof j)throw new j(f,{clientVersion:this.client._clientVersion,batchRequestIdx:e.batchRequestIdx});if(e instanceof I)throw new I(f,this.client._clientVersion);if(e instanceof we)throw new we(f,this.client._clientVersion)}throw e.clientVersion=this.client._clientVersion,e}sanitizeMessage(e){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,_o.default)(e):e}unpack(e,r,n){if(!e||(e.data&&(e=e.data),!e))return e;let i=Object.keys(e)[0],o=Object.values(e)[0],s=r.filter(h=>h!=="select"&&h!=="include"),a=Kr(o,s),f=i==="queryRaw"?hr(a):$e(a);return n?n(f):f}get[Symbol.toStringTag](){return"RequestHandler"}};function Il(t){if(t){if(t.kind==="batch")return{kind:"batch",options:{isolationLevel:t.isolationLevel}};if(t.kind==="itx")return{kind:"itx",options:Do(t)};be(t,"Unknown transaction kind")}}function Do(t){return{id:t.id,payload:t.payload}}function _l(t,e){return gr(t)&&e?.kind==="batch"&&t.batchRequestIdx!==e.index}function Dl(t){return t.code==="P2009"||t.code==="P2012"}function Lo(t){if(t.kind==="Union")return{kind:"Union",errors:t.errors.map(Lo)};if(Array.isArray(t.selectionPath)){let[,...e]=t.selectionPath;return{...t,selectionPath:e}}return t}u();c();m();p();d();l();var Fo="6.6.0";var No=Fo;u();c();m();p();d();l();var Vo=nt(Fr());u();c();m();p();d();l();var _=class extends Error{constructor(e){super(e+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};te(_,"PrismaClientConstructorValidationError");var qo=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],Uo=["pretty","colorless","minimal"],Bo=["info","query","warn","error"],Fl={datasources:(t,{datasourceNames:e})=>{if(t){if(typeof t!="object"||Array.isArray(t))throw new _(`Invalid value ${JSON.stringify(t)} for "datasources" provided to PrismaClient constructor`);for(let[r,n]of Object.entries(t)){if(!e.includes(r)){let i=tt(r,e)||` Available datasources: ${e.join(", ")}`;throw new _(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new _(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new _(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new _(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(t,e)=>{if(!t&&Ue(e.generator)==="client")throw new _('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(t===null)return;if(t===void 0)throw new _('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!dr(e).includes("driverAdapters"))throw new _('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Ue(e.generator)==="binary")throw new _('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:t=>{if(typeof t<"u"&&typeof t!="string")throw new _(`Invalid value ${JSON.stringify(t)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:t=>{if(t){if(typeof t!="string")throw new _(`Invalid value ${JSON.stringify(t)} for "errorFormat" provided to PrismaClient constructor.`);if(!Uo.includes(t)){let e=tt(t,Uo);throw new _(`Invalid errorFormat ${t} provided to PrismaClient constructor.${e}`)}}},log:t=>{if(!t)return;if(!Array.isArray(t))throw new _(`Invalid value ${JSON.stringify(t)} for "log" provided to PrismaClient constructor.`);function e(r){if(typeof r=="string"&&!Bo.includes(r)){let n=tt(r,Bo);throw new _(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}}for(let r of t){e(r);let n={level:e,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=tt(i,o);throw new _(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(r&&typeof r=="object")for(let[i,o]of Object.entries(r))if(n[i])n[i](o);else throw new _(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:t=>{if(!t)return;let e=t.maxWait;if(e!=null&&e<=0)throw new _(`Invalid value ${e} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let r=t.timeout;if(r!=null&&r<=0)throw new _(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(t,e)=>{if(typeof t!="object")throw new _('"omit" option is expected to be an object.');if(t===null)throw new _('"omit" option can not be `null`');let r=[];for(let[n,i]of Object.entries(t)){let o=ql(n,e.runtimeDataModel);if(!o){r.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let f=o.fields.find(h=>h.name===s);if(!f){r.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(f.relationName){r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(r.length>0)throw new _(Ul(t,r))},__internal:t=>{if(!t)return;let e=["debug","engine","configOverride"];if(typeof t!="object")throw new _(`Invalid value ${JSON.stringify(t)} for "__internal" to PrismaClient constructor`);for(let[r]of Object.entries(t))if(!e.includes(r)){let n=tt(r,e);throw new _(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function jo(t,e){for(let[r,n]of Object.entries(t)){if(!qo.includes(r)){let i=tt(r,qo);throw new _(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}Fl[r](n,e)}if(t.datasourceUrl&&t.datasources)throw new _('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function tt(t,e){if(e.length===0||typeof t!="string")return"";let r=Nl(t,e);return r?` Did you mean "${r}"?`:""}function Nl(t,e){if(e.length===0)return null;let r=e.map(i=>({value:i,distance:(0,Vo.default)(t,i)}));r.sort((i,o)=>i.distance<o.distance?-1:1);let n=r[0];return n.distance<3?n.value:null}function ql(t,e){return $o(e.models,t)??$o(e.types,t)}function $o(t,e){let r=Object.keys(t).find(n=>ve(n)===e);if(r)return t[r]}function Ul(t,e){let r=He(t);for(let o of e)switch(o.kind){case"UnknownModel":r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=Ht(r,"colorless");return`Error validating "omit" option:

${i}

${n}`}u();c();m();p();d();l();function Qo(t){return t.length===0?Promise.resolve([]):new Promise((e,r)=>{let n=new Array(t.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===t.length&&(o=!0,i?r(i):e(n)))},f=h=>{o||(o=!0,r(h))};for(let h=0;h<t.length;h++)t[h].then(T=>{n[h]=T,a()},T=>{if(!gr(T)){f(T);return}T.batchRequestIdx===h?f(T):(i||(i=T),a())})})}var Ae=J("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var Bl={requestArgsToMiddlewareArgs:t=>t,middlewareArgsToRequestArgs:t=>t},$l=Symbol.for("prisma.client.transaction.id"),Vl={id:0,nextId(){return++this.id}};function Wo(t){class e{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new fr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=sn();constructor(n){t=n?.__internal?.configOverride?.(t)??t,po(t),n&&jo(n,t);let i=new nr().on("error",()=>{});this._extensions=ze.empty(),this._previewFeatures=dr(t),this._clientVersion=t.clientVersion??No,this._activeProvider=t.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=ko();let o=t.relativeEnvPaths&&{rootEnvPath:t.relativeEnvPaths.rootEnvPath&&Nt.resolve(t.dirname,t.relativeEnvPaths.rootEnvPath),schemaEnvPath:t.relativeEnvPaths.schemaEnvPath&&Nt.resolve(t.dirname,t.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let f=t.activeProvider==="postgresql"?"postgres":t.activeProvider;if(s.provider!==f)throw new I(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${f}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new I("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=t.injectableEdgeEnv?.();try{let f=n??{},h=f.__internal??{},T=h.debug===!0;T&&J.enable("prisma:client");let C=Nt.resolve(t.dirname,t.relativePath);qn.existsSync(C)||(C=t.dirname),Ae("dirname",t.dirname),Ae("relativePath",t.relativePath),Ae("cwd",C);let k=h.engine||{};if(f.errorFormat?this._errorFormat=f.errorFormat:g.env.NODE_ENV==="production"?this._errorFormat="minimal":g.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=t.runtimeDataModel,this._engineConfig={cwd:C,dirname:t.dirname,enableDebugLogs:T,allowTriggerPanic:k.allowTriggerPanic,prismaPath:k.binaryPath??void 0,engineEndpoint:k.endpoint,generator:t.generator,showColors:this._errorFormat==="pretty",logLevel:f.log&&Mo(f.log),logQueries:f.log&&!!(typeof f.log=="string"?f.log==="query":f.log.find(A=>typeof A=="string"?A==="query":A.level==="query")),env:a?.parsed??{},flags:[],engineWasm:t.engineWasm,compilerWasm:t.compilerWasm,clientVersion:t.clientVersion,engineVersion:t.engineVersion,previewFeatures:this._previewFeatures,activeProvider:t.activeProvider,inlineSchema:t.inlineSchema,overrideDatasources:fo(f,t.datasourceNames),inlineDatasources:t.inlineDatasources,inlineSchemaHash:t.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:f.transactionOptions?.maxWait??2e3,timeout:f.transactionOptions?.timeout??5e3,isolationLevel:f.transactionOptions?.isolationLevel},logEmitter:i,isBundled:t.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:cr,getBatchRequestPayload:sr,prismaGraphQLToJSError:ar,PrismaClientUnknownRequestError:j,PrismaClientInitializationError:I,PrismaClientKnownRequestError:X,debug:J("prisma:client:accelerateEngine"),engineVersion:Go.version,clientVersion:t.clientVersion}},Ae("clientVersion",t.clientVersion),this._engine=bo(t,this._engineConfig),this._requestHandler=new br(this,i),f.log)for(let A of f.log){let O=typeof A=="string"?A:A.emit==="stdout"?A.level:null;O&&this.$on(O,S=>{at.log(`${at.tags[O]??""}`,S.message||S.query)})}}catch(f){throw f.clientVersion=this._clientVersion,f}return this._appliedParent=Tt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Fn()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:on({clientMethod:i,activeProvider:a}),callsite:Ce(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=Jo(n,i);return nn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new W("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(nn(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(t.activeProvider!=="mongodb")throw new W(`The ${t.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:wo,callsite:Ce(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:on({clientMethod:i,activeProvider:a}),callsite:Ce(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...Jo(n,i));throw new W("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new W("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=Vl.nextId(),s=Oo(n.length),a=n.map((f,h)=>{if(f?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let T=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,C={kind:"batch",id:o,index:h,isolationLevel:T,lock:s};return f.requestTransaction?.(C)??f});return Qo(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),f;try{let h={kind:"itx",...a};f=await n(this._createItxClient(h)),await this._engine.transaction("commit",o,a)}catch(h){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),h}return f}_createItxClient(n){return ae(Tt(ae(Yi(this),[K("_appliedParent",()=>this._appliedParent._createItxClient(n)),K("_createPrismaPromise",()=>sn(n)),K($l,()=>n.id)])),[Xe(ro)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Bl,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,f=async h=>{let T=this._middlewares.get(++a);if(T)return this._tracingHelper.runInChildSpan(s.middleware,M=>T(h,oe=>(M?.end(),f(oe))));let{runInTransaction:C,args:k,...A}=h,O={...n,...A};k&&(O.args=i.middlewareArgsToRequestArgs(k)),n.transaction!==void 0&&C===!1&&delete O.transaction;let S=await so(this,O);return O.model?to({result:S,modelName:O.model,args:O.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):S};return this._tracingHelper.runInChildSpan(s.operation,()=>f(o))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:f,argsMapper:h,transaction:T,unpacker:C,otelParentCtx:k,customDataProxyFetch:A}){try{n=h?h(n):n;let O={name:"serialize"},S=this._tracingHelper.runInChildSpan(O,()=>er({modelName:f,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return J.enabled("prisma:client")&&(Ae("Prisma Client call:"),Ae(`prisma.${i}(${$i(n)})`),Ae("Generated request:"),Ae(JSON.stringify(S,null,2)+`
`)),T?.kind==="batch"&&await T.lock,this._requestHandler.request({protocolQuery:S,modelName:f,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:T,unpacker:C,otelParentCtx:k,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:A})}catch(O){throw O.clientVersion=this._clientVersion,O}}$metrics=new Ye(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=Xi}return e}function Jo(t,e){return jl(t)?[new Z(t,e),Ro]:[t,Ao]}function jl(t){return Array.isArray(t)&&Array.isArray(t.raw)}u();c();m();p();d();l();var Ql=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Ko(t){return new Proxy(t,{get(e,r){if(r in e)return e[r];if(!Ql.has(r))throw new TypeError(`Invalid enum value: ${String(r)}`)}})}u();c();m();p();d();l();l();0&&(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});
//# sourceMappingURL=wasm.js.map

```

## 📄 lib\generated\prisma\wasm.d.ts

```ts
export * from "./index"
```

## 📄 lib\generated\prisma\wasm.js

```js

Object.defineProperty(exports, "__esModule", { value: true });

const {
  Decimal,
  objectEnumValues,
  makeStrictEnum,
  Public,
  getRuntime,
  skip
} = require('./runtime/index-browser.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 6.6.0
 * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
 */
Prisma.prismaVersion = {
  client: "6.6.0",
  engine: "f676762280b54cd07c770017ed3711ddde35f37a"
}

Prisma.PrismaClientKnownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)};
Prisma.PrismaClientUnknownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientRustPanicError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientInitializationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientValidationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.empty = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`empty is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.join = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`join is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.raw = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`raw is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.defineExtension = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}



/**
 * Enums
 */

exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});

exports.Prisma.PatientScalarFieldEnum = {
  id: 'id',
  first_name: 'first_name',
  last_name: 'last_name',
  date_of_birth: 'date_of_birth',
  gender: 'gender',
  phone: 'phone',
  email: 'email',
  marital_status: 'marital_status',
  address: 'address',
  emergency_contact_name: 'emergency_contact_name',
  emergency_contact_number: 'emergency_contact_number',
  relation: 'relation',
  blood_group: 'blood_group',
  allergies: 'allergies',
  medical_conditions: 'medical_conditions',
  medical_history: 'medical_history',
  insurance_provider: 'insurance_provider',
  insurance_number: 'insurance_number',
  privacy_consent: 'privacy_consent',
  service_consent: 'service_consent',
  medical_consent: 'medical_consent',
  img: 'img',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DoctorScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  specialization: 'specialization',
  license_number: 'license_number',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  availability_status: 'availability_status',
  type: 'type',
  colorCode: 'colorCode',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.WorkingDaysScalarFieldEnum = {
  id: 'id',
  doctor_id: 'doctor_id',
  day: 'day',
  start_time: 'start_time',
  close_time: 'close_time',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.StaffScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  department: 'department',
  img: 'img',
  license_number: 'license_number',
  role: 'role',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AppointmentScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  doctor_id: 'doctor_id',
  appointmentDate: 'appointmentDate',
  appointmentTime: 'appointmentTime',
  status: 'status',
  type: 'type',
  note: 'note',
  reason: 'reason',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PaymentScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  patient_id: 'patient_id',
  appointment_Id: 'appointment_Id',
  bill_date: 'bill_date',
  payment_Date: 'payment_Date',
  discount: 'discount',
  total_amount: 'total_amount',
  amount_paid: 'amount_paid',
  payment_method: 'payment_method',
  status: 'status',
  receipt_number: 'receipt_number',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.PatientBillsScalarFieldEnum = {
  id: 'id',
  bill_id: 'bill_id',
  service_id: 'service_id',
  service_date: 'service_date',
  quantity: 'quantity',
  unit_cost: 'unit_cost',
  total_cost: 'total_cost',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.LabTestScalarFieldEnum = {
  id: 'id',
  record_id: 'record_id',
  test_date: 'test_date',
  result: 'result',
  status: 'status',
  notes: 'notes',
  service_id: 'service_id',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.MedicalRecordsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  appointment_id: 'appointment_id',
  doctor_id: 'doctor_id',
  treatment_plan: 'treatment_plan',
  prescriptions: 'prescriptions',
  lab_request: 'lab_request',
  notes: 'notes',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.VitalSignsScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  body_temperature: 'body_temperature',
  systolic: 'systolic',
  diastolic: 'diastolic',
  heartRate: 'heartRate',
  respiratoryRate: 'respiratoryRate',
  oxygen_saturation: 'oxygen_saturation',
  weight: 'weight',
  height: 'height',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.DiagnosisScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  medical_id: 'medical_id',
  diagnosis: 'diagnosis',
  doctor_id: 'doctor_id',
  symptoms: 'symptoms',
  notes: 'notes',
  prescribed_medications: 'prescribed_medications',
  follow_up_plan: 'follow_up_plan',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.AuditLogScalarFieldEnum = {
  id: 'id',
  user_id: 'user_id',
  record_id: 'record_id',
  action: 'action',
  details: 'details',
  model: 'model',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.RatingScalarFieldEnum = {
  id: 'id',
  patient_id: 'patient_id',
  staff_id: 'staff_id',
  rating: 'rating',
  comment: 'comment',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.ServicesScalarFieldEnum = {
  id: 'id',
  service_name: 'service_name',
  description: 'description',
  price: 'price',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};
exports.GENDER = exports.$Enums.GENDER = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

exports.JOBTYPE = exports.$Enums.JOBTYPE = {
  FULL: 'FULL',
  PART: 'PART'
};

exports.Role = exports.$Enums.Role = {
  ADMIN: 'ADMIN',
  NURSE: 'NURSE',
  DOCTOR: 'DOCTOR',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  PATIENT: 'PATIENT',
  CASHIER: 'CASHIER'
};

exports.Status = exports.$Enums.Status = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DORMANT: 'DORMANT'
};

exports.AppointmentStatus = exports.$Enums.AppointmentStatus = {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

exports.PaymentMethod = exports.$Enums.PaymentMethod = {
  CASH: 'CASH',
  CARD: 'CARD',
  UPI: 'UPI'
};

exports.PaymentStatus = exports.$Enums.PaymentStatus = {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  PART: 'PART'
};

exports.Prisma.ModelName = {
  Patient: 'Patient',
  Doctor: 'Doctor',
  WorkingDays: 'WorkingDays',
  Staff: 'Staff',
  Appointment: 'Appointment',
  Payment: 'Payment',
  PatientBills: 'PatientBills',
  LabTest: 'LabTest',
  MedicalRecords: 'MedicalRecords',
  VitalSigns: 'VitalSigns',
  Diagnosis: 'Diagnosis',
  AuditLog: 'AuditLog',
  Rating: 'Rating',
  Services: 'Services'
};

/**
 * This is a stub Prisma Client that will error at runtime if called.
 */
class PrismaClient {
  constructor() {
    return new Proxy(this, {
      get(target, prop) {
        let message
        const runtime = getRuntime()
        if (runtime.isEdge) {
          message = `PrismaClient is not configured to run in ${runtime.prettyName}. In order to run Prisma Client on edge runtime, either:
- Use Prisma Accelerate: https://pris.ly/d/accelerate
- Use Driver Adapters: https://pris.ly/d/driver-adapters
`;
        } else {
          message = 'PrismaClient is unable to run in this browser environment, or has been bundled for the browser (running in `' + runtime.prettyName + '`).'
        }

        message += `
If this is unexpected, please open an issue: https://pris.ly/prisma-prisma-bug-report`

        throw new Error(message)
      }
    })
  }
}

exports.PrismaClient = PrismaClient

Object.assign(exports, Prisma)

```

## 📄 lib\index.ts

```ts
export const GENDER = [
    { label: "Male", value: "MALE" },
    { label: "Female", value: "FEMALE" },
  ];
  
  export const MARITAL_STATUS = [
    { label: "Single", value: "single" },
    { label: "Married", value: "married" },
    { label: "Divorced", value: "divorced" },
    { label: "Widowed", value: "widowed" },
    { label: "Separated", value: "separated" },
  ];
  
  export const RELATION = [
    { value: "mother", label: "Mother" },
    { value: "father", label: "Father" },
    { value: "husband", label: "Husband" },
    { value: "wife", label: "Wife" },
    { value: "other", label: "Other" },
  ];
  
  export const USER_ROLES = {
    ADMIN: "ADMIN" as string,
    DOCTOR: "DOCTOR",
    NURSE: "NURSE",
    LAB_TECHNICIAN: "LAB_TECHNICIAN",
    PATIENT: "PATIENT",
    CASHIER: "CASHIER",
  };
```

## 📄 lib\routes.ts

```ts
type RouteAccessProps = {
  [key: string]: string[];
};

export const routeAccess: RouteAccessProps = {
  "/admin(.*)": ["admin"],
  "/patient(.*)": ["patient", "admin", "doctor", "nurse"],
  "/doctor(.*)": ["doctor"],
  "/staff(.*)": ["nurse", "lab_technician", "cashier"],
  "/record/users": ["admin"],
  "/record/doctors": ["admin"],
  "/record/doctors(.*)": ["admin", "doctor"],
  "/record/staffs": ["admin", "doctor"],
  "/record/patients": ["admin", "doctor", "nurse"],
  "/patient/registrations": ["patient"],
};


```

## 📄 lib\schema.ts

```ts
import { z } from "zod";

export const PatientFormSchema = z.object({
  first_name: z
    .string()
    .trim()
    .min(2, "First name must be at least 2 characters")
    .max(30, "First name can't be more than 50 characters"),
  last_name: z
    .string()
    .trim()
    .min(2, "Last name must be at least 2 characters")
    .max(30, "First name can't be more than 50 characters"),
  date_of_birth: z.coerce.date(),
  gender: z.enum(["MALE", "FEMALE"], { message: "Gender is required" }),

  phone: z.string().min(10, "Enter phone number").max(10, "Enter phone number"),
  email: z.string().email("Invalid email address."),
  address: z
    .string()
    .min(5, "Address must be at least 5 characters")
    .max(500, "Address must be at most 500 characters"),
  marital_status: z.enum(
    ["married", "single", "divorced", "widowed", "separated"],
    { message: "Marital status is required." }
  ),
  emergency_contact_name: z
    .string()
    .min(2, "Emergency contact name is required.")
    .max(50, "Emergency contact must be at most 50 characters"),
  emergency_contact_number: z
    .string()
    .min(10, "Enter phone number")
    .max(10, "Enter phone number"),
  relation: z.enum(["mother", "father", "husband", "wife", "other"], {
    message: "Relations with contact person required",
  }),
  blood_group: z.string().optional(),
  allergies: z.string().optional(),
  medical_conditions: z.string().optional(),
  medical_history: z.string().optional(),
  insurance_provider: z.string().optional(),
  insurance_number: z.string().optional(),
  privacy_consent: z
    .boolean()
    .default(false)
    .refine((val) => val === true, {
      message: "You must agree to the privacy policy.",
    }),
  service_consent: z
    .boolean()
    .default(false)
    .refine((val) => val === true, {
      message: "You must agree to the terms of service.",
    }),
  medical_consent: z
    .boolean()
    .default(false)
    .refine((val) => val === true, {
      message: "You must agree to the medical treatment terms.",
    }),
  img: z.string().optional(),
});

export const AppointmentSchema = z.object({
  doctor_id: z.string().min(1, "Select physician"),
  type: z.string().min(1, "Select type of appointment"),
  appointment_date: z.string().min(1, "Select appointment date"),
  time: z.string().min(1, "Select appointment time"),
  note: z.string().optional(),
});

export const DoctorSchema = z.object({
  name: z
    .string()
    .trim()
    .min(2, "Name must be at least 2 characters")
    .max(50, "Name must be at most 50 characters"),
  phone: z.string().min(10, "Enter phone number").max(10, "Enter phone number"),
  email: z.string().email("Invalid email address."),
  address: z
    .string()
    .min(5, "Address must be at least 5 characters")
    .max(500, "Address must be at most 500 characters"),
  specialization: z.string().min(2, "Specialization is required."),
  license_number: z.string().min(2, "License number is required"),
  type: z.enum(["FULL", "PART"], { message: "Type is required." }),
  department: z.string().min(2, "Department is required."),
  img: z.string().optional(),
  password: z
    .string()
    .min(8, { message: "Password must be at least 8 characters long!" })
    .optional()
    .or(z.literal("")),
});

export const workingDaySchema = z.object({
  day: z.enum([
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday",
    "sunday",
  ]),
  start_time: z.string(),
  close_time: z.string(),
});
export const WorkingDaysSchema = z.array(workingDaySchema).optional();

export const StaffSchema = z.object({
  name: z
    .string()
    .trim()
    .min(2, "Name must be at least 2 characters")
    .max(50, "Name must be at most 50 characters"),
  role: z.enum(["NURSE", "LAB_TECHNICIAN"], { message: "Role is required." }),
  phone: z
    .string()
    .min(10, "Contact must be 10-digits")
    .max(10, "Contact must be 10-digits"),
  email: z.string().email("Invalid email address."),
  address: z
    .string()
    .min(5, "Address must be at least 5 characters")
    .max(500, "Address must be at most 500 characters"),
  license_number: z.string().optional(),
  department: z.string().optional(),
  img: z.string().optional(),
  password: z
    .string()
    .min(8, { message: "Password must be at least 8 characters long!" })
    .optional()
    .or(z.literal("")),
});

export const VitalSignsSchema = z.object({
  patient_id: z.string(),
  medical_id: z.string(),
  body_temperature: z.coerce.number({
    message: "Enter recorded body temperature",
  }),
  heartRate: z.string({ message: "Enter recorded heartbeat rate" }),
  systolic: z.coerce.number({
    message: "Enter recorded systolic blood pressure",
  }),
  diastolic: z.coerce.number({
    message: "Enter recorded diastolic blood pressure",
  }),
  respiratory_rate: z.coerce.number().optional(),
  oxygen_saturation: z.coerce.number().optional(),
  weight: z.coerce.number({ message: "Enter recorded weight (Kg)" }),
  height: z.coerce.number({ message: "Enter recorded height (Cm)" }),
});

export const DiagnosisSchema = z.object({
  patient_id: z.string(),
  medical_id: z.string(),
  doctor_id: z.string(),
  symptoms: z.string({ message: "Symptoms required" }),
  diagnosis: z.string({ message: "Diagnosis required" }),
  notes: z.string().optional(),
  prescribed_medications: z.string().optional(),
  follow_up_plan: z.string().optional(),
});

export const PaymentSchema = z.object({
  id: z.string(),
  // patient_id: z.string(),
  // appointment_id: z.string(),
  bill_date: z.coerce.date(),
  // payment_date: z.string(),
  discount: z.string({ message: "discount" }),
  total_amount: z.string(),
  // amount_paid: z.string(),
});

export const PatientBillSchema = z.object({
  bill_id: z.string(),
  service_id: z.string(),
  service_date: z.string(),
  appointment_id: z.string(),
  quantity: z.string({ message: "Quantity is required" }),
  unit_cost: z.string({ message: "Unit cost is required" }),
  total_cost: z.string({ message: "Total cost is required" }),
});

export const ServicesSchema = z.object({
  service_name: z.string({ message: "Service name is required" }),
  price: z.string({ message: "Service price is required" }),
  description: z.string({ message: "Service description is required" }),
});
```

## 📄 lib\utils.ts

```ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

## 📄 middleware.ts

```ts
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { routeAccess } from "./lib/routes";

const matchers = Object.keys(routeAccess).map((route) => ({
  matcher: createRouteMatcher([route]),
  allowedRoles: routeAccess[route],
}));

export default clerkMiddleware(async (auth, req) => {
  const { userId, sessionClaims } = await auth();
  const url = new URL(req.url);

  const role =
    userId && sessionClaims?.metadata?.role
      ? sessionClaims.metadata.role
      : userId
      ? "patient"
      : "sign-in";

  const matchingRoute = matchers.find(({ matcher }) => matcher(req));

  if (matchingRoute && !matchingRoute.allowedRoles.includes(role)) {
    // Redirect unauthorized roles to their respective default pages
    return NextResponse.redirect(new URL(`/${role}`, url.origin));
  }

  // Continue if the user is authorized
  return NextResponse.next();
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
```

## 📄 next-env.d.ts

```ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

## 📄 next.config.ts

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

```

## 📄 package-lock.json

```json
{
  "name": "hms",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "hms",
      "version": "0.1.0",
      "dependencies": {
        "@clerk/nextjs": "^6.16.0",
        "@faker-js/faker": "^9.7.0",
        "@hookform/resolvers": "^5.0.1",
        "@prisma/client": "^6.6.0",
        "@radix-ui/react-checkbox": "^1.2.2",
        "@radix-ui/react-dialog": "^1.1.11",
        "@radix-ui/react-label": "^2.1.4",
        "@radix-ui/react-popover": "^1.1.11",
        "@radix-ui/react-radio-group": "^1.3.2",
        "@radix-ui/react-select": "^2.2.2",
        "@radix-ui/react-separator": "^1.1.4",
        "@radix-ui/react-slot": "^1.2.0",
        "@radix-ui/react-switch": "^1.2.2",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "date-fns": "^4.1.0",
        "lucide-react": "^0.501.0",
        "next": "15.3.1",
        "print-code": "^1.0.2",
        "prisma": "^6.6.0",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-hook-form": "^7.56.1",
        "react-icons": "^5.5.0",
        "recharts": "^2.15.3",
        "sonner": "^2.0.3",
        "tailwind-merge": "^3.2.0",
        "tw-animate-css": "^1.2.5",
        "zod": "^3.24.3"
      },
      "devDependencies": {
        "@tailwindcss/postcss": "^4",
        "@types/node": "^20.17.30",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "tailwindcss": "^4",
        "ts-node": "^10.9.2",
        "tsx": "^4.19.3",
        "typescript": "^5.8.3"
      }
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.0.tgz",
      "integrity": "sha512-VtPOkrdPHZsKc/clNqyi9WUA8TINkZ4cGk63UUE3u4pmB2k+ZMQRDuIOagv8UVd6j7k0T3+RRIb7beKTebNbcw==",
      "license": "MIT",
      "dependencies": {
        "regenerator-runtime": "^0.14.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@clerk/backend": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/@clerk/backend/-/backend-1.29.2.tgz",
      "integrity": "sha512-mBvGyHjNj/t2X2y0Dn1V1EgsffhgNH1TJhB98k40dHxVxvosY9QdgCDMtru/Q1uZ7EXNOzYqzcB5FzAKCxFRZw==",
      "license": "MIT",
      "dependencies": {
        "@clerk/shared": "^3.7.3",
        "@clerk/types": "^4.55.0",
        "cookie": "1.0.2",
        "snakecase-keys": "8.0.1",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "svix": "^1.62.0"
      },
      "peerDependenciesMeta": {
        "svix": {
          "optional": true
        }
      }
    },
    "node_modules/@clerk/clerk-react": {
      "version": "5.29.0",
      "resolved": "https://registry.npmjs.org/@clerk/clerk-react/-/clerk-react-5.29.0.tgz",
      "integrity": "sha512-S8wenyl5R/8YmUT1tElQZdmHe/MASM9JDJRKqhy0kVYXdKzjhuwTBgT+m3hXl3zdq/Gwi3hgv7pRnQWpQisutQ==",
      "license": "MIT",
      "dependencies": {
        "@clerk/shared": "^3.7.3",
        "@clerk/types": "^4.55.0",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      }
    },
    "node_modules/@clerk/nextjs": {
      "version": "6.17.0",
      "resolved": "https://registry.npmjs.org/@clerk/nextjs/-/nextjs-6.17.0.tgz",
      "integrity": "sha512-ik+UU/cKZgC5pafJJ9oct0BUHvytUqof+r1RjFb71xU1TM7EOeL5XYafVxh+hlgwsE4jmrw+FVYe4DXDcyPeTQ==",
      "license": "MIT",
      "dependencies": {
        "@clerk/backend": "^1.29.2",
        "@clerk/clerk-react": "^5.29.0",
        "@clerk/shared": "^3.7.3",
        "@clerk/types": "^4.55.0",
        "server-only": "0.0.1",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "next": "^13.5.7 || ^14.2.25 || ^15.2.3",
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      }
    },
    "node_modules/@clerk/shared": {
      "version": "3.7.3",
      "resolved": "https://registry.npmjs.org/@clerk/shared/-/shared-3.7.3.tgz",
      "integrity": "sha512-IMpz1bgZZzlxNLyFliE0GrA3NT1Wgidl2CBORkE2S/YUSCH4ge8EPg5tfQq9Ja6d17TfarkzEafrm1b/BHxSWg==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "@clerk/types": "^4.55.0",
        "dequal": "2.0.3",
        "glob-to-regexp": "0.4.1",
        "js-cookie": "3.0.5",
        "std-env": "^3.8.1",
        "swr": "^2.3.3"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "react": {
          "optional": true
        },
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@clerk/types": {
      "version": "4.55.0",
      "resolved": "https://registry.npmjs.org/@clerk/types/-/types-4.55.0.tgz",
      "integrity": "sha512-MJc/zo9vJOq1mY37RbRjrZ883AKe9gitlYFyVB3R+ChKm0uBl2Mm8R2gkYy1GGKYvqBm27GJooWHxdcM1Yv1eQ==",
      "license": "MIT",
      "dependencies": {
        "csstype": "3.1.3"
      },
      "engines": {
        "node": ">=18.17.0"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@emnapi/runtime": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/@emnapi/runtime/-/runtime-1.4.3.tgz",
      "integrity": "sha512-pBPWdu6MLKROBX05wSNKcNb++m5Er+KQ9QkB+WVM+pW2Kx9hoSrVTnu3BdkI5eBLZoKu/J6mW/B6i6bJB2ytXQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.3.tgz",
      "integrity": "sha512-W8bFfPA8DowP8l//sxjJLSLkD8iEjMc7cBVyP+u4cEv9sM7mdUCkgsj+t0n/BWPFtv7WWCN5Yzj0N6FJNUUqBQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.3.tgz",
      "integrity": "sha512-PuwVXbnP87Tcff5I9ngV0lmiSu40xw1At6i3GsU77U7cjDDB4s0X2cyFuBiDa1SBk9DnvWwnGvVaGBqoFWPb7A==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.3.tgz",
      "integrity": "sha512-XelR6MzjlZuBM4f5z2IQHK6LkK34Cvv6Rj2EntER3lwCBFdg6h2lKbtRjpTTsdEjD/WSe1q8UyPBXP1x3i/wYQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.3.tgz",
      "integrity": "sha512-ogtTpYHT/g1GWS/zKM0cc/tIebFjm1F9Aw1boQ2Y0eUQ+J89d0jFY//s9ei9jVIlkYi8AfOjiixcLJSGNSOAdQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.3.tgz",
      "integrity": "sha512-eESK5yfPNTqpAmDfFWNsOhmIOaQA59tAcF/EfYvo5/QWQCzXn5iUSOnqt3ra3UdzBv073ykTtmeLJZGt3HhA+w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.3.tgz",
      "integrity": "sha512-Kd8glo7sIZtwOLcPbW0yLpKmBNWMANZhrC1r6K++uDR2zyzb6AeOYtI6udbtabmQpFaxJ8uduXMAo1gs5ozz8A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.3.tgz",
      "integrity": "sha512-EJiyS70BYybOBpJth3M0KLOus0n+RRMKTYzhYhFeMwp7e/RaajXvP+BWlmEXNk6uk+KAu46j/kaQzr6au+JcIw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.3.tgz",
      "integrity": "sha512-Q+wSjaLpGxYf7zC0kL0nDlhsfuFkoN+EXrx2KSB33RhinWzejOd6AvgmP5JbkgXKmjhmpfgKZq24pneodYqE8Q==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.3.tgz",
      "integrity": "sha512-dUOVmAUzuHy2ZOKIHIKHCm58HKzFqd+puLaS424h6I85GlSDRZIA5ycBixb3mFgM0Jdh+ZOSB6KptX30DD8YOQ==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.3.tgz",
      "integrity": "sha512-xCUgnNYhRD5bb1C1nqrDV1PfkwgbswTTBRbAd8aH5PhYzikdf/ddtsYyMXFfGSsb/6t6QaPSzxtbfAZr9uox4A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.3.tgz",
      "integrity": "sha512-yplPOpczHOO4jTYKmuYuANI3WhvIPSVANGcNUeMlxH4twz/TeXuzEP41tGKNGWJjuMhotpGabeFYGAOU2ummBw==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.3.tgz",
      "integrity": "sha512-P4BLP5/fjyihmXCELRGrLd793q/lBtKMQl8ARGpDxgzgIKJDRJ/u4r1A/HgpBpKpKZelGct2PGI4T+axcedf6g==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.3.tgz",
      "integrity": "sha512-eRAOV2ODpu6P5divMEMa26RRqb2yUoYsuQQOuFUexUoQndm4MdpXXDBbUoKIc0iPa4aCO7gIhtnYomkn2x+bag==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.3.tgz",
      "integrity": "sha512-ZC4jV2p7VbzTlnl8nZKLcBkfzIf4Yad1SJM4ZMKYnJqZFD4rTI+pBG65u8ev4jk3/MPwY9DvGn50wi3uhdaghg==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.3.tgz",
      "integrity": "sha512-LDDODcFzNtECTrUUbVCs6j9/bDVqy7DDRsuIXJg6so+mFksgwG7ZVnTruYi5V+z3eE5y+BJZw7VvUadkbfg7QA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.3.tgz",
      "integrity": "sha512-s+w/NOY2k0yC2p9SLen+ymflgcpRkvwwa02fqmAwhBRI3SC12uiS10edHHXlVWwfAagYSY5UpmT/zISXPMW3tQ==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.3.tgz",
      "integrity": "sha512-nQHDz4pXjSDC6UfOE1Fw9Q8d6GCAd9KdvMZpfVGWSJztYCarRgSDfOVBY5xwhQXseiyxapkiSJi/5/ja8mRFFA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.3.tgz",
      "integrity": "sha512-1QaLtOWq0mzK6tzzp0jRN3eccmN3hezey7mhLnzC6oNlJoUJz4nym5ZD7mDnS/LZQgkrhEbEiTn515lPeLpgWA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.3.tgz",
      "integrity": "sha512-i5Hm68HXHdgv8wkrt+10Bc50zM0/eonPb/a/OFVfB6Qvpiirco5gBA5bz7S2SHuU+Y4LWn/zehzNX14Sp4r27g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.3.tgz",
      "integrity": "sha512-zGAVApJEYTbOC6H/3QBr2mq3upG/LBEXr85/pTtKiv2IXcgKV0RT0QA/hSXZqSvLEpXeIxah7LczB4lkiYhTAQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.3.tgz",
      "integrity": "sha512-fpqctI45NnCIDKBH5AXQBsD0NDPbEFczK98hk/aa6HJxbl+UtLkJV2+Bvy5hLSLk3LHmqt0NTkKNso1A9y1a4w==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.3.tgz",
      "integrity": "sha512-ROJhm7d8bk9dMCUZjkS8fgzsPAZEjtRJqCAmVgB0gMrvG7hfmPmz9k1rwO4jSiblFjYmNvbECL9uhaPzONMfgA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.3.tgz",
      "integrity": "sha512-YWcow8peiHpNBiIXHwaswPnAXLsLVygFwCB3A7Bh5jRkIBFWHGmNQ48AlX4xDvQNoMZlPYzjVOQDYEzWCqufMQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.3.tgz",
      "integrity": "sha512-qspTZOIGoXVS4DpNqUYUs9UxVb04khS1Degaw/MnfMe7goQ3lTfQ13Vw4qY/Nj0979BGvMRpAYbs/BAxEvU8ew==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.3.tgz",
      "integrity": "sha512-ICgUR+kPimx0vvRzf+N/7L7tVSQeE3BYY+NhHRHXS1kBuPO7z2+7ea2HbhDyZdTephgvNvKrlDDKUexuCVBVvg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@faker-js/faker": {
      "version": "9.7.0",
      "resolved": "https://registry.npmjs.org/@faker-js/faker/-/faker-9.7.0.tgz",
      "integrity": "sha512-aozo5vqjCmDoXLNUJarFZx2IN/GgGaogY4TMJ6so/WLZOWpSV7fvj2dmrV6sEAnUm1O7aCrhTibjpzeDFgNqbg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fakerjs"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=9.0.0"
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.6.9",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.6.9.tgz",
      "integrity": "sha512-uMXCuQ3BItDUbAMhIXw7UPXRfAlOAvZzdK9BWpE60MCn+Svt3aLn9jsPTi/WNGlRUu2uI0v5S7JiIUsbsvh3fw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.6.13",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.6.13.tgz",
      "integrity": "sha512-umqzocjDgNRGTuO7Q8CU32dkHkECqI8ZdMZ5Swb6QAM0t5rnlrN3lGo1hdpscRd3WS8T6DKYK4ephgIH9iRh3w==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.6.0",
        "@floating-ui/utils": "^0.2.9"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.2.tgz",
      "integrity": "sha512-06okr5cgPzMNBy+Ycse2A6udMi4bqwW/zgBF/rwjcNqWkyr82Mcg8b0vjX8OJpZFy/FKjJmw6wV7t44kK6kW7A==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.0.0"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.9",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.9.tgz",
      "integrity": "sha512-MDWhGtE+eHw5JW7lq4qhc5yRLS11ERl1c7Z6Xd0a58DozHES6EnNNwUWbMiG4J9Cgj053Bhk8zvlhFYKVhULwg==",
      "license": "MIT"
    },
    "node_modules/@hookform/resolvers": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/@hookform/resolvers/-/resolvers-5.0.1.tgz",
      "integrity": "sha512-u/+Jp83luQNx9AdyW2fIPGY6Y7NG68eN2ZW8FOJYL+M0i4s49+refdJdOp/A9n9HFQtQs3HIDHQvX3ZET2o7YA==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/utils": "^0.3.0"
      },
      "peerDependencies": {
        "react-hook-form": "^7.55.0"
      }
    },
    "node_modules/@img/sharp-darwin-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-arm64/-/sharp-darwin-arm64-0.34.1.tgz",
      "integrity": "sha512-pn44xgBtgpEbZsu+lWf2KNb6OAf70X68k+yk69Ic2Xz11zHR/w24/U49XT7AeRwJ0Px+mhALhU5LPci1Aymk7A==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-darwin-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-x64/-/sharp-darwin-x64-0.34.1.tgz",
      "integrity": "sha512-VfuYgG2r8BpYiOUN+BfYeFo69nP/MIwAtSJ7/Zpxc5QF3KS22z8Pvg3FkrSFJBPNQ7mmcUcYQFBmEQp7eu1F8Q==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-arm64/-/sharp-libvips-darwin-arm64-1.1.0.tgz",
      "integrity": "sha512-HZ/JUmPwrJSoM4DIQPv/BfNh9yrOA8tlBbqbLz4JZ5uew2+o22Ik+tHQJcih7QJuSa0zo5coHTfD5J8inqj9DA==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-x64/-/sharp-libvips-darwin-x64-1.1.0.tgz",
      "integrity": "sha512-Xzc2ToEmHN+hfvsl9wja0RlnXEgpKNmftriQp6XzY/RaSfwD9th+MSh0WQKzUreLKKINb3afirxW7A0fz2YWuQ==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm/-/sharp-libvips-linux-arm-1.1.0.tgz",
      "integrity": "sha512-s8BAd0lwUIvYCJyRdFqvsj+BJIpDBSxs6ivrOPm/R7piTs5UIwY5OjXrP2bqXC9/moGsyRa37eYWYCOGVXxVrA==",
      "cpu": [
        "arm"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm64/-/sharp-libvips-linux-arm64-1.1.0.tgz",
      "integrity": "sha512-IVfGJa7gjChDET1dK9SekxFFdflarnUB8PwW8aGwEoF3oAsSDuNUTYS+SKDOyOJxQyDC1aPFMuRYLoDInyV9Ew==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-ppc64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-ppc64/-/sharp-libvips-linux-ppc64-1.1.0.tgz",
      "integrity": "sha512-tiXxFZFbhnkWE2LA8oQj7KYR+bWBkiV2nilRldT7bqoEZ4HiDOcePr9wVDAZPi/Id5fT1oY9iGnDq20cwUz8lQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-s390x": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-s390x/-/sharp-libvips-linux-s390x-1.1.0.tgz",
      "integrity": "sha512-xukSwvhguw7COyzvmjydRb3x/09+21HykyapcZchiCUkTThEQEOMtBj9UhkaBRLuBrgLFzQ2wbxdeCCJW/jgJA==",
      "cpu": [
        "s390x"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-x64/-/sharp-libvips-linux-x64-1.1.0.tgz",
      "integrity": "sha512-yRj2+reB8iMg9W5sULM3S74jVS7zqSzHG3Ol/twnAAkAhnGQnpjj6e4ayUz7V+FpKypwgs82xbRdYtchTTUB+Q==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-arm64/-/sharp-libvips-linuxmusl-arm64-1.1.0.tgz",
      "integrity": "sha512-jYZdG+whg0MDK+q2COKbYidaqW/WTz0cc1E+tMAusiDygrM4ypmSCjOJPmFTvHHJ8j/6cAGyeDWZOsK06tP33w==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-x64/-/sharp-libvips-linuxmusl-x64-1.1.0.tgz",
      "integrity": "sha512-wK7SBdwrAiycjXdkPnGCPLjYb9lD4l6Ze2gSdAGVZrEL05AOUJESWU2lhlC+Ffn5/G+VKuSm6zzbQSzFX/P65A==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-linux-arm": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm/-/sharp-linux-arm-0.34.1.tgz",
      "integrity": "sha512-anKiszvACti2sGy9CirTlNyk7BjjZPiML1jt2ZkTdcvpLU1YH6CXwRAZCA2UmRXnhiIftXQ7+Oh62Ji25W72jA==",
      "cpu": [
        "arm"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm64/-/sharp-linux-arm64-0.34.1.tgz",
      "integrity": "sha512-kX2c+vbvaXC6vly1RDf/IWNXxrlxLNpBVWkdpRq5Ka7OOKj6nr66etKy2IENf6FtOgklkg9ZdGpEu9kwdlcwOQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-s390x": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-s390x/-/sharp-linux-s390x-0.34.1.tgz",
      "integrity": "sha512-7s0KX2tI9mZI2buRipKIw2X1ufdTeaRgwmRabt5bi9chYfhur+/C1OXg3TKg/eag1W+6CCWLVmSauV1owmRPxA==",
      "cpu": [
        "s390x"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-s390x": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-x64/-/sharp-linux-x64-0.34.1.tgz",
      "integrity": "sha512-wExv7SH9nmoBW3Wr2gvQopX1k8q2g5V5Iag8Zk6AVENsjwd+3adjwxtp3Dcu2QhOXr8W9NusBU6XcQUohBZ5MA==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-arm64/-/sharp-linuxmusl-arm64-0.34.1.tgz",
      "integrity": "sha512-DfvyxzHxw4WGdPiTF0SOHnm11Xv4aQexvqhRDAoD00MzHekAj9a/jADXeXYCDFH/DzYruwHbXU7uz+H+nWmSOQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-x64/-/sharp-linuxmusl-x64-0.34.1.tgz",
      "integrity": "sha512-pax/kTR407vNb9qaSIiWVnQplPcGU8LRIJpDT5o8PdAx5aAA7AS3X9PS8Isw1/WfqgQorPotjrZL3Pqh6C5EBg==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-wasm32": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-wasm32/-/sharp-wasm32-0.34.1.tgz",
      "integrity": "sha512-YDybQnYrLQfEpzGOQe7OKcyLUCML4YOXl428gOOzBgN6Gw0rv8dpsJ7PqTHxBnXnwXr8S1mYFSLSa727tpz0xg==",
      "cpu": [
        "wasm32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later AND MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/runtime": "^1.4.0"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-ia32": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-ia32/-/sharp-win32-ia32-0.34.1.tgz",
      "integrity": "sha512-WKf/NAZITnonBf3U1LfdjoMgNO5JYRSlhovhRhMxXVdvWYveM4kM3L8m35onYIdh75cOMCo1BexgVQcCDzyoWw==",
      "cpu": [
        "ia32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-x64/-/sharp-win32-x64-0.34.1.tgz",
      "integrity": "sha512-hw1iIAHpNE8q3uMIRCgGOeDoz9KtFNarFLQclLxr/LK1VBkj8nby18RjFvr6aP7USRYAjTZW6yisnBWMX571Tw==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@next/env": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/env/-/env-15.3.1.tgz",
      "integrity": "sha512-cwK27QdzrMblHSn9DZRV+DQscHXRuJv6MydlJRpFSqJWZrTYMLzKDeyueJNN9MGd8NNiUKzDQADAf+dMLXX7YQ==",
      "license": "MIT"
    },
    "node_modules/@next/swc-darwin-arm64": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-arm64/-/swc-darwin-arm64-15.3.1.tgz",
      "integrity": "sha512-hjDw4f4/nla+6wysBL07z52Gs55Gttp5Bsk5/8AncQLJoisvTBP0pRIBK/B16/KqQyH+uN4Ww8KkcAqJODYH3w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-darwin-x64": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-x64/-/swc-darwin-x64-15.3.1.tgz",
      "integrity": "sha512-q+aw+cJ2ooVYdCEqZVk+T4Ni10jF6Fo5DfpEV51OupMaV5XL6pf3GCzrk6kSSZBsMKZtVC1Zm/xaNBFpA6bJ2g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-gnu": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-gnu/-/swc-linux-arm64-gnu-15.3.1.tgz",
      "integrity": "sha512-wBQ+jGUI3N0QZyWmmvRHjXjTWFy8o+zPFLSOyAyGFI94oJi+kK/LIZFJXeykvgXUk1NLDAEFDZw/NVINhdk9FQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-musl": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-musl/-/swc-linux-arm64-musl-15.3.1.tgz",
      "integrity": "sha512-IIxXEXRti/AulO9lWRHiCpUUR8AR/ZYLPALgiIg/9ENzMzLn3l0NSxVdva7R/VDcuSEBo0eGVCe3evSIHNz0Hg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-gnu": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-gnu/-/swc-linux-x64-gnu-15.3.1.tgz",
      "integrity": "sha512-bfI4AMhySJbyXQIKH5rmLJ5/BP7bPwuxauTvVEiJ/ADoddaA9fgyNNCcsbu9SlqfHDoZmfI6g2EjzLwbsVTr5A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-musl": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-musl/-/swc-linux-x64-musl-15.3.1.tgz",
      "integrity": "sha512-FeAbR7FYMWR+Z+M5iSGytVryKHiAsc0x3Nc3J+FD5NVbD5Mqz7fTSy8CYliXinn7T26nDMbpExRUI/4ekTvoiA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-arm64-msvc": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-arm64-msvc/-/swc-win32-arm64-msvc-15.3.1.tgz",
      "integrity": "sha512-yP7FueWjphQEPpJQ2oKmshk/ppOt+0/bB8JC8svPUZNy0Pi3KbPx2Llkzv1p8CoQa+D2wknINlJpHf3vtChVBw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-x64-msvc": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-x64-msvc/-/swc-win32-x64-msvc-15.3.1.tgz",
      "integrity": "sha512-3PMvF2zRJAifcRNni9uMk/gulWfWS+qVI/pagd+4yLF5bcXPZPPH2xlYRYOsUjmCJOXSTAC2PjRzbhsRzR2fDQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@prisma/client": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-6.6.0.tgz",
      "integrity": "sha512-vfp73YT/BHsWWOAuthKQ/1lBgESSqYqAWZEYyTdGXyFAHpmewwWL2Iz6ErIzkj4aHbuc6/cGSsE6ZY+pBO04Cg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "prisma": "*",
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/config": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/config/-/config-6.6.0.tgz",
      "integrity": "sha512-d8FlXRHsx72RbN8nA2QCRORNv5AcUnPXgtPvwhXmYkQSMF/j9cKaJg+9VcUzBRXGy9QBckNzEQDEJZdEOZ+ubA==",
      "license": "Apache-2.0",
      "dependencies": {
        "esbuild": ">=0.12 <1",
        "esbuild-register": "3.6.0"
      }
    },
    "node_modules/@prisma/debug": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-6.6.0.tgz",
      "integrity": "sha512-DL6n4IKlW5k2LEXzpN60SQ1kP/F6fqaCgU/McgaYsxSf43GZ8lwtmXLke9efS+L1uGmrhtBUP4npV/QKF8s2ZQ==",
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/engines": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-6.6.0.tgz",
      "integrity": "sha512-nC0IV4NHh7500cozD1fBoTwTD1ydJERndreIjpZr/S3mno3P6tm8qnXmIND5SwUkibNeSJMpgl4gAnlqJ/gVlg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.6.0",
        "@prisma/engines-version": "6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",
        "@prisma/fetch-engine": "6.6.0",
        "@prisma/get-platform": "6.6.0"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a.tgz",
      "integrity": "sha512-JzRaQ5Em1fuEcbR3nUsMNYaIYrOT1iMheenjCvzZblJcjv/3JIuxXN7RCNT5i6lRkLodW5ojCGhR7n5yvnNKrw==",
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-6.6.0.tgz",
      "integrity": "sha512-Ohfo8gKp05LFLZaBlPUApM0M7k43a0jmo86YY35u1/4t+vuQH9mRGU7jGwVzGFY3v+9edeb/cowb1oG4buM1yw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.6.0",
        "@prisma/engines-version": "6.6.0-53.f676762280b54cd07c770017ed3711ddde35f37a",
        "@prisma/get-platform": "6.6.0"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-6.6.0.tgz",
      "integrity": "sha512-3qCwmnT4Jh5WCGUrkWcc6VZaw0JY7eWN175/pcb5Z6FiLZZ3ygY93UX0WuV41bG51a6JN/oBH0uywJ90Y+V5eA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.6.0"
      }
    },
    "node_modules/@radix-ui/number": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/number/-/number-1.1.1.tgz",
      "integrity": "sha512-MkKCwxlXTgz6CFoJx3pCwn07GKp36+aZyu/u2Ln2VrA5DcdyCZkASEDBTd8x5whTQQL5CiYf4prXKLcgQdv29g==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/primitive": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/primitive/-/primitive-1.1.2.tgz",
      "integrity": "sha512-XnbHrrprsNqZKQhStrSwgRUQzoCI1glLzdw79xiZPoofhGICeZRSQ3dIxAKH1gb3OHfNf4d6f+vAv3kil2eggA==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/react-arrow": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-arrow/-/react-arrow-1.1.4.tgz",
      "integrity": "sha512-qz+fxrqgNxG0dYew5l7qR3c7wdgRu1XVUHGnGYX7rg5HM4p9SWaRmJwfgR3J0SgyUKayLmzQIun+N6rWRgiRKw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-checkbox": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-checkbox/-/react-checkbox-1.2.3.tgz",
      "integrity": "sha512-pHVzDYsnaDmBlAuwim45y3soIN8H4R7KbkSVirGhXO+R/kO2OLCe0eucUEbddaTcdMHHdzcIGHtZSMSQlA+apw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-presence": "1.1.4",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collection/-/react-collection-1.1.4.tgz",
      "integrity": "sha512-cv4vSf7HttqXilDnAnvINd53OTl1/bjUYVZrkFnA7nwmY9Ob2POUy0WY0sfqBAe1s5FyKsyceQlqiEGPYNTadg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-slot": "1.2.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-compose-refs": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-compose-refs/-/react-compose-refs-1.1.2.tgz",
      "integrity": "sha512-z4eqJvfiNnFMHIIvXP3CY57y2WJs5g2v3X0zm9mEJkrkNv4rDxu+sg9Jh8EkXyeqBkB7SOcboo9dMVqhyrACIg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-context/-/react-context-1.1.2.tgz",
      "integrity": "sha512-jCi/QKUM2r1Ju5a3J64TH2A5SpKAgh0LpknyqdQ4m6DCV0xJ2HG1xARRwNGPQfi1SLdLWZ1OJz6F4OMBBNiGJA==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dialog/-/react-dialog-1.1.11.tgz",
      "integrity": "sha512-yI7S1ipkP5/+99qhSI6nthfo/tR6bL6Zgxi/+1UO6qPa6UeM6nlafWcQ65vB4rU2XjgjMfMhI3k9Y5MztA62VQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.7",
        "@radix-ui/react-focus-guards": "1.1.2",
        "@radix-ui/react-focus-scope": "1.1.4",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-portal": "1.1.6",
        "@radix-ui/react-presence": "1.1.4",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-slot": "1.2.0",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-direction": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-direction/-/react-direction-1.1.1.tgz",
      "integrity": "sha512-1UEWRX6jnOA2y4H5WczZ44gOOjTEmlqv1uNW4GAJEO5+bauCBhv8snY65Iw5/VOS/ghKN9gr2KjnLKxrsvoMVw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.7.tgz",
      "integrity": "sha512-j5+WBUdhccJsmH5/H0K6RncjDtoALSEr6jbkaZu+bjw6hOPOhHycr6vEUujl+HBK8kjUfWcoCJXxP6e4lUlMZw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.2.tgz",
      "integrity": "sha512-fyjAACV62oPV925xFCrH8DR5xWhg9KYtJT4s3u54jxp+L/hbpTY2kIeEFFbFe+a/HCE94zGQMZLIpVTPVZDhaA==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-scope": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-scope/-/react-focus-scope-1.1.4.tgz",
      "integrity": "sha512-r2annK27lIW5w9Ho5NyQgqs0MmgZSTIKXWpVCJaLC1q2kZrZkcqnmHkCHMEmv8XLvsLlurKMPT+kbKkRkm/xVA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-id": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-id/-/react-id-1.1.1.tgz",
      "integrity": "sha512-kGkGegYIdQsOb4XjsfM97rXsiHaBwco+hFI66oO4s9LU+PLAC5oJ7khdOVFxkhsmlbpUqDAvXw11CluXP+jkHg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-label/-/react-label-2.1.4.tgz",
      "integrity": "sha512-wy3dqizZnZVV4ja0FNnUhIWNwWdoldXrneEyUcVtLYDAt8ovGS4ridtMAOGgXBBIfggL4BOveVWsjXDORdGEQg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popover/-/react-popover-1.1.11.tgz",
      "integrity": "sha512-yFMfZkVA5G3GJnBgb2PxrrcLKm1ZLWXrbYVgdyTl//0TYEIHS9LJbnyz7WWcZ0qCq7hIlJZpRtxeSeIG5T5oJw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.7",
        "@radix-ui/react-focus-guards": "1.1.2",
        "@radix-ui/react-focus-scope": "1.1.4",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.4",
        "@radix-ui/react-portal": "1.1.6",
        "@radix-ui/react-presence": "1.1.4",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-slot": "1.2.0",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popper": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.4.tgz",
      "integrity": "sha512-3p2Rgm/a1cK0r/UVkx5F/K9v/EplfjAeIFCGOPYPO4lZ0jtg4iSQXt/YGTSLWaf4x7NG6Z4+uKFcylcTZjeqDA==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.4",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-portal": {
      "version": "1.1.6",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-portal/-/react-portal-1.1.6.tgz",
      "integrity": "sha512-XmsIl2z1n/TsYFLIdYam2rmFwf9OC/Sh2avkbmVMDuBZIe7hSpM0cYnWPAo7nHOVx8zTuwDZGByfcqLdnzp3Vw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-presence": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-presence/-/react-presence-1.1.4.tgz",
      "integrity": "sha512-ueDqRbdc4/bkaQT3GIpLQssRlFgWaL/U2z/S31qRwwLWoxHLgry3SIfCwhxeQNbirEUXFa+lq3RL3oBYXtcmIA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.0.tgz",
      "integrity": "sha512-/J/FhLdK0zVcILOwt5g+dH4KnkonCtkVJsa2G6JmvbbtZfBEI1gMsO3QMjseL4F/SwfAMt1Vc/0XKYKq+xJ1sw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-radio-group": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-radio-group/-/react-radio-group-1.3.4.tgz",
      "integrity": "sha512-N4J9QFdW5zcJNxxY/zwTXBN4Uc5VEuRM7ZLjNfnWoKmNvgrPtNNw4P8zY532O3qL6aPkaNO+gY9y6bfzmH4U1g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-presence": "1.1.4",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-roving-focus": "1.1.7",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-roving-focus": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-roving-focus/-/react-roving-focus-1.1.7.tgz",
      "integrity": "sha512-C6oAg451/fQT3EGbWHbCQjYTtbyjNO1uzQgMzwyivcHT3GKNEmu1q3UuREhN+HzHAVtv3ivMVK08QlC+PkYw9Q==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-collection": "1.1.4",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-select": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-select/-/react-select-2.2.2.tgz",
      "integrity": "sha512-HjkVHtBkuq+r3zUAZ/CvNWUGKPfuicGDbgtZgiQuFmNcV5F+Tgy24ep2nsAW2nFgvhGPJVqeBZa6KyVN0EyrBA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-collection": "1.1.4",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.7",
        "@radix-ui/react-focus-guards": "1.1.2",
        "@radix-ui/react-focus-scope": "1.1.4",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.4",
        "@radix-ui/react-portal": "1.1.6",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-slot": "1.2.0",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-visually-hidden": "1.2.0",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-separator/-/react-separator-1.1.4.tgz",
      "integrity": "sha512-2fTm6PSiUm8YPq9W0E4reYuv01EE3aFSzt8edBiXqPHshF8N9+Kymt/k0/R+F3dkY5lQyB/zPtrP82phskLi7w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-slot": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.0.tgz",
      "integrity": "sha512-ujc+V6r0HNDviYqIK3rW4ffgYiZ8g5DEHrGJVk4x7kTlLXRDILnKX9vAUYeIsLOoDpDJ0ujpqMkjH4w2ofuo6w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-switch": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-switch/-/react-switch-1.2.2.tgz",
      "integrity": "sha512-7Z8n6L+ifMIIYZ83f28qWSceUpkXuslI2FJ34+kDMTiyj91ENdpdQ7VCidrzj5JfwfZTeano/BnGBbu/jqa5rQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.2",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.0",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-callback-ref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-callback-ref/-/react-use-callback-ref-1.1.1.tgz",
      "integrity": "sha512-FkBMwD+qbGQeMu1cOHnuGB6x4yzPjho8ap5WtbEJ26umhgqVXbhekKUQO+hZEL1vU92a3wHwdp0HAcqAUF5iDg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-controllable-state": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-controllable-state/-/react-use-controllable-state-1.2.2.tgz",
      "integrity": "sha512-BjasUjixPFdS+NKkypcyyN5Pmg83Olst0+c6vGov0diwTEo6mgdqVR6hxcEgFuh4QrAs7Rc+9KuGJ9TVCj0Zzg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-effect-event": "0.0.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-effect-event": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-effect-event/-/react-use-effect-event-0.0.2.tgz",
      "integrity": "sha512-Qp8WbZOBe+blgpuUT+lw2xheLP8q0oatc9UpmiemEICxGvFLYmHm9QowVZGHtJlGbS6A6yJ3iViad/2cVjnOiA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-escape-keydown": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-escape-keydown/-/react-use-escape-keydown-1.1.1.tgz",
      "integrity": "sha512-Il0+boE7w/XebUHyBjroE+DbByORGR9KKmITzbR7MyQ4akpORYP/ZmbhAr0DG7RmmBqoOnZdy2QlvajJ2QA59g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-layout-effect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-layout-effect/-/react-use-layout-effect-1.1.1.tgz",
      "integrity": "sha512-RbJRS4UWQFkzHTTwVymMTUv8EqYhOp8dOOviLj2ugtTiXRaRQS7GLGxZTLL1jWhMeoSCf5zmcZkqTl9IiYfXcQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-previous": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-previous/-/react-use-previous-1.1.1.tgz",
      "integrity": "sha512-2dHfToCj/pzca2Ck724OZ5L0EVrr3eHRNsG/b3xQJLA2hZpVCS99bLAX+hm1IHXDEnzU6by5z/5MIY794/a8NQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-rect/-/react-use-rect-1.1.1.tgz",
      "integrity": "sha512-QTYuDesS0VtuHNNvMh+CjlKJ4LJickCMUAqjlE3+j8w+RlRpwyX3apEQKGFzbZGdo7XNG1tXa+bQqIE7HIXT2w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-size": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-size/-/react-use-size-1.1.1.tgz",
      "integrity": "sha512-ewrXRDTAqAXlkl6t/fkXWNAhFX9I+CkKlw6zjEwk86RSPKwZr3xpBRso655aqYafwtnbpHLj6toFzmd6xdVptQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-visually-hidden": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-visually-hidden/-/react-visually-hidden-1.2.0.tgz",
      "integrity": "sha512-rQj0aAWOpCdCMRbI6pLQm8r7S2BM3YhTa0SzOYD55k+hJA8oo9J+H+9wLM9oMlZWOX/wJWPTzfDfmZkf7LvCfg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.0"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/rect/-/rect-1.1.1.tgz",
      "integrity": "sha512-HPwpGIzkl28mWyZqG52jiqDJ12waP11Pa1lGoiyUkIEuMLBP0oeK/C89esbXrxsky5we7dfd8U58nm0SgAWpVw==",
      "license": "MIT"
    },
    "node_modules/@standard-schema/utils": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/utils/-/utils-0.3.0.tgz",
      "integrity": "sha512-e7Mew686owMaPJVNNLs55PUvgz371nKgwsc4vxE49zsODpJEnxgxRo2y/OKrqueavXgZNMDVj3DdHFlaSAeU8g==",
      "license": "MIT"
    },
    "node_modules/@swc/counter": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@swc/counter/-/counter-0.1.3.tgz",
      "integrity": "sha512-e2BR4lsJkkRlKZ/qCHPw9ZaSxc0MVUd7gtbtaB7aMvHeJVYe8sOB8DBZkP2DtISHGSku9sCK6T6cnY0CtXrOCQ==",
      "license": "Apache-2.0"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.15",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.15.tgz",
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@tailwindcss/node": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/node/-/node-4.1.4.tgz",
      "integrity": "sha512-MT5118zaiO6x6hNA04OWInuAiP1YISXql8Z+/Y8iisV5nuhM8VXlyhRuqc2PEviPszcXI66W44bCIk500Oolhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "enhanced-resolve": "^5.18.1",
        "jiti": "^2.4.2",
        "lightningcss": "1.29.2",
        "tailwindcss": "4.1.4"
      }
    },
    "node_modules/@tailwindcss/oxide": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide/-/oxide-4.1.4.tgz",
      "integrity": "sha512-p5wOpXyOJx7mKh5MXh5oKk+kqcz8T+bA3z/5VWWeQwFrmuBItGwz8Y2CHk/sJ+dNb9B0nYFfn0rj/cKHZyjahQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 10"
      },
      "optionalDependencies": {
        "@tailwindcss/oxide-android-arm64": "4.1.4",
        "@tailwindcss/oxide-darwin-arm64": "4.1.4",
        "@tailwindcss/oxide-darwin-x64": "4.1.4",
        "@tailwindcss/oxide-freebsd-x64": "4.1.4",
        "@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.4",
        "@tailwindcss/oxide-linux-arm64-gnu": "4.1.4",
        "@tailwindcss/oxide-linux-arm64-musl": "4.1.4",
        "@tailwindcss/oxide-linux-x64-gnu": "4.1.4",
        "@tailwindcss/oxide-linux-x64-musl": "4.1.4",
        "@tailwindcss/oxide-wasm32-wasi": "4.1.4",
        "@tailwindcss/oxide-win32-arm64-msvc": "4.1.4",
        "@tailwindcss/oxide-win32-x64-msvc": "4.1.4"
      }
    },
    "node_modules/@tailwindcss/oxide-android-arm64": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-android-arm64/-/oxide-android-arm64-4.1.4.tgz",
      "integrity": "sha512-xMMAe/SaCN/vHfQYui3fqaBDEXMu22BVwQ33veLc8ep+DNy7CWN52L+TTG9y1K397w9nkzv+Mw+mZWISiqhmlA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-arm64": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-arm64/-/oxide-darwin-arm64-4.1.4.tgz",
      "integrity": "sha512-JGRj0SYFuDuAGilWFBlshcexev2hOKfNkoX+0QTksKYq2zgF9VY/vVMq9m8IObYnLna0Xlg+ytCi2FN2rOL0Sg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-darwin-x64": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-darwin-x64/-/oxide-darwin-x64-4.1.4.tgz",
      "integrity": "sha512-sdDeLNvs3cYeWsEJ4H1DvjOzaGios4QbBTNLVLVs0XQ0V95bffT3+scptzYGPMjm7xv4+qMhCDrkHwhnUySEzA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-freebsd-x64": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-freebsd-x64/-/oxide-freebsd-x64-4.1.4.tgz",
      "integrity": "sha512-VHxAqxqdghM83HslPhRsNhHo91McsxRJaEnShJOMu8mHmEj9Ig7ToHJtDukkuLWLzLboh2XSjq/0zO6wgvykNA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm-gnueabihf": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm-gnueabihf/-/oxide-linux-arm-gnueabihf-4.1.4.tgz",
      "integrity": "sha512-OTU/m/eV4gQKxy9r5acuesqaymyeSCnsx1cFto/I1WhPmi5HDxX1nkzb8KYBiwkHIGg7CTfo/AcGzoXAJBxLfg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-gnu": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-gnu/-/oxide-linux-arm64-gnu-4.1.4.tgz",
      "integrity": "sha512-hKlLNvbmUC6z5g/J4H+Zx7f7w15whSVImokLPmP6ff1QqTVE+TxUM9PGuNsjHvkvlHUtGTdDnOvGNSEUiXI1Ww==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-arm64-musl": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-arm64-musl/-/oxide-linux-arm64-musl-4.1.4.tgz",
      "integrity": "sha512-X3As2xhtgPTY/m5edUtddmZ8rCruvBvtxYLMw9OsZdH01L2gS2icsHRwxdU0dMItNfVmrBezueXZCHxVeeb7Aw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-gnu": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-gnu/-/oxide-linux-x64-gnu-4.1.4.tgz",
      "integrity": "sha512-2VG4DqhGaDSmYIu6C4ua2vSLXnJsb/C9liej7TuSO04NK+JJJgJucDUgmX6sn7Gw3Cs5ZJ9ZLrnI0QRDOjLfNQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-linux-x64-musl": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-linux-x64-musl/-/oxide-linux-x64-musl-4.1.4.tgz",
      "integrity": "sha512-v+mxVgH2kmur/X5Mdrz9m7TsoVjbdYQT0b4Z+dr+I4RvreCNXyCFELZL/DO0M1RsidZTrm6O1eMnV6zlgEzTMQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-wasm32-wasi": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-wasm32-wasi/-/oxide-wasm32-wasi-4.1.4.tgz",
      "integrity": "sha512-2TLe9ir+9esCf6Wm+lLWTMbgklIjiF0pbmDnwmhR9MksVOq+e8aP3TSsXySnBDDvTTVd/vKu1aNttEGj3P6l8Q==",
      "bundleDependencies": [
        "@napi-rs/wasm-runtime",
        "@emnapi/core",
        "@emnapi/runtime",
        "@tybys/wasm-util",
        "@emnapi/wasi-threads",
        "tslib"
      ],
      "cpu": [
        "wasm32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/core": "^1.4.0",
        "@emnapi/runtime": "^1.4.0",
        "@emnapi/wasi-threads": "^1.0.1",
        "@napi-rs/wasm-runtime": "^0.2.8",
        "@tybys/wasm-util": "^0.9.0",
        "tslib": "^2.8.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-arm64-msvc": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-arm64-msvc/-/oxide-win32-arm64-msvc-4.1.4.tgz",
      "integrity": "sha512-VlnhfilPlO0ltxW9/BgfLI5547PYzqBMPIzRrk4W7uupgCt8z6Trw/tAj6QUtF2om+1MH281Pg+HHUJoLesmng==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/oxide-win32-x64-msvc": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/oxide-win32-x64-msvc/-/oxide-win32-x64-msvc-4.1.4.tgz",
      "integrity": "sha512-+7S63t5zhYjslUGb8NcgLpFXD+Kq1F/zt5Xv5qTv7HaFTG/DHyHD9GA6ieNAxhgyA4IcKa/zy7Xx4Oad2/wuhw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@tailwindcss/postcss": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/@tailwindcss/postcss/-/postcss-4.1.4.tgz",
      "integrity": "sha512-bjV6sqycCEa+AQSt2Kr7wpGF1bOZJ5wsqnLEkqSbM/JEHxx/yhMH8wHmdkPyApF9xhHeMSwnnkDUUMMM/hYnXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "@tailwindcss/node": "4.1.4",
        "@tailwindcss/oxide": "4.1.4",
        "postcss": "^8.4.41",
        "tailwindcss": "4.1.4"
      }
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/d3-array": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/@types/d3-array/-/d3-array-3.2.1.tgz",
      "integrity": "sha512-Y2Jn2idRrLzUfAKV2LyRImR+y4oa2AntrgID95SHJxuMUrkNXmanDSed71sRNZysveJVt1hLLemQZIady0FpEg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-color": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/@types/d3-color/-/d3-color-3.1.3.tgz",
      "integrity": "sha512-iO90scth9WAbmgv7ogoq57O9YpKmFBbmoEoCHDB2xMBY0+/KVrqAaCDyCE16dUspeOvIxFFRI+0sEtqDqy2b4A==",
      "license": "MIT"
    },
    "node_modules/@types/d3-ease": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-ease/-/d3-ease-3.0.2.tgz",
      "integrity": "sha512-NcV1JjO5oDzoK26oMzbILE6HW7uVXOHLQvHshBUW4UMdZGfiY6v5BeQwh9a9tCzv+CeefZQHJt5SRgK154RtiA==",
      "license": "MIT"
    },
    "node_modules/@types/d3-interpolate": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-interpolate/-/d3-interpolate-3.0.4.tgz",
      "integrity": "sha512-mgLPETlrpVV1YRJIglr4Ez47g7Yxjl1lj7YKsiMCb27VJH9W8NVM6Bb9d8kkpG/uAQS5AmbA48q2IAolKKo1MA==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-color": "*"
      }
    },
    "node_modules/@types/d3-path": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/@types/d3-path/-/d3-path-3.1.1.tgz",
      "integrity": "sha512-VMZBYyQvbGmWyWVea0EHs/BwLgxc+MKi1zLDCONksozI4YJMcTt8ZEuIR4Sb1MMTE8MMW49v0IwI5+b7RmfWlg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-scale": {
      "version": "4.0.9",
      "resolved": "https://registry.npmjs.org/@types/d3-scale/-/d3-scale-4.0.9.tgz",
      "integrity": "sha512-dLmtwB8zkAeO/juAMfnV+sItKjlsw2lKdZVVy6LRr0cBmegxSABiLEpGVmSJJ8O08i4+sGR6qQtb6WtuwJdvVw==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-time": "*"
      }
    },
    "node_modules/@types/d3-shape": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/@types/d3-shape/-/d3-shape-3.1.7.tgz",
      "integrity": "sha512-VLvUQ33C+3J+8p+Daf+nYSOsjB4GXp19/S/aGo60m9h1v6XaxjiT82lKVWJCfzhtuZ3yD7i/TPeC/fuKLLOSmg==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-path": "*"
      }
    },
    "node_modules/@types/d3-time": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-time/-/d3-time-3.0.4.tgz",
      "integrity": "sha512-yuzZug1nkAAaBlBBikKZTgzCeA+k1uy4ZFwWANOfKw5z5LRhV0gNA7gNkKm7HoK+HRN0wX3EkxGk0fpbWhmB7g==",
      "license": "MIT"
    },
    "node_modules/@types/d3-timer": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-timer/-/d3-timer-3.0.2.tgz",
      "integrity": "sha512-Ps3T8E8dZDam6fUyNiMkekK3XUsaUEik+idO9/YjPtfj2qruF8tFBXS7XhtE4iIXBLxhmLjP3SXpLhVf21I9Lw==",
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.17.30",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.17.30.tgz",
      "integrity": "sha512-7zf4YyHA+jvBNfVrk2Gtvs6x7E8V+YDW05bNfG2XkWDJfYRXrTiP/DsB2zSYTaHX0bGIujTBQdMVAhb+j7mwpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.19.2"
      }
    },
    "node_modules/@types/react": {
      "version": "19.1.2",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.1.2.tgz",
      "integrity": "sha512-oxLPMytKchWGbnQM9O7D67uPa9paTNxO7jVoNMXgkkErULBPhPARCfkKL9ytcIJJRGjbsVwW4ugJzyFFvm/Tiw==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.1.2",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.2.tgz",
      "integrity": "sha512-XGJkWF41Qq305SKWEILa1O8vzhb3aOo3ogBlSmiqNko/WmRb6QIaweuZCXjKygVDXpzXb5wyxKTSOsmkuqj+Qw==",
      "devOptional": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.14.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
      "integrity": "sha512-TIGnTpdo+E3+pCyAluZvtED5p5wCqLdezCyhPZzKPcxvFplEt4i+W7OONCKgeZFT3+y5NZZfOOS/Bdcanm1MYA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ansi-styles": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
      "integrity": "sha512-kmCevFghRiWM7HB5zTPULl4r9bVFSWjz62MhqizDGUrq2NWuNMQyuv4tHHoKJHs69M/MF64lEcHdYIocrdWQYA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/aria-hidden": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/aria-hidden/-/aria-hidden-1.2.4.tgz",
      "integrity": "sha512-y+CcFFwelSXpLZk/7fMB2mUbGtX9lKycf1MWJ7CaTIERyitVlyQx6C+sxcROU2BAJ24OiZyK+8wj2i8AlBoS3A==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001715",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001715.tgz",
      "integrity": "sha512-7ptkFGMm2OAOgvZpwgA4yjQ5SQbrNVGdRjzH0pBdy1Fasvcr+KAeECmbCAECzTuDuoX0FCY8KzUxjf9+9kfZEw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
      "integrity": "sha512-U3lRVLMSlsCfjqYPbLyVv11M9CPW4I728d6TCKMAOJueEeB9/8o+eSsMnxPJD+Q+K909sdESg7C+tIkoH6on1A==",
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^2.2.1",
        "escape-string-regexp": "^1.0.2",
        "has-ansi": "^2.0.0",
        "strip-ansi": "^3.0.0",
        "supports-color": "^2.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/class-variance-authority": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/class-variance-authority/-/class-variance-authority-0.7.1.tgz",
      "integrity": "sha512-Ka+9Trutv7G8M6WT6SeiRWz792K5qEqIGEGzXKhAE6xOWAY6pPH8U+9IY3oCMv6kqTmLsv7Xh/2w2RigkePMsg==",
      "license": "Apache-2.0",
      "dependencies": {
        "clsx": "^2.1.1"
      },
      "funding": {
        "url": "https://polar.sh/cva"
      }
    },
    "node_modules/client-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/client-only/-/client-only-0.0.1.tgz",
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA==",
      "license": "MIT"
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/color/-/color-4.2.3.tgz",
      "integrity": "sha512-1rXeuUUiGGrykh+CeBdu5Ie7OJwinCgQY0bc7GCRxy5xVHy+moaqkpL/jqQq0MtQOeYcrqEz4abc5f0KtU7W4A==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-convert": "^2.0.1",
        "color-string": "^1.9.0"
      },
      "engines": {
        "node": ">=12.5.0"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/color-string": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/color-string/-/color-string-1.9.1.tgz",
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-name": "^1.0.0",
        "simple-swizzle": "^0.2.2"
      }
    },
    "node_modules/cookie": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.0.2.tgz",
      "integrity": "sha512-9Kr/j4O16ISv8zBBhJoi4bXOYNTkFLOqSL3UDB0njXxCXNezjeyVrJyGOWtgfs/q2km1gwBcfH8q1yEGoMYunA==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/d3-array": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/d3-array/-/d3-array-3.2.4.tgz",
      "integrity": "sha512-tdQAmyA18i4J7wprpYq8ClcxZy3SC31QMeByyCFyRt7BVHdREQZ5lpzoe5mFEYZUWe+oq8HBvk9JjpibyEV4Jg==",
      "license": "ISC",
      "dependencies": {
        "internmap": "1 - 2"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-color": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-color/-/d3-color-3.1.0.tgz",
      "integrity": "sha512-zg/chbXyeBtMQ1LbD/WSoW2DpC3I0mpmPdW+ynRTj/x2DAWYrIY7qeZIHidozwV24m4iavr15lNwIwLxRmOxhA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-ease": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-ease/-/d3-ease-3.0.1.tgz",
      "integrity": "sha512-wR/XK3D3XcLIZwpbvQwQ5fK+8Ykds1ip7A2Txe0yxncXSdq1L9skcG7blcedkOX+ZcgxGAmLX1FrRGbADwzi0w==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-format": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-format/-/d3-format-3.1.0.tgz",
      "integrity": "sha512-YyUI6AEuY/Wpt8KWLgZHsIU86atmikuoOmCfommt0LYHiQSPjvX2AcFc38PX0CBpr2RCyZhjex+NS/LPOv6YqA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-interpolate": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-interpolate/-/d3-interpolate-3.0.1.tgz",
      "integrity": "sha512-3bYs1rOD33uo8aqJfKP3JWPAibgw8Zm2+L9vBKEHJ2Rg+viTR7o5Mmv5mZcieN+FRYaAOWX5SJATX6k1PWz72g==",
      "license": "ISC",
      "dependencies": {
        "d3-color": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-path": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-path/-/d3-path-3.1.0.tgz",
      "integrity": "sha512-p3KP5HCf/bvjBSSKuXid6Zqijx7wIfNW+J/maPs+iwR35at5JCbLUT0LzF1cnjbCHWhqzQTIN2Jpe8pRebIEFQ==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-scale": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/d3-scale/-/d3-scale-4.0.2.tgz",
      "integrity": "sha512-GZW464g1SH7ag3Y7hXjf8RoUuAFIqklOAq3MRl4OaWabTFJY9PN/E1YklhXLh+OQ3fM9yS2nOkCoS+WLZ6kvxQ==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2.10.0 - 3",
        "d3-format": "1 - 3",
        "d3-interpolate": "1.2.0 - 3",
        "d3-time": "2.1.1 - 3",
        "d3-time-format": "2 - 4"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-shape": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/d3-shape/-/d3-shape-3.2.0.tgz",
      "integrity": "sha512-SaLBuwGm3MOViRq2ABk3eLoxwZELpH6zhl3FbAoJ7Vm1gofKx6El1Ib5z23NUEhF9AsGl7y+dzLe5Cw2AArGTA==",
      "license": "ISC",
      "dependencies": {
        "d3-path": "^3.1.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-time/-/d3-time-3.1.0.tgz",
      "integrity": "sha512-VqKjzBLejbSMT4IgbmVgDjpkYrNWUYJnbCGo874u7MMKIWsILRX+OpX/gTk8MqjpT1A/c6HY2dCA77ZN0lkQ2Q==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time-format": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/d3-time-format/-/d3-time-format-4.1.0.tgz",
      "integrity": "sha512-dJxPBlzC7NugB2PDLwo9Q8JiTR3M3e4/XANkreKSUxF8vvXKqm1Yfq4Q5dl8budlunRVlUUaDUgFt7eA8D6NLg==",
      "license": "ISC",
      "dependencies": {
        "d3-time": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-timer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-timer/-/d3-timer-3.0.1.tgz",
      "integrity": "sha512-ndfJ/JxxMd3nw31uyKoY2naivF+r29V+Lc0svZxe1JvvIRmi8hUsrMvdOwgS1o6uBHmiz91geQ0ylPP0aj1VUA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/debug": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
      "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js-light": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/decimal.js-light/-/decimal.js-light-2.5.1.tgz",
      "integrity": "sha512-qIMFpTMZmny+MMIitAB6D7iVPEorVw6YQRWkvarTkT4tBeSLLiHzcwj6q0MmYSFCiVpiqPJTJEYIrpcPzVEIvg==",
      "license": "MIT"
    },
    "node_modules/dequal": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/dequal/-/dequal-2.0.3.tgz",
      "integrity": "sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.4.tgz",
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/detect-node-es": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/detect-node-es/-/detect-node-es-1.1.0.tgz",
      "integrity": "sha512-ypdmJU/TbBby2Dxibuv7ZLW3Bs1QEmM7nHjEANfohJLvE0XVujisn1qPJcZxg+qDucsr+bP6fLD1rPS3AhJ7EQ==",
      "license": "MIT"
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dom-helpers": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz",
      "integrity": "sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.8.7",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/dot-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
      "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
      "license": "MIT",
      "dependencies": {
        "no-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/enhanced-resolve": {
      "version": "5.18.1",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.18.1.tgz",
      "integrity": "sha512-ZSW3ma5GkcQBIpwZTSRAI8N71Uuwgs93IezB7mf7R60tC8ZbJideoDNKjHn2O9KIlx6rkGTTEk1xUCK2E1Y2Yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.2.0"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/esbuild": {
      "version": "0.25.3",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.3.tgz",
      "integrity": "sha512-qKA6Pvai73+M2FtftpNKRxJ78GIjmFXFxd/1DVBqGo/qNhLSfv+G12n9pNoWdytJC8U00TrViOwpjT0zgqQS8Q==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.3",
        "@esbuild/android-arm": "0.25.3",
        "@esbuild/android-arm64": "0.25.3",
        "@esbuild/android-x64": "0.25.3",
        "@esbuild/darwin-arm64": "0.25.3",
        "@esbuild/darwin-x64": "0.25.3",
        "@esbuild/freebsd-arm64": "0.25.3",
        "@esbuild/freebsd-x64": "0.25.3",
        "@esbuild/linux-arm": "0.25.3",
        "@esbuild/linux-arm64": "0.25.3",
        "@esbuild/linux-ia32": "0.25.3",
        "@esbuild/linux-loong64": "0.25.3",
        "@esbuild/linux-mips64el": "0.25.3",
        "@esbuild/linux-ppc64": "0.25.3",
        "@esbuild/linux-riscv64": "0.25.3",
        "@esbuild/linux-s390x": "0.25.3",
        "@esbuild/linux-x64": "0.25.3",
        "@esbuild/netbsd-arm64": "0.25.3",
        "@esbuild/netbsd-x64": "0.25.3",
        "@esbuild/openbsd-arm64": "0.25.3",
        "@esbuild/openbsd-x64": "0.25.3",
        "@esbuild/sunos-x64": "0.25.3",
        "@esbuild/win32-arm64": "0.25.3",
        "@esbuild/win32-ia32": "0.25.3",
        "@esbuild/win32-x64": "0.25.3"
      }
    },
    "node_modules/esbuild-register": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/esbuild-register/-/esbuild-register-3.6.0.tgz",
      "integrity": "sha512-H2/S7Pm8a9CL1uhp9OvjwrBh5Pvx0H8qVOxNu8Wed9Y7qv56MPtq+GGM8RJpq6glYJn9Wspr8uw7l55uyinNeg==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.4"
      },
      "peerDependencies": {
        "esbuild": ">=0.12 <1"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.8.0"
      }
    },
    "node_modules/eventemitter3": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
      "license": "MIT"
    },
    "node_modules/fast-equals": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/fast-equals/-/fast-equals-5.2.2.tgz",
      "integrity": "sha512-V7/RktU11J3I36Nwq2JnZEM7tNm17eBJz+u25qdxBZeCKiX6BkVSZQjwWIr+IobgnZy+ag73tTZgZi7tr0LrBw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/get-nonce": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-nonce/-/get-nonce-1.0.1.tgz",
      "integrity": "sha512-FJhYRoDaiatfEkUK8HKlicmu/3SGFD51q3itKDGoSTysQJBnfOcxU5GxnhE1E6soB76MbT0MBtnKJuXyAx+96Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/get-tsconfig": {
      "version": "4.10.0",
      "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.10.0.tgz",
      "integrity": "sha512-kGzZ3LWWQcGIAmg6iWvXn0ei6WDtV26wzHRMwDSzmAbcXrTEXxHy6IehI6/4eT6VRKyMP1eF1VqwrVUmE/LR7A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "resolve-pkg-maps": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
      }
    },
    "node_modules/glob-to-regexp": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.4.1.tgz",
      "integrity": "sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==",
      "license": "BSD-2-Clause"
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/has-ansi": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz",
      "integrity": "sha512-C8vBJ8DwUCx19vhm7urhTuUsr4/IyP6l4VzNQDv+ryHQObW3TTTp9yB68WpYgRe2bbaGuZ/se74IqFeVnMnLZg==",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^2.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/internmap": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/internmap/-/internmap-2.0.3.tgz",
      "integrity": "sha512-5Hh7Y1wQbvY5ooGgPbDaL5iYLAPzMTUrjMulskHLH6wnv/A+1q5rgEaiuqEjB+oxGXIVZs1FF+R/KPN3ZSQYYg==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.3.2.tgz",
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/jiti": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.4.2.tgz",
      "integrity": "sha512-rg9zJN+G4n2nfJl5MW3BMygZX56zKPNVEYYqq7adpmMh4Jn2QNEwhvQlFy6jPVdcod7txZtKHWnyZiA3a0zP7A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-cookie": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/js-cookie/-/js-cookie-3.0.5.tgz",
      "integrity": "sha512-cEiJEAEoIbWfCZYKWhVwFuvPX1gETRYPw6LlaTKoxD3s2AkXzkCjnp6h0V77ozyqj0jakteJ4YqDJT830+lVGw==",
      "license": "MIT",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/lightningcss": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss/-/lightningcss-1.29.2.tgz",
      "integrity": "sha512-6b6gd/RUXKaw5keVdSEtqFVdzWnU5jMxTUjA2bVcMNPLwSQ08Sv/UodBVtETLCn7k4S1Ibxwh7k68IwLZPgKaA==",
      "dev": true,
      "license": "MPL-2.0",
      "dependencies": {
        "detect-libc": "^2.0.3"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      },
      "optionalDependencies": {
        "lightningcss-darwin-arm64": "1.29.2",
        "lightningcss-darwin-x64": "1.29.2",
        "lightningcss-freebsd-x64": "1.29.2",
        "lightningcss-linux-arm-gnueabihf": "1.29.2",
        "lightningcss-linux-arm64-gnu": "1.29.2",
        "lightningcss-linux-arm64-musl": "1.29.2",
        "lightningcss-linux-x64-gnu": "1.29.2",
        "lightningcss-linux-x64-musl": "1.29.2",
        "lightningcss-win32-arm64-msvc": "1.29.2",
        "lightningcss-win32-x64-msvc": "1.29.2"
      }
    },
    "node_modules/lightningcss-darwin-arm64": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-arm64/-/lightningcss-darwin-arm64-1.29.2.tgz",
      "integrity": "sha512-cK/eMabSViKn/PG8U/a7aCorpeKLMlK0bQeNHmdb7qUnBkNPnL+oV5DjJUo0kqWsJUapZsM4jCfYItbqBDvlcA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-darwin-x64": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-darwin-x64/-/lightningcss-darwin-x64-1.29.2.tgz",
      "integrity": "sha512-j5qYxamyQw4kDXX5hnnCKMf3mLlHvG44f24Qyi2965/Ycz829MYqjrVg2H8BidybHBp9kom4D7DR5VqCKDXS0w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-freebsd-x64": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-freebsd-x64/-/lightningcss-freebsd-x64-1.29.2.tgz",
      "integrity": "sha512-wDk7M2tM78Ii8ek9YjnY8MjV5f5JN2qNVO+/0BAGZRvXKtQrBC4/cn4ssQIpKIPP44YXw6gFdpUF+Ps+RGsCwg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm-gnueabihf": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm-gnueabihf/-/lightningcss-linux-arm-gnueabihf-1.29.2.tgz",
      "integrity": "sha512-IRUrOrAF2Z+KExdExe3Rz7NSTuuJ2HvCGlMKoquK5pjvo2JY4Rybr+NrKnq0U0hZnx5AnGsuFHjGnNT14w26sg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-gnu": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-gnu/-/lightningcss-linux-arm64-gnu-1.29.2.tgz",
      "integrity": "sha512-KKCpOlmhdjvUTX/mBuaKemp0oeDIBBLFiU5Fnqxh1/DZ4JPZi4evEH7TKoSBFOSOV3J7iEmmBaw/8dpiUvRKlQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-arm64-musl": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-arm64-musl/-/lightningcss-linux-arm64-musl-1.29.2.tgz",
      "integrity": "sha512-Q64eM1bPlOOUgxFmoPUefqzY1yV3ctFPE6d/Vt7WzLW4rKTv7MyYNky+FWxRpLkNASTnKQUaiMJ87zNODIrrKQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-gnu": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-gnu/-/lightningcss-linux-x64-gnu-1.29.2.tgz",
      "integrity": "sha512-0v6idDCPG6epLXtBH/RPkHvYx74CVziHo6TMYga8O2EiQApnUPZsbR9nFNrg2cgBzk1AYqEd95TlrsL7nYABQg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-linux-x64-musl": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-linux-x64-musl/-/lightningcss-linux-x64-musl-1.29.2.tgz",
      "integrity": "sha512-rMpz2yawkgGT8RULc5S4WiZopVMOFWjiItBT7aSfDX4NQav6M44rhn5hjtkKzB+wMTRlLLqxkeYEtQ3dd9696w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-arm64-msvc": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-arm64-msvc/-/lightningcss-win32-arm64-msvc-1.29.2.tgz",
      "integrity": "sha512-nL7zRW6evGQqYVu/bKGK+zShyz8OVzsCotFgc7judbt6wnB2KbiKKJwBE4SGoDBQ1O94RjW4asrCjQL4i8Fhbw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lightningcss-win32-x64-msvc": {
      "version": "1.29.2",
      "resolved": "https://registry.npmjs.org/lightningcss-win32-x64-msvc/-/lightningcss-win32-x64-msvc-1.29.2.tgz",
      "integrity": "sha512-EdIUW3B2vLuHmv7urfzMI/h2fmlnOQBk1xlsDxkN1tCWKjNFjfLhGxYk8C8mzpSfr+A6jFFIi8fU6LbQGsRWjA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MPL-2.0",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/parcel"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lower-case": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
      "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.3"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.501.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.501.0.tgz",
      "integrity": "sha512-E2KoyhW59fCb/yUbR3rbDer83fqn7a8NG91ZhIot2yWaPHjPyGzzsNKh40N//GezYShAuycf3TcQksRQznIsRw==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/make-array": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/make-array/-/make-array-1.0.5.tgz",
      "integrity": "sha512-sgK2SAzxT19rWU+qxKUcn6PAh/swiIiz2F8C2cZjLc1z4iwYIfdoihqFIDQ8BDzAGtWPYJ6Sr13K1j/DXynDLA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/map-obj": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/map-obj/-/map-obj-4.3.0.tgz",
      "integrity": "sha512-hdN1wVrZbb29eBGiGjJbeP8JbKjq1urkHJ/LIP/NY48MZ1QVXUsQBV1G1zvYFHn1XE06cwjBsOI2K3Ulnj1YXQ==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/next": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/next/-/next-15.3.1.tgz",
      "integrity": "sha512-8+dDV0xNLOgHlyBxP1GwHGVaNXsmp+2NhZEYrXr24GWLHtt27YrBPbPuHvzlhi7kZNYjeJNR93IF5zfFu5UL0g==",
      "license": "MIT",
      "dependencies": {
        "@next/env": "15.3.1",
        "@swc/counter": "0.1.3",
        "@swc/helpers": "0.5.15",
        "busboy": "1.6.0",
        "caniuse-lite": "^1.0.30001579",
        "postcss": "8.4.31",
        "styled-jsx": "5.1.6"
      },
      "bin": {
        "next": "dist/bin/next"
      },
      "engines": {
        "node": "^18.18.0 || ^19.8.0 || >= 20.0.0"
      },
      "optionalDependencies": {
        "@next/swc-darwin-arm64": "15.3.1",
        "@next/swc-darwin-x64": "15.3.1",
        "@next/swc-linux-arm64-gnu": "15.3.1",
        "@next/swc-linux-arm64-musl": "15.3.1",
        "@next/swc-linux-x64-gnu": "15.3.1",
        "@next/swc-linux-x64-musl": "15.3.1",
        "@next/swc-win32-arm64-msvc": "15.3.1",
        "@next/swc-win32-x64-msvc": "15.3.1",
        "sharp": "^0.34.1"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.1.0",
        "@playwright/test": "^1.41.2",
        "babel-plugin-react-compiler": "*",
        "react": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "react-dom": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "sass": "^1.3.0"
      },
      "peerDependenciesMeta": {
        "@opentelemetry/api": {
          "optional": true
        },
        "@playwright/test": {
          "optional": true
        },
        "babel-plugin-react-compiler": {
          "optional": true
        },
        "sass": {
          "optional": true
        }
      }
    },
    "node_modules/next/node_modules/postcss": {
      "version": "8.4.31",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.4.31.tgz",
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.6",
        "picocolors": "^1.0.0",
        "source-map-js": "^1.0.2"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/no-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
      "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
      "license": "MIT",
      "dependencies": {
        "lower-case": "^2.0.2",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.3",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.3.tgz",
      "integrity": "sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.8",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/print-code": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/print-code/-/print-code-1.0.2.tgz",
      "integrity": "sha512-nmTYPigkBuCJixGNzvmI8Wi9Ts8ZgNvH/V1xhr1A4FVpLQfgkYVi+B6xsG+VgY/1nKG2QdIuLCzZTOvCPv9OXA==",
      "license": "MIT",
      "dependencies": {
        "chalk": "^1.1.1",
        "make-array": "^1.0.1",
        "set-options": "^1.0.2"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/prisma": {
      "version": "6.6.0",
      "resolved": "https://registry.npmjs.org/prisma/-/prisma-6.6.0.tgz",
      "integrity": "sha512-SYCUykz+1cnl6Ugd8VUvtTQq5+j1Q7C0CtzKPjQ8JyA2ALh0EEJkMCS+KgdnvKW1lrxjtjCyJSHOOT236mENYg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/config": "6.6.0",
        "@prisma/engines": "6.6.0"
      },
      "bin": {
        "prisma": "build/index.js"
      },
      "engines": {
        "node": ">=18.18"
      },
      "optionalDependencies": {
        "fsevents": "2.3.3"
      },
      "peerDependencies": {
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/prop-types/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-hook-form": {
      "version": "7.56.1",
      "resolved": "https://registry.npmjs.org/react-hook-form/-/react-hook-form-7.56.1.tgz",
      "integrity": "sha512-qWAVokhSpshhcEuQDSANHx3jiAEFzu2HAaaQIzi/r9FNPm1ioAvuJSD4EuZzWd7Al7nTRKcKPnBKO7sRn+zavQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/react-hook-form"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17 || ^18 || ^19"
      }
    },
    "node_modules/react-icons": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/react-icons/-/react-icons-5.5.0.tgz",
      "integrity": "sha512-MEFcXdkP3dLo8uumGI5xN3lDFNsRtrjbOEKDLD7yv76v4wpnEq2Lt2qeHaQOr34I/wPN3s3+N08WkQ+CW37Xiw==",
      "license": "MIT",
      "peerDependencies": {
        "react": "*"
      }
    },
    "node_modules/react-is": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
      "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
      "license": "MIT"
    },
    "node_modules/react-remove-scroll": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/react-remove-scroll/-/react-remove-scroll-2.6.3.tgz",
      "integrity": "sha512-pnAi91oOk8g8ABQKGF5/M9qxmmOPxaAnopyTHYfqYEwJhyFrbbBtHuSgtKEoH0jpcxx5o3hXqH1mNd9/Oi+8iQ==",
      "license": "MIT",
      "dependencies": {
        "react-remove-scroll-bar": "^2.3.7",
        "react-style-singleton": "^2.2.3",
        "tslib": "^2.1.0",
        "use-callback-ref": "^1.3.3",
        "use-sidecar": "^1.1.3"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-remove-scroll-bar": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/react-remove-scroll-bar/-/react-remove-scroll-bar-2.3.8.tgz",
      "integrity": "sha512-9r+yi9+mgU33AKcj6IbT9oRCO78WriSj6t/cF8DWBZJ9aOGPOTEDvdUDz1FwKim7QXWwmHqtdHnRJfhAxEG46Q==",
      "license": "MIT",
      "dependencies": {
        "react-style-singleton": "^2.2.2",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-smooth": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/react-smooth/-/react-smooth-4.0.4.tgz",
      "integrity": "sha512-gnGKTpYwqL0Iii09gHobNolvX4Kiq4PKx6eWBCYYix+8cdw+cGo3do906l1NBPKkSWx1DghC1dlWG9L2uGd61Q==",
      "license": "MIT",
      "dependencies": {
        "fast-equals": "^5.0.1",
        "prop-types": "^15.8.1",
        "react-transition-group": "^4.4.5"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/react-style-singleton": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/react-style-singleton/-/react-style-singleton-2.2.3.tgz",
      "integrity": "sha512-b6jSvxvVnyptAiLjbkWLE/lOnR4lfTtDAl+eUC7RZy+QQWc6wRzIV2CE6xBuMmDxc2qIihtDCZD5NPOFl7fRBQ==",
      "license": "MIT",
      "dependencies": {
        "get-nonce": "^1.0.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-transition-group": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz",
      "integrity": "sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/runtime": "^7.5.5",
        "dom-helpers": "^5.0.1",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.6.2"
      },
      "peerDependencies": {
        "react": ">=16.6.0",
        "react-dom": ">=16.6.0"
      }
    },
    "node_modules/recharts": {
      "version": "2.15.3",
      "resolved": "https://registry.npmjs.org/recharts/-/recharts-2.15.3.tgz",
      "integrity": "sha512-EdOPzTwcFSuqtvkDoaM5ws/Km1+WTAO2eizL7rqiG0V2UVhTnz0m7J2i0CjVPUCdEkZImaWvXLbZDS2H5t6GFQ==",
      "license": "MIT",
      "dependencies": {
        "clsx": "^2.0.0",
        "eventemitter3": "^4.0.1",
        "lodash": "^4.17.21",
        "react-is": "^18.3.1",
        "react-smooth": "^4.0.4",
        "recharts-scale": "^0.4.4",
        "tiny-invariant": "^1.3.1",
        "victory-vendor": "^36.6.8"
      },
      "engines": {
        "node": ">=14"
      },
      "peerDependencies": {
        "react": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/recharts-scale": {
      "version": "0.4.5",
      "resolved": "https://registry.npmjs.org/recharts-scale/-/recharts-scale-0.4.5.tgz",
      "integrity": "sha512-kivNFO+0OcUNu7jQquLXAxz1FIwZj8nrj+YkOKc5694NbjCvcT6aSZiIzNzd2Kul4o4rTto8QVR9lMNtxD4G1w==",
      "license": "MIT",
      "dependencies": {
        "decimal.js-light": "^2.4.1"
      }
    },
    "node_modules/regenerator-runtime": {
      "version": "0.14.1",
      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.14.1.tgz",
      "integrity": "sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==",
      "license": "MIT"
    },
    "node_modules/resolve-pkg-maps": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz",
      "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==",
      "license": "ISC",
      "optional": true,
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/server-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/server-only/-/server-only-0.0.1.tgz",
      "integrity": "sha512-qepMx2JxAa5jjfzxG79yPPq+8BuFToHd1hm7kI+Z4zAq1ftQiP7HcxMhDDItrbtwVeLg/cY2JnKnrcFkmiswNA==",
      "license": "MIT"
    },
    "node_modules/set-options": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/set-options/-/set-options-1.0.4.tgz",
      "integrity": "sha512-C4HiE/+WxvExWkAu7g9GhqAyENjxLDz9py3ihJeT1mrGd7oIVfG48EupFxri+4nlXdDklhc7GRsPMWUUgnNSlg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/sharp": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/sharp/-/sharp-0.34.1.tgz",
      "integrity": "sha512-1j0w61+eVxu7DawFJtnfYcvSv6qPFvfTaqzTQ2BLknVhHTwGS8sc63ZBF4rzkWMBVKybo4S5OBtDdZahh2A1xg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "color": "^4.2.3",
        "detect-libc": "^2.0.3",
        "semver": "^7.7.1"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-darwin-arm64": "0.34.1",
        "@img/sharp-darwin-x64": "0.34.1",
        "@img/sharp-libvips-darwin-arm64": "1.1.0",
        "@img/sharp-libvips-darwin-x64": "1.1.0",
        "@img/sharp-libvips-linux-arm": "1.1.0",
        "@img/sharp-libvips-linux-arm64": "1.1.0",
        "@img/sharp-libvips-linux-ppc64": "1.1.0",
        "@img/sharp-libvips-linux-s390x": "1.1.0",
        "@img/sharp-libvips-linux-x64": "1.1.0",
        "@img/sharp-libvips-linuxmusl-arm64": "1.1.0",
        "@img/sharp-libvips-linuxmusl-x64": "1.1.0",
        "@img/sharp-linux-arm": "0.34.1",
        "@img/sharp-linux-arm64": "0.34.1",
        "@img/sharp-linux-s390x": "0.34.1",
        "@img/sharp-linux-x64": "0.34.1",
        "@img/sharp-linuxmusl-arm64": "0.34.1",
        "@img/sharp-linuxmusl-x64": "0.34.1",
        "@img/sharp-wasm32": "0.34.1",
        "@img/sharp-win32-ia32": "0.34.1",
        "@img/sharp-win32-x64": "0.34.1"
      }
    },
    "node_modules/simple-swizzle": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/simple-swizzle/-/simple-swizzle-0.2.2.tgz",
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "is-arrayish": "^0.3.1"
      }
    },
    "node_modules/snake-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
      "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
      "license": "MIT",
      "dependencies": {
        "dot-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/snakecase-keys": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/snakecase-keys/-/snakecase-keys-8.0.1.tgz",
      "integrity": "sha512-Sj51kE1zC7zh6TDlNNz0/Jn1n5HiHdoQErxO8jLtnyrkJW/M5PrI7x05uDgY3BO7OUQYKCvmeMurW6BPUdwEOw==",
      "license": "MIT",
      "dependencies": {
        "map-obj": "^4.1.0",
        "snake-case": "^3.0.4",
        "type-fest": "^4.15.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/sonner": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/sonner/-/sonner-2.0.3.tgz",
      "integrity": "sha512-njQ4Hht92m0sMqqHVDL32V2Oun9W1+PHO9NDv9FHfJjT3JT22IG4Jpo3FPQy+mouRKCXFWO+r67v6MrHX2zeIA==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-rc",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/std-env": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.9.0.tgz",
      "integrity": "sha512-UGvjygr6F6tpH7o2qyqR6QYpwraIjKSdtzyBdyytFOHmPZY917kwdwLG0RbOjWOnKmnm3PeHjaoLLMie7kPLQw==",
      "license": "MIT"
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/strip-ansi": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
      "integrity": "sha512-VhumSSbBqDTP8p2ZLKj40UjBCV4+v8bUSEpUb4KjRgWk9pbqGF4REFj6KEagidb2f/M6AzC0EmFyDNGaw9OCzg==",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^2.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/styled-jsx": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/styled-jsx/-/styled-jsx-5.1.6.tgz",
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "license": "MIT",
      "dependencies": {
        "client-only": "0.0.1"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "peerDependencies": {
        "react": ">= 16.8.0 || 17.x.x || ^18.0.0-0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "@babel/core": {
          "optional": true
        },
        "babel-plugin-macros": {
          "optional": true
        }
      }
    },
    "node_modules/supports-color": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
      "integrity": "sha512-KKNVtd6pCYgPIKU4cp2733HWYCpplQhddZLBUryaAHou723x+FRzQ5Df824Fj+IyyuiQTRoub4SnIFfIcrp70g==",
      "license": "MIT",
      "engines": {
        "node": ">=0.8.0"
      }
    },
    "node_modules/swr": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/swr/-/swr-2.3.3.tgz",
      "integrity": "sha512-dshNvs3ExOqtZ6kJBaAsabhPdHyeY4P2cKwRCniDVifBMoG/SVI7tfLWqPXriVspf2Rg4tPzXJTnwaihIeFw2A==",
      "license": "MIT",
      "dependencies": {
        "dequal": "^2.0.3",
        "use-sync-external-store": "^1.4.0"
      },
      "peerDependencies": {
        "react": "^16.11.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/tailwind-merge": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/tailwind-merge/-/tailwind-merge-3.2.0.tgz",
      "integrity": "sha512-FQT/OVqCD+7edmmJpsgCsY820RTD5AkBryuG5IUqR5YQZSdj5xlH5nLgH7YPths7WsLPSpSBNneJdM8aS8aeFA==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/dcastil"
      }
    },
    "node_modules/tailwindcss": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.4.tgz",
      "integrity": "sha512-1ZIUqtPITFbv/DxRmDr5/agPqJwF69d24m9qmM1939TJehgY539CtzeZRjbLt5G6fSy/7YqqYsfvoTEw9xUI2A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tapable": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.2.1.tgz",
      "integrity": "sha512-GNzQvQTOIP6RyTfE2Qxb8ZVlNmw0n88vp1szwWRimP02mnTsx3Wtn5qRdqY9w2XduFNUgvOwhNnQsjwCp+kqaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/tiny-invariant": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/tiny-invariant/-/tiny-invariant-1.3.3.tgz",
      "integrity": "sha512-+FbBPE1o9QAYvviau/qC5SE3caw21q3xkvWKBtja5vgqOWIHHJ3ioaq1VPfn/Szqctz2bU/oYeKd9/z5BL+PVg==",
      "license": "MIT"
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/tsx": {
      "version": "4.19.3",
      "resolved": "https://registry.npmjs.org/tsx/-/tsx-4.19.3.tgz",
      "integrity": "sha512-4H8vUNGNjQ4V2EOoGw005+c+dGuPSnhpPBPHBtsZdGZBk/iJb4kguGlPWaZTZ3q5nMtFOEsY0nRDlh9PJyd6SQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "~0.25.0",
        "get-tsconfig": "^4.7.5"
      },
      "bin": {
        "tsx": "dist/cli.mjs"
      },
      "engines": {
        "node": ">=18.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      }
    },
    "node_modules/tw-animate-css": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/tw-animate-css/-/tw-animate-css-1.2.8.tgz",
      "integrity": "sha512-AxSnYRvyFnAiZCUndS3zQZhNfV/B77ZhJ+O7d3K6wfg/jKJY+yv6ahuyXwnyaYA9UdLqnpCwhTRv9pPTBnPR2g==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/Wombosvideo"
      }
    },
    "node_modules/type-fest": {
      "version": "4.40.0",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-4.40.0.tgz",
      "integrity": "sha512-ABHZ2/tS2JkvH1PEjxFDTUWC8dB5OsIGZP4IFLhR293GqT5Y5qB1WwL2kMPYhQW9DVgVD8Hd7I8gjwPIf5GFkw==",
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=16"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
      "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/use-callback-ref": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz",
      "integrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sidecar": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/use-sidecar/-/use-sidecar-1.1.3.tgz",
      "integrity": "sha512-Fedw0aZvkhynoPYlA5WXrMCAMm+nSWdZt6lzJQ7Ok8S6Q+VsHmHpRWndVRJ8Be0ZbkfPc5LRYH+5XrzXcEeLRQ==",
      "license": "MIT",
      "dependencies": {
        "detect-node-es": "^1.1.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.5.0.tgz",
      "integrity": "sha512-Rb46I4cGGVBmjamjphe8L/UnvJD+uPPtTkNvX5mZgqdbavhI4EbgIWJiIHXJ8bc/i9EQGPRh4DwEURJ552Do0A==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/victory-vendor": {
      "version": "36.9.2",
      "resolved": "https://registry.npmjs.org/victory-vendor/-/victory-vendor-36.9.2.tgz",
      "integrity": "sha512-PnpQQMuxlwYdocC8fIJqVXvkeViHYzotI+NJrCuav0ZYFoq912ZHBk3mCeuj+5/VpodOjPe1z0Fk2ihgzlXqjQ==",
      "license": "MIT AND ISC",
      "dependencies": {
        "@types/d3-array": "^3.0.3",
        "@types/d3-ease": "^3.0.0",
        "@types/d3-interpolate": "^3.0.1",
        "@types/d3-scale": "^4.0.2",
        "@types/d3-shape": "^3.1.0",
        "@types/d3-time": "^3.0.0",
        "@types/d3-timer": "^3.0.0",
        "d3-array": "^3.1.6",
        "d3-ease": "^3.0.1",
        "d3-interpolate": "^3.0.1",
        "d3-scale": "^4.0.2",
        "d3-shape": "^3.1.0",
        "d3-time": "^3.0.0",
        "d3-timer": "^3.0.1"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/zod": {
      "version": "3.24.3",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.24.3.tgz",
      "integrity": "sha512-HhY1oqzWCQWuUqvBFnsyrtZRhyPeR7SUGv+C4+MsisMuVfSPx8HpwWqH8tRahSlt6M3PiFAcoeFhZAqIXTxoSg==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    }
  }
}

```

## 📄 package.json

```json
{
  "name": "fuckin_dbms",
  "version": "0.1.0",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "seed": "ts-node ./prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node ./prisma/seed.ts"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.16.0",
    "@faker-js/faker": "^9.7.0",
    "@hookform/resolvers": "^5.0.1",
    "@prisma/client": "^6.6.0",
    "@radix-ui/react-checkbox": "^1.2.2",
    "@radix-ui/react-dialog": "^1.1.11",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-popover": "^1.1.11",
    "@radix-ui/react-radio-group": "^1.3.2",
    "@radix-ui/react-select": "^2.2.2",
    "@radix-ui/react-separator": "^1.1.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.2.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.501.0",
    "next": "15.3.1",
    "print-code": "^1.0.2",
    "prisma": "^6.6.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.56.1",
    "react-icons": "^5.5.0",
    "recharts": "^2.15.3",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.2.0",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.17.30",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.3",
    "typescript": "^5.8.3"
  }
}

```

## 📄 postcss.config.mjs

```
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

## 📄 prisma\seed.ts

```ts
import { PrismaClient } from "@/lib/generated/prisma";
import { generateRandomColor } from "@/utils";
import { fakerDE as faker } from "@faker-js/faker";
import { Role } from "@/lib/generated/prisma";

const prisma = new PrismaClient();

async function seed() {
  console.log("Seeding data...");

  // Create 3 staff
  const staffRoles = [Role.NURSE, Role.CASHIER, Role.LAB_TECHNICIAN];
  for (const role of staffRoles) {
    const mobile = faker.phone.number();

    await prisma.staff.create({
      data: {
        id: faker.string?.uuid(),
        email: faker.internet.email(),
        name: faker.name.fullName(),
        phone: mobile,
        address: faker.address.streetAddress(),
        department: faker.company.name(),
        status: "ACTIVE",
        role: role,
      },
    });
  }

  // Create 10 doctors
  const doctors = [];
  for (let i = 0; i < 10; i++) {
    const doctor = await prisma.doctor.create({
      data: {
        id: faker.string.uuid(),
        email: faker.internet.email(),
        name: faker.name.fullName(),
        specialization: faker.name.jobType(),
        license_number: faker.string.uuid(),
        phone: faker.phone.number(),
        address: faker.address.streetAddress(),
        department: faker.company.name(),
        availability_status: "ACTIVE",
        type: i % 2 === 0 ? "FULL" : "PART",
        working_days: {
          create: [
            {
              day: "Monday",
              start_time: "08:00",
              close_time: "17:00",
            },
            {
              day: "Wednesday",
              start_time: "08:00",
              close_time: "17:00",
            },
          ],
        },
      },
    });
    doctors.push(doctor);
  }

  // Create 20 patients
  const patients = [];
  for (let i = 0; i < 20; i++) {
    const patient = await prisma.patient.create({
      data: {
        id: faker.string.uuid(),
        first_name: faker.name.firstName(),
        last_name: faker.name.lastName(),
        date_of_birth: faker.date.birthdate(),
        gender: i % 2 === 0 ? "MALE" : "FEMALE",
        phone: faker.phone.number(),
        email: faker.internet.email(),
        marital_status: i % 3 === 0 ? "Married" : "Single",
        address: faker.address.streetAddress(),
        emergency_contact_name: faker.name.fullName(),
        emergency_contact_number: faker.phone.number(),
        relation: "Sibling",
        blood_group: i % 4 === 0 ? "O+" : "A+",
        allergies: faker.lorem.words(2),
        medical_conditions: faker.lorem.words(3),
        privacy_consent: true,
        service_consent: true,
        medical_consent: true,
      },
    });

    patients.push(patient);
  }

  // Create Appointments
  for (let i = 0; i < 20; i++) {
    const doctor = doctors[Math.floor(Math.random() * doctors.length)];
    const patient = patients[Math.floor(Math.random() * patients.length)];

    await prisma.appointment.create({
      data: {
        patient_id: patient.id,
        doctor_id: doctor.id,
        appointmentDate: faker.date.soon(),
        appointmentTime: "10:00",
        status: i % 4 === 0 ? "PENDING" : "SCHEDULED",
        type: "Checkup",
        reason: faker.lorem.sentence(),
      },
    });
  }

  console.log("Seeding complete!");
  await prisma.$disconnect();
}

seed().catch((e) => {
  console.error(e);
  prisma.$disconnect();
  process.exit(1);
});

```

## 📄 README.md

```md


```
├─ app
│  ├─ (auth)
│  │  ├─ layout.tsx
│  │  ├─ sign-in
│  │  │  └─ [[...sign-in]]
│  │  │     └─ page.tsx
│  │  └─ sign-up
│  │     └─ [[...sign-up]]
│  │        └─ page.tsx
│  ├─ (protected)
│  │  ├─ admin
│  │  │  ├─ page.tsx
│  │  │  └─ system-settings
│  │  │     └─ page.tsx
│  │  ├─ doctor
│  │  │  └─ page.tsx
│  │  ├─ layout.tsx
│  │  ├─ patient
│  │  │  ├─ page.tsx
│  │  │  ├─ registration
│  │  │  │  └─ page.tsx
│  │  │  └─ [patientId]
│  │  │     └─ page.tsx
│  │  └─ record
│  │     ├─ appointments
│  │     │  ├─ page.tsx
│  │     │  └─ [id]
│  │     │     └─ page.tsx
│  │     ├─ billing
│  │     │  └─ page.tsx
│  │     ├─ doctors
│  │     │  ├─ page.tsx
│  │     │  └─ [id]
│  │     │     └─ page.tsx
│  │     ├─ medical-records
│  │     │  └─ page.tsx
│  │     ├─ patients
│  │     │  └─ page.tsx
│  │     ├─ staffs
│  │     │  └─ page.tsx
│  │     └─ users
│  │        └─ page.tsx
│  ├─ actions
│  │  ├─ admin.ts
│  │  ├─ appointment.ts
│  │  ├─ general.ts
│  │  ├─ medical.ts
│  │  └─ patient.ts
│  ├─ favicon.ico
│  ├─ fonts
│  ├─ globals.css
│  ├─ layout.tsx
│  ├─ layoutDebugger.tsx
│  └─ page.tsx
├─ assests
│  ├─ hospitalLandingPage.jpg
│  └─ Signup.jpg
├─ components
│  ├─ action-dialog.tsx
│  ├─ action-options.tsx
│  ├─ appointment
│  │  ├─ appointment-details.tsx
│  │  ├─ appointment-quick-links.tsx
│  │  ├─ bills-container.tsx
│  │  ├─ blood-pressure-chart.tsx
│  │  ├─ chart-container.tsx
│  │  ├─ diagnosis-container.tsx
│  │  ├─ generate-final-bill.tsx
│  │  ├─ heart-rate-chart.tsx
│  │  ├─ medical-history-card.tsx
│  │  ├─ patient-details-card.tsx
│  │  ├─ payment-container.tsx
│  │  └─ vital-signs.tsx
│  ├─ appointment-action-dialog.tsx
│  ├─ appointment-action.tsx
│  ├─ appointment-actions.tsx
│  ├─ appointment-container.tsx
│  ├─ appointment-status-indicator.tsx
│  ├─ available-doctor.tsx
│  ├─ charts
│  │  ├─ appointment-chart.tsx
│  │  ├─ rating-chart.tsx
│  │  └─ stat-summary.tsx
│  ├─ cutom-input.tsx
│  ├─ dialogs
│  │  ├─ add-bills.tsx
│  │  ├─ add-diagnosis.tsx
│  │  ├─ add-service.tsx
│  │  ├─ add-vital-signs.tsx
│  │  └─ review-form.tsx
│  ├─ forms
│  │  ├─ book-appointment.tsx
│  │  ├─ doctor-form.tsx
│  │  └─ staff-form.tsx
│  ├─ logoutButton.tsx
│  ├─ medical-history-container.tsx
│  ├─ medical-history-dialog.tsx
│  ├─ medical-history.tsx
│  ├─ navbar.tsx
│  ├─ new-patient.tsx
│  ├─ no-data-found.tsx
│  ├─ pagination.tsx
│  ├─ patient-rating-container.tsx
│  ├─ profile-image.tsx
│  ├─ rating-container.tsx
│  ├─ rating-list.tsx
│  ├─ search-input.tsx
│  ├─ settings
│  │  ├─ quick-link-settings.tsx
│  │  └─ service-settings.tsx
│  ├─ sidebar.tsx
│  ├─ small-card.tsx
│  ├─ stat-card.tsx
│  ├─ tables
│  │  ├─ recent-appointment.tsx
│  │  └─ table.tsx
│  ├─ ui
│  │  ├─ button.tsx
│  │  ├─ card.tsx
│  │  ├─ checkbox.tsx
│  │  ├─ dialog.tsx
│  │  ├─ form.tsx
│  │  ├─ input.tsx
│  │  ├─ label.tsx
│  │  ├─ popover.tsx
│  │  ├─ radio-group.tsx
│  │  ├─ select.tsx
│  │  ├─ separator.tsx
│  │  ├─ sheet.tsx
│  │  ├─ switch.tsx
│  │  └─ textarea.tsx
│  └─ view-appointment.tsx
├─ components.json
├─ lib
│  ├─ db.ts
│  ├─ generated
│  │  └─ prisma
│  │     ├─ client.d.ts
│  │     ├─ client.js
│  │     ├─ default.d.ts
│  │     ├─ default.js
│  │     ├─ edge.d.ts
│  │     ├─ edge.js
│  │     ├─ index-browser.js
│  │     ├─ index.d.ts
│  │     ├─ index.js
│  │     ├─ package.json
│  │     ├─ query_engine-windows.dll.node
│  │     ├─ query_engine-windows.dll.node.tmp21332
│  │     ├─ runtime
│  │     │  ├─ edge-esm.js
│  │     │  ├─ edge.js
│  │     │  ├─ index-browser.d.ts
│  │     │  ├─ index-browser.js
│  │     │  ├─ library.d.ts
│  │     │  ├─ library.js
│  │     │  ├─ react-native.js
│  │     │  └─ wasm.js
│  │     ├─ schema.prisma
│  │     ├─ wasm.d.ts
│  │     └─ wasm.js
│  ├─ index.ts
│  ├─ routes.ts
│  ├─ schema.ts
│  └─ utils.ts
├─ middleware.ts
├─ next.config.ts
├─ package-lock.json
├─ package.json
├─ postcss.config.mjs
├─ prisma
│  ├─ migrations
│  │  ├─ 20250420080632_init
│  │  │  └─ migration.sql
│  │  ├─ 20250420081245_user_table
│  │  │  └─ migration.sql
│  │  ├─ 20250420092635_tables
│  │  │  └─ migration.sql
│  │  ├─ 20250423205219_add_color_code_to_doctor
│  │  │  └─ migration.sql
│  │  └─ migration_lock.toml
│  ├─ schema.prisma
│  └─ seed.ts
├─ public
│  ├─ file.svg
│  ├─ globe.svg
│  ├─ next.svg
│  ├─ vercel.svg
│  └─ window.svg
├─ README.md
├─ tsconfig.json
├─ types
│  ├─ data-types.ts
│  ├─ global.d.ts
│  └─ index.ts
└─ utils
   ├─ index.ts
   ├─ roles.ts
   ├─ seetings.ts
   └─ services
      ├─ admin.ts
      ├─ appointment.ts
      ├─ doctor.ts
      ├─ medical-record.ts
      ├─ medical.ts
      ├─ patient.ts
      ├─ payments.ts
      └─ staff.ts

```
```

## 📄 tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

```

## 📄 types\data-types.ts

```ts
import { Doctor, Patient, AppointmentStatus } from "@/lib/generated/prisma";

export type AppointmentsChartProps = {
  name: string;
  appointment: number;
  completed: number;
}[];

export type Appointment = {
  id: string;
  patient_id: string;
  doctor_id: string;
  type: string;
  appointmentDate: Date;
  time: string;
  status: AppointmentStatus;

  patient: Patient;
  doctor: Doctor;
};

export type AvailableDoctorProps = {
  id: string;
  name: string;
  specialization: string;
  img?: string;
  // colorCode?: string;
  working_days: {
    day: string;
    start_time: string;
    close_time: string;
  }[];
}[];

```

## 📄 types\global.d.ts

```ts
import {Role} from "@prisma/client"

export {}

export type Roles = Role;

declare global {
    interface CustomJwtSessionClaims{
        metadata :{
            role?: Roles;
        }
    }
}
```

## 📄 types\index.ts

```ts
export interface SearchParamsProps {
    searchParams?: Promise<{ [key: string]: string | undefined }>;
  }
```

## 📄 utils\index.ts

```ts
export function formatNumber(amount: number): string {
    return amount?.toLocaleString("en-US", {
      maximumFractionDigits: 0,
    });
  }
  
  export function getInitials(name: string): string {
    const words = name.trim().split(" ");
  
    const firstTwoWords = words.slice(0, 2);
  
    const initials = firstTwoWords.map((word) => word.charAt(0).toUpperCase());
  
    return initials.join("");
  }
  
  export function formatDateTime(isoDate: string): string {
    const date = new Date(isoDate);
  
    const options: Intl.DateTimeFormatOptions = {
      weekday: "short",
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      // timeZoneName: "short", // "UTC"
    };
  
    return date.toLocaleString("en-US", options);
  }
  
  export function calculateAge(dob: Date): string {
    const today = new Date();
    let years = today.getFullYear() - dob.getFullYear();
    let months = today.getMonth() - dob.getMonth();
  
    if (months < 0) {
      years--;
      months += 12;
    }
  
    if (months === 0 && today.getDate() < dob.getDate()) {
      years--;
      months = 11;
    }
  
    if (years === 0) {
      return `${months} months old`;
    }
  
    let ageString = `${years} years`;
  
    if (months > 0) {
      ageString += ` ${months} months`;
    }
  
    return ageString + " old";
  }
  
  export const daysOfWeek = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday",
  ];
  
  export function generateRandomColor(): string {
    let hexColor = "";
    do {
      const randomInt = Math.floor(Math.random() * 16777216);
  
      hexColor = `#${randomInt.toString(16).padStart(6, "0")}`;
    } while (
      hexColor.toLowerCase() === "#ffffff" ||
      hexColor.toLowerCase() === "#000000"
    ); // Ensure it’s not white or black
    return hexColor;
  }
  
  function formatTime(hour: number, minute: number): string {
    const period = hour >= 12 ? "PM" : "AM";
    const adjustedHour = hour % 12 || 12;
    const formattedMinute = minute.toString().padStart(2, "0");
    return `${adjustedHour}:${formattedMinute} ${period}`;
  }
  
  export function generateTimes(
    start_hour: number,
    close_hour: number,
    interval_in_minutes: number
  ) {
    const times = [];
    const startHour = start_hour;
    const endHour = close_hour;
    const intervalMinutes = interval_in_minutes;
  
    for (let hour = startHour; hour <= endHour; hour++) {
      for (let minute = 0; minute < 60; minute += intervalMinutes) {
        if (hour === endHour && minute > 0) break;
        const formattedTime = formatTime(hour, minute);
        times.push({ label: formattedTime, value: formattedTime });
      }
    }
  
    return times;
  }
  
  export const calculateBMI = (weight: number, height: number) => {
    const heightInMeters = height / 100;
  
    const bmi = weight / (heightInMeters * heightInMeters);
  
    let status: string;
    let colorCode: string;
  
    if (bmi < 18.5) {
      status = "Underweight";
      colorCode = "#1E90FF";
    } else if (bmi >= 18.5 && bmi <= 24.9) {
      status = "Normal";
      colorCode = "#1E90FF";
    } else if (bmi >= 25 && bmi <= 29.9) {
      status = "Overweight";
      colorCode = "#FF9800";
    } else {
      status = "Obesity";
      colorCode = "#FF5722";
    }
  
    return {
      bmi: parseFloat(bmi.toFixed(2)),
      status,
      colorCode,
    };
  };
  
  type DiscountInput = {
    amount: number;
    discount?: number;
    discountPercentage?: number;
  };
  
  export function calculateDiscount({
    amount,
    discount,
    discountPercentage,
  }: DiscountInput): {
    finalAmount: number;
    discountPercentage?: number;
    discountAmount?: number;
  } {
    if (discount != null && discountPercentage != null) {
      throw new Error(
        "Provide either discount amount or discount percentage, not both."
      );
    }
  
    if (discount != null) {
      // Calculate discount percentage if a discount amount is provided
      const discountPercent = (discount / amount) * 100;
      return {
        finalAmount: amount - discount,
        discountPercentage: discountPercent,
        discountAmount: discount,
      };
    } else if (discountPercentage != null) {
      // Calculate discount amount if a discount percentage is provided
      const discountAmount = (discountPercentage / 100) * amount;
      return {
        finalAmount: amount - discountAmount,
        discountPercentage,
        discountAmount,
      };
    } else {
      throw new Error(
        "Please provide either a discount amount or a discount percentage."
      );
    }
  }
```

## 📄 utils\roles.ts

```ts
import { Roles } from "../types/global";
import { auth } from "@clerk/nextjs/server";

export const checkRole = async (role: Roles) => {
  const { sessionClaims } = await auth();

  return sessionClaims?.metadata?.role === role.toLowerCase();
};

export const getRole = async () => {
  const { sessionClaims } = await auth();

  const role = sessionClaims?.metadata.role!?.toLowerCase() || "patient";

  return role;
};
```

## 📄 utils\seetings.ts

```ts
export const DATA_LIMIT = 10;

export const SPECIALIZATION = [
  {
    label: "Cardiologist",
    value: "cardiologist",
    department: "Cardiovascular",
  },
  {
    label: "Dermatologist",
    value: "dermatologist",
    department: "Dermatology",
  },
  {
    label: "Endocrinologist",
    value: "endocrinologist",
    department: "Endocrinology",
  },
  {
    label: "Gastroenterologist",
    value: "gastroenterologist",
    department: "Gastroenterology",
  },
  {
    label: "Neurologist",
    value: "neurologist",
    department: "Neurology",
  },
  {
    label: "Oncologist",
    value: "oncologist",
    department: "Oncology",
  },
  {
    label: "Orthopedic Surgeon",
    value: "orthopedic surgeon",
    department: "Orthopedics",
  },
  {
    label: "Pediatrician",
    value: "pediatrician",
    department: "Pediatrics",
  },
  {
    label: "Psychiatrist",
    value: "psychiatrist",
    department: "Psychiatry",
  },
  {
    label: "Radiologist",
    value: "radiologist",
    department: "Radiology",
  },
  {
    label: "Urologist",
    value: "urologist",
    department: "Urology",
  },
  {
    label: "Ophthalmologist",
    value: "ophthalmologist",
    department: "Ophthalmology",
  },
  {
    label: "Obstetrician/Gynecologist",
    value: "obstetrician/gynecologist",
    department: "Obstetrics and Gynecology",
  },
  {
    label: "Anesthesiologist",
    value: "anesthesiologist",
    department: "Anesthesiology",
  },
  {
    label: "Pulmonologist",
    value: "pulmonologist",
    department: "Pulmonology",
  },
  {
    label: "Rheumatologist",
    value: "rheumatologist",
    department: "Rheumatology",
  },
  {
    label: "Otolaryngologist (ENT)",
    value: "otolaryngologist",
    department: "Otolaryngology (ENT)",
  },
  {
    label: "Nephrologist",
    value: "nephrologist",
    department: "Nephrology",
  },
  {
    label: "Geriatrician",
    value: "geriatrician",
    department: "Geriatrics",
  },
];
```

## 📄 utils\services\admin.ts

```ts
import db from "@/lib/db";
import { daysOfWeek } from "..";
import { processAppointments } from "./patient";

export async function getAdminDashboardStats() {
  try {
    const todayDate = new Date().getDay();
    const today = daysOfWeek[todayDate];

    const [totalPatient, totalDoctors, appointments, doctors] =
      await Promise.all([
        db.patient.count(),
        db.doctor.count(),
        db.appointment.findMany({
          include: {
            patient: {
              select: {
                id: true,
                last_name: true,
                first_name: true,
                img: true,
                colorCode: true,
                gender: true,
                date_of_birth: true,
              },
            },
            doctor: {
              select: {
                id: true,
                name: true,
                img: true,
                colorCode: true,
                specialization: true,
              },
            },
          },
          orderBy: { appointmentDate: "desc" },
        }),
        db.doctor.findMany({
          where: {
            working_days: {
              some: { day: { equals: today, mode: "insensitive" } },
            },
          },
          select: {
            id: true,
            name: true,
            specialization: true,
            img: true,
            colorCode: true,
          },
          take: 5,
        }),
      ]);

    const { appointmentCounts, monthlyData } = await processAppointments(
      appointments
    );

    const last5Records = appointments.slice(0, 5);

    return {
      success: true,
      totalPatient,
      totalDoctors,
      appointmentCounts,
      availableDoctors: doctors,
      monthlyData,
      last5Records,
      totalAppointments: appointments.length,
      status: 200,
    };
  } catch (error) {
    console.log(error);

    return { error: true, message: "Something went wrong" };
  }
}

export async function getServices() {
  try {
    const data = await db.services.findMany({
      orderBy: { service_name: "asc" },
    });

    if (!data) {
      return {
        success: false,
        message: "Data not found",
        status: 404,
        data: [],
      };
    }

    return {
      success: true,
      data,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

## 📄 utils\services\appointment.ts

```ts
import db from "@/lib/db";
import { Prisma } from "@/lib/generated/prisma";

export async function getAppointmentById(id: number) {
  try {
    if (!id) {
      return {
        success: false,
        message: "Appointment id does not exist.",
        status: 404,
      };
    }

    const data = await db.appointment.findUnique({
      where: { id },
      include: {
        doctor: {
          select: { id: true, name: true, specialization: true, img: true },
        },
        patient: {
          select: {
            id: true,
            first_name: true,
            last_name: true,
            date_of_birth: true,
            gender: true,
            img: true,
            address: true,
            phone: true,
          },
        },
      },
    });

    if (!data) {
      return {
        success: false,
        message: "Appointment data not found",
        status: 200,
        data: null,
      };
    }

    return { success: true, data, status: 200 };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

interface AllAppointmentsProps {
  page: number | string;
  limit?: number | string;
  search?: string;
  id?: string;
}

const buildQuery = (id?: string, search?: string) => {
  // Base conditions for search if it exists
  const searchConditions: Prisma.AppointmentWhereInput = search
    ? {
        OR: [
          {
            patient: {
              first_name: { contains: search, mode: "insensitive" },
            },
          },
          {
            patient: {
              last_name: { contains: search, mode: "insensitive" },
            },
          },
          {
            doctor: {
              name: { contains: search, mode: "insensitive" },
            },
          },
        ],
      }
    : {};

  // ID filtering conditions if ID exists
  const idConditions: Prisma.AppointmentWhereInput = id
    ? {
        OR: [{ patient_id: id }, { doctor_id: id }],
      }
    : {};

  // Combine both conditions with AND if both exist
  const combinedQuery: Prisma.AppointmentWhereInput =
    id || search
      ? {
          AND: [
            ...(Object.keys(searchConditions).length > 0
              ? [searchConditions]
              : []),
            ...(Object.keys(idConditions).length > 0 ? [idConditions] : []),
          ],
        }
      : {};

  return combinedQuery;
};

export async function getPatientAppointments({
  page,
  limit,
  search,
  id,
}: AllAppointmentsProps) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT; //0 -9

    const [data, totalRecord] = await Promise.all([
      db.appointment.findMany({
        where: buildQuery(id, search),
        skip: SKIP,
        take: LIMIT,
        select: {
          id: true,
          patient_id: true,
          doctor_id: true,
          type: true,
          appointmentDate: true,
          appointmentTime: true,
          status: true,
          patient: {
            select: {
              id: true,
              first_name: true,
              last_name: true,
              phone: true,
              gender: true,
              img: true,
              date_of_birth: true,
              colorCode: true,
            },
          },
          doctor: {
            select: {
              id: true,
              name: true,
              specialization: true,
              colorCode: true,
              img: true,
            },
          },
        },
        orderBy: { appointmentDate: "desc" },
      }),
      db.appointment.count({
        where: buildQuery(id, search),
      }),
    ]);

    if (!data) {
      return {
        success: false,
        message: "Appointment data not found",
        status: 200,
        data: null,
      };
    }

    const totalPages = Math.ceil(totalRecord / LIMIT);

    return {
      success: true,
      data,
      totalPages,
      currentPage: PAGE_NUMBER,
      totalRecord,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getAppointmentWithMedicalRecordsById(id: number) {
  try {
    if (!id) {
      return {
        success: false,
        message: "Appointment id does not exist.",
        status: 404,
      };
    }

    const data = await db.appointment.findUnique({
      where: { id },
      include: {
        patient: true,
        doctor: true,
        bills: true,
        medical: {
          include: {
            diagnosis: true,
            lab_test: true,
            vital_signs: true,
          },
        },
      },
    });

    if (!data) {
      return {
        success: false,
        message: "Appointment data not found",
        status: 200,
      };
    }

    return { success: true, data, status: 200 };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

## 📄 utils\services\doctor.ts

```ts
import db from "@/lib/db";
import { auth } from "@clerk/nextjs/server";
import { daysOfWeek } from "..";
import { processAppointments } from "./patient";

export async function getDoctors() {
  try {
    const data = await db.doctor.findMany();

    return { success: true, data, status: 200 };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
export async function getDoctorDashboardStats() {
  try {
    const { userId } = await auth();

    const todayDate = new Date().getDay();
    const today = daysOfWeek[todayDate];

    const [totalPatient, totalNurses, appointments, doctors] =
      await Promise.all([
        db.patient.count(),
        db.staff.count({ where: { role: "NURSE" } }),
        db.appointment.findMany({
          where: { doctor_id: userId!, appointmentDate: { lte: new Date() } },
          include: {
            patient: {
              select: {
                id: true,
                first_name: true,
                last_name: true,
                gender: true,
                date_of_birth: true,
                colorCode: true,
                img: true,
              },
            },
            doctor: {
              select: {
                id: true,
                name: true,
                specialization: true,
                img: true,
                colorCode: true,
              },
            },
          },
          orderBy: { appointmentDate: "desc" },
        }),
        db.doctor.findMany({
          where: {
            working_days: {
              some: { day: { equals: today, mode: "insensitive" } },
            },
          },
          select: {
            id: true,
            name: true,
            specialization: true,
            img: true,
            colorCode: true,
            working_days: true,
          },
          take: 5,
        }),
      ]);

    const { appointmentCounts, monthlyData } = await processAppointments(
      appointments
    );

    const last5Records = appointments.slice(0, 5);
    // const availableDoctors = doctors.slice(0, 5);

    return {
      totalNurses,
      totalPatient,
      appointmentCounts,
      last5Records,
      availableDoctors: doctors,
      totalAppointment: appointments?.length,
      monthlyData,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getDoctorById(id: string) {
  try {
    const [doctor, totalAppointment] = await Promise.all([
      db.doctor.findUnique({
        where: { id },
        include: {
          working_days: true,
          appointments: {
            include: {
              patient: {
                select: {
                  id: true,
                  first_name: true,
                  last_name: true,
                  gender: true,
                  img: true,
                  colorCode: true,
                },
              },
              doctor: {
                select: {
                  name: true,
                  specialization: true,
                  img: true,
                  colorCode: true,
                },
              },
            },
            orderBy: { appointmentDate: "desc" },
            take: 10,
          },
        },
      }),
      db.appointment.count({
        where: { doctor_id: id },
      }),
    ]);

    return { data: doctor, totalAppointment };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getRatingById(id: string) {
  try {
    const data = await db.rating.findMany({
      where: { staff_id: id },
      include: {
        patient: { select: { last_name: true, first_name: true } },
      },
    });

    const totalRatings = data?.length;
    const sumRatings = data?.reduce((sum, el) => sum + el.rating, 0);

    const averageRating = totalRatings > 0 ? sumRatings / totalRatings : 0;
    const formattedRatings = (Math.round(averageRating * 10) / 10).toFixed(1);

    return {
      totalRatings,
      averageRating: formattedRatings,
      ratings: data,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getAllDoctors({
  page,
  limit,
  search,
}: {
  page: number | string;
  limit?: number | string;
  search?: string;
}) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT;

    const [doctors, totalRecords] = await Promise.all([
      db.doctor.findMany({
        where: {
          OR: [
            { name: { contains: search, mode: "insensitive" } },
            { specialization: { contains: search, mode: "insensitive" } },
            { email: { contains: search, mode: "insensitive" } },
          ],
        },
        include: { working_days: true },
        skip: SKIP,
        take: LIMIT,
      }),
      db.doctor.count(),
    ]);

    const totalPages = Math.ceil(totalRecords / LIMIT);

    return {
      success: true,
      data: doctors,
      totalRecords,
      totalPages,
      currentPage: PAGE_NUMBER,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

## 📄 utils\services\medical-record.ts

```ts
import db from "@/lib/db";
import { Prisma } from "@/lib/generated/prisma";

export async function getMedicalRecords({
  page,
  limit,
  search,
}: {
  page: number | string;
  limit?: number | string;
  search?: string;
}) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT;

    const where: Prisma.MedicalRecordsWhereInput = {
      OR: [
        {
          patient: {
            first_name: { contains: search, mode: "insensitive" },
          },
        },
        {
          patient: {
            last_name: { contains: search, mode: "insensitive" },
          },
        },
        { patient_id: { contains: search, mode: "insensitive" } },
      ],
    };

    const [data, totalRecords] = await Promise.all([
      db.medicalRecords.findMany({
        where: where,
        include: {
          patient: {
            select: {
              first_name: true,
              last_name: true,
              date_of_birth: true,
              img: true,
              colorCode: true,
              gender: true,
            },
          },

          diagnosis: {
            include: {
              doctor: {
                select: {
                  name: true,
                  specialization: true,
                  img: true,
                  colorCode: true,
                },
              },
            },
          },
          lab_test: true,
        },
        skip: SKIP,
        take: LIMIT,
        orderBy: { created_at: "desc" },
      }),
      db.medicalRecords.count({
        where,
      }),
    ]);

    const totalPages = Math.ceil(totalRecords / LIMIT);

    return {
      success: true,
      data,
      totalRecords,
      totalPages,
      currentPage: PAGE_NUMBER,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

## 📄 utils\services\medical.ts

```ts
import db from "@/lib/db";
import { format } from "date-fns";

export const getVitalSignData = async (id: string) => {
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

  const data = await db.vitalSigns.findMany({
    where: {
      patient_id: id,
      created_at: {
        gte: sevenDaysAgo,
      },
    },
    select: {
      created_at: true,
      systolic: true,
      diastolic: true,
      heartRate: true,
    },
    orderBy: {
      created_at: "asc",
    },
  });
  // 56 - 60
  const formatVitals = data?.map((record) => ({
    label: format(new Date(record.created_at), "MMM d"),
    systolic: record.systolic,
    diastolic: record.diastolic,
  }));

  const formattedData = data.map((record) => {
    const heartRates = record.heartRate
      .split("-")
      .map((rate) => parseInt(rate.trim()));

    return {
      label: format(new Date(record.created_at), "MMM d"),
      value1: heartRates[0],
      value2: heartRates[1],
    };
  });

  const totalSystolic = data?.reduce((sum, acc) => sum + acc.systolic, 0);
  const totalDiastolic = data?.reduce((sum, acc) => sum + acc.diastolic, 0);

  const totalValue1 = formattedData?.reduce((sum, acc) => sum + acc.value1, 0);
  const totalValue2 = formattedData?.reduce((sum, acc) => sum + acc.value2, 0);

  const count = data?.length;

  const averageSystolic = totalSystolic / count;
  const averageDiastolic = totalDiastolic / count;

  const averageValue1 = totalValue1 / count;
  const averageValue2 = totalValue2 / count;

  const average = `${averageSystolic.toFixed(2)}/${averageDiastolic.toFixed(
    2
  )} mg/dL`;
  const averageHeartRate = `${averageValue1.toFixed(2)}-${averageValue2.toFixed(
    2
  )} bpm`;

  return {
    data: formatVitals,
    average,
    heartRateData: formattedData,
    averageHeartRate,
  };
};
```

## 📄 utils\services\patient.ts

```ts
import db from "@/lib/db";
import { getMonth, format, startOfYear, endOfMonth, isToday } from "date-fns";
import { daysOfWeek } from "..";
import { $Enums } from "@/lib/generated/prisma";


type AppointmentStatus = "PENDING" | "SCHEDULED" | "COMPLETED" | "CANCELLED";

interface Appointment {
  id: number;
  status: $Enums.AppointmentStatus;
  appointmentDate: Date;
  patient: {
    first_name: string;
    last_name: string;
    date_of_birth: Date;
    gender: $Enums.GENDER;
    img: string | null;
  };
  doctor: {
    name: string;
    id: string;
    img: string | null;
    specialization: string;
  };
}

function isValidStatus(status: string): status is AppointmentStatus {
  return ["PENDING", "SCHEDULED", "COMPLETED", "CANCELLED"].includes(status);
}

const initializeMonthlyData = () => {
  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().getMonth();

  return Array.from({ length: currentMonth + 1 }, (_, index) => ({
    name: format(new Date(currentYear, index), "MMM"),
    appointment: 0,
    completed: 0,
  }));
};

export const processAppointments = (appointments: Appointment[]) => {
  const monthlyData = initializeMonthlyData();
  const currentYearStart = startOfYear(new Date());
  const currentMonthEnd = endOfMonth(new Date());

  const appointmentCounts = appointments.reduce<
    Record<AppointmentStatus, number>
  >(
    (acc, appointment) => {
      const status = appointment.status;
      const appointmentDate = new Date(appointment.appointmentDate);
      const monthIndex = getMonth(appointmentDate);

      // Count monthly appointments
      if (
        appointmentDate >= currentYearStart &&
        appointmentDate <= currentMonthEnd
      ) {
        monthlyData[monthIndex].appointment += 1;
        if (status === "COMPLETED") {
          monthlyData[monthIndex].completed += 1;
        }
      }

      // Count by status
      if (isValidStatus(status)) {
        acc[status] = (acc[status] || 0) + 1;
      }

      return acc;
    },
    {
      PENDING: 0,
      SCHEDULED: 0,
      COMPLETED: 0,
      CANCELLED: 0,
    }
  );

  return { appointmentCounts, monthlyData };
};

export async function getPatientDashboardStatistics(id: string) {
  try {
    if (!id) {
      return {
        success: false,
        message: "No data found",
        data: null,
      };
    }

    const data = await db.patient.findUnique({
      where: { id },
      select: {
        id: true,
        first_name: true,
        last_name: true,
        gender: true,
        img: true,
      },
    });

    if (!data) {
      return {
        success: false,
        message: "Patient data not found",
        status: 200,
        data: null,
      };
    }

    const appointments = await db.appointment.findMany({
      where: { patient_id: data?.id },
      include: {
        doctor: {
          select: {
            id: true,
            name: true,
            img: true,
            specialization: true,
          },
        },
        patient: {
          select: {
            first_name: true,
            last_name: true,
            gender: true,
            date_of_birth: true,
            img: true,
          },
        },
      },

      orderBy: { appointmentDate: "desc" },
    });

    const { appointmentCounts, monthlyData } = await processAppointments(
      appointments
    );
    const last5Records = appointments.slice(0, 5);

    const today = daysOfWeek[new Date().getDay()];

 const availableDoctor = await db.doctor.findMany({
  select: {
    id: true,
    name: true,
    specialization: true,
    img: true,
  },
  take: 4,
});

    console.log(availableDoctor);
    return {
      success: true,
      data,
      appointmentCounts,
      last5Records,
      totalAppointments: appointments.length,
      availableDoctor,
      monthlyData,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getPatientById(id: string) {
  try {
    const patient = await db.patient.findUnique({
      where: { id },
    });

    if (!patient) {
      return {
        success: false,
        message: "Patient data not found",
        status: 200,
        data: null,
      };
    }

    return { success: true, data: patient, status: 200 };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getPatientFullDataById(id: string) {
  try {
    const patient = await db.patient.findFirst({
      where: {
        OR: [
          {
            id,
          },
          { email: id },
        ],
      },
      include: {
        _count: {
          select: {
            appointments: true,
          },
        },
        appointments: {
          select: {
            appointmentDate: true,
          },
          orderBy: {
            appointmentDate: "desc",
          },
          take: 1,
        },
      },
    });

    if (!patient) {
      return {
        success: false,
        message: "Patient data not found",
        status: 404,
      };
    }
    const lastVisit = patient.appointments[0]?.appointmentDate || null;

    return {
      success: true,
      data: {
        ...patient,
        totalAppointments: patient._count.appointments,
        lastVisit,
      },
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

export async function getAllPatients({
  page,
  limit,
  search,
}: {
  page: number | string;
  limit?: number | string;
  search?: string;
}) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT;

    const [patients, totalRecords] = await Promise.all([
      db.patient.findMany({
        where: {
          OR: [
            { first_name: { contains: search, mode: "insensitive" } },
            { last_name: { contains: search, mode: "insensitive" } },
            { phone: { contains: search, mode: "insensitive" } },
            { email: { contains: search, mode: "insensitive" } },
          ],
        },
        include: {
          appointments: {
            select: {
              medical: {
                select: { created_at: true, treatment_plan: true },
                orderBy: { created_at: "desc" },
                take: 1,
              },
            },
            orderBy: { appointmentDate: "desc" },
            take: 1,
          },
        },
        skip: SKIP,
        take: LIMIT,
        orderBy: { first_name: "asc" },
      }),
      db.patient.count(),
    ]);

    const totalPages = Math.ceil(totalRecords / LIMIT);

    return {
      success: true,
      data: patients,
      totalRecords,
      totalPages,
      currentPage: PAGE_NUMBER,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}

// function processAppointments(appointments: ({ patient: { first_name: string; last_name: string; date_of_birth: Date; gender: $Enums.GENDER; img: string | null; }; doctor: { name: string; id: string; img: string | null; specialization: string; }; } & { id: number; created_at: Date; updated_at: Date; patient_id: string; doctor_id: string; appointmentDate: Date; appointmentTime: string; status: $Enums.AppointmentStatus; type: string; note: string | null; reason: string | null; })[]): { appointmentCounts: any; monthlyData: any; } | PromiseLike<{ appointmentCounts: any; monthlyData: any; }> {
//   throw new Error("Function not implemented.");
// }

```

## 📄 utils\services\payments.ts

```ts
import db from "@/lib/db";
import { Prisma } from "@/lib/generated/prisma";

export async function getPaymentRecords({
  page,
  limit,
  search,
}: {
  page: number | string;
  limit?: number | string;
  search?: string;
}) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT;

    const where: Prisma.PaymentWhereInput = {
      OR: [
        {
          patient: {
            first_name: { contains: search, mode: "insensitive" },
          },
        },
        {
          patient: {
            last_name: { contains: search, mode: "insensitive" },
          },
        },
        { patient_id: { contains: search, mode: "insensitive" } },
      ],
    };

    const [data, totalRecords] = await Promise.all([
      db.payment.findMany({
        where: where,
        include: {
          patient: {
            select: {
              first_name: true,
              last_name: true,
              date_of_birth: true,
              img: true,
              colorCode: true,
              gender: true,
            },
          },
        },
        skip: SKIP,
        take: LIMIT,
        orderBy: { created_at: "desc" },
      }),
      db.payment.count({
        where,
      }),
    ]);

    const totalPages = Math.ceil(totalRecords / LIMIT);

    return {
      success: true,
      data,
      totalRecords,
      totalPages,
      currentPage: PAGE_NUMBER,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

## 📄 utils\services\staff.ts

```ts
import db from "@/lib/db";

export async function getAllStaff({
  page,
  limit,
  search,
}: {
  page: number | string;
  limit?: number | string;
  search?: string;
}) {
  try {
    const PAGE_NUMBER = Number(page) <= 0 ? 1 : Number(page);
    const LIMIT = Number(limit) || 10;

    const SKIP = (PAGE_NUMBER - 1) * LIMIT;

    const [staff, totalRecords] = await Promise.all([
      db.staff.findMany({
        where: {
          OR: [
            { name: { contains: search, mode: "insensitive" } },
            { phone: { contains: search, mode: "insensitive" } },
            { email: { contains: search, mode: "insensitive" } },
          ],
        },

        skip: SKIP,
        take: LIMIT,
      }),
      db.staff.count(),
    ]);

    const totalPages = Math.ceil(totalRecords / LIMIT);

    return {
      success: true,
      data: staff,
      totalRecords,
      totalPages,
      currentPage: PAGE_NUMBER,
      status: 200,
    };
  } catch (error) {
    console.log(error);
    return { success: false, message: "Internal Server Error", status: 500 };
  }
}
```

